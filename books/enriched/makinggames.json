{
  "metadata": {
    "title": "makinggames",
    "source_file": "makinggames_metadata.json"
  },
  "chapters": [
    {
      "chapter_number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "summary": "Python & Pygame \nto http://inventwithpython.com/pygame to download the latest version.\nWho is this book for?\nWHO IS THIS BOOK FOR?\nWhen you get down to it, programming video games is just about lighting up pixels to make \nThis book will teach you how to make graphical computer games in the Python programming \nfree book ―Invent Your Own Computer Games with Python‖ from http://inventwithpython.com.\nmy hope that the games in this book will give you enough ideas about how programs work to \nhttp://inventwithpython.com/pygame.\nii    http://inventwithpython.com/pygame \nABOUT THIS BOOK \nThis book will teach you how to make graphical computer games with the Pygame \nframework (also called the Pygame library) in the Python programming language.\nPygame makes \nBoth Python and the Pygame framework can be \ndownloaded for free from http://python.org and http://pygame.org.\nand this book to begin making your own games.\nThis book is an intermediate programming book.\nComputer Games with Python‖ is a book that is available completely for free from \nThat book teaches programming by making non-graphical, text-\nbased games for complete beginners, and also has a few chapters about using the Pygame library.\nbook for you.\nThe book starts with a short introduction to how the Pygame library works and the \nexplains how the code works, so you can understand how actual game programs make use of \nPygame.\nThe website for this book is http://inventwithpython.com/pygame.\nWho is this book for?\nAbout This Book ..............................................................................................................................\nSource Code for Hello World with Pygame ................................................................................\nSetting Up a Pygame Program .....................................................................................................\niv    http://inventwithpython.com/pygame \npygame.Color Objects ..........................................................................................................",
      "keywords": [
        "Book",
        "Python",
        "Pygame",
        "Games",
        "Albert Sweigart",
        "computer games",
        "source code",
        "Pygame library",
        "Code",
        "Making Games",
        "Installing Python",
        "work",
        "programming",
        "programs",
        "Making"
      ],
      "concepts": [
        "programming",
        "program",
        "book",
        "making",
        "make",
        "games",
        "work",
        "functions",
        "function",
        "objects"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 3,
          "title": "",
          "score": 0.912,
          "base_score": 0.762,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 4,
          "title": "",
          "score": 0.821,
          "base_score": 0.671,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 19,
          "title": "",
          "score": 0.706,
          "base_score": 0.556,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 42,
          "title": "",
          "score": 0.698,
          "base_score": 0.548,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 6,
          "title": "",
          "score": 0.678,
          "base_score": 0.528,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "book",
          "games",
          "python",
          "pygame",
          "computer games"
        ],
        "semantic": [],
        "merged": [
          "book",
          "games",
          "python",
          "pygame",
          "computer games"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4448480664616169,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.260463+00:00"
      }
    },
    {
      "chapter_number": 2,
      "title": "Segment 2 (pages 9-16)",
      "start_page": 9,
      "end_page": 16,
      "summary": "Data Structures and 2D Lists .....................................................................................................\nDrawing the Game State to the Screen ......................................................................................\nCreating the Board Data Structure: Step 1 – Get All Possible Icons .........................................\nDrawing the Box Cover .............................................................................................................\nDrawing the Entire Board ..........................................................................................................\nSource Code to Slide Puzzle ......................................................................................................\nCreating the Board Data Structure .............................................................................................\nMaking a Move by Updating the Board Data Structure ............................................................\nDrawing a Tile ...........................................................................................................................\nDrawing the Board .....................................................................................................................\nDrawing the Border of the Board ...............................................................................................\nDrawing the Buttons ................................................................................................................\nSource Code to Simulate ..........................................................................................................\nThe main() Function .............................................................................................................\nDrawing the Board and Handling Input ...................................................................................\nDrawing the Board to the Screen .............................................................................................\nDrawing the Buttons ................................................................................................................\nThe Game Over Animation ......................................................................................................\nSource Code to Wormy ............................................................................................................\nThe main() Function .............................................................................................................\nDrawing the Screen ..................................................................................................................\nDrawing ―Press a key‖ Text to the Screen ...............................................................................\nGame Over Screens ..................................................................................................................\nDrawing Functions ...................................................................................................................\nSource Code to Tetromino .......................................................................................................\nThe main() Function .............................................................................................................\nDrawing Everything on the Screen ..........................................................................................\nshowTextScreen(), A Generic Text Screen Function .....................................................\nAdding Pieces to the Board Data Structure .............................................................................\nCreating a New Board Data Structure ......................................................................................\nDrawing a Box on the Board or Elsewhere on the Screen .......................................................\nDrawing Everything to the Screen ...........................................................................................\nDrawing the Score and Level Text ..........................................................................................\nDrawing a Piece on the Board or Elsewhere on the Screen .....................................................\nChapter 8 – Squirrel Eat Squirrel .................................................................................................\nSource Code to Squirrel Eat Squirrel .......................................................................................\nDrawing the Background, Grass, Squirrels, and Health Meter ................................................\nThe Game Over Screen ............................................................................................................\nCreating Enemy Squirrel Data Structures ................................................................................\nCreating Grass Data Structures ................................................................................................\nSource Code to Star Pusher ......................................................................................................\nData Structures in Star Pusher .................................................................................................\nSource Code for Flippy ............................................................................................................\nSource Code for Ink Spill ........................................................................................................\nSource Code for Four-In-A-Row .............................................................................................\nSource Code for Gemgem ........................................................................................................",
      "keywords": [
        "Board Data Structure",
        "Source Code",
        "Event Handling Loop",
        "Data Structure",
        "Trailing Comma",
        "Drawing",
        "Board Data",
        "Game Loop",
        "Board",
        "Function",
        "Code",
        "Game",
        "Squirrel Data Structures",
        "Handling Loop",
        "Text Screen Function"
      ],
      "concepts": [
        "function",
        "functions",
        "drawing",
        "text",
        "game",
        "summary",
        "squirrel",
        "animation",
        "animating",
        "data"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 9,
          "title": "",
          "score": 0.728,
          "base_score": 0.578,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 12,
          "title": "",
          "score": 0.632,
          "base_score": 0.482,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 14,
          "title": "",
          "score": 0.613,
          "base_score": 0.463,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 39,
          "title": "",
          "score": 0.591,
          "base_score": 0.441,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 7,
          "title": "",
          "score": 0.59,
          "base_score": 0.44,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "drawing",
          "source code",
          "source",
          "board",
          "data"
        ],
        "semantic": [],
        "merged": [
          "drawing",
          "source code",
          "source",
          "board",
          "data"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.37294043172948677,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.260538+00:00"
      }
    },
    {
      "chapter_number": 3,
      "title": "Segment 3 (pages 17-24)",
      "start_page": 17,
      "end_page": 24,
      "summary": "Chapter 1 – Installing Python and Pygame    1 \nPYTHON AND PYGAME \nIt might help if you know a bit about Python programming (or how to program in another \nlanguage besides Python) before you read through this book; however even if you haven’t you \nYou don’t need to know how to use the Pygame library before reading this book.\nJust in case you haven’t read the first book and already installed Python and Pygame on your \nDownloading and Installing Python \nBefore we can begin programming you'll need to install software called the Python interpreter on \nthe interpreter, your computer won't be able to run your Python programs.\nprogramming language, http://www.python.org.\ndownload and install the Python software.\ncan also find videos online of people installing the Python software on their computers at \ndoes not include source)‖ and click on its link to download Python for Windows.\nDouble-click on the python-3.2.msi file that you've just downloaded to start the Python installer.\nHowever, the programs in this book work with both Python \nPygame for Linux also only supports Python 2, not Python 3.\nyou can install Python by opening a terminal window (from the desktop click on Applications > \nAccessories > Terminal) and entering ―sudo apt-get install python2.7‖ then \nYou will need to enter the root password to install Python, so ask the person who \neasy to write Python programs, just like word processor software makes it easy to write books.\nIf your operating system is Windows XP, you should be able to run Python by clicking the Start \nbutton, then selecting Programs, Python 3.1, IDLE (Python GUI).\nChapter 1 – Installing Python and Pygame    3 \nInstalling Pygame \nPygame does not come with Python.\ndownload and install Pygame, which is as easy as downloading and installing the Python \ninstaller for your operating system and the version of Python you have installed.\nPygame for Python 3.2 on Windows.\nIf you installed a different version of Python (such as 2.7 or \n2.6) download the .msi file for your version of Python.) The current version of Pygame at the \nFor Mac OS X, download the .zip or .dmg file for the version of Python you have and run it.\nFor Linux, open a terminal and run ―sudo apt-get install python-pygame‖.\nOn Windows, double click on the downloaded file to install Pygame.\ninstall Pygame again (and make sure you typed import pygame correctly).\nPython with Pygame.\nA video tutorial of how to install Pygame is available from this book's website at \n―Making Games with Python & Pygame‖ is different from other programming books because it \nIt is very helpful to copy these programs by typing in the code line by line from this book.\nHowever, you can also download the source code file from this book's website.\ngo to the URL http://invpy.com/source and follow the instructions to download the source code \nWhile you can just type in the code you read out of this book, you will need to download the \ngraphics and sound files used by the games in this book from http://invpy.com/downloads.\notherwise your Python program will not be able to find these files.\nWhen entering the source code yourself, do not type the line numbers that appear at the beginning \nChapter 1 – Installing Python and Pygame    5 \nThose numbers are only used so that this book can refer to specific lines in the code.\nSome lines of code are too long to fit on one line on the pages in this book, and the text of the \ntyping out the source code for these programs, you may accidentally make typos that cause your ",
      "keywords": [
        "Python",
        "Pygame",
        "Installing Python",
        "Book",
        "Python interpreter",
        "IDLE",
        "code",
        "install Pygame",
        "line",
        "Python programs",
        "Windows",
        "install",
        "download",
        "text",
        "Python GUI"
      ],
      "concepts": [
        "python",
        "programming",
        "program",
        "book",
        "windows",
        "downloading",
        "installing",
        "line",
        "file",
        "idle"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 1,
          "title": "",
          "score": 0.912,
          "base_score": 0.762,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 4,
          "title": "",
          "score": 0.804,
          "base_score": 0.654,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 19,
          "title": "",
          "score": 0.649,
          "base_score": 0.499,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 11,
          "title": "",
          "score": 0.624,
          "base_score": 0.474,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 42,
          "title": "",
          "score": 0.582,
          "base_score": 0.432,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "python",
          "install",
          "book",
          "python pygame",
          "installing"
        ],
        "semantic": [],
        "merged": [
          "python",
          "install",
          "book",
          "python pygame",
          "installing"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3350253507080326,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.260580+00:00"
      }
    },
    {
      "chapter_number": 4,
      "title": "Segment 4 (pages 25-33)",
      "start_page": 25,
      "end_page": 33,
      "summary": "additional functions for your programs, the Pygame framework includes several modules with \nThis chapter will cover the basic modules and functions that Pygame provides and assumes you \nThese CLI programs only get input from the keyboard with the input() function and \nPygame provides functions for creating programs with a graphical user interface, or GUI \nOur first program made with Pygame is a small program that makes a window that says ―Hello \n8.     for event in pygame.event.get(): \nCalling the print() function to make text appear in the window won’t work because \nprint() is a function for CLI programs.\nPygame uses other functions for input and output which are explained later in this \nSetting Up a Pygame Program \nprogram you write that uses Pygame.\nLine 1 is a simple import statement that imports the pygame and sys modules so that our \nprogram can use the functions in them.\nAll of the Pygame functions dealing with graphics, sound, \nLine 4 is the pygame.init() function call, which always needs to be called after importing \nthe pygame module and before calling any other Pygame function.\nthis function does, you just need to know that it needs to be called first in order for many Pygame \nLine 5 is a call to the pygame.display.set_mode() function, which returns the \npygame.Surface object for the window.\nthe set_mode() function how wide and how high to make the window in pixels.\ncorrect way to call the function is like this: pygame.display.set_mode((400, 300)).\nA function call like pygame.display.set_mode(400, 300) will cause an error that \nThe pygame.Surface object (we will just call them Surface objects for short) returned is \npygame.display.set_caption() function.\n8.     for event in pygame.event.get(): \nevents have been created (with Pygame, this is done by calling the pygame.event.get() \nfunction).\npygame.event.Event Objects \npygame.event.Event object is created by the Pygame library to record this ―event‖.\na type of object called Event that exists in the event module, which itself is in the pygame \nmodule.) We can find out which events have happened by calling the pygame.event.get() \nfunction, which returns a list of pygame.event.Event objects (which we will just call Event \npygame.event.get() function was called.\n(Or, if pygame.event.get() has never been \ncalled, the events that have happened since the start of the program.) \n8.     for event in pygame.event.get(): \nLine 8 is a for loop that will iterate over the list of Event objects that was returned by \npygame.event.get().\nThe list of Event objects returned \nhave happened, then pygame.event.get() will return a blank list.\nThe QUIT Event and pygame.quit() Function \nEvent objects have a member variable (also called attributes or properties) named type \nLine 9 checks if the Event object’s type is \nIf the Event object is a quit event, then the pygame.quit() and sys.exit() functions are \nThe pygame.quit() function is sort of the opposite of the pygame.init() \nfunction: it runs code that deactivates the Pygame library.\npygame.quit() before they call sys.exit() to terminate the program.\nthat causes IDLE to hang if a Pygame program terminates before pygame.quit() is called.\nSince we have no if statements that run code for other types of Event object, there is no event-\ntype of Event objects to be created.\nThe user can do things to create these Event objects but it \ncode for these types of Event objects.\nobjects that have been returned by pygame.event.get(), the program execution continues \nLine 12 calls the pygame.display.update() function, which draws the Surface object \nreturned by pygame.display.set_mode() to the screen (remember we stored this object \nto the screen each time pygame.display.update() is called.\nPygame drawing functions.\nCoordinates work in Pygame (and almost every programming language).\nA call to a function inside of a module may look like a method call.\nYou can tell that sys.exit() is a call to function inside of a module, \nshort) are just a name given to functions that return a new object.\nThis is why when you write your own programs, your function names should only \nFor example, pygame.Rect() and pygame.Surface() are both constructor functions \ninside the pygame module that return new Rect and Surface objects.\nWombat() is also a function call, in this case it is a constructor function that returns an object.\nregular function, but it is a safe bet.) The object is stored in a variable named egg.\ncan be changed by calling the Pygame drawing functions (described later in this chapter) and then \nIn particular, the Surface object returned by pygame.display.set_mode() is called the \nwindow when the pygame.display.update() function is called.\nOften your program will draw several different things to a Surface object.\ndrawing everything on the display Surface object for this iteration of the game loop (called a ",
      "keywords": [
        "Pygame",
        "Surface object",
        "function",
        "Event objects",
        "event",
        "object",
        "Surface",
        "function call",
        "functions",
        "pygame module",
        "Pygame Basics",
        "program",
        "Pygame drawing functions",
        "game",
        "call"
      ],
      "concepts": [
        "functions",
        "function",
        "programs",
        "programming",
        "imports",
        "object",
        "called",
        "line",
        "window",
        "pixels"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 19,
          "title": "",
          "score": 0.853,
          "base_score": 0.703,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 1,
          "title": "",
          "score": 0.821,
          "base_score": 0.671,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 3,
          "title": "",
          "score": 0.804,
          "base_score": 0.654,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 11,
          "title": "",
          "score": 0.775,
          "base_score": 0.625,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 20,
          "title": "",
          "score": 0.724,
          "base_score": 0.574,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "event",
          "pygame",
          "function",
          "event objects",
          "pygame event"
        ],
        "semantic": [],
        "merged": [
          "event",
          "pygame",
          "function",
          "event objects",
          "pygame event"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.45311318917982024,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.260627+00:00"
      }
    },
    {
      "chapter_number": 5,
      "title": "Segment 5 (pages 34-42)",
      "start_page": 34,
      "end_page": 42,
      "summary": "Colors \nIn Pygame, we \nrepresent colors with tuples of three integers.\ncolor.\nThese tuples of three integers used to represent a color are often called RGB values.\nmeans Pygame can draw 16,777,216 different colors (that is, 256 x 256 x 256 colors).\nno amount of red, green, or blue, the resulting color is completely black.\nThe color white is the full combination of red, green, and blue.\nColor \nyour color values.\ncolor is.\nNormally when you draw a pixel onto a surface object, the new color completely \nBut with colors that have an alpha value, you can \nFor example, this tuple of three integers is for the color green: (0, 255, 0).\nfourth integer for the alpha value, we can make this a half transparent green color: (0, 255, \nIf you draw any color that has an alpha value of 0 to a \nsurface object, it will have no effect, because this color is completely transparent and invisible.\nIn order to draw using transparent colors, you must create a Surface object with the \nIt’s important to note that you cannot use transparent colors on Surface objects not returned from \nIf we were to create a color tuple to draw the legendary Invisible Pink Unicorn, we would use \npygame.Color Objects \nYou need to know how to represent a color because Pygame’s drawing functions need a way to \nknow what color you want to draw with.\nway is as a pygame.Color object.\nYou can create Color objects by calling the \npygame.Color() constructor function and passing either three or four integers.\nthis Color object in variables just like you can store tuples in variables.\n>>> pygame.Color(255, 0, 0) \n>>> myColor = pygame.Color(255, 0, 0, 128) \nAny drawing function in Pygame (which we will learn about in a bit) that has a parameter for \ncolor can have either the tuple form or Color object form of a color passed for it.\nthey are different data types, a Color object is equal to a tuple of four integers if they both \nNow that you know how to represent colors (as a pygame.Color object or a tuple of three or \nfor X and Y), let’s learn about pygame.Rect objects so we can start using Pygame’s drawing \ncolors).\nedge of the pygame.Rect object we stored in the spamRect variable, you can just access the \nThe Pygame code for the Rect object automatically calculated that if the left edge is at the X \nPygame provides several different functions for drawing different shapes onto a surface object.\n8. pygame.display.set_caption('Drawing') \n# draw on the surface object \npygame.draw.polygon(DISPLAYSURF, GREEN, ((146, 0), (291, 106), (236, 277), \npygame.draw.line(DISPLAYSURF, BLUE, (60, 60), (120, 60), 4) \npygame.draw.line(DISPLAYSURF, BLUE, (120, 60), (60, 120)) \npygame.draw.line(DISPLAYSURF, BLUE, (60, 120), (120, 120), 4) \npygame.draw.circle(DISPLAYSURF, BLUE, (300, 50), 20, 0) \npygame.draw.ellipse(DISPLAYSURF, RED, (300, 250, 40, 80), 1) \npygame.draw.rect(DISPLAYSURF, RED, (200, 150, 100, 50)) \nthe color green than (0, 255, 0) is.\nfunctions tell them which Surface object to draw on, where to draw the shape (and what size), in \nfill(color) – The fill() method is not a function but a method of pygame.Surface \nIt will completely fill in the entire Surface object with whatever color value you pass \nas for the color parameter.\npygame.draw.polygon(surface, color, pointlist, width) – A polygon is shape made up of \nThe surface and color parameters tell the function on what surface to \ndraw the polygon, and what color to make it.\nAll of the pygame.draw drawing functions have optional width parameters at the end, \nand they work the same way as pygame.draw.polygon()’s width parameter.\npygame.draw.line(surface, color, start_point, end_point, width) – This function draws a \npygame.draw.lines(surface, color, closed, pointlist, width) – This function draws a series \nof lines from one point to the next, much like pygame.draw.polygon().\npygame.draw.circle(surface, color, center_point, radius, width) – This function draws a \npygame.draw.ellipse(surface, color, bounding_rectangle, width) – This function draws an \nThe bounding_rectangle parameter can be a pygame.Rect object or a tuple of four \npygame.draw.circle() function.\npygame.draw.rect(surface, color, rectangle_tuple, width) – This function draws a \nof the top left corner, and the width and height) or a pygame.Rect object can be passed \npygame.PixelArray Objects \n(unless you call pygame.draw.line() with the same start and end point).\nWhile a Surface object is locked, the drawing \nthe BLACK variable stores the color tuple (0, 0, 0)).\nTo tell Pygame that you are finished drawing individual pixels, delete the PixelArray object with \nSurface object so that you can once again draw images on it.\nPixelArray object, the next time you try to blit (that is, draw) an image to the Surface the program \nAfter you are done calling the drawing functions to make the display Surface object look the way ",
      "keywords": [
        "surface object",
        "color",
        "surface",
        "object",
        "tuple",
        "Pygame",
        "blue",
        "Color object",
        "red",
        "Drawing",
        "Rect object",
        "green",
        "rectangle",
        "BLACK",
        "width"
      ],
      "concepts": [
        "colors",
        "draw",
        "parameter",
        "surface",
        "object",
        "pixel",
        "images",
        "black",
        "width",
        "different"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 24,
          "title": "",
          "score": 0.772,
          "base_score": 0.622,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 38,
          "title": "",
          "score": 0.768,
          "base_score": 0.618,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 37,
          "title": "",
          "score": 0.736,
          "base_score": 0.586,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 10,
          "title": "",
          "score": 0.697,
          "base_score": 0.547,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 17,
          "title": "",
          "score": 0.681,
          "base_score": 0.531,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "color",
          "pygame",
          "draw",
          "object",
          "surface"
        ],
        "semantic": [],
        "merged": [
          "color",
          "pygame",
          "draw",
          "object",
          "surface"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.41021950791419365,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.260682+00:00"
      }
    },
    {
      "chapter_number": 6,
      "title": "Segment 6 (pages 43-50)",
      "start_page": 43,
      "end_page": 50,
      "summary": "26    http://inventwithpython.com/pygame \nDISPLAYSURF = pygame.display.set_mode((400, 300), 0, 32) \npygame.display.set_caption('Animation') \ncatImg = pygame.image.load('cat.png') \npygame.quit() \nFrames Per Second and pygame.time.Clock Objects \nA pygame.time.Clock object can help us make sure our program runs at a certain maximum \nThis Clock object will ensure that our game programs don’t run too fast by putting in \nClock object in the game loop can make sure the game runs at the same speed no matter how \nThe Clock object’s tick() method should be called at the very end of the game loop, after the \npause at all.) In the animation program, is it run on line 47 as the last instruction in the game loop.\n28    http://inventwithpython.com/pygame \nDrawing Images with pygame.image.load() and blit() \nPygame is able to load images onto Surface objects from PNG, \n'cat.png' is passed to the pygame.image.load() function.\npygame.image.load() function call will return a Surface object that has the image drawn \nmust blit (that is, copy) the image’s Surface object to the display Surface object.\ncalling pygame.image.load(), then make sure the cat.png file is in the same folder as the \ncatanimation.py file before you run the program.\nLine 39 of the animation program uses the blit() method to copy catImg to DISPLAYSURF.\nIf you want to draw text to the screen, you could write several calls to pygame.draw.line() \npygame.draw.line() calls and figure out all the XY coordinates, and probably wouldn’t \nThe above message would take forty one calls to the pygame.draw.line() function to \nInstead, Pygame provides some much simpler functions for fonts and creating text.\na small Hello World program using Pygame’s font functions.\n5. DISPLAYSURF = pygame.display.set_mode((400, 300)) \n6. pygame.display.set_caption('Hello World!') \n1. Create a pygame.font.Font object.\n30    http://inventwithpython.com/pygame \npygame.display.set_mode().\n6. Call pygame.display.update() to make the display Surface appear on the screen.\nThe parameters to the pygame.font.Font() constructor function is a string of the font file to \nOn line 12, we pass 'freesansbold.ttf' (this is a font that comes with Pygame) and the \nTo make Pygame’s text use anti-aliasing, just pass True for the second parameter of the \nfunctions have the same parameters as pygame.draw.line() and \npygame.draw.lines(), except they will draw anti-aliased (smooth) lines instead of aliased \nPlaying sounds that are stored in sound files is even simpler than displaying images from image \nFirst, you must create a pygame.mixer.Sound object (which we will call Sound objects \nfor short) by calling the pygame.mixer.Sound() constructor function.\nPygame can load WAV, MP3, or OGG files.\nTo play this sound, call the Sound object’s play() method.\nSound object from playing call the stop() method.\nsoundObj = pygame.mixer.Sound('beeps.wav') \nsound to finish playing before moving on to the next line of code.\nPygame can only load one music file to \npygame.mixer.music.load() function and pass it a string argument of the sound file to \nTo begin playing the loaded sound file as the background music, call the \npygame.mixer.music.play(-1, 0.0) function.\nbackground music forever loop when it reaches the end of the sound file.\nthe music will begin playing that many seconds into the sound file.\n13.5 for the second parameter, the sound file with begin playing at the point 13.5 seconds in \n32    http://inventwithpython.com/pygame \nTo stop playing the background music immediately, call the pygame.mixer.music.stop() \nsoundObj = pygame.mixer.Sound('beepingsound.wav') \npygame.mixer.music.load(backgroundmusic.mp3') \npygame.mixer.music.play(-1, 0.0) \npygame.mixer.music.stop() \nThis covers the basics of making graphical games with the Pygame framework.\ncan then get some ideas for how to code your own game programs.",
      "keywords": [
        "Surface object",
        "object",
        "Surface",
        "game",
        "file",
        "sound",
        "sound file",
        "game loop",
        "Pygame",
        "program",
        "black pixel",
        "call",
        "DISPLAYSURF Surface object",
        "line",
        "display Surface object"
      ],
      "concepts": [
        "programs",
        "programming",
        "file",
        "playing",
        "functions",
        "function",
        "line",
        "game",
        "look",
        "objects"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 19,
          "title": "",
          "score": 0.808,
          "base_score": 0.658,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 15,
          "title": "",
          "score": 0.714,
          "base_score": 0.564,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 20,
          "title": "",
          "score": 0.713,
          "base_score": 0.563,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 4,
          "title": "",
          "score": 0.71,
          "base_score": 0.56,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 1,
          "title": "",
          "score": 0.678,
          "base_score": 0.528,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "pygame",
          "sound",
          "music",
          "mixer",
          "pygame mixer"
        ],
        "semantic": [],
        "merged": [
          "pygame",
          "sound",
          "music",
          "mixer",
          "pygame mixer"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.44634605690782997,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.260727+00:00"
      }
    },
    {
      "chapter_number": 7,
      "title": "Segment 7 (pages 51-59)",
      "start_page": 51,
      "end_page": 59,
      "summary": "In the Memory Puzzle game, several icons are covered up by white boxes.\nThe player can click on two boxes to see what icon is behind them.\nThe player wins when all the boxes on the board are uncovered.\nX and Y coordinate on the board.\nBOXSIZE = 40 # size of box height & width in pixels \nALLCOLORS = (RED, GREEN, BLUE, YELLOW, ORANGE, PURPLE, CYAN) \n\"Board is too big for the number of shapes/colors defined.\" \nfirstSelection = None # stores the (x, y) of the first box clicked.\nif boxx != None and boxy != None: \nif not revealedBoxes[boxx][boxy]: \nif not revealedBoxes[boxx][boxy] and mouseClicked: \nrevealBoxesAnimation(mainBoard, [(boxx, boxy)]) \nrevealedBoxes[boxx][boxy] = True # set the box as \nfirstSelection = (boxx, boxy) \nboxx, boxy) \nrevealedBoxes[boxx][boxy] = False \nicons.append( (shape, color) ) \nboard = [] \nreturn board \ndef leftTopCoordsOfBox(boxx, boxy): \nleft = boxx * (BOXSIZE + GAPSIZE) + XMARGIN \nleft, top = leftTopCoordsOfBox(boxx, boxy) \nboxRect = pygame.Rect(left, top, BOXSIZE, BOXSIZE) \nreturn (boxx, boxy) \ndef drawIcon(shape, color, boxx, boxy): \nleft, top = leftTopCoordsOfBox(boxx, boxy) # get pixel coords from \npygame.draw.circle(DISPLAYSURF, color, (left + half, top + half), \npygame.draw.circle(DISPLAYSURF, BGCOLOR, (left + half, top + \npygame.draw.rect(DISPLAYSURF, color, (left + quarter, top + \npygame.draw.polygon(DISPLAYSURF, color, ((left + half, top), (left \npygame.draw.line(DISPLAYSURF, color, (left, top + i), (left + \npygame.draw.line(DISPLAYSURF, color, (left + i, top + BOXSIZE \npygame.draw.ellipse(DISPLAYSURF, color, (left, top + quarter, \ndef getShapeAndColor(board, boxx, boxy): \n# shape value for x, y spot is stored in board[x][y][0] \n# color value for x, y spot is stored in board[x][y][1] \nreturn board[boxx][boxy][0], board[boxx][boxy][1] \ndef drawBoxCovers(board, boxes, coverage): \n# Draws boxes being covered/revealed.\n\"boxes\" is a list \n# of two-item lists, which have the x & y spot of the box.\nleft, top = leftTopCoordsOfBox(box[0], box[1]) \npygame.draw.rect(DISPLAYSURF, BGCOLOR, (left, top, BOXSIZE, \nshape, color = getShapeAndColor(board, box[0], box[1]) \ndrawIcon(shape, color, box[0], box[1]) \npygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, coverage, \n# Do the \"box reveal\" animation.\n# Do the \"box cover\" animation.\ndef drawBoard(board, revealed): \n# Draws all of the boxes in their covered or revealed state.\nleft, top = leftTopCoordsOfBox(boxx, boxy) \nif not revealed[boxx][boxy]: \n# Draw a covered box.\npygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, \n# Draw the (revealed) icon.\nshape, color = getShapeAndColor(board, boxx, boxy) \ndrawIcon(shape, color, boxx, boxy) \ndef drawHighlightBox(boxx, boxy): \nleft, top = leftTopCoordsOfBox(boxx, boxy) \npygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, (left - 5, top - 5, \ndef startGameAnimation(board): \n# Randomly reveal the boxes 8 at a time.\nboxes = [] \nboxes.append( (x, y) ) \ndef gameWonAnimation(board): \n# Returns True if all the boxes have been revealed, otherwise False \nreturn False # return False if any boxes are covered.",
      "keywords": [
        "Memory Puzzle",
        "BOXSIZE",
        "left",
        "top",
        "board",
        "boxx",
        "boxy",
        "Memory",
        "DISPLAYSURF",
        "Puzzle",
        "BOARDWIDTH",
        "BOARDHEIGHT",
        "box",
        "icons",
        "Memory Puzzle code"
      ],
      "concepts": [
        "board",
        "boxes",
        "box",
        "icons",
        "color",
        "left",
        "returns",
        "shapes",
        "drawing",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 9,
          "title": "",
          "score": 0.875,
          "base_score": 0.725,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 36,
          "title": "",
          "score": 0.699,
          "base_score": 0.549,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 13,
          "title": "",
          "score": 0.66,
          "base_score": 0.51,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 39,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 21,
          "title": "",
          "score": 0.629,
          "base_score": 0.479,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "boxx",
          "boxx boxy",
          "boxy",
          "left",
          "box"
        ],
        "semantic": [],
        "merged": [
          "boxx",
          "boxx boxy",
          "boxy",
          "left",
          "box"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.41629793879464977,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.260782+00:00"
      }
    },
    {
      "chapter_number": 8,
      "title": "Segment 8 (pages 60-68)",
      "start_page": 60,
      "end_page": 68,
      "summary": "This program makes use of many functions in other modules, so it imports those modules on line \npygame.locals module, but there are several constant variables in it that we want to use such \nThe game programs in this book use a lot of constant variables.\nFor example, instead of using the BOXSIZE variable in our code we could just \nBut there are two reasons to use constant variables.\nconstant, we only have to change line 13 and the rest of the program is already up to date.\nsize of the white boxes, and changing that 40 accidentally would cause bugs in our program.\nBut if line 18 didn’t use constant variables, it would look like this: \nyourself entering magic numbers, you should consider replacing them with a constant variable \nOf course, you can go too far replacing numbers with constant variables.\nThe assert statement on line 15 ensures that the board width and height we’ve selected will \nif the program crashes because of the assertion.\nIf the values we chose for BOARDWIDTH and BOARDHEIGHT that we chose on line 15 and 16 \nof the bug was on line 15 and 16 where we set the BOARDWIDTH and BOARDHEIGHT constants.\nMaking the Source Code Look Pretty \nRemember that colors in Pygame are represented by a tuple of three integers from 0 to 255.\ntuples are called RGB values.\nNotice the spacing of the tuples on lines 22 to 31 are such that the \nintegers in the tuple out, we can clearly see how the RGB values compare to each other.\nmore time typing spaces than you would have saved by having readable tuple values.\nUsing Constant Variables Instead of Strings \nThe program also sets up constant variables for some strings.\nconstant variable instead of the string value is a good idea.\nThe shape variable will be set to one of the strings 'donut', 'square', 'diamond', \nSince the program has crashed on line 187, when we check that line it will be easy \nvariables and made the same typo, line 187 would look like this: \nALLCOLORS = (RED, GREEN, BLUE, YELLOW, ORANGE, PURPLE, CYAN) \ncombination, we need to make a tuple that holds all of these values.\nassertion on line 46 to make sure that there are enough color/shape combinations for the size of \nIf there isn’t, then the program will crash on line 46 and we will know that we \nYou might have noticed that the ALLCOLORS and ALLSHAPES variables are tuples instead of \nTuples and lists are the same in every way except two: tuples use parentheses instead of square \noften call lists mutable (meaning they can be changed) and tuples immutable (meaning they \nFor an example of trying to change values in lists and tuples, look at the following code: \ncode that uses tuples is slightly faster than code that uses lists.\noptimizations knowing that the values in a tuple will never change.) But having your code run a \nThe important benefit to using tuples is similar to the benefit of using constant variables: it’s a \nsign that the value in the tuple will never change, so anyone reading the code later will be able to \nused a list.‖ This also lets a future programmer reading your code say, ―If I see a list value, I \nwrote this code would have used a tuple.‖ \nYou can still assign a new tuple value to a variable: \nThe reason this code works is because the code isn’t changing the (1, 2, 3) tuple on the \noverwriting the old tuple value.\nin the tuple.\nAlso, one minor details about tuples: if you ever need to write code about a tuple that has one \nexample, look at the following two lines of code: \nvariableB’s assignment statement is the single-item tuple value (30, ).\nBlank tuple values \nYou can convert between list and tuple values just like you can convert between string and \nJust pass a tuple value to the list() function and it will return a list form of that \ntuple value.\nOr, pass a list value to the tuple() function and it will return a tuple form of that \nLine 49 is a global statement.\nvariables.\nInside the main() function, those names are not for local variables that might just \nhappen to have the same name as global variables.\nThey are the global variables.\nother functions in the program.\n1. If there is a global statement for a variable at the beginning of the function, then the \nvariable is global.\n2. If the name of a variable in a function has the same name as a global variable and the \nfunction never assigns the variable a value, then that variable is the global variable.\n3. If the name of a variable in a function has the same name as a global variable and the \nfunction does assign the variable a value, then that variable is a local variable.\n4. If there isn't a global variable with the same name as the variable in the function, then \nYou generally want to avoid using global variables inside functions.\nBut a function that reads and writes to global variables has additional inputs and \nSince the global variable could have been modified in many places before the function \nwas called, it can be tricky to track down a bug involving a bad value set in the global variable.\nHaving a function as a separate mini-program that doesn’t use global variables makes it easier to \nBasically, using global variables might make it easier to write your program but they generally \nconstants that never change, but need the pygame.init() function called first.\nBut the global variables are used as constants and don’t change, so \nJust write your code so that you pass in values to \nfunctions rather than have the functions read global variables as a general rule.",
      "keywords": [
        "code",
        "variable",
        "Global Variables",
        "variables",
        "constant variables",
        "tuple",
        "line",
        "global",
        "program",
        "function",
        "constant",
        "Memory Puzzle",
        "n’t",
        "crash",
        "Simplified BSD"
      ],
      "concepts": [
        "code",
        "value",
        "line",
        "functions",
        "function",
        "variable",
        "list",
        "look",
        "assert",
        "assertion"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 11,
          "title": "",
          "score": 0.762,
          "base_score": 0.612,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 20,
          "title": "",
          "score": 0.761,
          "base_score": 0.611,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 4,
          "title": "",
          "score": 0.704,
          "base_score": 0.554,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 15,
          "title": "",
          "score": 0.677,
          "base_score": 0.527,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 1,
          "title": "",
          "score": 0.65,
          "base_score": 0.5,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "tuple",
          "global",
          "variables",
          "variable",
          "global variables"
        ],
        "semantic": [],
        "merged": [
          "tuple",
          "global",
          "variables",
          "variable",
          "global variables"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.46997768702095727,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.260838+00:00"
      }
    },
    {
      "chapter_number": 9,
      "title": "Segment 9 (pages 69-77)",
      "start_page": 69,
      "end_page": 77,
      "summary": "The getRandomizedBoard() function returns a data structure that represents the state of the \nmap a 2D board to a 2D list value.\nSince the mainBoard variable will store icons in it, if we \nwanted to get the icon on the board at the position (4, 5) then we could just use the expression \nand color, the complete data structure is a list of list of two-item tuples.\nicon at the (x, y) coordinate on the board.\nlike the board data structure, it has Boolean values: True if the box at that x, y coordinate is \ngenerateRevealedBoxesData() function sets all of the Boolean values to False.\nThese two data structures are used to keep track of the state of the game board.\nfirstSelection = None # stores the (x, y) of the first box clicked.\nLine 61 sets up a variable called firstSelection with the value None.\nhttp://invpy.com/None) When the player clicks on an icon on the board, the program needs to \ntrack if this was the first icon of the pair that was clicked on or the second icon.\nfirstSelection is None, the click was on the first icon and we store the XY coordinates in \nOn the second click the value will be this tuple and not None, which is how the program tracks \nthat it is the second icon click.\nicons are under which boxes.\nRemember that the game loop handles events, updates the game state, and draws \nThe game state for the Memory Puzzle program is stored in the following variables: \nOn each iteration of the game loop in the Memory Puzzle program, the mouseClicked variable \nstores a Boolean value that is True if the player has clicked the mouse during this iteration \npygame.display.update(), which is done at the end of the game loop on line 121.\nThis loop is called the event handling loop (which is different from the game \nloop, although the event handling loop is inside of the game loop) and iterates over the list of \nOnce we have handled all of the events, the values stored in mousex, mousey, and \nXY board coordinates of the box that the mouse coordinates are over.\ncoordinates were over a box, a tuple of the XY board coordinates are returned by the function and \nthe side of the board or in a gap in between boxes) then the tuple (None, None) is returned by \nThe if statement on line 85 checks if the box is covered up or not by reading the value stored in \nWhenever the mouse is over a covered up box, we want to draw a blue highlight around the box \nrevealedBoxes[boxx][boxy] = True # set the box as \nOn line 87, we check if the mouse cursor is not only over a covered up box but if the mouse has \nrevealedBoxes[boxx][boxy] = True that the data structure that tracks the game state \nIf you comment out line 89 and then run the program, you’ll notice that after clicking on a box \nbecause revealedBoxes[boxx][boxy] is still set to False, so on the next iteration of the \ngame loop, the board is drawn with this box covered up.\nHandling the First Clicked Box \nbox clicked \nBefore the execution entered the game loop, the firstSelection variable was set to None.\nOur program will interpret this to mean that no boxes have been clicked, so if line 90’s condition \nfirstSelection variable to a tuple of the box coordinates for the box that was clicked.\nIf this is the second box the player has clicked on, we want to play the reveal animation for that \nbox but then check if the two icons under the boxes are matching.\nfunction (explained later) will retrieve the shape and color values of the icons.\nThe if statement on line 97 checks if either the shapes or colors of the two icons don’t match.\nupdate the game state to mark these boxes as not revealed (that is, covered up).\nOtherwise, if line 97’s condition was False, then the two icons must be a match.\nHowever, the program should check if this was the last pair of icons on the \nboard is in a winning state (that is, all of the boxes are revealed).\nreset the data structures in mainBoard and revealedBoxes to start a new game.\nthrough the game loop as usual, and the player can continue playing until they quit the program.\nNo matter if the two boxes were matching or not, after the second box was clicked line 118 will \nset the firstSelection variable back to None so that the next box the player clicks on will \nbe interpreted as the first clicked box of a pair of possibly matching icons.\nof the game loop, so we call pygame.display.update() to draw the DISPLAYSURF \nLine 9 set the FPS constant to the integer value 30, meaning we want the game to run (at most) at \nmeans that pygame.display.update() and all the code in the game loop must execute in \nWe start the data structure as an empty list in the revealedBoxes variable.\nCreating the Board Data Structure: Step 1 – Get All Possible Icons \nicons = [] \nThe board data structure is just a list of lists of tuples, where each tuple has a two values: one for \nWe need to be sure to have exactly as many icons for the number of boxes on the \nboard and also be sure there are two and only two icons of each type.\nThese are each added to the list in the icons variable on line 137.\nStep 2 – Shuffling and Truncating the List of All Icons \nrandom.shuffle(icons) # randomize the order of the icons list \nLine 141 uses list slicing to grab the first numIconsUsed number of icons in the list.\non line 139, so it won’t always be the same icons each game.\nthe old list in the icons variable.\nStep 3 – Placing the Icons on the Board \n# Create the board data structure, with randomly placed icons.\nNow we need to create a list of lists data structure for the board.\nboard, we will create a list of randomly selected icons.\nAs we add icons to the column, on line \n149 we will then delete them from the front of the icons list on line 150.",
      "keywords": [
        "Game Loop",
        "icons",
        "game",
        "list",
        "data structure",
        "box",
        "board",
        "Memory Puzzle",
        "Loop",
        "game state",
        "board data structure",
        "Line",
        "Data",
        "structure",
        "icons list"
      ],
      "concepts": [
        "icons",
        "lists",
        "lines",
        "value",
        "board",
        "events",
        "functions",
        "game",
        "boxes",
        "box"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 7,
          "title": "",
          "score": 0.875,
          "base_score": 0.725,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 21,
          "title": "",
          "score": 0.768,
          "base_score": 0.618,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 36,
          "title": "",
          "score": 0.732,
          "base_score": 0.582,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 2,
          "title": "",
          "score": 0.728,
          "base_score": 0.578,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 14,
          "title": "",
          "score": 0.723,
          "base_score": 0.573,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "icons",
          "box",
          "board",
          "list",
          "clicked"
        ],
        "semantic": [],
        "merged": [
          "icons",
          "box",
          "board",
          "list",
          "clicked"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4677912301173998,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.260894+00:00"
      }
    },
    {
      "chapter_number": 10,
      "title": "Segment 10 (pages 78-86)",
      "start_page": 78,
      "end_page": 86,
      "summary": "But we will also be using another coordinate system for the boxes.\nbox’s top left corner, (220, 165).\nThe leftTopCoordsOfBox() function will take box coordinates and return pixel \nBecause a box takes up multiple pixels on the screen, we will always return the \nsingle pixel at the top left corner of the box.\ndrawing these boxes.\nConverting from Pixel Coordinates to Box Coordinates \nmouse movement events use) to box coordinates (so we can find out over which box the mouse \nIn order to find which box the mouse coordinates are over, we will go through each box’s \nmoved over and will return the box coordinates.\nThe drawIcon() function will draw an icon (with the specified shape and color) at the \ndifferent set of Pygame drawing function calls for it, so we must have a large set of if and elif \nThe X and Y coordinates of the left and top edge of the box can be obtained by calling the \npygame.draw.circle(DISPLAYSURF, color, (left + half, top + half), \npygame.draw.circle(DISPLAYSURF, BGCOLOR, (left + half, top + \npygame.draw.rect(DISPLAYSURF, color, (left + quarter, top + \npygame.draw.polygon(DISPLAYSURF, color, ((left + half, top), (left \npygame.draw.line(DISPLAYSURF, color, (left, top + i), (left + \npygame.draw.line(DISPLAYSURF, color, (left + i, top + BOXSIZE \npygame.draw.ellipse(DISPLAYSURF, color, (left, top + quarter, \nSyntactic Sugar with Getting a Board Space’s Icon’s Shape and Color \nBut if you looked a code like shape, color = board[boxx][boxy][0], \nDrawing the Box Cover \ndef drawBoxCovers(board, boxes, coverage): \n# Draws boxes being covered/revealed.\n\"boxes\" is a list \n# of two-item lists, which have the x & y spot of the box.\nleft, top = leftTopCoordsOfBox(box[0], box[1]) \npygame.draw.rect(DISPLAYSURF, BGCOLOR, (left, top, BOXSIZE, \nshape, color = getShapeAndColor(board, box[0], box[1]) \ndrawIcon(shape, color, box[0], box[1]) \npygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, coverage, \nThe drawBoxCovers() function has three parameters: the board data structure, a list of (X, Y) \ntuples for each box that should have the cover drawn, and then the amount of coverage to draw \nfor the boxes.\nSince we want to use the same drawing code for each box in the boxes parameter, we will use a \nfor loop on line 211 so we execute the same code on each box in the boxes list.\nwas there before), draw the icon, then draw however much of the white box over the icon that is \nThe leftTopCoordsOfBox() function will return the pixel coordinates of the top \nleft corner of the box.\n20, there is a 20 pixel wide white box covering the icon.\n# Do the \"box reveal\" animation.\n# Do the \"box cover\" animation.\nto 1, then the white box will only appear to decrease or increase by 1 pixel on each iteration, \n# Draws all of the boxes in their covered or revealed state.\n# Draw a covered box.\npygame.draw.rect(DISPLAYSURF, BOXCOLOR, (left, top, \nshape, color = getShapeAndColor(board, boxx, boxy) \nThe drawBoard() function makes a call to drawIcon() for each of the boxes on the board.\nfor the boxes, and will either draw the icon at that location or draw a white square instead (to \nrepresent a covered up box).\npygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, (left - 5, top - 5, \nTo help the player recognize that they can click on a covered box to reveal it, we will make a blue \n# Randomly reveal the boxes 8 at a time.\nboxes = [] \nboxes.append( (x, y) ) \nThe nested for loops on lines 257 and 258 will add (X, Y) tuples to a list in the boxes \nWe will reveal and cover up the first 8 boxes in this list, then the next 8, then the next 8 after that, \nHowever, since the order of the (X, Y) tuples in boxes would be the same each time, \nTo change up the boxes each time a game starts, we will call the random.shuffle() function \nto randomly shuffle the order of the tuples in the boxes list.\nboxes.\nTo get the lists of 8 boxes, we call our splitIntoGroupsOf() function, passing 8 and the \nlist in boxes.\nRevealing and Covering the Groups of Boxes \nFirst, we draw the board.\ndrawBoard() will end up drawing only covered up white boxes.\nrevealBoxesAnimation(), which will perform the animation of the white boxes being \nanimate the white boxes expanding to cover up the icons.\niteration to animate the next set of 8 boxes.\ncolor1 variable for the background color and then draw the board over it.",
      "keywords": [
        "del myList",
        "BOXSIZE",
        "list",
        "box",
        "boxes",
        "left",
        "board",
        "top",
        "myList",
        "coordinates",
        "function",
        "color",
        "pixel coordinates",
        "box coordinates",
        "draw"
      ],
      "concepts": [
        "boxes",
        "box",
        "function",
        "functions",
        "drawing",
        "color",
        "left",
        "shape",
        "list",
        "returning"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 24,
          "title": "",
          "score": 0.9,
          "base_score": 0.75,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 38,
          "title": "",
          "score": 0.815,
          "base_score": 0.665,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 37,
          "title": "",
          "score": 0.735,
          "base_score": 0.585,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 5,
          "title": "",
          "score": 0.697,
          "base_score": 0.547,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 16,
          "title": "",
          "score": 0.683,
          "base_score": 0.533,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "box",
          "boxes",
          "left",
          "draw",
          "color"
        ],
        "semantic": [],
        "merged": [
          "box",
          "boxes",
          "left",
          "draw",
          "color"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.47444996453467686,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.260942+00:00"
      }
    },
    {
      "chapter_number": 11,
      "title": "Segment 11 (pages 87-94)",
      "start_page": 87,
      "end_page": 94,
      "summary": "# Returns True if all the boxes have been revealed, otherwise False \nIt may seem pointless to have a main() function, since you could just put that code in the global \nscope at the bottom of the program instead, and the code would run the exact same.\nSecond, this also lets you import the program so that you can call and test individual functions.\nWhen a module is imported, all of the code in it is run.\nThat’s why the code is in a separate function that we have named main().\nvariable is automatically set by the Python interpreter to the string '__main__' if the program \nitself is being run and 'memorypuzzle' if it is being imported.\nfunction is not run when we executed the import memorypuzzle statement in the interactive \ninteractive shell and make sure individual functions are returning the correct values by testing \ncan run so much as how to write programs that programmers can read.\nthis, it is important that your program is readable so that you can look at the code and understand \nBut if there was a bug with this code, it would be \nimpossible to read the code and understand what’s going on, much less fix the bug.\nimport random, pygame, sys \nfrom pygame.locals import * \nbb, ee = m(j, k) \nif bb != None and ee != None: \nif not hh[bb][ee]: \nif not hh[bb][ee] and e: \no(i, [(bb, ee)]) \nhh[bb][ee] = True \nh = (bb, ee) \np(i, [(h[0], h[1]), (bb, ee)]) \nhh[bb][ee] = False \nrr.append( (ss, tt) ) \nreturn bbb \ndef aa(bb, ee): \nreturn (bb * 50 + 70, ee * 50 + 65) \noo, ddd = aa(bb, ee) \nreturn (bb, ee) \ndef w(ss, tt, bb, ee): \noo, ddd = aa(bb, ee) \npygame.draw.circle(b, tt, (oo + 20, ddd + 20), 15) \npygame.draw.circle(b, (60, 60, 100), (oo + 20, ddd + 20), 5) \npygame.draw.rect(b, tt, (oo + 10, ddd + 10, 20, 20)) \npygame.draw.polygon(b, tt, ((oo + 20, ddd), (oo + 40 - 1, ddd + 20), \npygame.draw.line(b, tt, (oo, ddd + i), (oo + i, ddd)) \npygame.draw.line(b, tt, (oo + i, ddd + 39), (oo + 39, ddd + i)) \npygame.draw.ellipse(b, tt, (oo, ddd + 10, 40, 20)) \ndef s(bbb, bb, ee): \nreturn bbb[bb][ee][0], bbb[bb][ee][1] \ndef dd(bbb, boxes, gg): \npygame.draw.rect(b, (60, 60, 100), (oo, ddd, 40, 40)) \nss, tt = s(bbb, box[0], box[1]) \npygame.draw.rect(b, (255, 255, 255), (oo, ddd, gg, 40)) \noo, ddd = aa(bb, ee) \npygame.draw.rect(b, (255, 255, 255), (oo, ddd, 40, 40)) \nss, tt = s(bbb, bb, ee) \nw(ss, tt, bb, ee) \ndef n(bb, ee): \noo, ddd = aa(bb, ee) \npygame.draw.rect(b, (0, 0, 255), (oo - 5, ddd - 5, 50, 50), 4) \ndef g(bbb): \ndef jj(bbb): \nThis chapter covers the entire explanation of how the Memory Puzzle program works.\nMany of the other game programs in \nTry running the program to figure out what the bug is, ",
      "keywords": [
        "False return True",
        "ddd",
        "return False",
        "Memory Puzzle",
        "code",
        "Memory Puzzle program",
        "program",
        "bbb",
        "range",
        "main",
        "return True",
        "Memory",
        "Puzzle",
        "function"
      ],
      "concepts": [
        "returns",
        "program",
        "programming",
        "code",
        "bugs",
        "bug",
        "boxes",
        "box",
        "make",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 4,
          "title": "",
          "score": 0.775,
          "base_score": 0.625,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 8,
          "title": "",
          "score": 0.762,
          "base_score": 0.612,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 20,
          "title": "",
          "score": 0.732,
          "base_score": 0.582,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 15,
          "title": "",
          "score": 0.667,
          "base_score": 0.517,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 19,
          "title": "",
          "score": 0.652,
          "base_score": 0.502,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "ee",
          "bb",
          "bb ee",
          "ddd",
          "oo"
        ],
        "semantic": [],
        "merged": [
          "ee",
          "bb",
          "bb ee",
          "ddd",
          "oo"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3753477672980065,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.260985+00:00"
      }
    },
    {
      "chapter_number": 12,
      "title": "Segment 12 (pages 95-102)",
      "start_page": 95,
      "end_page": 102,
      "summary": "The board is a 4x4 grid with fifteen tiles (numbered 1 through 15 going left to right) and one \nBOARDWIDTH = 4  # number of columns in the board \nBOARDHEIGHT = 4 # number of rows in the board \nSOLVEDBOARD = getStartingBoard() # a solved board is the same as the \nelif NEW_RECT.collidepoint(event.pos): \nelif SOLVE_RECT.collidepoint(event.pos): \nslideTo = LEFT \nif event.key in (K_LEFT, K_a) and isValidMove(mainBoard, \nLEFT): \nslideTo = LEFT \nelif event.key in (K_RIGHT, K_d) and \nelif event.key in (K_UP, K_w) and isValidMove(mainBoard, \nelif event.key in (K_DOWN, K_s) and isValidMove(mainBoard, \n# Return a board data structure with tiles in the solved state.\nboard = [] \nboard.append(column) \nboard[BOARDWIDTH-1][BOARDHEIGHT-1] = None \nreturn board \ndef getBlankPosition(board): \n# Return the x and y of board coordinates of the blank space.\nif board[x][y] == None: \ndef makeMove(board, move): \nblankx, blanky = getBlankPosition(board) \nelif move == LEFT: \n1][blanky], board[blankx][blanky] \n1][blanky], board[blankx][blanky] \ndef isValidMove(board, move): \nblankx, blanky = getBlankPosition(board) \nreturn (move == UP and blanky != len(board[0]) - 1) or \\ \n(move == LEFT and blankx != len(board) - 1) or \\ \ndef getRandomMove(board, lastMove=None): \nvalidMoves = [UP, DOWN, LEFT, RIGHT] \nif lastMove == UP or not isValidMove(board, DOWN): \nif lastMove == DOWN or not isValidMove(board, UP): \nif lastMove == LEFT or not isValidMove(board, RIGHT): \nif lastMove == RIGHT or not isValidMove(board, LEFT): \nreturn (left, top) \ndef getSpotClicked(board, x, y): \nfor tileX in range(len(board)): \nfor tileY in range(len(board[0])): \ntileRect = pygame.Rect(left, top, TILESIZE, TILESIZE) \n# draw a tile at board coordinates tilex and tiley, optionally a few \npygame.draw.rect(DISPLAYSURF, TILECOLOR, (left + adjx, top + adjy, \ndef makeText(text, color, bgcolor, top, left): \ndef drawBoard(board, message): \nfor tilex in range(len(board)): \nfor tiley in range(len(board[0])): \nif board[tilex][tiley]: \npygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (left - 5, top - 5, width + \ndef slideAnimation(board, direction, message, animationSpeed): \nblankx, blanky = getBlankPosition(board) \nelif direction == LEFT: \ndrawBoard(board, message) \npygame.draw.rect(baseSurf, BGCOLOR, (moveLeft, moveTop, TILESIZE, \nif direction == LEFT: \nboard = getStartingBoard() \ndrawBoard(board, '') \nmove = getRandomMove(board, lastMove) ",
      "keywords": [
        "board",
        "Play Slide Puzzle",
        "TILESIZE",
        "Slide Puzzle",
        "blanky",
        "left",
        "blankx",
        "Slide",
        "Play Slide",
        "SURF",
        "Puzzle",
        "RECT",
        "BOARDWIDTH",
        "move",
        "movex"
      ],
      "concepts": [
        "board",
        "left",
        "event",
        "returns",
        "messages",
        "right",
        "slide",
        "sliding",
        "white",
        "numbered"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 14,
          "title": "",
          "score": 0.843,
          "base_score": 0.693,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 13,
          "title": "",
          "score": 0.804,
          "base_score": 0.654,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 36,
          "title": "",
          "score": 0.768,
          "base_score": 0.618,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 39,
          "title": "",
          "score": 0.761,
          "base_score": 0.611,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 21,
          "title": "",
          "score": 0.723,
          "base_score": 0.573,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "board",
          "blanky",
          "left",
          "blankx",
          "isvalidmove"
        ],
        "semantic": [],
        "merged": [
          "board",
          "blanky",
          "left",
          "blankx",
          "isvalidmove"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4593439926339829,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261031+00:00"
      }
    },
    {
      "chapter_number": 13,
      "title": "Segment 13 (pages 103-111)",
      "start_page": 103,
      "end_page": 111,
      "summary": "pygame.display.set_caption('Slide Puzzle') \nwill undo any moves the player has made, a ―New‖ button that will create a new slide puzzle, and \nWhen the current game state’s board is exactly the same as the solved \nsolved state and then had 80 random slide moves performed on it (because we passed the integer \nThis will make the board into a randomly jumbled state that the player will have to solve (which \nslides it made when it created the board data structure, and then the board can be solved just by \nSince the board originally started in the solved state, undoing all \nthe slides would return it to the solved state.\nFor example, below we perform a ―right‖ slide on the board on the left side of the page, which \nAfter the right slide, if we do the opposite slide (a left slide) then the board will be back in the \nIn the main game loop, the slideTo variable will track which direction the player wants to slide \non line 64 to see if the board data structure has the same value as the solved board data structure \nfor event in pygame.event.get(): # event handling loop \nspotx, spoty = getSpotClicked(mainBoard, event.pos[0], \nelif NEW_RECT.collidepoint(event.pos): \nelif SOLVE_RECT.collidepoint(event.pos): \nBefore going into the event loop, the program calls checkForQuit() on line 69 to see if any \nQUIT events have been created (and terminates the program if there have).\nseparate function (the checkForQuit() function) for handling the QUIT events will be \nThe for loop on line 70 executes the event handling code for any other event \ncreated since the last time pygame.event.get() was called (or since the program started, if \npygame.event.get() has never been called before).\ngetSpotClicked() function which will return the board coordinates of the spot on the board \nThe coordinates of where these buttons are on the window are stored in the pygame.Rect \npass the mouse coordinates from the Event object to the collidepoint() method.\nOur getBlankPosition() function will take the board data structure and return the X and Y \nelif event.type == KEYUP: \n# check if the user pressed a key to slide a tile \nif event.key in (K_LEFT, K_a) and isValidMove(mainBoard, \nelif event.key in (K_RIGHT, K_d) and \nelif event.key in (K_UP, K_w) and isValidMove(mainBoard, \nelif event.key in (K_DOWN, K_s) and isValidMove(mainBoard, \nWe can also let the user slide tiles by pressing keyboard keys.\nThe expression event.key in (K_LEFT, K_a) is just a Python trick to make the code \nIt is a way of saying ―evaluate to True if event.key is equal to one of K_LEFT or \nevent.key in (K_LEFT, K_a) \nevent.key == K_LEFT or event.key == K_a \nNow that the events have all been handled, we should update the variables of the game state and \nIf slideTo has been set (either by the mouse event or \nkeyboard event handling code) then we can call slideAnimation() to perform the sliding \nThe parameters are the board data structure, the direction of the slide, a message to \nChecking for a Specific Event, and Posting Events to Pygame’s Event \nfor event in pygame.event.get(QUIT): # get all the QUIT events \nfor event in pygame.event.get(KEYUP): # get all the KEYUP events \nif event.key == K_ESCAPE: \nterminate() # terminate if the KEYUP event was for the Esc key \npygame.event.post(event) # put the other KEYUP event objects back \nThe checkForQuit() function will check for QUIT events (or if the user has pressed the Esc \nPygame internally has its own list data structure that it creates and appends Event objects to as \nThis data structure is called the event queue.\npygame.event.get() function is called with no parameters, the entire list is returned.\nHowever, you can pass a constant like QUIT to pygame.event.get() so that it will only \nreturn the QUIT events (if any) that are in the internal event queue.\nstay in the event queue for the next time pygame.event.get() is called.\nYou should note that Pygame’s event queue only stores up to 127 Event objects.\ndoes not call pygame.event.get() frequently enough and the queue fills up, then any new \nLine 123 pulls out a list of QUIT events from Pygame’s event queue and returns them.\nare any QUIT events in the event queue, the program terminates.\nLine 125 pulls out all the KEYUP events from the event queue and checks if any of them are for \nIf one of the events is, then the program terminates.\nevents for keys other than the Esc key.\nPygame’s event queue.\nWe can do this with the pygame.event.post() function, which adds \nthe Event object passed to it to the end of the Pygame event queue.\npygame.event.get() the non-Esc key KEYUP events will still be there.\nThe pygame.event.post() function is also handy if you ever want your program to add \nEvent objects to the Pygame event queue.\n# Return a board data structure with tiles in the solved state.",
      "keywords": [
        "Slide Puzzle",
        "Slide",
        "event",
        "board",
        "QUIT events",
        "Event Queue",
        "board data structure",
        "KEYUP events",
        "LEFT",
        "board data",
        "left slide",
        "Puzzle",
        "SOLVE",
        "Pygame event queue",
        "function"
      ],
      "concepts": [
        "event",
        "slide",
        "sliding",
        "key",
        "keys",
        "board",
        "functions",
        "function",
        "solved",
        "solve"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 12,
          "title": "",
          "score": 0.804,
          "base_score": 0.654,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 15,
          "title": "",
          "score": 0.761,
          "base_score": 0.761,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 41,
          "title": "",
          "score": 0.737,
          "base_score": 0.587,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 14,
          "title": "",
          "score": 0.694,
          "base_score": 0.544,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 9,
          "title": "",
          "score": 0.684,
          "base_score": 0.534,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "event",
          "pygame event",
          "queue",
          "slide",
          "events"
        ],
        "semantic": [],
        "merged": [
          "event",
          "pygame event",
          "queue",
          "slide",
          "events"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.48997003791508076,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261077+00:00"
      }
    },
    {
      "chapter_number": 14,
      "title": "Segment 14 (pages 112-120)",
      "start_page": 112,
      "end_page": 120,
      "summary": "board = [] \nboard[BOARDWIDTH-1][BOARDHEIGHT-1] = None \nreturn board \nrepresents a ―solved‖ board, where all the numbered tiles are in order and the blank tile is in the \nGoing down the column, the numbers increase by the size of the board’s width (which is stored in \n# Return the x and y of board coordinates of the blank space.\nentire board and finds the blank space coordinates.\nThe None value is used in the board data \nfor loops to find which space on the board is the blank space.\nMaking a Move by Updating the Board Data Structure \nThe data structure in the board parameter is a 2D list that represents where all the tiles are.\nThe makeMove() function doesn’t have to return any values, because the board parameter has \nreturn (move == UP and blanky != len(board[0]) - 1) or \\ \n(move == LEFT and blankx != len(board) - 1) or \\ \nThe isValidMove() function is passed a board data structure and a move the player would \nexample, you cannot slide a tile to the left one hundred times in a row, because eventually the \nblank space will be at the edge and there are no more tiles to slide to the left.\nif lastMove == LEFT or not isValidMove(board, RIGHT): \nif lastMove == RIGHT or not isValidMove(board, LEFT): \nand create the puzzle by randomly sliding around tiles.\nIf you had a slide puzzle and slid a tile to left, and then slid a tile to the right, you would end up \ntile up or to the left.\nDepending on if the blank space is at the edge of the board, lines 184 to 191 will \nThe getLeftTopOfTile() function converts board coordinates to pixel coordinates.\nboard XY coordinates that are passed in, the function calculates and returns the pixel XY \ncoordinates of the pixel at the top left of that board space.\nConverting from Pixel Coordinates to Board Coordinates \n# from the x & y pixel coordinates, get the x & y board coordinates \nconverts from pixel coordinates to board coordinates.\nthrough every possible XY board coordinate, and if the pixel coordinates that were passed in are \nwithin that space on the board, it returns those board coordinates.\nrepresents the space on the board by getting the pixel coordinates of the top left corner of the \nboard space, and then use the collidepoint() Rect method to see if the pixel coordinates are \nIf the pixel coordinates that were passed in were not over any board space, then the value \nDrawing a Tile \n# draw a tile at board coordinates tilex and tiley, optionally a few \npygame.draw.rect(DISPLAYSURF, TILECOLOR, (left + adjx, top + adjy, \nThe drawTile() function will draw a single numbered tile on the board.\ntiley parameters are the board coordinates of the tile.\ntile appear 5 pixels to the right of the tilex and tiley space on the board.\nadjx would make the tile appear 10 pixels to the left of the space.\nThese adjustment values will be handy when we need to draw the tile in the middle of sliding.\nThis means they will be exactly on the board space given by tilex and tiley.\nThe Pygame drawing functions only use pixel coordinates, so first line 217 converts the board \ncoordinates in tilex and tiley to pixel coordinates, which we will store in variables left \nbackground square of the tile with a call to pygame.draw.rect() while adding the adjx \nand adjy values to left and top in case the code needs to adjust the position of the tile.\nLines 219 to 222 then create the Surface object that has the number text drawn on it.\nsince the caller of drawTile() probably will want to draw more tiles for the rest of the board \nThe makeText() function handles creating the Surface and Rect objects for positioning text on \nDrawing the Board \nif board[tilex][tiley]: \nThis function handles drawing the entire board and all of its tiles to the DISPLAYSURF display \nNext, nested for loops are used to draw each tile to the display Surface object by calling the \nDrawing the Border of the Board \npygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (left - 5, top - 5, width + \nLines 244 to 247 draw a border around the tiles.\nto the left and 5 pixels above the top left corner of the tile at board coordinates (0, 0).\nand height of the border are calculated from the number of tiles wide and high the board is (stored \ndef slideAnimation(board, direction, message, animationSpeed): \nThe first thing our tile sliding animation code needs to calculate is where the blank space is and \ncoordinates and the direction of the slide, we can figure out the XY board coordinates of the tile \n# draw a blank space over the moving tile on the baseSurf Surface.\ndraw on one Surface object using blit() or the Pygame drawing functions, it will not change \nNext, we paint another blank space over the tile that will slide.\neach frame of the sliding animation, we will draw the sliding tile over different parts of the \nIf we didn’t blank out the moving tile on the baseSurf Surface, \nthen it would still be there as we draw the sliding tile.\nAnd then what it would look like when we draw the ―9‖ tile sliding upwards on top of it: \ndisplay Surface, then on each frame of the animation draw the sliding tile closer and closer to its ",
      "keywords": [
        "board",
        "board coordinates",
        "LEFT",
        "tile",
        "Surface",
        "coordinates",
        "Surface object",
        "blank space",
        "Pixel Coordinates",
        "TILESIZE",
        "Move",
        "space",
        "blankx",
        "board data structure",
        "blanky"
      ],
      "concepts": [
        "board",
        "left",
        "lines",
        "function",
        "functions",
        "returned",
        "surface",
        "numbers",
        "numbering",
        "text"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 12,
          "title": "",
          "score": 0.843,
          "base_score": 0.693,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 36,
          "title": "",
          "score": 0.819,
          "base_score": 0.669,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 39,
          "title": "",
          "score": 0.756,
          "base_score": 0.606,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 35,
          "title": "",
          "score": 0.74,
          "base_score": 0.59,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 9,
          "title": "",
          "score": 0.723,
          "base_score": 0.573,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "board",
          "tile",
          "coordinates",
          "space",
          "pixel coordinates"
        ],
        "semantic": [],
        "merged": [
          "board",
          "tile",
          "coordinates",
          "space",
          "pixel coordinates"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.43921467089851934,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261120+00:00"
      }
    },
    {
      "chapter_number": 15,
      "title": "Segment 15 (pages 121-129)",
      "start_page": 121,
      "end_page": 129,
      "summary": "Those events will be handled the next time execution reaches line 70 in the main() \npygame.time.wait(500) # pause 500 milliseconds for effect \ncreate a new board data structure by calling getStartingBoard() and then randomly \nThe first few lines of generateNewPuzzle() get the board and then draw it to \nslideAnimation(board, move, 'Generating new puzzle...', \nThe code for doing a random move is the getRandomMove() call on line 305 to get the \n104    http://inventwithpython.com/pygame \ndoing the slide animation does not actually update the board data structure, we update the board \nWe need to keep track of each of the random moves that was made so that the player can click the \n―Solve‖ button later and have the program undo all these random moves.\nlist of moves in sequence on line 308.\nThen we store the random move in a variable called lastMove which will be passed to \nAll of this needs to happen numSlides number of times, so we put lines 305 to 309 inside a \nalso the list of the random moves made on it.\nslideAnimation(board, oppositeMove, '', int(TILESIZE / 2)) \nmakeMove(board, oppositeMove) \nWhen the player clicks on ―Reset‖ or ―Solve‖, the Slide Puzzle game program needs to undo all \nof the moves that were made to the board.\nLine 315 uses list slicing to create a duplicate of the allMoves list.\nThis makes a copy of the actual list to store in revAllMoves, rather than just a \nWe call this on the revAllMoves list on line 316.\nThe for loop on line 318 iterates over the list of directional values.\nanimation, and makeMove() to update the board data structure.\nJust like in the Memory Puzzle game, after all the def statements have been executed to create \nThat’s all there is to the Slide Puzzle program!\nbetween execution time and memory usage.\nThe more variables and the larger the lists your program uses, the more memory it takes \n(You can find out how to measure your program’s memory usage and execution time at \nThis function takes time to run, \n106    http://inventwithpython.com/pygame \ncoordinates so we would not have to look through the entire board each time we want to know \nThis code could go in makeMove().) Using these variables \nwould take up more memory, but they would save you on execution time so your program would \nvariable, so that we can compare the current board to SOLVEDBOARD to see if the player has \nthen our program would take longer to run because it is re-creating the solved-state board data \nIf another programmer can look at your program’s source code and figure \nideas for new features always come up), then having a readable program makes those tasks much \nyou any memory when your program actually runs.\nbecause they’ll make your program more readable.\nSimilarly, there are times when you can rearrange your code in some way to make it slightly \nsentence, saving a few nanoseconds of execution time in your program won’t be noticed by the \nThis chapter hasn’t introduced any new Pygame programming concepts that the Memory Puzzle \n108    http://inventwithpython.com/pygame \nThe buttons \nEach time the player successfully simulates the pattern, the pattern \nThis source code can be downloaded from http://invpy.com/simulate.py.\nhttp://invpy.com/diff/simulate to see if the differences between your code and the code in the \n3. # http://inventwithpython.com/pygame \n6. import random, sys, time, pygame \nYELLOWRECT = pygame.Rect(XMARGIN, YMARGIN, BUTTONSIZE, BUTTONSIZE) \nBLUERECT   = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN, \nREDRECT    = pygame.Rect(XMARGIN, YMARGIN + BUTTONSIZE + BUTTONGAPSIZE, \nGREENRECT  = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN + \nFPSCLOCK = pygame.time.Clock() \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \n110    http://inventwithpython.com/pygame \n# Initialize some variables for a new game \nclickedButton = None # button that was clicked (set to YELLOW, \nfor event in pygame.event.get(): # event handling loop \npygame.time.wait(1000) \npattern.append(random.choice((YELLOW, BLUE, RED, GREEN))) \nfor button in pattern: \npygame.time.wait(FLASHDELAY) \nif clickedButton and clickedButton == pattern[currentStep]: \n# pushed the last button in the pattern \nelif (clickedButton and clickedButton != pattern[currentStep]) \n# pushed the incorrect button, or has timed out \n# reset the variables for a new game: \npygame.time.wait(1000) ",
      "keywords": [
        "board",
        "Slide Puzzle",
        "move",
        "BUTTONSIZE",
        "code",
        "program",
        "Puzzle",
        "Slide Puzzle game",
        "list",
        "Memory Puzzle game",
        "pattern",
        "Memory",
        "board data structure",
        "time",
        "Puzzle game"
      ],
      "concepts": [
        "board",
        "program",
        "programming",
        "button",
        "variable",
        "variables",
        "simulators",
        "simulate",
        "pattern",
        "code"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 13,
          "title": "",
          "score": 0.761,
          "base_score": 0.761,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 19,
          "title": "",
          "score": 0.76,
          "base_score": 0.61,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 20,
          "title": "",
          "score": 0.722,
          "base_score": 0.572,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 6,
          "title": "",
          "score": 0.714,
          "base_score": 0.564,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 8,
          "title": "",
          "score": 0.677,
          "base_score": 0.527,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "pattern",
          "time",
          "memory",
          "puzzle",
          "board"
        ],
        "semantic": [],
        "merged": [
          "pattern",
          "time",
          "memory",
          "puzzle",
          "board"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.48215802633570143,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261166+00:00"
      }
    },
    {
      "chapter_number": 16,
      "title": "Segment 16 (pages 130-139)",
      "start_page": 130,
      "end_page": 139,
      "summary": "pygame.draw.rect(DISPLAYSURF, YELLOW, YELLOWRECT) \npygame.draw.rect(DISPLAYSURF, BLUE,   BLUERECT) \npygame.draw.rect(DISPLAYSURF, RED,    REDRECT) \npygame.draw.rect(DISPLAYSURF, GREEN,  GREENRECT) \nflashSurf = pygame.Surface(DISPLAYSURF.get_size()) \n6. import random, sys, time, pygame \nTIMEOUT = 4 # seconds before game over if no button is pushed.\nbuttons light up) and the amount of time the player has to push the next button in the sequence \nbefore the game times out.\nSetting Up the Buttons \n# Rect objects for each of the four buttons \nYELLOWRECT = pygame.Rect(XMARGIN, YMARGIN, BUTTONSIZE, BUTTONSIZE) \nBLUERECT   = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN, \nREDRECT    = pygame.Rect(XMARGIN, YMARGIN + BUTTONSIZE + BUTTONGAPSIZE, \nGREENRECT  = pygame.Rect(XMARGIN + BUTTONSIZE + BUTTONGAPSIZE, YMARGIN + \nSimulate game has four rectangular areas and code to handle when the player clicks inside of \nThe program will need Rect objects for the areas of the four buttons so it can call the \nFPSCLOCK = pygame.time.Clock() \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \nbutton or using the Q, W, A, S keys.', 1, DARKGRAY) \nLines 55 to 58 will load sound files so that Simulate can play sound effects as the player clicks on \neach button.\ncurrentStep = 0 # the color the player must push next \nlastClickTime = 0 # timestamp of the player's last button push \nplayer to click a colored button: \nThe pattern variable will be a list of color values (either YELLOW, RED, BLUE, or GREEN) to \nhave to first click the red button twice, then the yellow button, then the red button, and so on until \nthe final green button.\nThe currentStep variable will keep track of which color in the pattern list the player has to \nIf currentStep was 0 and pattern was [GREEN, RED, RED, YELLOW], \nthen the player would have to click the green button.\nIf they clicked on any other button, the code \nThere is a TIMEOUT constant that makes the player click on next button in the pattern within a \npassed since the last button click, the lastClickTime variable needs to keep track of the last \ntime the player clicked on a button.\nbuttons for the player (in which case, waitingForInput is set to False), or the program has \nfinished playing the pattern and is waiting for the user to click the buttons in the correct order (in \nclickedButton = None # button that was clicked (set to YELLOW, \nLine 68 is the start of the main game loop.\nIf a button is clicked during this iteration, then clickedButton \nwill be set to one of the color values to match the button (YELLOW, RED, GREEN, or BLUE).\nThe four colored buttons are drawn with a call to the drawButtons() \nwhy we create new Surface objects by calling the render() method on line 73 inside the game \nfor event in pygame.event.get(): # event handling loop \nIf the mouse click was over one of the four buttons, then our \ngetButtonClicked() function will return a Color object of the button clicked (otherwise it \nThe Q key is in the upper left of the four keyboard keys, just like the yellow button on the screen \nis in the upper left, so we will make pressing the Q key the same as clicking on the yellow button.\npygame.time.wait(1000) \npattern.append(random.choice((YELLOW, BLUE, RED, GREEN))) \nfor button in pattern: \nflashButtonAnimation(button) \npygame.time.wait(FLASHDELAY) \nWhen waitingForInput is True, the program will be waiting for the user to select buttons.\nLines 97 to 105 will cover the case where the program displays the pattern animation.\nis done at the start of the game or when the player finishes a pattern, line 101 will add a random \nAfter it is done lighting up all the buttons in the pattern list, the program sets the \nFiguring Out if the Player Pressed the Right Buttons \n# wait for the player to enter buttons \n108 checks if the player has clicked on a button during this iteration of the game loop and if that \nbutton was the correct one.\nlist for the button that the player should click on next.\nFor example, if pattern was set to [YELLOW, RED, RED] and the currentStep variable \nwas set to 0 (like it would be when the player first starts the game), then the correct button for the \nplayer to click would be pattern[0] (the yellow button).\nIf the player has clicked on the correct button, we want to flash the button the player clicked by \n# pushed the last button in the pattern \nthat else statement, we know the player clicked on a button and also it was the correct button.\nLine 114 checks if this was the last correct button in the pattern list by checking if the integer \nstored in currentStep is equal to the number of values inside the pattern list.\nloop the code will add a new Color value to the pattern list and then flash the buttons.\nelif (clickedButton and clickedButton != pattern[currentStep]) \nIf the player did not click on the correct button, the elif statement on line 121 handles the case \nwhere either the player clicked on the wrong button or the player has waited too long to click on a \nbutton.\nthe elif statement’s condition checks if a button was clicked and was the wrong button to click.\nclickedButton == pattern[currentStep] which evaluates to True if the player \nclicked a button and it was the correct button to click.\nThe other part of line 121’s elif condition is (currentStep != 0 and time.time() \nIn order to ―time out‖, it must not be the player’s first button click.\n0 is True, then we know the player has begun clicking the buttons.\n(because 4 is stored in TIMEOUT) must be greater than the last time clicked a button (stored in ",
      "keywords": [
        "button",
        "pattern",
        "player",
        "RED",
        "BUTTONSIZE",
        "yellow button",
        "YELLOW",
        "time",
        "line",
        "game",
        "GREEN",
        "correct button",
        "color",
        "BLUE",
        "red button"
      ],
      "concepts": [
        "buttons",
        "time",
        "pattern",
        "color",
        "event",
        "variables",
        "variable",
        "key",
        "keys",
        "lines"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 38,
          "title": "",
          "score": 0.861,
          "base_score": 0.711,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 37,
          "title": "",
          "score": 0.799,
          "base_score": 0.649,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 17,
          "title": "",
          "score": 0.767,
          "base_score": 0.617,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 24,
          "title": "",
          "score": 0.724,
          "base_score": 0.574,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 10,
          "title": "",
          "score": 0.683,
          "base_score": 0.533,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "button",
          "pattern",
          "click",
          "buttons",
          "player"
        ],
        "semantic": [],
        "merged": [
          "button",
          "pattern",
          "click",
          "buttons",
          "player"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5062102197412772,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261213+00:00"
      }
    },
    {
      "chapter_number": 17,
      "title": "Segment 17 (pages 140-147)",
      "start_page": 140,
      "end_page": 147,
      "summary": "A small pause and a new background color will be set to indicate to the player the \nJust like the other game programs, the last thing done in the game loop is drawing the display \ndef flashButtonAnimation(color, animationSpeed=50): \nthree local variables differently depending on the value in the color parameter: sound, \nAnimating the Button Flash \nboard is drawn and then on top of that, the bright color version of the button that is flashing is \nThe alpha value of the bright color starts off at 0 for the first frame of \nanimation, but then on each frame after the alpha value is slowly increased until it is fully opaque \nis done with the same code, except that instead of the alpha value increasing for each frame, it \nAs the alpha value gets lower and lower, the bright color painted on top will \nTo do this in code, line 168 creates a copy of the display Surface object and stores it in \nLine 169 creates a new Surface object the size of a single button and stores it in \nThe convert_alpha() method is called on flashSurf so that the Surface \nobject can have transparent colors drawn on it (otherwise, the alpha value in the Color objects we \nconvert_alpha() method on any Surface objects that have transparent colors painted on \nLine 171 creates individual local variables named r, g, and b to store the individual RGB values \nBefore we begin animating the button flash, line 172 will play \nstarted to play, so the sound will be playing during the button flash animation.\nfor start, end, step in ((0, 255, 1), (255, 0, -1)): # animation loop \nRemember that to do the animation, we want to first draw the flashSurf with color that has \nincreasing alpha values from 0 to 255 to do the brightening part of the animation.\npart of the animation (where the alpha value goes from 0 to 255) and the second for loop would \nhandle the dimming part of the animation (where the alpha values goes from 255 to 0).\nThis is what we do with the for loop on line 173, which supplies different values for \nfor start, end, step in ((0, 255, 1), (255, 0, -1)): # animation loop \nOn the first iteration of line 173’s for loop, start is set to 0, end is set to 255, and step is \nThis way, when the for loop on line 174 is executed, it is calling range(0, 255, \nLine 174’s for loop then executes and performs the brightening animation.\nOn the second iteration of line 173’s for loop (there are always two and only two iterations of \nWhen the line \n174’s for loop is executed, it is calling range(255, 0, -animationSpeed).\nHere’s the code again that is inside line 174’s for loop: \nby calling fill() (supplying the r, g, b values of the color we got on line 171 and the alpha \nvalue that the for loop sets in the alpha variable).\nSince each of the buttons is just a rectangle of a certain color in a certain place, we just make four \ncalls to pygame.draw.rect() to draw the buttons on the display Surface.\nfor alpha in range(0, 255, animationSpeed): # animation loop \nThe background color change animation happens whenever the player finishes entering the entire \nOn each iteration through the loop which starts on line 198 the entire display \nSurface has to be redrawn (blended with a less and less transparent new background color, until \nLine 200 fills in the entire display Surface (stored in DISPLAYSURF) with the old \nbackground color (which is stored in bgColor).\nLine 202 fills in a different Surface object (stored in newBgSurf) with the new \nbackground color’s RGB values (and the alpha transparency value changes on each \niteration since that is what the for loop on line 198 does).\nLine 203 then draws the newBgSurf Surface to the display Surface in DISPLAYSURF.\non the Surface, whereas the blit() method will blend the colors.\nLine 207 and 208 then just draws the display Surface to the screen and adds a pause.\nfunction modifies the content of the variable with an assignment statement on line 209.\nfunction can read the value of a global variable without specifying the global statement.\nIf that function assigns a value to a global variable without a global statement, then Python \nThe main() function uses the bgColor variable but doesn’t need a global statement \ndef gameOverAnimation(color=WHITE, animationSpeed=50): \nflashSurf = pygame.Surface(DISPLAYSURF.get_size()) \nEach of the iterations of the for loop on the next line (line 223 below) will perform a flash.\nhave three flashes done, we put all of that code in a for loop that has three iterations.\nvariables will be used on the next for loop (on line 224) to control how the alpha variable \nanimation loop \nThis animation loop works the same as the previous flashing animation code in the ―Animating \ndrawn on the display Surface, then flashSurf (which has the new flashing color painted on it) \nAfter the background color is set up, the buttons are drawn \nThe for loop on line 226 adjusts the alpha value for the color used for each frame of animation \nvalues YELLOW, BLUE, RED, or GREEN if one of the buttons was clicked, or returns None if the \nNormally when a function reaches the end and returns the None value implicitly (that is, there is \nabout the return value.\nAll function calls have to return a value (so that they can evaluate to \nsomething and be part of expressions), but our code doesn’t always make use of the return value.",
      "keywords": [
        "display Surface",
        "line",
        "Surface",
        "color",
        "alpha",
        "loop",
        "Surface object",
        "animation",
        "background color",
        "button",
        "animation loop",
        "display Surface object",
        "animationSpeed",
        "Button Flash",
        "code"
      ],
      "concepts": [
        "color",
        "function",
        "functions",
        "line",
        "value",
        "animation",
        "animating",
        "surface",
        "flash",
        "flashes"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 16,
          "title": "",
          "score": 0.767,
          "base_score": 0.617,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 38,
          "title": "",
          "score": 0.727,
          "base_score": 0.577,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 5,
          "title": "",
          "score": 0.681,
          "base_score": 0.531,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 37,
          "title": "",
          "score": 0.657,
          "base_score": 0.507,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 24,
          "title": "",
          "score": 0.638,
          "base_score": 0.488,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "alpha",
          "animation",
          "color",
          "loop",
          "line"
        ],
        "semantic": [],
        "merged": [
          "alpha",
          "animation",
          "color",
          "loop",
          "line"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.39685725245026693,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261271+00:00"
      }
    },
    {
      "chapter_number": 18,
      "title": "Segment 18 (pages 148-160)",
      "start_page": 148,
      "end_page": 160,
      "summary": "To make your code more readable, it is better to have your code be explicit (that is, clearly state \nAlthough never is often better than *right* now.\nthe worm so that it eats the apple.\nThe game is over if the worm \n6. import random, pygame, sys \nHEAD = 0 # syntactic sugar: index of the worm's head \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \npygame.display.set_caption('Wormy') \nwormCoords = [{'x': startx,     'y': starty}, \nfor event in pygame.event.get(): # event handling loop \nif (event.key == K_LEFT or event.key == K_a) and direction \nif wormCoords[HEAD]['x'] == -1 or wormCoords[HEAD]['x'] == \nCELLWIDTH or wormCoords[HEAD]['y'] == -1 or wormCoords[HEAD]['y'] == \nif wormBody['x'] == wormCoords[HEAD]['x'] and wormBody['y'] == \nwormCoords[HEAD]['y']: \nif wormCoords[HEAD]['x'] == apple['x'] and wormCoords[HEAD]['y'] \ndel wormCoords[-1] # remove worm's tail segment \n# move the worm by adding a segment in the direction it is moving \nnewHead = {'x': wormCoords[HEAD]['x'], 'y': \nwormCoords[HEAD]['y'] - 1} \nnewHead = {'x': wormCoords[HEAD]['x'], 'y': \nwormCoords[HEAD]['y'] + 1} \nnewHead = {'x': wormCoords[HEAD]['x'] - 1, 'y': \nwormCoords[HEAD]['y']} \nnewHead = {'x': wormCoords[HEAD]['x'] + 1, 'y': \nwormCoords[HEAD]['y']} \nif len(pygame.event.get(QUIT)) > 0: \nkeyUpEvents = pygame.event.get(KEYUP) \nreturn {'x': random.randint(0, CELLWIDTH - 1), 'y': random.randint(0, \ndef drawWorm(wormCoords): \nwormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \npygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \nwormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, \npygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nappleRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \npygame.draw.rect(DISPLAYSURF, RED, appleRect) \nfor x in range(0, WINDOWWIDTH, CELLSIZE): # draw vertical lines \npygame.draw.line(DISPLAYSURF, DARKGRAY, (x, 0), (x, WINDOWHEIGHT)) \nfor y in range(0, WINDOWHEIGHT, CELLSIZE): # draw horizontal lines \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, y), (WINDOWWIDTH, y)) \nIf you play the game a little, you’ll notice that the apple and the segments of the worm’s body \n6. import random, pygame, sys \nThe code at the start of the program just sets up some constant variables used in the game.\nthe WINDOWWIDTH or WINDOWHEIGHT constants were set to 15, then only 1.5 cells could fit.\nHEAD = 0 # syntactic sugar: index of the worm's head \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \npygame.display.set_caption('Wormy') \nIn the Wormy game program, we’ve put the main part of the code in a function called \nThen we want to call runGame(), which will start a game of Wormy.\nwill return when the player’s worm collides into a wall or into itself and causes a game over.\nthat function call returns, the loop goes back to the start and calls runGame() again.\nwormCoords = [{'x': startx,     'y': starty}, \nAt the beginning of a game, we want the worm to start in a random position (but not too close to \nThe body of the worm will be stored in a list of dictionary values.\nvalue per body segment of the worm.\nThe dictionary will have keys 'x' and 'y' for the XY \ntwo body segments will be one and two cells to the left of the head.\nThe head of the worm will always be the body part at wormCoords[0].\nmore readable, we’ve set the HEAD constant to 0 on line 32, so that we can use \nfor event in pygame.event.get(): # event handling loop \nif (event.key == K_LEFT or event.key == K_a) and direction \nLine 61 is the start of the main game loop and line 62 is the start of the event handling loop.\nFor example, if the worm is moving left, then if the player accidentally presses the right \narrow key, the worm would immediate start going right and crash into itself.\nif wormCoords[HEAD]['x'] == -1 or wormCoords[HEAD]['x'] == \nCELLWIDTH or wormCoords[HEAD]['y'] == -1 or wormCoords[HEAD]['y'] == \nif wormBody['x'] == wormCoords[HEAD]['x'] and wormBody['y'] == \nwormCoords[HEAD]['y']: \nThe worm has crashed when the head has moved off the edge of the grid or when the head moves \nWe can check if the head has moved off the edge of the grid by seeing if either the X coordinate \nof the head (which is stored in wormCoords[HEAD]['x']) is -1 (which is past the left edge \nof the grid) or equal to CELLWIDTH (which is past the right edge, since the rightmost X cell \nThe head has also moved off the grid if the Y coordinate of the head (which is stored in \nwormCoords[HEAD]['y']) is either -1 (which is past the top edge) or CELLHEIGHT \nreturns to the function call in main(), the next line after the runGame() call (line 46) is the \nLine 80 loops through every body segment in wormCoords after the head (which is at index 0.\nboth the 'x' and 'y' values of the body segment are the same as the 'x' and 'y' of the head, \nthen we also end the game by returning out of the runGame() function.\nif wormCoords[HEAD]['x'] == apple['x'] and wormCoords[HEAD]['y'] \ndel wormCoords[-1] # remove worm's tail segment \nWe do a similar collision detection check between the head of the worm and the apple’s XY \nIf the head has not collided with an apple, then we delete the last body segment in the \nbody segment (for the head) in the direction that the worm is going.\nBy not deleting the last body segment when the worm eats an apple, the overall \nremains the same because a new head segment is added right afterwards.\n# move the worm by adding a segment in the direction it is moving \nnewHead = {'x': wormCoords[HEAD]['x'], 'y': \nwormCoords[HEAD]['y'] - 1} \nnewHead = {'x': wormCoords[HEAD]['x'], 'y': \nwormCoords[HEAD]['y'] + 1} \nnewHead = {'x': wormCoords[HEAD]['x'] - 1, 'y': \nwormCoords[HEAD]['y']} \nnewHead = {'x': wormCoords[HEAD]['x'] + 1, 'y': \nwormCoords[HEAD]['y']} \nTo move the worm, we add a new body segment to the beginning of the wormCoords list.\nBecause the body segment is being added to the beginning of the list, it will become the new \nis added or subtracted from either the X or Y coordinate depends on the direction the worm was \nThis new head segment is added to wormCoords with the insert() list method on line 100.",
      "keywords": [
        "HEAD",
        "wormCoords",
        "worm",
        "CELLSIZE",
        "direction",
        "Wormy",
        "WINDOWWIDTH",
        "WINDOWHEIGHT",
        "LEFT",
        "apple",
        "game",
        "worm head",
        "segment",
        "event.key",
        "body segment"
      ],
      "concepts": [
        "wormy",
        "key",
        "keys",
        "worm",
        "randomly",
        "returns",
        "head",
        "right",
        "idea",
        "apple"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 19,
          "title": "",
          "score": 0.88,
          "base_score": 0.73,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 20,
          "title": "",
          "score": 0.771,
          "base_score": 0.621,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 4,
          "title": "",
          "score": 0.706,
          "base_score": 0.556,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 6,
          "title": "",
          "score": 0.666,
          "base_score": 0.516,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 15,
          "title": "",
          "score": 0.662,
          "base_score": 0.512,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "head",
          "wormcoords",
          "wormcoords head",
          "worm",
          "head wormcoords"
        ],
        "semantic": [],
        "merged": [
          "head",
          "wormcoords",
          "wormcoords head",
          "worm",
          "head wormcoords"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.47238735323206593,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261318+00:00"
      }
    },
    {
      "chapter_number": 19,
      "title": "Segment 19 (pages 161-168)",
      "start_page": 161,
      "end_page": 168,
      "summary": "Then the call to pygame.display.update() draws \nif len(pygame.event.get(QUIT)) > 0: \npygame.event.get() on line 117 returns a list of all the QUIT events in the event queue \nthe list that pygame.event.get() returns will be the empty list: [] \nThe len() call on line 117 will return 0 if pygame.event.get() returned an empty list.\npygame.event.get()), then the terminate() function gets called on line 118 and the \nOtherwise, the first key event object in the list that was returned by pygame.event.get() is \nThe Wormy start screen requires two Surface objects with the ―Wormy!‖ text drawn on them.\nLine 135 begins the animation loop for the start screen.\ntext will be rotated and drawn to the display Surface object.\nRotating the Start Screen Text \nrotatedSurf1 = pygame.transform.rotate(titleSurf1, degrees1) \nrotatedSurf2 = pygame.transform.rotate(titleSurf2, degrees2) \nThe showStartScreen() function will rotate the images on the Surface objects that the \nThe first parameter is the Surface object to make a rotated copy of.\nThe second parameter is the number of degrees to rotate the Surface.\npygame.transform.rotate() function doesn’t change the Surface object you pass it, but \nrather returns a new Surface object with the rotated image drawn on it.\nIn order to make a Surface object that can fit the rotated \nfact, if the rotation argument you pass to pygame.transform.rotate() is 360 or larger, \nThe two rotated ―Wormy!‖ Surface objects are blitted to the display Surface on each frame of the \nOn line 147 the drawPressKeyMsg() function call draws the ―Press a key to play.‖ text in the \nBefore returning, pygame.event.get() is called simply to clear out any other events \nThe amount that we rotate the two ―Wormy!‖ text Surface objects is stored in degrees1 and \nthe white text ―Wormy!‖ Surface object will be rotated by another 3 degrees and the green text \n―Wormy!‖ Surface object will be rotated by another 7 degrees.\nThe terminate() function calls pygame.quit() and sys.exit() so that the game \nThe Game Over text will stay on the screen until the player pushes a key.\npygame.time.wait() on line 180.\nThe drawScore() function simply renders and draws the text of the score that was passed in \nwormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \npygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \nwormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, \npygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nLine 199 creates a Rect object for the worm segment that will be passed to the \npygame.draw.rect() function on line 200.\nLine 200 draws a dark green rectangle for the segment.\nappleRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \npygame.draw.rect(DISPLAYSURF, RED, appleRect) \napple (line 208), and then pass this Rect object to the pygame.draw.rect() function.\nfor x in range(0, WINDOWWIDTH, CELLSIZE): # draw vertical lines \npygame.draw.line(DISPLAYSURF, DARKGRAY, (x, 0), (x, WINDOWHEIGHT)) \nfor y in range(0, WINDOWHEIGHT, CELLSIZE): # draw horizontal lines \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, y), (WINDOWWIDTH, y)) \nJust to make it easier to visualize the grid of cells, we call pygame.draw.line() to draw out \npygame.draw.line() with the following coordinates: \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 0), (0, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (20, 0), (20, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (40, 0), (40, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (60, 0), (60, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (560, 0), (560, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (580, 0), (580, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (600, 0), (600, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (620, 0), (620, WINDOWHEIGHT)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 0), (WINDOWWIDTH, 0)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 20), (WINDOWWIDTH, 20)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 40), (WINDOWWIDTH, 40)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 60), (WINDOWWIDTH, 60)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 400), (WINDOWWIDTH, 400)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 420), (WINDOWWIDTH, 420)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 440), (WINDOWWIDTH, 440)) \npygame.draw.line(DISPLAYSURF, DARKGRAY, (0, 460), (WINDOWWIDTH, 460)) \nhere so we don’t have to type out all those pygame.draw.line() calls.",
      "keywords": [
        "Surface object",
        "Surface",
        "DISPLAYSURF",
        "DARKGRAY",
        "WINDOWWIDTH",
        "start screen",
        "display Surface object",
        "display Surface",
        "Wormy",
        "Screen",
        "CELLSIZE",
        "function",
        "WINDOWHEIGHT",
        "key",
        "object"
      ],
      "concepts": [
        "rotated",
        "rotate",
        "rotation",
        "rotations",
        "line",
        "function",
        "functions",
        "drawing",
        "green",
        "coordinates"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 18,
          "title": "",
          "score": 0.88,
          "base_score": 0.73,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 4,
          "title": "",
          "score": 0.853,
          "base_score": 0.703,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 6,
          "title": "",
          "score": 0.808,
          "base_score": 0.658,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 20,
          "title": "",
          "score": 0.804,
          "base_score": 0.654,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 15,
          "title": "",
          "score": 0.76,
          "base_score": 0.61,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "displaysurf darkgray",
          "darkgray",
          "draw line",
          "line displaysurf",
          "pygame"
        ],
        "semantic": [],
        "merged": [
          "displaysurf darkgray",
          "darkgray",
          "draw line",
          "line displaysurf",
          "pygame"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5013362875573883,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261364+00:00"
      }
    },
    {
      "chapter_number": 20,
      "title": "Segment 20 (pages 169-178)",
      "start_page": 169,
      "end_page": 178,
      "summary": "We could have typed out all 56 pygame.draw.line() calls and the \nwormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \npygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \nwormInnerSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, \npygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nNotice that two different Rect objects are created on lines 199 and 201.\npygame.draw.rect() function on line 200.\nThe Rect object created on line 201 is stored in \nthe wormInnerSegmentRect local variable and is passed to the pygame.draw.rect() \nEvery time you create a variable, it takes up a small amount of the computer’s memory.\nmight think it would be clever to reuse the wormSegmentRect variable for both Rect objects, \nwormSegmentRect = pygame.Rect(x, y, CELLSIZE, CELLSIZE) \npygame.draw.rect(DISPLAYSURF, DARKGREEN, wormSegmentRect) \nwormSegmentRect = pygame.Rect(x + 4, y + 4, CELLSIZE - 8, CELLSIZE \npygame.draw.rect(DISPLAYSURF, GREEN, wormInnerSegmentRect) \nBecause the Rect object returned by pygame.Rect() on line 199 won’t be needed after 200, \npygame.Rect() on line 201.\n152    http://inventwithpython.com/pygame \nthey would see that wormSegmentRect is passed to the pygame.draw.rect() calls on \nIf they tried to find the first time the wormSegmentRect variable was \nassigned a value, they would see the pygame.Rect() call on line 199.\nthat the Rect object returned by line 199’s pygame.Rect() call isn’t the same as the one that is \npassed to the pygame.draw.rect() call on line 202.\nDifferently shaped blocks (each made up of four boxes) fall from the \nBoard – The board is made up of 10 x 20 spaces that the blocks fall and stack up in.\nPiece – The things that fall from the top of the board that the player can rotate and \nEach piece has a shape and is made up of 4 boxes.\nShape – The shapes are the different types of pieces in the game.\n154    http://inventwithpython.com/pygame \nThese are store in variables with names like S_SHAPE_TEMPLATE or \nThis source code can be downloaded from http://invpy.com/tetromino.py.\nhttp://invpy.com/diff/tetromino to see if the differences between your code and the code in the \n3. # http://inventwithpython.com/pygame \n6. import random, time, pygame, sys \nCOLORS      = (     BLUE,      GREEN,      RED,      YELLOW) \nLIGHTCOLORS = (LIGHTBLUE, LIGHTGREEN, LIGHTRED, LIGHTYELLOW) \nS_SHAPE_TEMPLATE = [['.....', \nI_SHAPE_TEMPLATE = [['..O..', \n156    http://inventwithpython.com/pygame \nO_SHAPE_TEMPLATE = [['.....', \nT_SHAPE_TEMPLATE = [['.....', \n'I': I_SHAPE_TEMPLATE, \n'T': T_SHAPE_TEMPLATE} \nFPSCLOCK = pygame.time.Clock() \n158    http://inventwithpython.com/pygame \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \npygame.display.set_caption('Tetromino') \nif fallingPiece == None: \nif not isValidPosition(board, fallingPiece): \nreturn # can't fit a new piece on the board, so game over \nfor event in pygame.event.get(): # event handling loop \nisValidPosition(board, fallingPiece, adjX=-1): \nisValidPosition(board, fallingPiece, adjX=1): \n1) % len(SHAPES[fallingPiece['shape']]) \nif not isValidPosition(board, fallingPiece): \n(fallingPiece['rotation'] - 1) % len(SHAPES[fallingPiece['shape']]) \n1) % len(SHAPES[fallingPiece['shape']]) \nif not isValidPosition(board, fallingPiece): \n(fallingPiece['rotation'] + 1) % len(SHAPES[fallingPiece['shape']]) \n160    http://inventwithpython.com/pygame \nif isValidPosition(board, fallingPiece, adjY=1): \nif not isValidPosition(board, fallingPiece, \nif movingLeft and isValidPosition(board, fallingPiece, adjX=-\nelif movingRight and isValidPosition(board, fallingPiece, \nand isValidPosition(board, fallingPiece, adjY=1): \nif not isValidPosition(board, fallingPiece, adjY=1): \n# falling piece has landed, set it on the board \nfallingPiece = None ",
      "keywords": [
        "shape",
        "fallingPiece",
        "Noticing regular patterns",
        "Template",
        "Board",
        "event.key",
        "Rect object",
        "Tetromino",
        "CELLSIZE",
        "Noticing regular",
        "time.time",
        "Rect",
        "code",
        "line",
        "Piece"
      ],
      "concepts": [
        "time",
        "key",
        "variables",
        "variable",
        "fall",
        "board",
        "shape",
        "lines",
        "game",
        "music"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 19,
          "title": "",
          "score": 0.804,
          "base_score": 0.654,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 18,
          "title": "",
          "score": 0.771,
          "base_score": 0.621,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 8,
          "title": "",
          "score": 0.761,
          "base_score": 0.611,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 11,
          "title": "",
          "score": 0.732,
          "base_score": 0.582,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 4,
          "title": "",
          "score": 0.724,
          "base_score": 0.574,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "fallingpiece",
          "board fallingpiece",
          "isvalidposition board",
          "isvalidposition",
          "pygame"
        ],
        "semantic": [],
        "merged": [
          "fallingpiece",
          "board fallingpiece",
          "isvalidposition board",
          "isvalidposition",
          "pygame"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.49612059451377644,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261411+00:00"
      }
    },
    {
      "chapter_number": 21,
      "title": "Segment 21 (pages 179-188)",
      "start_page": 179,
      "end_page": 188,
      "summary": "drawBoard(board) \nFPSCLOCK.tick(FPS) \ndef makeTextObjs(text, font, color): \nreturn event.key \nreturn None \n# return a random new piece in a random rotation and color \n'y': -2, # start it above the board (i.e. less than 0) \ndef addToBoard(board, piece): \n# fill in the board based on piece's location, shape, and rotation \nif SHAPES[piece['shape']][piece['rotation']][y][x] != BLANK: \nboard[x + piece['x']][y + piece['y']] = piece['color'] \n# create and return a new blank board data structure \nboard = [] \nboard.append([BLANK] * BOARDHEIGHT) \nreturn board \ndef isOnBoard(x, y): \nreturn x >= 0 and x < BOARDWIDTH and y < BOARDHEIGHT \ndef isValidPosition(board, piece, adjX=0, adjY=0): \n# Return True if the piece is within the board and not colliding \nisAboveBoard = y + piece['y'] + adjY < 0 \nSHAPES[piece['shape']][piece['rotation']][y][x] == BLANK: \nif not isOnBoard(x + piece['x'] + adjX, y + piece['y'] + \nif board[x + piece['x'] + adjX][y + piece['y'] + adjY] != \ndef isCompleteLine(board, y): \nif board[x][y] == BLANK: \ndef removeCompleteLines(board): \n# Remove any completed lines on the board, move everything above them \ny = BOARDHEIGHT - 1 # start y at the bottom of the board \nif isCompleteLine(board, y): \nboard[x][0] = BLANK \ndef drawBox(boxx, boxy, color, pixelx=None, pixely=None): \n# draw a single box (each tetromino piece has four boxes) \n# pixelx & pixely (this is used for the \"Next\" piece).\nreturn \npygame.draw.rect(DISPLAYSURF, COLORS[color], (pixelx + 1, pixely + 1, \npygame.draw.rect(DISPLAYSURF, LIGHTCOLORS[color], (pixelx + 1, pixely \ndef drawBoard(board): \n# draw the border around the board \npygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (XMARGIN - 3, TOPMARGIN - \n# fill the background of the board \npygame.draw.rect(DISPLAYSURF, BGCOLOR, (XMARGIN, TOPMARGIN, BOXSIZE * \n# draw the individual boxes on the board \ndrawBox(x, y, board[x][y]) \n# draw the score text \n# draw the level text \ndef drawPiece(piece, pixelx=None, pixely=None): \nshapeToDraw = SHAPES[piece['shape']][piece['rotation']] \npixelx, pixely = convertToPixelCoords(piece['x'], piece['y']) \n# draw each of the blocks that make up the piece \nif shapeToDraw[y][x] != BLANK: \ndrawBox(None, None, piece['color'], pixelx + (x * \nBOXSIZE), pixely + (y * BOXSIZE)) \ndef drawNextPiece(piece): \n# draw the \"next\" piece \ndrawPiece(piece, pixelx=WINDOWWIDTH-120, pixely=100) \nThe board itself is 10 boxes wide and 20 boxes tall.\nas a value to represent blank spaces in the board’s data structure.\nEvery time the player pushes the left or right arrow key down, the falling piece should move one \nthat every 0.15 seconds that passes with the left or right arrow key held down, the piece will \nXMARGIN = int((WINDOWWIDTH - BOARDWIDTH * BOXSIZE) / 2) \nThe program needs to calculate how many pixels are to the left and right side of the board to use \nboard is BOARDWIDTH boxes wide and each box is BOXSIZE pixels wide.\nBOXSIZE pixels from this for each of the boxes wide in the board (which is BOARDWIDTH * \nBOXSIZE), we’ll have the size of the margin to the left and right of the board.\nLIGHTCOLORS = (LIGHTBLUE, LIGHTGREEN, LIGHTRED, LIGHTYELLOW) \nThe pieces will come in four colors: blue, green, red, and yellow.\nSetting Up the Piece Templates ",
      "keywords": [
        "board",
        "piece",
        "BOXSIZE",
        "shape",
        "BOARDWIDTH",
        "BLANK",
        "Return True",
        "color",
        "Draw",
        "range",
        "pixelx",
        "shape piece",
        "WINDOWWIDTH",
        "BOARDHEIGHT",
        "pixely"
      ],
      "concepts": [
        "board",
        "color",
        "piece",
        "text",
        "event",
        "blank",
        "shape",
        "shaped",
        "key",
        "keys"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 39,
          "title": "",
          "score": 0.809,
          "base_score": 0.659,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 36,
          "title": "",
          "score": 0.804,
          "base_score": 0.654,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 9,
          "title": "",
          "score": 0.768,
          "base_score": 0.618,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 22,
          "title": "",
          "score": 0.747,
          "base_score": 0.597,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 12,
          "title": "",
          "score": 0.723,
          "base_score": 0.573,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "piece",
          "board",
          "pixelx",
          "pixely",
          "blank"
        ],
        "semantic": [],
        "merged": [
          "piece",
          "board",
          "pixelx",
          "pixely",
          "blank"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.45736429907655496,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261454+00:00"
      }
    },
    {
      "chapter_number": 22,
      "title": "Segment 22 (pages 189-197)",
      "start_page": 189,
      "end_page": 197,
      "summary": "and store them in variables such as S_SHAPE_TEMPLATE.\ntemplate has all the possible rotations of a single shape, this means that the SHAPES variable \nWhen the player presses a key, the showTextScreen() function that displays the game over \nlevel, fallFreq = calculateLevelAndFallFreq(score) \nBefore the game begins and pieces start falling, we need to initialize some variables to their start-\nOn line 191 the fallingPiece variable will be set to the currently falling \npiece that can be rotated by the player.\nOn line 192 the nextPiece variable will be set to the \nafter setting the falling piece.\nif not isValidPosition(board, fallingPiece): \nreturn # can't fit a new piece on the board, so game over \nThe main game loop that starts on line 194 handles all of the code for the main part of the game \nwhen pieces are falling to the bottom.\nThe fallingPiece variable is set to None after the \nfallingPiece variable, and a random new piece should be put into the nextPiece variable.\nvariable is also reset to the current time so that the piece will fall in however many seconds is in \nthe piece already on the board.\nup there (in which case the isValidPosition() call on line 201 will return False), then \nThe event handling loop takes care of when the player rotates the falling piece, moves the falling \npiece, or pauses the game.\nIf the player has pressed the P key, then the game should pause.\nto move the piece).\nOnce the player has pressed a key, showTextScreen() will return.\nvariables should all be reset to the current time (which is done on lines 213 to 215).\nrotating the piece, not moving the piece up.\nisValidPosition(board, fallingPiece, adjX=-1): \nWhen the left arrow key is pressed down (and moving to the left is a valid move for the falling \nisValidPosition() function checks the position of the data provided by the piece object \nPassing -1 for adjY checks one space above where the piece is \nwhere the piece is.\nThe movingLeft variable is set to True, and just to make sure the falling piece won’t move \nboth left and right, the movingRight variable is set to False on line 228.\nlastMoveSidewaysTime variable will be updated to the current time on line 229.\nThese variables are set so that the player can just hold down the arrow key to keep moving the \npiece over.\nIf the movingLeft variable is set to True, the program can know that the left \nthen it is time for the program to move the falling piece to the left again.\nisValidPosition(board, fallingPiece, adjX=1): \nthe falling piece to the right when the right arrow key (or D key) has been pressed.\nThe up arrow key (or W key) will rotate the falling piece to its next rotation.\ndo is increment the 'rotation' key’s value in the fallingPiece dictionary by 1.\nif not isValidPosition(board, fallingPiece): \n(fallingPiece['rotation'] - 1) % len(SHAPES[fallingPiece['shape']]) \nelif (event.key == K_q): # rotate the other direction \nif not isValidPosition(board, fallingPiece): \n(fallingPiece['rotation'] + 1) % len(SHAPES[fallingPiece['shape']]) \npressed the Q key which rotates the piece in the opposite direction.\nfrom fallingPiece['rotation'] (which is done on line 243) instead of adding 1.\nif isValidPosition(board, fallingPiece, adjY=1): \nIf the down arrow or S key is pressed down, then the player wants the piece to fall faster than \nLine 251 moves the piece down one space on the board (but only if it is a valid space).\nThe movingDown variable is set to True and lastMoveDownTime is reset to the current \nThese variables will be checked later so that the piece keeps falling at the faster rate as long \nif not isValidPosition(board, fallingPiece, \nWhen the player presses the space key the falling piece will immediately drop down as far as it \nLines 256 to 258 will set all the moving variables to False (which makes the code in later parts \nTo find the farthest that the piece can fall, we should first call isValidPosition() and pass \nthe piece cannot fall any further and is already at the bottom.\nloop on line 259 handles: calling isValidPosition() with increasing integer values to pass \nif movingLeft and isValidPosition(board, fallingPiece, adjX=-\nelif movingRight and isValidPosition(board, fallingPiece, \nRemember that on line 227 the movingLeft variable was set to True if the player pressed \n(The same for line 233 where movingRight was set to True if \nthe player pressed down on the right arrow key.) The moving variables were set back to False if \nWhat also happened when the player pressed down on the left or right arrow key was that the \nlastMoveSidewaysTime variable was set to the current time (which was the return value of \nthen the movingLeft or movingRight variable would still be set to True.",
      "keywords": [
        "SHAPE",
        "piece",
        "fallingPiece",
        "template",
        "game",
        "key",
        "Line",
        "variable",
        "player",
        "board",
        "arrow key",
        "rotation",
        "isValidPosition",
        "SHAPES variable",
        "event.key"
      ],
      "concepts": [
        "key",
        "keys",
        "variables",
        "variable",
        "game",
        "line",
        "lined",
        "time",
        "rotations",
        "rotation"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 23,
          "title": "",
          "score": 0.865,
          "base_score": 0.715,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 21,
          "title": "",
          "score": 0.747,
          "base_score": 0.597,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 39,
          "title": "",
          "score": 0.69,
          "base_score": 0.54,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 12,
          "title": "",
          "score": 0.674,
          "base_score": 0.524,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 13,
          "title": "",
          "score": 0.671,
          "base_score": 0.521,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "piece",
          "fallingpiece",
          "isvalidposition",
          "falling",
          "key"
        ],
        "semantic": [],
        "merged": [
          "piece",
          "fallingpiece",
          "isvalidposition",
          "falling",
          "key"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4055055880419416,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261498+00:00"
      }
    },
    {
      "chapter_number": 23,
      "title": "Segment 23 (pages 198-212)",
      "start_page": 198,
      "end_page": 212,
      "summary": "keys to get the falling piece to move over multiple spaces on the board.\nThat is what stops the falling piece from sliding over more.\nThe first number on each line of output is the return value of time.time() when the program \nMOVESIDEWAYSFREQ, we know it is time for the code to move the falling piece over one more \npiece down.\nLetting the Piece “Naturally” Fall \n# let the piece fall if it is time to fall \n# falling piece has landed, set it on the board \nIf enough time has elapsed since the falling piece last fell down one \nspace, lines 279 to 288 will handle dropping the piece by one space.\nIf the condition on line 279 is True, then the piece has landed.\nmake the piece part of the board data structure (so that future pieces can land on it), and the \nremoveCompleteLines() call will handle erasing any complete lines on the board and \nvalue of how many lines were removed, so we add this number to the score.\nfunction to update the current level and frequency that the pieces fall.\nfallingPiece variable to None to indicate that the next piece should become the new falling \nIf the piece has not landed, we simply set its Y position down one space (on line 287) and reset \nlastFallTime to the current time (on line 288).\nreturn event.key \nIf there were no KEYUP events in the event queue, then the function returns None.\nBecause the pygame.event.get() call on line 350 pulls out all of the KEYUP events \n# how many seconds pass until a falling piece falls one space.\nEvery time the player completes a line, their score will increase by one point.\nthe game goes up a level and the pieces start falling down faster.\nTo calculate the falling frequency, we start with a base time of 0.27 (meaning that the piece will \nlevel * 0.02 part of the equation as ―for every level, the piece will fall 0.02 seconds faster \nWe can also make a graph showing how fast the pieces will fall at each level of the game: \nwith our code, because line 277 just checks that the elapsed time since the falling piece last fell \nthen the condition on line 277 will always be True and the piece will fall on every iteration of \nFrom level 14 and beyond, the piece cannot fall any faster.\nIf the FPS is set at 25, this means that at reaching level 14, the falling piece will fall 25 spaces a \na second to set each piece!\nIf you want the pieces to start (if you can see what I mean) falling faster at a slower rate, you can \nIn the above case, the pieces would only fall 0.01 seconds faster on each level rather than 0.02 \nGenerating Pieces with the getNewPiece() Function \n# return a random new piece in a random rotation and color \n'y': -2, # start it above the board (i.e. less than 0) \nThe getNewPiece() function generates a random piece that is positioned at the top of the \nboard.\nby calling list(SHAPES.keys()) on line 365.\nThe piece data structures are simply a dictionary value with the keys 'shape', 'rotation', \nS_SHAPE_TEMPLATE) in each piece data structure to represent the boxes of each piece.\nThe 'x' key’s value is always set to the middle of the board (also accounting for the width of the \nThe 'y' key’s value is \nto the length of COLORS (subtracting one) will give us a random index value for the piece’s \nAdding Pieces to the Board Data Structure \ndef addToBoard(board, piece): \n# fill in the board based on piece's location, shape, and rotation \nif SHAPES[piece['shape']][piece['rotation']][y][x] != BLANK: \nboard[x + piece['x']][y + piece['y']] = piece['color'] \nThe board data structure is a data representation for the rectangular space where pieces that have \nThe currently falling piece is not marked on the board data \nWhat the addToBoard() function does is takes a piece data structure and adds its \nboxes to the board data structure.\nThe nested for loops on lines 376 and 377 go through every space in the piece data structure, \nand if it finds a box in the space (line 378), it adds it to the board (line 379).\n# create and return a new blank board data structure \nboard = [] \nreturn board \ncolumns in the board (this is what the for loop on line 385 does).\ndef isValidPosition(board, piece, adjX=0, adjY=0): \n# Return True if the piece is within the board and not colliding \nisAboveBoard = y + piece['y'] + adjY < 0 \nSHAPES[piece['shape']][piece['rotation']][y][x] == BLANK: \nThe isValidPosition() function is given a board data structure and a piece data structure, \nand returns True if all the boxes in the piece are both on the board and not overlapping any \nboxes on the board.\nthe piece data structure.\nThe board with a falling piece in a valid \nThe board with the falling piece in an invalid \nOn the left board, the falling piece’s (that is, the top left corner of the falling piece’s) XY \nBut the boxes inside the falling piece’s coordinate system \nthe ―board‖ coordinates of the falling piece’s top left box and the ―piece‖ coordinates of the \nOn the left board, the falling piece’s boxes are at the following ―piece‖ coordinates: \nWhen we add the (2, 3) coordinate (the piece’s coordinates on the board) to these coordinates, it \nAnd now that we can figure out where the falling piece’s boxes are as board coordinates, we can \nlines 396 and 397 go through each of the possible coordinates on the falling piece.\nWe want to check if a box of the falling piece is either off of the board or overlapping a box on \nthe board.\nwhen the falling piece just begins falling.) Line 398 creates a variable named isAboveBoard \nthat is set to True if the box on the falling piece at the coordinates pointed to be x and y is above \nthe board.\nThe if statement on line 399 checks if the space on the piece is above the board or is blank.\nif board[x + piece['x'] + adjX][y + piece['y'] + adjY] != \nThe if statement on line 401 checks that the piece’s box is not located on the board.\nstatement on line 403 checks that the board space the piece’s box is located is not blank.\nposition of the piece must be valid and so the function returns True on line 405.\ndef isCompleteLine(board, y): \n# Return True if the line filled with boxes with no gaps.\nif board[x][y] == BLANK: \nsame value as the BLANK constant), then the function return False.\n# Remove any completed lines on the board, move everything above them \ndown, and return the number of complete lines.\nThe removeCompleteLines() function will find any complete lines in the passed board data \nstructure, remove the lines, and then shift all the boxes on the board above that line down one \nThe function will return the number of lines that were removed (which is tracked by the \nThe way this function works is by running in a loop starting on line 419 with the y variable \nif isCompleteLine(board, y): \nThe isCompleteLine() function will return True if the line that y is referring to is \nIn that case, the program needs to copy the values of each row above the removed line \nrange() function begins at y, rather than 0.",
      "keywords": [
        "piece",
        "falling piece",
        "board",
        "PASSED WAIT TIME",
        "Line",
        "board data structure",
        "function",
        "piece data structure",
        "level",
        "function returns True",
        "falling",
        "time",
        "board data",
        "WAIT TIME",
        "PASSED WAIT"
      ],
      "concepts": [
        "function",
        "functions",
        "board",
        "returns",
        "time",
        "line",
        "pieces",
        "text",
        "fall",
        "level"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 22,
          "title": "",
          "score": 0.865,
          "base_score": 0.715,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 14,
          "title": "",
          "score": 0.681,
          "base_score": 0.531,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 12,
          "title": "",
          "score": 0.665,
          "base_score": 0.515,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 13,
          "title": "",
          "score": 0.646,
          "base_score": 0.496,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 41,
          "title": "",
          "score": 0.639,
          "base_score": 0.489,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "piece",
          "falling",
          "board",
          "falling piece",
          "data"
        ],
        "semantic": [],
        "merged": [
          "piece",
          "falling",
          "board",
          "falling piece",
          "data"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3444195338864213,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261537+00:00"
      }
    },
    {
      "chapter_number": 24,
      "title": "Segment 24 (pages 213-221)",
      "start_page": 213,
      "end_page": 221,
      "summary": "This helper function converts the board’s box coordinates to pixel coordinates.\nDrawing a Box on the Board or Elsewhere on the Screen \ndef drawBox(boxx, boxy, color, pixelx=None, pixely=None): \n# draw a single box (each tetromino piece has four boxes) \n# are specified, draw to the pixel coordinates stored in \n# pixelx & pixely (this is used for the \"Next\" piece).\npygame.draw.rect(DISPLAYSURF, COLORS[color], (pixelx + 1, pixely + 1, \npygame.draw.rect(DISPLAYSURF, LIGHTCOLORS[color], (pixelx + 1, pixely \nThe drawBox() function draws a single box on the screen.\nboxy parameters for board coordinates where the box should be drawn.\nand pixely parameters are specified, then these pixel coordinates will override the boxx and \nThe pixelx and pixely parameters are used to draw the boxes of the \nboxes of a piece, the left and top parameters in the pygame.draw.rect() call have + 1 \n# draw the border around the board \npygame.draw.rect(DISPLAYSURF, BORDERCOLOR, (XMARGIN - 3, TOPMARGIN - \npygame.draw.rect(DISPLAYSURF, BGCOLOR, (XMARGIN, TOPMARGIN, BOXSIZE * \n# draw the individual boxes on the board \nThe drawBoard() function is responsible for calling the drawing functions for the board’s \nDrawing a Piece on the Board or Elsewhere on the Screen \ndef drawPiece(piece, pixelx=None, pixely=None): \npixelx, pixely = convertToPixelCoords(piece['x'], piece['y']) \ndrawBox(None, None, piece['color'], pixelx + (x * \nThe drawPiece() function will draw the boxes of a piece according to the piece data structure \nThis function will be used to draw the falling piece and the ―Next‖ piece.\ninformation, nothing else besides the piece data structure needs to be passed to the function.\nHowever, the ―Next‖ piece is not drawn on the board.\nfunction pass in arguments for the optional pixelx and pixely parameters to specify where \nThe nested for loops on line 489 and 490 will then call drawBox() for each box of the piece \n# draw the \"next\" piece \ndrawPiece(piece, pixelx=WINDOWWIDTH-120, pixely=100) \nThe drawNextPiece() draws the ―Next‖ piece in the upper right corner of the screen.\nexplain to someone in English: ―Blocks fall from the top of a board, and the player moves and \nof this game with pieces made up of five boxes.\nSQUIRREL \nSquirrel Eat Squirrel is loosely based on the game ―Katamari Damacy‖.\nsquirrels.\nEach time the player’s squirrel eats a squirrel that is smaller than it, it grows larger.\nthe player’s squirrel gets hit by a larger squirrel larger than it, it loses a life point.\nThe player \nI’m not really sure where I got the idea for a video game where squirrels eat each other.\nThe types are player squirrels, enemy squirrels, and grass objects.\nThere is only one player \nsquirrel object at a time in the game.\nBut really, the player squirrel, enemy \nAll the objects have the following keys in their dictionary value: 'x', 'y', and 'rect'.\n'x' and 'y' key’s value give the coordinates of the top left of the object in game world \nThe difference between game world and pixel coordinates will be explained when you \nIn addition, the player squirrel, enemy squirrel, and grass objects have other keys which are \nThis source code can be downloaded from http://invpy.com/squirrel.py.\nhttp://invpy.com/diff/squirrel to see if the differences between your code and the code in the \nhttp://invpy.com/squirrel.png \nThis program has three data structures to represent the player, enemy \nsquirrels, and grass background objects.\n'x' - the left edge coordinate of the object in the game world (not a \n'y' - the top edge coordinate of the object in the game world (not a \n'rect' - the pygame.Rect object representing where on the screen the \nPlayer data structure keys: \nsquirrel which will be drawn to the screen.\nEnemy Squirrel data structure keys: \nsquirrel which will be drawn to the screen.\n'movex' - how many pixels per frame the squirrel moves horizontally.\n'movey' - how many pixels per frame the squirrel moves vertically.\n'width' - the width of the squirrel's image, in pixels \n'height' - the height of the squirrel's image, in pixels \n'bounceheight' - how high (in pixels) the squirrel bounces \npygame.display.set_caption('Squirrel Eat Squirrel') \nL_SQUIR_IMG = pygame.image.load('squirrel.png') ",
      "keywords": [
        "SQUIRREL",
        "SQUIRREL EAT",
        "player",
        "piece",
        "Board",
        "BOXSIZE",
        "Coordinates",
        "player squirrel",
        "pixely",
        "Pixel Coordinates",
        "pixelx",
        "game",
        "player squirrel object",
        "piece data structure",
        "screen"
      ],
      "concepts": [
        "squirrel",
        "game",
        "drawing",
        "piece",
        "bounces",
        "function",
        "functions",
        "programs",
        "programmed",
        "objects"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 10,
          "title": "",
          "score": 0.9,
          "base_score": 0.75,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 38,
          "title": "",
          "score": 0.849,
          "base_score": 0.699,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 5,
          "title": "",
          "score": 0.772,
          "base_score": 0.622,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 16,
          "title": "",
          "score": 0.724,
          "base_score": 0.574,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 37,
          "title": "",
          "score": 0.722,
          "base_score": 0.572,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "squirrel",
          "piece",
          "pixelx",
          "pixely",
          "pixelx pixely"
        ],
        "semantic": [],
        "merged": [
          "squirrel",
          "piece",
          "pixelx",
          "pixely",
          "pixelx pixely"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5045709207089644,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261582+00:00"
      }
    },
    {
      "chapter_number": 25,
      "title": "Segment 25 (pages 222-229)",
      "start_page": 222,
      "end_page": 229,
      "summary": "squirrelObjs = [] # stores all the non-player squirrel objects \nplayerObj = {'surface': pygame.transform.scale(L_SQUIR_IMG, \ngrassObjs.append(makeNewGrass(camerax, cameray)) \ngrassObjs[i]['x'] = random.randint(0, WINWIDTH) \ngrassObjs[i]['y'] = random.randint(0, WINHEIGHT) \nsObj['surface'] = pygame.transform.scale(R_SQUIR_IMG, \nsObj['surface'] = pygame.transform.scale(L_SQUIR_IMG, \nif isOutsideActiveArea(camerax, cameray, grassObjs[i]): \nif isOutsideActiveArea(camerax, cameray, squirrelObjs[i]): \ngrassObjs.append(makeNewGrass(camerax, cameray)) \nsquirrelObjs.append(makeNewSquirrel(camerax, cameray)) \nif (camerax + HALF_WINWIDTH) - playerCenterx > CAMERASLACK: \ncamerax = playerCenterx + CAMERASLACK - HALF_WINWIDTH \nelif playerCenterx – (camerax + HALF_WINWIDTH) > CAMERASLACK: \ncamerax = playerCenterx – CAMERASLACK - HALF_WINWIDTH \nif (cameray + HALF_WINHEIGHT) - playerCentery > CAMERASLACK: \ncameray = playerCentery + CAMERASLACK - HALF_WINHEIGHT \nelif playerCentery – (cameray + HALF_WINHEIGHT) > CAMERASLACK: \ncameray = playerCentery – CAMERASLACK - HALF_WINHEIGHT \ngRect = pygame.Rect( (gObj['x'] - camerax, \nsObj['rect'] = pygame.Rect( (sObj['x'] - camerax, \nsObj['y'] - cameray - \nDISPLAYSURF.blit(sObj['surface'], sObj['rect']) \n# draw the player squirrel \nplayerObj['rect'] = pygame.Rect( (playerObj['x'] - camerax, \nplayerObj['y'] – cameray - \ngetBounceAmount(playerObj['bounce'], BOUNCERATE, BOUNCEHEIGHT), \nDISPLAYSURF.blit(playerObj['surface'], playerObj['rect']) \nif playerObj['facing'] == RIGHT: # change player image \npygame.transform.scale(L_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \nif playerObj['facing'] == LEFT: # change player image \npygame.transform.scale(R_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \nplayerObj['bounce'] != 0: \nplayerObj['bounce'] += 1 \nif playerObj['bounce'] > BOUNCERATE: \nplayerObj['rect'].colliderect(sqObj['rect']): \nplayerObj['size'] += int( (sqObj['width'] * \npygame.transform.scale(L_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \npygame.transform.scale(R_SQUIR_IMG, (playerObj['size'], playerObj['size'])) \npygame.draw.rect(DISPLAYSURF, RED,   (15, 5 + (10 * MAXHEALTH) - i \npygame.draw.rect(DISPLAYSURF, WHITE, (15, 5 + (10 * MAXHEALTH) - i \ncameraRect = pygame.Rect(camerax, cameray, WINWIDTH, WINHEIGHT) \nwhile True: \nx = random.randint(camerax - WINWIDTH, camerax + (2 * WINWIDTH)) \ny = random.randint(cameray - WINHEIGHT, cameray + (2 * WINHEIGHT)) \nobjRect = pygame.Rect(x, y, objWidth, objHeight) \ndef makeNewSquirrel(camerax, cameray): \nsq['width']  = (generalSize + random.randint(0, 10)) * multiplier \nsq['height'] = (generalSize + random.randint(0, 10)) * multiplier \nsq['x'], sq['y'] = getRandomOffCameraPos(camerax, cameray, \nif sq['movex'] < 0: # squirrel is facing left \nsq['surface'] = pygame.transform.scale(L_SQUIR_IMG, (sq['width'], \nsq['surface'] = pygame.transform.scale(R_SQUIR_IMG, (sq['width'], \nsq['bouncerate'] = random.randint(10, 18) \nsq['bounceheight'] = random.randint(10, 50) \ndef makeNewGrass(camerax, cameray): \ngr['x'], gr['y'] = getRandomOffCameraPos(camerax, cameray, \ngr['rect'] = pygame.Rect( (gr['x'], gr['y'], gr['width'], \ndef isOutsideActiveArea(camerax, cameray, obj): \n# Return False if camerax and cameray are more than \nobjRect = pygame.Rect(obj['x'], obj['y'], obj['width'], obj['height']) \n6. import random, sys, time, math, pygame ",
      "keywords": [
        "playerObj",
        "HALF",
        "WINWIDTH",
        "WINHEIGHT",
        "sObj",
        "SQUIRREL",
        "cameray",
        "camerax",
        "size",
        "CAMERASLACK",
        "Squirrel Eat",
        "SQUIR",
        "IMG",
        "bounce",
        "player"
      ],
      "concepts": [
        "squirrel",
        "returns",
        "bounce",
        "random",
        "game",
        "height",
        "player",
        "white",
        "later",
        "draw"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 26,
          "title": "",
          "score": 0.882,
          "base_score": 0.732,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 29,
          "title": "",
          "score": 0.879,
          "base_score": 0.729,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 31,
          "title": "",
          "score": 0.799,
          "base_score": 0.649,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 27,
          "title": "",
          "score": 0.707,
          "base_score": 0.557,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 28,
          "title": "",
          "score": 0.623,
          "base_score": 0.473,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "playerobj",
          "cameray",
          "camerax",
          "sq",
          "camerax cameray"
        ],
        "semantic": [],
        "merged": [
          "playerobj",
          "cameray",
          "camerax",
          "sq",
          "camerax cameray"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4657605778383462,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261626+00:00"
      }
    },
    {
      "chapter_number": 26,
      "title": "Segment 26 (pages 230-238)",
      "start_page": 230,
      "end_page": 238,
      "summary": "NUMSQUIRRELS = 30    # number of squirrels in the active area \nsquirrels, and grass background objects.\n'x' - the left edge coordinate of the object in the game world (not a \n'y' - the top edge coordinate of the object in the game world (not a \n'rect' - the pygame.Rect object representing where on the screen the \n'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen.\nEnemy Squirrel data structure keys: \n'surface' - the pygame.Surface object that stores the image of the \nsquirrel which will be drawn to the screen.\n'movex' - how many pixels per frame the squirrel moves horizontally.\n'width' - the width of the squirrel's image, in pixels \n'height' - the height of the squirrel's image, in pixels \n'bouncerate' - how quickly the squirrel bounces.\n'bounceheight' - how high (in pixels) the squirrel bounces \npygame.Surface object in GRASSIMAGES used for this grass object \nthe player squirrel, enemy squirrel, and grass objects.\npygame.display.set_caption('Squirrel Eat Squirrel') \nL_SQUIR_IMG = pygame.image.load('squirrel.png') \nThe image for the player and enemy squirrels is loaded from squirrel.png on line 74.\npygame.error: Couldn't open squirrel.png.\nThe image in squirrel.png (which you can download from http://invpy.com/squirrel.png) is of a \nsquirrel facing to the left.\nWe also need a Surface object that contains a picture of the squirrel \nSurface object that returns has the image of the squirrel facing to the right.\nThe Squirrel Eat Squirrel game has quite a few variables that track the game state.\nSQUIRREL!‖, and ―(Press \"r\" to restart.)‖ text that appears on the screen after the game ends \nThe camerax and cameray variables track the game coordinates of the ―camera‖.\nbecause it is as though our screen is just the area of the game world in front what a camera would \nHere’s a picture of the game world (an infinite green field) and the area that the camera can \nsquirrels are located (in game world coordinates) at (-384, -84), (384, 306), and (585, -234).\nwhere the camera’s origin is located in game world coordinates.\nis placed at (-486, -330) in game world coordinates.\ngame world coordinates (-486, -330).\ncoordinates of the squirrels (that is, where on the screen they appear), take the game coordinates \nof the squirrel and subtract the game coordinates of the camera’s origin.\nSo the squirrel on the left has game world coordinates of (-384, -84) but appears at (102, 246) on \nWhen we do the same calculation to find the pixel coordinates of the other two squirrels, we find \nenemy squirrel or grass objects, we don’t want them to be created inside the view of the camera, \nsquirrel and grass objects can safely be created.\nAlso, when squirrel and grass objects are beyond the border of the active area then they are far \ngrassObjs = []    # stores all the grass objects in the game \nsquirrelObjs = [] # stores all the non-player squirrel objects \n# stores the player object: \nThe grassObjs variable holds a list of all the grass objects in the game.\nThe same goes for the squirrelObjs variable and the enemy squirrel objects.\nThe active area should start off with a few grass objects visible on the screen.\nmakeNewGrass() function will create and return a grass object that is randomly located \nWhen the player gets hit by an enemy squirrel and does not die, we make the player invulnerable \n# move all the squirrels \n# move the squirrel, and adjust for their bounce \nThe enemy squirrels all move according to the values in their 'movex' and 'movey' keys.\nthese values are positive, the squirrels move right or down.\nThe for loop on line 137 will apply this moving code to each of the enemy squirrel objects in the \nThe value in sObj['bounce'] is incremented on each iteration of the game loop for each \nsquirrel.\nWhen this value is 0, the squirrel is at the very beginning of its bounce.\nthen it only takes three iterations through the game loop for the squirrel to do a full bounce.\nsObj['surface'] = pygame.transform.scale(R_SQUIR_IMG, \nsObj['surface'] = pygame.transform.scale(L_SQUIR_IMG, \nThere is a 2% chance on each iteration through the game loop that the squirrel will randomly \nBecause this means the squirrel might have changed direction, the Surface object in \nSurface object scaled from R_SQUIR_IMG and line 152 gets one scaled from L_SQUIR_IMG.",
      "keywords": [
        "squirrel",
        "game",
        "game world",
        "game world coordinates",
        "Squirrel Eat",
        "player",
        "grass objects",
        "Surface object",
        "sObj",
        "Enemy Squirrel",
        "Eat Squirrel game",
        "camera",
        "enemy squirrel objects",
        "objects",
        "squirrel objects"
      ],
      "concepts": [
        "squirrels",
        "game",
        "bounce",
        "object",
        "keys",
        "value",
        "cameras",
        "variable",
        "variables",
        "number"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 29,
          "title": "",
          "score": 0.91,
          "base_score": 0.76,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 25,
          "title": "",
          "score": 0.882,
          "base_score": 0.732,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 31,
          "title": "",
          "score": 0.798,
          "base_score": 0.648,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 28,
          "title": "",
          "score": 0.705,
          "base_score": 0.555,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 27,
          "title": "",
          "score": 0.695,
          "base_score": 0.545,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "squirrel",
          "game world",
          "game",
          "grass",
          "squirrels"
        ],
        "semantic": [],
        "merged": [
          "squirrel",
          "game world",
          "game",
          "grass",
          "squirrels"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4779476178704076,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261672+00:00"
      }
    },
    {
      "chapter_number": 27,
      "title": "Segment 27 (pages 239-248)",
      "start_page": 239,
      "end_page": 248,
      "summary": "Removing the Far Away Grass and Squirrel Objects \nDuring each iteration of the game loop, the code will check all of the grass and enemy squirrel \nthe grass/enemy squirrel object, and returns True if the object is not located in the active area.\nIf this is the case, this object is deleted on line 158 (for grass objects) or line 161 (for squirrel \nThis is how squirrel and grass objects get deleted when the player moves far enough \naway from them (or when the enemy squirrels move away far enough from the player).\nensures that there is always a number of squirrels and grass objects near the player.\nDeleting squirrel and grass objects is done with the del operator.\nFirst, the animals list would be set \nmeans that the call to range(4) would cause the for loop to iterate with the values 0, 1, 2, \nWhen the for loop iterates with i set to 2, the if statement’s condition will be True and the \nAfter animals[2] is deleted, the animals list is set to ['cat', 'mouse', 'horse'].\nSimilarly, we can delete grass and squirrel objects from the grassObjs and squirrelObjs \nlists without error because the for loop on lines 156 and 159 iterate in reverse order.\nAdding New Grass and Squirrel Objects \n# add more grass & squirrels if we don't have enough.\nalways plenty of grass and squirrel objects in the active area at all times.\nthen new grass and squirrel objects are created.\nThe camera’s position (which is stored as integers in the camerax and cameray variables) \nconstant to 90, which our program will take to mean that the player squirrel can move 90 pixels \nThe playerCenterx and playerCentery is set to the middle of the player’s squirrel’s \nCAMERASLACK value, that means the player is more pixels to the right of the center of the \nplayer squirrel is just at the edge of the camera slack.\nvariable is changed, not the playerObj['x'] value.\nplayer.\nDrawing the Background, Grass, Squirrels, and Health Meter \nLine 182 begins the code that starts drawing the contents of the display Surface object.\nThe for loop on line 185 goes through all the grass objects in the grassObjs list and creates a \nthe grass objects with similar gObj['grassImage'] values look identical.\n# draw the other squirrels \nThe for loop that draws all the enemy squirrel game objects is similar to the previous for loop, \nexcept that the Rect object it creates is saved in the 'rect' key’s value of the squirrel \nthe enemy squirrels have collided with the player squirrel.\nAlso, there is no common list of Surface objects of the squirrel images, like there was with grass \nEach enemy squirrel game object has its own Surface object \n# draw the player squirrel \nAfter drawing the grass and enemy squirrels, the code will draw the player’s squirrel.\nthere is one case where we would skip drawing the player’s squirrel.\nwith a larger enemy squirrel, the player takes damage and flashes for a little bit to indicate that \nThis flashing effect is done by drawing the player squirrel \nThe player squirrel will be drawn on game loop iterations for a tenth of a second, and then not \nas the player is invulnerable (which, in the code, means that the invulnerableMode variable \nThere are three things that must be True before we draw the player’s squirrel.\nThe code for drawing the player’s squirrel is almost identical to the code for drawing the enemy \nsquirrels.\ntells the player how many times the player squirrel can be hit before dying.\nvariable (moveRight, moveDown, etc.) for that direction should be set to True and the move \nif playerObj['facing'] == RIGHT: # change player image \nif playerObj['facing'] == LEFT: # change player image \nThe moveLeft and moveRight variables should also be set when the left or right arrow keys \nAlso, the value in playerObj['facing'] should be updated to either LEFT or \nIf the player squirrel is now facing a new direction, the playerObj['surface'] \nvalue should be replaced with a correctly scaled image of the squirrel facing the new direction.\nLine 229 is run if the left arrow key was pressed and checks if the player squirrel was facing \nIf that was so, then a new scaled Surface object of the player squirrel image is stored in \n# stop moving the player's squirrel \nIf the player lets up on any of the arrow or WASD keys, then the code should set the move \nThe code inside the if statement on line 255 will move the player’s squirrel around only if the \n(This is why pressing on the arrow keys after the player’s squirrel dies will have \nno effect.) Depending on which of the move variables is set to True, the playerObj dictionary \n(This is why a larger value in MOVERATE makes the squirrel move faster.) \nThe value in playerObj['bounce'] keeps track of at what point in bouncing the player is \nthe enemy squirrels, a playerObj['bounce'] value of 0 means the player squirrel is at the \nstart of a bounce and a value of BOUNCERATE means the player squirrel is at the end of the \nThe player squirrel will bounce whenever the player is moving, or if the player has stopped \nmoving but the squirrel hasn’t finished its current bounce.\nplayerObj['bounce'] is not 0 (which means the player is currently in a bounce), then the \nBecause the playerObj['bounce'] variable should only be in the range of 0 to \n# check if the player has collided with any squirrels \nThe for loop on 273 will go run code on each of the enemy squirrel game objects in \ndeleting some of these enemy squirrel game objects (if the player’s squirrel ends up eating them), \n# a player/squirrel collision has occurred \n# player is larger and eats the squirrel \nIf the player’s squirrel is equal or larger than the size of the enemy squirrel it has collided with, \nthen the player’s squirrel will eat that squirrel and grow.\nkey in the player object (that is, the growth) is calculated based on the enemy squirrel’s size on \nLine 281 deletes the eaten squirrel object from the squirrelObjs list so that it will no longer \nThe player’s squirrel image needs to be updated now that the squirrel is larger.\nwhich original squirrel image we pass to the function.\nSize of Eaten Squirrel (width & height) ",
      "keywords": [
        "Squirrel",
        "player squirrel",
        "player",
        "playerObj",
        "Squirrel Objects",
        "enemy squirrel",
        "squirrel game objects",
        "Objects",
        "List",
        "Squirrel Eat",
        "grass objects",
        "Grass",
        "animals",
        "enemy squirrel game",
        "line"
      ],
      "concepts": [
        "squirrel",
        "line",
        "values",
        "key",
        "keys",
        "sizes",
        "sized",
        "list",
        "drawing",
        "objects"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 25,
          "title": "",
          "score": 0.707,
          "base_score": 0.557,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 26,
          "title": "",
          "score": 0.695,
          "base_score": 0.545,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 29,
          "title": "",
          "score": 0.677,
          "base_score": 0.527,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 28,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 31,
          "title": "",
          "score": 0.427,
          "base_score": 0.277,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "squirrel",
          "player squirrel",
          "player",
          "grass",
          "enemy"
        ],
        "semantic": [],
        "merged": [
          "squirrel",
          "player squirrel",
          "player",
          "grass",
          "enemy"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.319824870359027,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261709+00:00"
      }
    },
    {
      "chapter_number": 28,
      "title": "Segment 28 (pages 249-257)",
      "start_page": 249,
      "end_page": 257,
      "summary": "The way the player wins the game is by getting the squirrel to have a size larger than the integer \nIf the player’s area was not equal to or larger than the area of the enemy squirrel, and \ninvulnerableMode was not set to True, then the player will take damage from colliding \nTo prevent the player from being damaged several times by the same squirrel immediately, we \nwill briefly make the player invulnerable to further squirrel attacks by setting \nthe current time (which is returned by time.time()) so that lines 133 and 134 can know when \nLine 295 decrements the player’s health by 1.\nwill return.\nThe winMode variable is set to True on line 289 if the player has reached a certain size (which \nfor all of the possible health the player could have (which is the integer value stored in the \nreturn int(math.sin( (math.pi / float(bounceRate)) * currentBounce ) * \nPython has this mathematic function as a Python function in the math \nYou can pass an int or float value to math.sin(), and it will return a float value that is \nIn the interactive shell, let’s see what math.sin() returns for some values: \nIt seems really hard to predict what value math.sin() is going to return based on what value \nYou can kind of see a wavy pattern in the values returned by math.sin().\nsine values for more numbers besides integers (for example, 1.5 and 2.5 and so on) and then \nValues Returned by math.sin() \nValues Returned by math.sin() \nreturns 1, then it begins to decrease until math.sin(3.14) returns 0.\nalso stored in the constant variable pi in the math module (which is why line 333 uses the \nvariable, math.pi), which is technically the float value 3.1415926535897931.\nwant a wavy-looking bounce for our squirrel, we’ll only pay attention to the return values of \nLet’s take a look at the return value of getBounceAmount() and figure out what it does \nreturn int(math.sin( (math.pi / float(bounceRate)) * currentBounce ) * \nRemember that on line 21 we set the BOUNCERATE constant to 6.\nThen math.sin(1.5707) will return 1.0, which is the highest part of the sine \nValues Returned by math.sin() \nAs playerObj['bounce'] gets its value incremented, the getBounceAmount() function \nwill return values that have the same bounce shape that the sine wave has from 0 to 3.14.\nevaluate to a floating point value even if both of the operands are integers, like this: \nHowever, in Python version 2, the / division operator will only evaluate to a floating point value \nBut if we always convert one of the values to a floating point value with the float() function, \nthen the division operator will evaluate to a float value no matter which version of Python runs \nsquirrel will move.\ncameraRect = pygame.Rect(camerax, cameray, WINWIDTH, WINHEIGHT) \nx = random.randint(camerax - WINWIDTH, camerax + (2 * WINWIDTH)) \ny = random.randint(cameray - WINHEIGHT, cameray + (2 * WINHEIGHT)) \n# create a Rect object with the random coordinates and use \nWhen a new squirrel or grass object is created in the game world, we want it to be within the \nactive area (so that it is near the player’s squirrel) but not within the view of the camera (so that it \nLine 352 will check if the random XY coordinates would \nsq['width']  = (generalSize + random.randint(0, 10)) * multiplier \nsq['height'] = (generalSize + random.randint(0, 10)) * multiplier \nCreating enemy squirrel game objects is similar to making the grass game objects.\nThe width and height are set to random sizes on \nwidth and height of the squirrel are this general size with a random number from 0 to 10 added to \nThe original XY coordinate position of the squirrel will be a random location that the camera \nif sq['movex'] < 0: # squirrel is facing left \nsq['surface'] = pygame.transform.scale(R_SQUIR_IMG, (sq['width'], \nsq['bouncerate'] = random.randint(10, 18) \nsq['bounceheight'] = random.randint(10, 50) \nreturn sq \npygame.transform.scale() function to match the squirrel’s  width and height (stored in \nAfter that, the three bounce-related values are randomly generated (except for sq['bounce'] \nreturned on line 372.\nreturn gr ",
      "keywords": [
        "Squirrel",
        "Squirrel Eat",
        "math.sin",
        "Python",
        "player",
        "Python Version",
        "game",
        "function",
        "enemy squirrel",
        "line",
        "width",
        "height",
        "WINHEIGHT",
        "bounce",
        "WINWIDTH"
      ],
      "concepts": [
        "squirrel",
        "random",
        "returned",
        "function",
        "functions",
        "game",
        "value",
        "bounce",
        "constant",
        "code"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 26,
          "title": "",
          "score": 0.705,
          "base_score": 0.555,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 27,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 25,
          "title": "",
          "score": 0.623,
          "base_score": 0.473,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 29,
          "title": "",
          "score": 0.611,
          "base_score": 0.461,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 31,
          "title": "",
          "score": 0.427,
          "base_score": 0.277,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "math",
          "math sin",
          "sin",
          "squirrel",
          "sq"
        ],
        "semantic": [],
        "merged": [
          "math",
          "math sin",
          "sin",
          "squirrel",
          "sq"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.31501141805602384,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261747+00:00"
      }
    },
    {
      "chapter_number": 29,
      "title": "Segment 29 (pages 258-265)",
      "start_page": 258,
      "end_page": 265,
      "summary": "240    http://inventwithpython.com/pygame \nThe grass game objects are dictionaries with the usual 'x', 'y', 'width', 'height', and \nThis number will determine what image the grass game object \nFor example, if the value of the grass object’s 'grassImage' key is 3, then it will use the \nThe isOutsideActiveArea() will return True if the object you pass it is outside of the \nWe can create a Rect object that represents the active area by passing camerax - WINWIDTH \nSince the player squirrel, enemy squirrel and grass objects all have 'x', 'y', 'width' and \n'height' keys, the isOutsideActiveArea() code can work with any type of those game \nthat involve a player moving around a large game world, you will need code to handle converting \n242    http://inventwithpython.com/pygame \nthe player will have to restart the level.\nEach level is made up of a 2D grid of tile images.\nThe level file can be downloaded from http://invpy.com/starPusherLevels.txt.\n3. # http://inventwithpython.com/pygame \nTEXTCOLOR = WHITE \nDISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT)) \npygame.display.set_caption('Star Pusher') \n# Surface objects returned by pygame.image.load().\nIMAGESDICT = {'uncovered goal': pygame.image.load('RedSelector.png'), \n'covered goal': pygame.image.load('Selector.png'), \n'star': pygame.image.load('Star.png'), \n'corner': pygame.image.load('Wall Block Tall.png'), \n'wall': pygame.image.load('Wood Block Tall.png'), \n'inside floor': pygame.image.load('Plain Block.png'), \n'outside floor': pygame.image.load('Grass Block.png'), \n'title': pygame.image.load('star_title.png'), \n'solved': pygame.image.load('star_solved.png'), \n'princess': pygame.image.load('princess.png'), \n'boy': pygame.image.load('boy.png'), \n'catgirl': pygame.image.load('catgirl.png'), \n'horngirl': pygame.image.load('horngirl.png'), \n'pinkgirl': pygame.image.load('pinkgirl.png'), \n'rock': pygame.image.load('Rock.png'), \n'short tree': pygame.image.load('Tree_Short.png'), \n'tall tree': pygame.image.load('Tree_Tall.png'), \n'ugly tree': pygame.image.load('Tree_Ugly.png')} \n# in the level file to the Surface object it represents.\nwhile True: # main game loop \n# Run the level to actually start playing the game: \n# Go to the next level.\n# If there are no more levels, go back to the first one.\nwhile True: # main game loop \nif event.key == K_LEFT: \nelif event.key == K_RIGHT: \nelif event.key == K_UP: \nelif event.key == K_DOWN: \nelif event.key == K_a: \nelif event.key == K_d: \nelif event.key == K_w: \nelif event.key == K_s: \nelif event.key == K_n: \nelif event.key == K_b: \nelif event.key == K_ESCAPE: \nelif event.key == K_BACKSPACE: \nelif event.key == K_p: \nif event.key == K_a: \nelif event.key == K_d: \nelif event.key == K_w: \nelif event.key == K_s: ",
      "keywords": [
        "STAR PUSHER",
        "elif event.key",
        "IMAGESDICT",
        "level",
        "STAR",
        "Squirrel",
        "game",
        "Squirrel Eat",
        "event.key",
        "PUSHER",
        "WINHEIGHT",
        "objects"
      ],
      "concepts": [
        "key",
        "loaded",
        "level",
        "games",
        "object",
        "squirrel",
        "star",
        "player",
        "moving",
        "moves"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 26,
          "title": "",
          "score": 0.91,
          "base_score": 0.76,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 25,
          "title": "",
          "score": 0.879,
          "base_score": 0.729,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 31,
          "title": "",
          "score": 0.789,
          "base_score": 0.639,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 27,
          "title": "",
          "score": 0.677,
          "base_score": 0.527,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 28,
          "title": "",
          "score": 0.611,
          "base_score": 0.461,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "pygame image",
          "image load",
          "elif event",
          "load",
          "event key"
        ],
        "semantic": [],
        "merged": [
          "pygame image",
          "image load",
          "elif event",
          "load",
          "event key"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.441891134654091,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261792+00:00"
      }
    },
    {
      "chapter_number": 30,
      "title": "Segment 30 (pages 266-273)",
      "start_page": 266,
      "end_page": 273,
      "summary": "mapSurf = drawMap(mapObj, gameStateObj, levelObj['goals']) \n# Draw mapSurf to the DISPLAYSURF Surface object.\nfor x in range(len(mapObjCopy)): \nfor y in range(len(mapObjCopy[0])): \nif mapObjCopy[x][y] in ('$', '.', '@', '+', '*'): \nmapObjCopy[x][y] = ' ' \nfor x in range(len(mapObjCopy)): \nfor y in range(len(mapObjCopy[0])): \nif mapObjCopy[x][y] == '#': \nmapObjCopy[x][y] = 'x' \nelif mapObjCopy[x][y] == ' ' and random.randint(0, 99) < \nmapObjCopy[x][y] = \ndef isBlocked(mapObj, gameStateObj, x, y): \n\"\"\"Returns True if the (x, y) position on the map is \nif isWall(mapObj, x, y): \nelif x < 0 or x >= len(mapObj) or y < 0 or y >= len(mapObj[x]): \nreturn True # x and y aren't actually on the map.\nelif (x, y) in gameStateObj['stars']: \nmapTextLines = [] # contains the lines for a single level's map.\nmapObj = [] # the map object made from the data in mapTextLines \nelif line == '' and len(mapTextLines) > 0: \n# A blank line indicates the end of a level's map in the file.\nfor x in range(len(mapTextLines[0])): \nfor y in range(len(mapTextLines)): \nmapObj[x].append(mapTextLines[y][x]) \nstartx = None # The x and y for the player's starting position \ngoals = [] # list of (x, y) tuples for each goal.\nstars = [] # list of (x, y) for each star's starting position.\nfor y in range(len(mapObj[x])): \nif mapObj[x][y] in ('@', '+'): \nif mapObj[x][y] in ('.', '+', '*'): \ngoals.append((x, y)) \nif mapObj[x][y] in ('$', '*'): \nstars.append((x, y)) \nassert len(goals) > 0, 'Level %s (around line %s) in %s must \nassert len(stars) >= len(goals), 'Level %s (around line %s) in \nlineNum, filename, len(goals), len(stars)) \ndef floodFill(mapObj, x, y, oldCharacter, newCharacter): \nnewCharacter at the (x, y) position, and does the same for the \npositions to the left, right, down, and up of (x, y), recursively.\"\"\" \nif mapObj[x][y] == oldCharacter: \nmapObj[x][y] = newCharacter \nif x < len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter: \nfloodFill(mapObj, x+1, y, oldCharacter, newCharacter) # call right \nif x > 0 and mapObj[x-1][y] == oldCharacter: \nfloodFill(mapObj, x-1, y, oldCharacter, newCharacter) # call left \nif y < len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter: \nfloodFill(mapObj, x, y+1, oldCharacter, newCharacter) # call down \nif y > 0 and mapObj[x][y-1] == oldCharacter: \nfloodFill(mapObj, x, y-1, oldCharacter, newCharacter) # call up \n\"\"\"Draws the map to a Surface object, including the player and \nfor x in range(len(mapObj)): \nfor y in range(len(mapObj[x])): \nspaceRect = pygame.Rect((x * TILEWIDTH, y * (TILEHEIGHT - \nif mapObj[x][y] in TILEMAPPING: \nbaseTile = TILEMAPPING[mapObj[x][y]] \nelif mapObj[x][y] in OUTSIDEDECOMAPPING: \nif mapObj[x][y] in OUTSIDEDECOMAPPING: \nmapSurf.blit(OUTSIDEDECOMAPPING[mapObj[x][y]], spaceRect) \nelif (x, y) in gameStateObj['stars']: \nif (x, y) in goals: \nelif (x, y) in goals: \n# Draw a goal without a star on it.",
      "keywords": [
        "mapObj",
        "len",
        "mapObjCopy",
        "stars",
        "level",
        "map",
        "gameStateObj",
        "line",
        "CAM",
        "range",
        "player",
        "return True",
        "mapTextLines",
        "object",
        "Draw"
      ],
      "concepts": [
        "star",
        "level",
        "returns",
        "goals",
        "objects",
        "tile",
        "map",
        "draw",
        "filename",
        "line"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 32,
          "title": "",
          "score": 0.782,
          "base_score": 0.632,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 34,
          "title": "",
          "score": 0.691,
          "base_score": 0.541,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 25,
          "title": "",
          "score": 0.547,
          "base_score": 0.547,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 21,
          "title": "",
          "score": 0.547,
          "base_score": 0.547,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 36,
          "title": "",
          "score": 0.54,
          "base_score": 0.54,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "mapobj",
          "len",
          "mapobjcopy",
          "oldcharacter",
          "mapobj oldcharacter"
        ],
        "semantic": [],
        "merged": [
          "mapobj",
          "len",
          "mapobjcopy",
          "oldcharacter",
          "mapobj oldcharacter"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4490212709846162,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261838+00:00"
      }
    },
    {
      "chapter_number": 31,
      "title": "Segment 31 (pages 274-281)",
      "start_page": 274,
      "end_page": 281,
      "summary": "# specific player image we want to show.\nTEXTCOLOR = WHITE \nvariables show that each of the tile images are 50 pixels wide and 85 pixels tall.\n# Pygame initialization and basic set up of the global variables.\nDISPLAYSURF = pygame.display.set_mode((WINWIDTH, WINHEIGHT)) \n# Surface objects returned by pygame.image.load().\nIMAGESDICT = {'uncovered goal': pygame.image.load('RedSelector.png'), \n'covered goal': pygame.image.load('Selector.png'), \n'star': pygame.image.load('Star.png'), \n'corner': pygame.image.load('Wall Block Tall.png'), \n'wall': pygame.image.load('Wood Block Tall.png'), \n'inside floor': pygame.image.load('Plain Block.png'), \n'outside floor': pygame.image.load('Grass Block.png'), \n'title': pygame.image.load('star_title.png'), \n'solved': pygame.image.load('star_solved.png'), \n'princess': pygame.image.load('princess.png'), \n'boy': pygame.image.load('boy.png'), \n'catgirl': pygame.image.load('catgirl.png'), \n'horngirl': pygame.image.load('horngirl.png'), \n'pinkgirl': pygame.image.load('pinkgirl.png'), \n'rock': pygame.image.load('Rock.png'), \n'short tree': pygame.image.load('Tree_Short.png'), \n'tall tree': pygame.image.load('Tree_Tall.png'), \n'ugly tree': pygame.image.load('Tree_Ugly.png')} \nThe IMAGESDICT is a dictionary where all of the loaded images are stored.\n# currentImage is the index of the player's current player image.\nThe PLAYERIMAGES list stores the images used for the player.\ntracks the index of the currently selected player image.\nset to 0 then PLAYERIMAGES[0], which is the ―princess‖ player image, is drawn to the screen.\ninstructions for the game) until the player presses a key.\nWhen the player presses a key, the \nstartScreen() function returns and then reads in the levels from the level file.\nIt is passed a list of level objects, \nthe level, runLevel() will return one of the following strings: 'solved' (because the player \nnext level), 'back' (because the player wants to go back to the previous level), and 'reset' \n(because the player wants to start playing the current level over again, maybe because they \n# Go to the next level.\n# If there are no more levels, go back to the first one.\ndef runLevel(levels, levelNum): \nlevelObj = levels[levelnum] \nThe levels list contains all the level objects that were loaded from the level file.\nThe level object \nfor the current level (which is what levelNum is set to) is stored in the levelObj variable.\nthe state of the game while the player plays this level, a copy of the game state object that is \nlevelObj['startState'] represents the game state at the very beginning of the level, and \nOtherwise, if the player restarts the level, the original game state \nMore variables are set at the start of playing a level.\nThe playerMoveTo variable will be set to the direction constant that the player intends to \nelif event.key == K_RIGHT: \nelif event.key == K_UP: \nelif event.key == K_DOWN: \nelif event.key == K_a: \nelif event.key == K_d: \nelif event.key == K_w: \nelif event.key == K_s: \nelif event.key == K_n: \nelif event.key == K_ESCAPE: \nelif event.key == K_BACKSPACE: \nreturn 'reset' # Reset the level.\n# Change the player image to the next one.\n# After the last player image, use the first one.\nelif event.key == K_d: \nelif event.key == K_w: \nelif event.key == K_s: \n# If the player pushed a key to move, make the move ",
      "keywords": [
        "level",
        "player",
        "IMAGESDICT",
        "elif event.key",
        "Star Pusher",
        "player image",
        "event.key",
        "star",
        "game",
        "tree",
        "PLAYERIMAGES",
        "object",
        "Pusher",
        "images",
        "currentImage"
      ],
      "concepts": [
        "player",
        "loaded",
        "key",
        "keys",
        "level",
        "variables",
        "variable",
        "returns",
        "function",
        "functions"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 25,
          "title": "",
          "score": 0.799,
          "base_score": 0.649,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 26,
          "title": "",
          "score": 0.798,
          "base_score": 0.648,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 29,
          "title": "",
          "score": 0.789,
          "base_score": 0.639,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 37,
          "title": "",
          "score": 0.71,
          "base_score": 0.71,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 38,
          "title": "",
          "score": 0.675,
          "base_score": 0.675,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "image",
          "image load",
          "pygame image",
          "load",
          "png"
        ],
        "semantic": [],
        "merged": [
          "image",
          "image load",
          "pygame image",
          "load",
          "png"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5028691775968148,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261884+00:00"
      }
    },
    {
      "chapter_number": 32,
      "title": "Segment 32 (pages 282-290)",
      "start_page": 282,
      "end_page": 290,
      "summary": "The call to makeMove() handles changing the XY coordinates of the player’s position in \nthe gameStateObj, as well as pushing any stars.\nIf this value is True, then the player character was moved in that direction.\nvalue was False, then the player must have tried to move into a tile that was a wall, or push a \nIn this case, the player can’t move and nothing on the map \nplayer moving or a star being pushed).\nAfter the map has been drawn on line 225, the mapNeedsRedraw variable is set to False.\npassed) the boundaries set by the MAX_CAM_X_PAN and MAX_CAM_Y_PAN, then the camera \nLines 237 to 261 position the camera and draw the map and other graphics to the display Surface \nThe keyPressed variable will be set to True if the user pressed a key during \ndef isWall(mapObj, x, y): \n\"\"\"Returns True if the (x, y) position on \nthe map is a wall, otherwise return False.\"\"\" \nreturn False # x and y aren't actually on the map.\nelif mapObj[x][y] in ('#', 'x'): \nreturn True # wall is blocking \nThe isWall() function returns True if there is a wall on the map object at the XY coordinates \nWall objects are represented as either a 'x' or '#' string in the map \nReturns the decorated map object.\"\"\" \nif mapObjCopy[x][y] in ('$', '.', '@', '+', '*'): \nmapObjCopy[x][y] = ' ' \nThe map object has characters that represent the position of the player, goals, and stars.\nnecessary for the map object (they’re stored in other data structures after the map file is read) so \nif mapObjCopy[x][y] == '#': \nelif mapObjCopy[x][y] == ' ' and random.randint(0, 99) < \nmapObjCopy[x][y] = \nIf so, the '#' string in the map object that represents a normal wall is changed to a \n'x' string which represents a corner wall tile.\ndef isBlocked(mapObj, gameStateObj, x, y): \n\"\"\"Returns True if the (x, y) position on the map is \nblocked by a wall or star, otherwise return False.\"\"\" \nif isWall(mapObj, x, y): \nelif x < 0 or x >= len(mapObj) or y < 0 or y >= len(mapObj[x]): \nreturn True # x and y aren't actually on the map.\nelif (x, y) in gameStateObj['stars']: \nreturn True # a star is blocking \nThere are three cases where a space on the map would be blocked: if there is a star, a wall, or the \nthese three cases and returns True if the XY coordinates are blocked and False if not.\n\"\"\"Given a map and game state object, see if it is possible for the \nIf it is, then change the player's \nReturns True if the player moved, otherwise False.\"\"\" \nplayerx, playery = gameStateObj['player'] \n# There is a star in the way, see if the player can push it.\ngameStateObj['player'] = (playerx + xOffset, playery + yOffset) \nThe makeMove() function checks to make sure if moving the player in a particular direction is \nupdated to reflect this, and the True value will be returned to tell the function’s caller that the \nplayer was moved.\nIf there was a star in the space that the player wanted to move, that star’s position is also changed \nIf the player is blocked from moving in the desired direction, then the gameStateObj is not \nthe star_title.png file)) will be positioned 50 pixels from the top of the window.\ntrack the Y axis positioning of the title image and the instructional text.\ngoing to be set so that the images and text are centered, as it is on line 385 for the title image.\ntopCoord += 10 # 10 pixels will go in between each line of text.\nLine 400 is where the title image is blitted to the display Surface object.\nline 403 will render, position, and blit each instructional string in the instructionText loop.\nplayer does either, the loop will keep calling pygame.display.update() and \nStar Pusher has a specific format for the levels, maps, and game state data structures.\nThe game state object will be a dictionary with three keys: 'player', 'stepCounter', and \nThe value at the 'player' key will be a tuple of two integers for the current XY \nposition of the player.\nThe value at the 'stars' key is a list of two-integer tuples of XY values for each of the \nThe map data structure is simply a 2D list of lists where the two indexes used represent the X and \nY coordinates of the map.\n'x' – A corner wall.\n'@' – The starting space for the player on this level.\n'$' – A space where a star is at the start of the level.\n'+' – A space with a goal and the starting player’s space.\n'*' – A space with a goal and a star at the start of the level.\nstarts), a map object, and a few other values.\nThe value at the key 'width' is an integer of how many tiles wide the entire map is.\nThe value at the key 'height' is an integer of how many tiles tall the entire map is.\nThe value at the key 'mapObj' is the map object for this level.\nThe value at the key 'startState' is a game state object used to show the starting \nposition of the stars and player at the start of the level.\nnew levels, the player doesn’t have to change the source code of the game but instead can just ",
      "keywords": [
        "map",
        "player",
        "star",
        "Returns True",
        "map object",
        "return False",
        "text",
        "Star Pusher",
        "move",
        "object",
        "mapObjCopy",
        "CAM",
        "line",
        "level",
        "wall"
      ],
      "concepts": [
        "function",
        "functions",
        "text",
        "returns",
        "key",
        "keys",
        "tile",
        "file",
        "level",
        "wall"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 30,
          "title": "",
          "score": 0.782,
          "base_score": 0.632,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 34,
          "title": "",
          "score": 0.676,
          "base_score": 0.526,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 36,
          "title": "",
          "score": 0.558,
          "base_score": 0.558,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 25,
          "title": "",
          "score": 0.536,
          "base_score": 0.536,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 31,
          "title": "",
          "score": 0.536,
          "base_score": 0.536,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "map",
          "wall",
          "star",
          "player",
          "map object"
        ],
        "semantic": [],
        "merged": [
          "map",
          "wall",
          "star",
          "player",
          "map object"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.44325778620834183,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261930+00:00"
      }
    },
    {
      "chapter_number": 33,
      "title": "Segment 33 (pages 291-299)",
      "start_page": 291,
      "end_page": 299,
      "summary": "To create a file, call the open() function pass it two arguments: a string for the name of the file, \nand the string 'w' to tell the open() function you want to open the file in ―write‖ mode.\nopen() function returns a file object: \nIf you run this code from the interactive shell, the hello.txt file that this function creates will be \nIf the open() function is called from a .py program, the file is created in the same \nit a string like you would pass a string to the print() function.\n(Although Python will automatically close any opened file objects when \nTo read the content of a file, pass the string 'r' instead of 'w' to the open() function.\nThe readlines() method returns a list of strings: one string for each line of text in the file: \nIf you want to re-read the contents of that file, you will have to call close() on the file object \nAbout the Star Pusher Map File Format \nWe need the level text file to be in a specific format.\nmap file format.\nIf you download the levels file from http://invpy.com/starPusherLevels.txt and \n; Level maps are separated by a blank line (I like to use a ; at the start \nJust place the levels in a text file \nassert os.path.exists(filename), 'Cannot find the level file: %s' % \nThe os.path.exists() function will return True if the file specified by the string passed to \n# Each level must end with a blank line \nmapTextLines = [] # contains the lines for a single level's map.\nThe file object for the level file that is opened for reading is stored in mapFile.\nfrom the level file is stored as a list of strings in the content variable, with a blank line added \nAfter the level objects are created, they will be stored in the levels list.\nvariable will keep track of how many levels are found inside the level file.\nstores the strings of all maps in the level file).\n# Process each line that was in the level file.\nThe for loop on line 437 will go through each line that was read from the level file one line at a \nThe line number will be stored in lineNum and the string of text for the line will be stored \nin line.\nif ';' in line: \n# Ignore the ; lines, they're comments in the level file.\nAny text that exists after a semicolon in the map file is treated like a comment and is ignored.\nif line != '': \n# This line is part of the map.\nmapTextLines.append(line) \nThere can be maps for multiple levels in the map file.\nlines of text from the map file for the current level being loaded.\nblank, the line will be appended to the end of mapTextLines.\nelif line == '' and len(mapTextLines) > 0: \n# A blank line indicates the end of a level's map in the file.\n# Convert the text in mapTextLines into a level object.\nWhen there is a blank line in the map file, that indicates that the map for the current level has \nAnd future lines of text will be for the later levels.\nbe one line in mapTextLines so that multiple blank lines together are not counted as the start \nThe for loop on line 459 goes through the strings in mapTextLines again, this time to add \nThis is why line \ngame.) But the map object will have to be a list of list of single-character strings such that \nThe nested for loops on line 465 and 466 will fill these lists with single-character strings to \nAfter creating the map object, the nested for loops on lines 475 and 476 will go through each \nwhich will then be stored in the game state object later on line 494.\nstored in the game state object on line 496.\nin the level object on line 500.\nBut the goals are stored in the level \nassert len(goals) > 0, 'Level %s (around line %s) in %s must \nassert len(stars) >= len(goals), 'Level %s (around line %s) in \nwith the level file.\nThe first assertion on line 489 checks to make sure that there is a player starting point listed \n# Create level object and starting game state object.\nThe level object is added to a list of level objects on line 503.\nNow that this level is done processing, the variables for mapTextLines, mapObj, and \nlevel file.\nWhen you run this program, the function gets defined when the def statement on line A \nfunction calls itself on line F and passes 42.\nOn line K, the function is called and 41 is passed for the param parameter.\nLine F will then make a call, recursively, to the function and passes \nline of the function, line I, will execute to print out ―End of function.‖ and the function returns to \nthe line that called it.\nBut remember, the line of code that called the function was line F.\nline I which makes ―End of function.‖ display for a second time.\nSince it has reached the end of the function, it returns to the line of code that called this function \nEach time a function is called, the Python interpreter remembers which line of code made the call.",
      "keywords": [
        "line",
        "file",
        "level file",
        "level",
        "function",
        "Map File",
        "Map",
        "Star Pusher",
        "file object",
        "mapTextLines",
        "level object",
        "object",
        "Map File Format",
        "string",
        "open"
      ],
      "concepts": [
        "line",
        "functions",
        "level",
        "files",
        "content",
        "string",
        "strings",
        "star",
        "starting",
        "python"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 4,
          "title": "",
          "score": 0.631,
          "base_score": 0.481,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 11,
          "title": "",
          "score": 0.526,
          "base_score": 0.376,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 19,
          "title": "",
          "score": 0.479,
          "base_score": 0.329,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 3,
          "title": "",
          "score": 0.447,
          "base_score": 0.297,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 1,
          "title": "",
          "score": 0.444,
          "base_score": 0.294,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "file",
          "level",
          "line",
          "map",
          "level file"
        ],
        "semantic": [],
        "merged": [
          "file",
          "level",
          "line",
          "map",
          "level file"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23695868013583568,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.261964+00:00"
      }
    },
    {
      "chapter_number": 34,
      "title": "Segment 34 (pages 300-307)",
      "start_page": 300,
      "end_page": 307,
      "summary": "remember what line of code made that call so that when the function returns it can resume the \nBut the funky() function never returns, it just keeps making calls to itself.\nIn order to prevent stack overflow bugs, you must have a base case where the function stops \nThe flood fill algorithm is used in Star Pusher to change all of the floor tiles inside the walls of \ndef floodFill(mapObj, x, y, oldCharacter, newCharacter): \nif mapObj[x][y] == oldCharacter: \nmapObj[x][y] = newCharacter \nLine 522 and 523 converts the tile at the XY coordinate passed to floodFill() to the \nif x < len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter: \nfloodFill(mapObj, x+1, y, oldCharacter, newCharacter) # call right \nif x > 0 and mapObj[x-1][y] == oldCharacter: \nfloodFill(mapObj, x-1, y, oldCharacter, newCharacter) # call left \nif y < len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter: \nfloodFill(mapObj, x, y+1, oldCharacter, newCharacter) # call down \nif y > 0 and mapObj[x][y-1] == oldCharacter: \nfloodFill(mapObj, x, y-1, oldCharacter, newCharacter) # call up \nrecursive calls, but instead uses a list of XY coordinates to keep track of which spaces on the map \ndef floodFill(mapObj, x, y, oldCharacter, newCharacter): \nif mapObj[x][y] == oldCharacter: \nmapObj[x][y] = newCharacter \nif x < len(mapObj) - 1 and mapObj[x+1][y] == oldCharacter: \nif x > 0 and mapObj[x-1][y] == oldCharacter: \nif y < len(mapObj[x]) - 1 and mapObj[x][y+1] == oldCharacter: \nif y > 0 and mapObj[x][y-1] == oldCharacter: \n# mapSurf will be the single Surface object that the tiles are drawn \nThe drawMap() function will return a Surface object with the entire map (and the player and \nfor y in range(len(mapObj[x])): \nif mapObj[x][y] in TILEMAPPING: \nbaseTile = TILEMAPPING[mapObj[x][y]] \nelif mapObj[x][y] in OUTSIDEDECOMAPPING: \nThe baseTile variable is set to the Surface object of the tile image to be drawn at the \nif mapObj[x][y] in OUTSIDEDECOMAPPING: \nmapSurf.blit(OUTSIDEDECOMAPPING[mapObj[x][y]], spaceRect) \nelif (x, y) in gameStateObj['stars']: \nif (x, y) in goals: \n# A goal AND star are on this space, draw goal first.\nIf there is a star located at this XY coordinate on the map (which can be found out by checking \nfor (x, y) in the list at gameStateObj['stars']), then a star should be drawn at this XY \nBefore the star is drawn, the code should first check if \nelif (x, y) in goals: \n# Draw a goal without a star on it.\nIf there is a goal at this XY coordinate on the map, then the ―uncovered goal‖ should be drawn on \nstar that is also at this XY coordinate.\nif (x, y) == gameStateObj['player']: \nFinally, the drawMap() function checks if the player is located at this XY coordinate, and if so, \non line 549 and 550, so by the time the Surface object is returned, the entire map has been drawn \n\"\"\"Returns True if all the goals have stars in them.\"\"\" \nif goal not in gameStateObj['stars']: \nThe isLevelFinished() function returns True if all the goals are covered stars.\nlevels could have more stars than goals, so it’s important to check that all the goals are covered \nby stars, rather than checking if all the stars are over goals.\ntuples of XY coordinates for each goal) and checks if there is a star in the \ngameStateObj['stars'] list that has those same XY coordinates (the not in operators \nThe first time the code finds a goal with no star at the same position, the function \nReally, rather than just make a simple game with a single map, the Star Pusher program is more \ncan change where walls, stars, and goals appear in the game world.\nThe Star Pusher program can \nlevel editor for the Star Pusher game.",
      "keywords": [
        "mapObj",
        "Star Pusher",
        "funky",
        "Star",
        "line",
        "File",
        "function",
        "Star Pusher game",
        "Surface object",
        "Star Pusher program",
        "oldCharacter",
        "Surface",
        "goal",
        "flood fill algorithm",
        "tile"
      ],
      "concepts": [
        "game",
        "star",
        "player",
        "function",
        "functions",
        "program",
        "programming",
        "buggy",
        "file",
        "images"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 30,
          "title": "",
          "score": 0.691,
          "base_score": 0.541,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 32,
          "title": "",
          "score": 0.676,
          "base_score": 0.526,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 12,
          "title": "",
          "score": 0.491,
          "base_score": 0.491,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 36,
          "title": "",
          "score": 0.49,
          "base_score": 0.49,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 14,
          "title": "",
          "score": 0.477,
          "base_score": 0.477,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "mapobj",
          "oldcharacter",
          "mapobj oldcharacter",
          "star",
          "stars"
        ],
        "semantic": [],
        "merged": [
          "mapobj",
          "oldcharacter",
          "mapobj oldcharacter",
          "star",
          "stars"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.35193782638235377,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.262004+00:00"
      }
    },
    {
      "chapter_number": 35,
      "title": "Segment 35 (pages 308-315)",
      "start_page": 308,
      "end_page": 315,
      "summary": "290    http://inventwithpython.com/pygame \nOthello, also known by the generic name Reversi, has an 8 x 8 board with tiles that are black on \nplacing down a new tile of their color.\nThe goal of the game is to have as many of the tiles \nplaces a new white tile on space 5, 6.\nThe starting Reversi board has two white tiles \nand two black tiles.\nWhite places a new tile.\nThe black tile at 5, 5 is in between the new white tile and the existing white tile at 5, 4.\ntile is flipped over and becomes a new white tile, making the board look like Figure 10-3.\nmakes a similar move next, placing a black tile on 4, 6 which flips the white tile at 4, 5.\nWhite's move will flip over one of black's tiles.\nBlack places a new tile, which flips over one of \nwhite's tiles.\nTiles in all directions are flipped as long as they are in between the player's new tile and existing \ntile.\nIn Figure 10-5, the white player places a tile at 3, 6 and flips black tiles in both directions \n292    http://inventwithpython.com/pygame \nblack's tiles.\nThe board after white's second move.\nAs you can see, each player can quickly grab a majority of the tiles on the board in just one or \nPlayers must always make a move that captures at least one tile.\na player either cannot make a move, or the board is completely full.\nThe player with the most tiles \nA text version of this game that uses print() and input() instead of Pygame is featured in \n3. # http://inventwithpython.com/pygame \nBOARDWIDTH = 8 # how many columns of spaces on the game board \nBOARDHEIGHT = 8 # how many rows of spaces on the game board \n# (YMARGIN) the game board, in pixels.\n294    http://inventwithpython.com/pygame \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \npygame.display.set_caption('Flippy') \nBGIMAGE = pygame.transform.smoothscale(BGIMAGE, (WINDOWWIDTH, \n# Reset the board and game.\n# Make the Surface and Rect objects for the \"New Game\" and \"Hints\" \nnewGameSurf = FONT.render('New Game', True, TEXTCOLOR, TEXTBGCOLOR2) \nhintsSurf = FONT.render('Hints', True, TEXTCOLOR, TEXTBGCOLOR2) \nwhile True: # main game loop \n# Start a new game \n# Draw the game board.\ndrawInfo(boardToDraw, playerTile, computerTile, turn) \n# Draw the \"New Game\" and \"Hints\" buttons.\n296    http://inventwithpython.com/pygame \nmakeMove(mainBoard, playerTile, movexy[0], movexy[1], True) \ndrawInfo(mainBoard, playerTile, computerTile, turn) \n# Draw the \"New Game\" and \"Hints\" buttons.\nmakeMove(mainBoard, computerTile, x, y, True) \n# Only set for the player's turn if they can make a move.\ntextSurf = FONT.render(text, True, TEXTCOLOR, TEXTBGCOLOR1) \nyesSurf = BIGFONT.render('Yes', True, TEXTCOLOR, TEXTBGCOLOR1) \nnoSurf = BIGFONT.render('No', True, TEXTCOLOR, TEXTBGCOLOR1) ",
      "keywords": [
        "tile",
        "white tile",
        "game",
        "black tiles",
        "white",
        "mainBoard",
        "black",
        "board",
        "WINDOWWIDTH",
        "player",
        "Extra Games",
        "game board",
        "Computer",
        "turn",
        "move"
      ],
      "concepts": [
        "game",
        "board",
        "white",
        "score",
        "event",
        "black",
        "turn",
        "player",
        "font",
        "text"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 36,
          "title": "",
          "score": 0.768,
          "base_score": 0.618,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 14,
          "title": "",
          "score": 0.74,
          "base_score": 0.59,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 39,
          "title": "",
          "score": 0.644,
          "base_score": 0.494,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 12,
          "title": "",
          "score": 0.635,
          "base_score": 0.485,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 13,
          "title": "",
          "score": 0.619,
          "base_score": 0.469,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "tile",
          "tiles",
          "white",
          "black",
          "white tile"
        ],
        "semantic": [],
        "merged": [
          "tile",
          "tiles",
          "white",
          "black",
          "white tile"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.39270033532703535,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.262048+00:00"
      }
    },
    {
      "chapter_number": 36,
      "title": "Segment 36 (pages 316-323)",
      "start_page": 316,
      "end_page": 323,
      "summary": "def translateBoardToPixelCoord(x, y): \nreturn XMARGIN + x * SPACESIZE + int(SPACESIZE / 2), YMARGIN + y * \nfor x, y in tilesToFlip: \ncenterx, centery = translateBoardToPixelCoord(x, y) \npygame.draw.circle(DISPLAYSURF, color, (centerx, centery), \n# Draw the black & white tiles or hint spots.\ncenterx, centery = translateBoardToPixelCoord(x, y) \nif board[x][y] == WHITE_TILE or board[x][y] == BLACK_TILE: \nif board[x][y] == WHITE_TILE: \nif board[x][y] == HINT_TILE: \npygame.draw.rect(DISPLAYSURF, HINTCOLOR, (centerx - 4, \nreturn (x, y) \nboard[x][y] = EMPTY_SPACE \nboard[3][3] = WHITE_TILE \nboard[3][4] = BLACK_TILE \nboard[4][3] = BLACK_TILE \nboard[4][4] = WHITE_TILE \nboard = [] \nreturn board \ndef isValidMove(board, tile, xstart, ystart): \nboard[xstart][ystart] = tile # temporarily set the tile on the board.\nx, y = xstart, ystart \nif isOnBoard(x, y) and board[x][y] == otherTile: \nwhile board[x][y] == otherTile: \nif board[x][y] == tile: \nif x == xstart and y == ystart: \ntilesToFlip.append([x, y]) \ndef isOnBoard(x, y): \nreturn x >= 0 and x < BOARDWIDTH and y >= 0 and y < BOARDHEIGHT \ndef getBoardWithValidMoves(board, tile): \nfor x, y in getValidMoves(dupeBoard, tile): \ndupeBoard[x][y] = HINT_TILE \ndef getValidMoves(board, tile): \n# Returns a list of (x,y) tuples of all valid moves.\nif isValidMove(board, tile, x, y) != False: \nif board[x][y] == WHITE_TILE: \nif board[x][y] == BLACK_TILE: \nreturn {WHITE_TILE:xscore, BLACK_TILE:oscore} \nreturn [WHITE_TILE, BLACK_TILE] \nreturn [BLACK_TILE, WHITE_TILE] \ndef makeMove(board, tile, xstart, ystart, realMove=False): \n# Place the tile on the board at xstart, ystart, and flip tiles \ntilesToFlip = isValidMove(board, tile, xstart, ystart) \nboard[xstart][ystart] = tile \nfor x, y in tilesToFlip: \nboard[x][y] = tile \ndef isOnCorner(x, y): \nreturn (x == 0 and y == 0) or \\ \n(x == BOARDWIDTH and y == 0) or \\ \n(x == 0 and y == BOARDHEIGHT) or \\ \n(x == BOARDWIDTH and y == BOARDHEIGHT) \n# Given a board and the computer's tile, determine where to \n# move and return that move as a [x, y] list.\nfor x, y in possibleMoves: \nreturn [x, y] \nfor x, y in possibleMoves: \nThe game ―Flood It‖ begins with a board filled with colored tiles.\nThis game also has a Settings screen where the player can change the size of the board and the ",
      "keywords": [
        "tile",
        "board",
        "SPACESIZE",
        "WHITE",
        "BLACK",
        "BOARDHEIGHT",
        "BOARDWIDTH",
        "range",
        "int",
        "Draw",
        "ystart",
        "YMARGIN",
        "returns",
        "XMARGIN",
        "return False"
      ],
      "concepts": [
        "board",
        "returns",
        "tile",
        "draw",
        "space",
        "score",
        "scoring",
        "events",
        "color",
        "size"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 39,
          "title": "",
          "score": 0.854,
          "base_score": 0.704,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 14,
          "title": "",
          "score": 0.819,
          "base_score": 0.669,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 21,
          "title": "",
          "score": 0.804,
          "base_score": 0.654,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 35,
          "title": "",
          "score": 0.768,
          "base_score": 0.618,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 12,
          "title": "",
          "score": 0.768,
          "base_score": 0.618,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "board",
          "ystart",
          "tile",
          "board tile",
          "white_tile"
        ],
        "semantic": [],
        "merged": [
          "board",
          "ystart",
          "tile",
          "board tile",
          "white_tile"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5124005029450499,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.262094+00:00"
      }
    },
    {
      "chapter_number": 37,
      "title": "Segment 37 (pages 324-331)",
      "start_page": 324,
      "end_page": 331,
      "summary": "306    http://inventwithpython.com/pygame \nCOLORSCHEMES = (((150, 200, 255), RED, GREEN, BLUE, YELLOW, ORANGE, \nfor i in range(len(COLORSCHEMES)): \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \nLOGOIMAGE = pygame.image.load('inkspilllogo.png') \nSPOTIMAGE = pygame.image.load('inkspillspot.png') \nSETTINGSIMAGE = pygame.image.load('inkspillsettings.png') \nSETTINGSBUTTONIMAGE = pygame.image.load('inkspillsettingsbutton.png') \nRESETBUTTONIMAGE = pygame.image.load('inkspillresetbutton.png') \npygame.display.set_caption('Ink Spill') \nmainBoard = generateRandomBoard(boardWidth, boardHeight, difficulty) \nfor event in pygame.event.get(): # event handling loop \n308    http://inventwithpython.com/pygame \nif pygame.Rect(WINDOWWIDTH - \nelif pygame.Rect(WINDOWWIDTH - \nresetGame = True # clicked on Reset button \nfor i in range(4): \ndifficulty) \nfor event in pygame.event.get(QUIT): # get all the QUIT events \npygame.quit() # terminate if any QUIT events are present \nfor event in pygame.event.get(KEYUP): # get all the KEYUP events \npygame.quit() # terminate if the KEYUP event was for the Esc \ndef hasWon(board): \n# if the entire board is the same color, player has won \nfor x in range(boardWidth): \nfor y in range(boardHeight): \nif board[x][y] != board[0][0]: \nglobal difficulty, boxSize, boardWidth, boardHeight, maxLife, \n310    http://inventwithpython.com/pygame \nfor i in range(len(COLORSCHEMES)): \nfor event in pygame.event.get(): # event handling loop \npygame.quit() \n# check for clicks on the difficulty buttons \nif pygame.Rect(74, 16, 111, 30).collidepoint(mousex, \nelif pygame.Rect(53, 50, 104, 29).collidepoint(mousex, \nelif pygame.Rect(72, 85, 65, 31).collidepoint(mousex, \nelif pygame.Rect(63, 156, 84, 31).collidepoint(mousex, \n# small board size setting: \nelif pygame.Rect(52, 192, 106,32).collidepoint(mousex, \n# medium board size setting: \nelif pygame.Rect(67, 228, 58, 37).collidepoint(mousex, \n# large board size setting: \nelif pygame.Rect(14, 299, 371, 97).collidepoint(mousex, \nelif pygame.Rect(178, 418, 215, 34).collidepoint(mousex, \nfor i in range(len(COLORSCHEMES)): \n# clicked on a color scheme button \nif pygame.Rect(500, 30 + i * 60, MEDIUMBOXSIZE * 3, \n312    http://inventwithpython.com/pygame \n# Draws the color scheme boxes that appear on the \"Settings\" screen.\npygame.draw.rect(DISPLAYSURF, COLORSCHEMES[schemeNum][3 * boxy \nDISPLAYSURF.blit(SPOTIMAGE, (x - 50, y)) \ndef flashBorderAnimation(color, board, animationSpeed=30): \nflashSurf = pygame.Surface(DISPLAYSURF.get_size()) \ndef floodAnimation(board, paletteClicked, animationSpeed=25): \ndrawBoard(board, transparency) \ndef generateRandomBoard(width, height, difficulty=MEDIUM): \n# Creates a board data structure with random colors for each box.\nboard = [] \nfor x in range(width): \nfor y in range(height): \n# Make board easier by setting some boxes to same color as a neighbor.\nelif difficulty == MEDIUM: \nreturn board ",
      "keywords": [
        "board",
        "COLORSCHEMES",
        "mousex",
        "mousey",
        "difficulty",
        "range",
        "SPOTIMAGE",
        "elif pygame.Rect",
        "MEDIUMBOXSIZE",
        "boxSize",
        "DISPLAYSURF.blit",
        "collidepoint",
        "pygame.Rect",
        "color",
        "MEDIUM"
      ],
      "concepts": [
        "board",
        "color",
        "difficulty",
        "event",
        "game",
        "range",
        "button",
        "mousey",
        "medium",
        "random"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 38,
          "title": "",
          "score": 0.867,
          "base_score": 0.717,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 16,
          "title": "",
          "score": 0.799,
          "base_score": 0.649,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 5,
          "title": "",
          "score": 0.736,
          "base_score": 0.586,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 10,
          "title": "",
          "score": 0.735,
          "base_score": 0.585,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 24,
          "title": "",
          "score": 0.722,
          "base_score": 0.572,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "pygame",
          "elif pygame",
          "mousex",
          "collidepoint mousex",
          "collidepoint"
        ],
        "semantic": [],
        "merged": [
          "pygame",
          "elif pygame",
          "mousex",
          "collidepoint mousex",
          "collidepoint"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.45603263686824597,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.262138+00:00"
      }
    },
    {
      "chapter_number": 38,
      "title": "Segment 38 (pages 332-339)",
      "start_page": 332,
      "end_page": 339,
      "summary": "DISPLAYSURF.blit(SETTINGSBUTTONIMAGE, (WINDOWWIDTH - \ntempSurf = pygame.Surface(DISPLAYSURF.get_size()) \nleft, top = leftTopPixelCoordOfBox(x, y) \nr, g, b = paletteColors[board[x][y]] \npygame.draw.rect(tempSurf, (r, g, b, transparency), (left, \npygame.draw.rect(tempSurf, BLACK, (left-1, top-1, boxSize * boardWidth \npygame.draw.rect(DISPLAYSURF, paletteColors[i], (left, top, \npygame.draw.rect(DISPLAYSURF, bgColor,   (left + 2, top + 2, \npygame.draw.rect(DISPLAYSURF, bgColor, (20, 20, 20, 20 + (maxLife * \npygame.draw.rect(DISPLAYSURF, RED, (20, 20 + (i * \npygame.draw.rect(DISPLAYSURF, WHITE, (20, 20 + (i * lifeBoxSize), \ndef getColorOfPaletteAt(x, y): \n# Returns the index of the color in paletteColors that the x and y \nReturns None if x and y are not over any palette.\nr = pygame.Rect(left, top, PALETTESIZE, PALETTESIZE) \ndef floodFill(board, oldColor, newColor, x, y): \nif oldColor == newColor or board[x][y] != oldColor: \nboard[x][y] = newColor # change the color of the current box \nfloodFill(board, oldColor, newColor, x - 1, y) # on box to the \nfloodFill(board, oldColor, newColor, x + 1, y) # on box to the \nfloodFill(board, oldColor, newColor, x, y - 1) # on box to up \nfloodFill(board, oldColor, newColor, x, y + 1) # on box to down \n# Returns the x and y of the left-topmost pixel of the xth & yth box.\nThe game ―Connect Four‖ has a 7 x 6 board where the players take turns dropping tokens from \nevery possible move the human player can make in response to each of those moves, and then \nmove the human player could make in response to each of those moves!\nSince there are seven possible moves you can make on your turn (unless some columns are full), \nseven moves in response to that, that means that on each turn the computer is considering 7 x 7 x \nassert BOARDWIDTH >= 4 and BOARDHEIGHT >= 4, 'Board must be at least 4x4.' \nSPACESIZE = 50 # size of the tokens and individual board spaces in pixels \nDISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT)) \npygame.display.set_caption('Four in a Row') \nREDPILERECT = pygame.Rect(int(SPACESIZE / 2), WINDOWHEIGHT - int(3 * \nBLACKPILERECT = pygame.Rect(WINDOWWIDTH - int(3 * SPACESIZE / 2), \nREDTOKENIMG = pygame.image.load('4row_red.png') \nBLACKTOKENIMG = pygame.image.load('4row_black.png') \nBOARDIMG = pygame.image.load('4row_board.png') \nHUMANWINNERIMG = pygame.image.load('4row_humanwinner.png') \nCOMPUTERWINNERIMG = pygame.image.load('4row_computerwinner.png') \nTIEWINNERIMG = pygame.image.load('4row_tie.png') \nARROWIMG = pygame.image.load('4row_arrow.png') \ndef makeMove(board, player, column): \nboard[column][lowest] = player \ndef drawBoard(board, extraToken=None): \nspaceRect = pygame.Rect(0, 0, SPACESIZE, SPACESIZE) \nspaceRect.topleft = (XMARGIN + (x * SPACESIZE), YMARGIN + (y * \nif board[x][y] == RED: \nelif board[x][y] == BLACK: \nDISPLAYSURF.blit(REDTOKENIMG, (extraToken['x'], \nDISPLAYSURF.blit(BLACKTOKENIMG, (extraToken['x'], \n# draw board over the tokens \nspaceRect.topleft = (XMARGIN + (x * SPACESIZE), YMARGIN + (y * \n# draw the red and black tokens off to the side \nDISPLAYSURF.blit(REDTOKENIMG, REDPILERECT) # red on the left \nDISPLAYSURF.blit(BLACKTOKENIMG, BLACKPILERECT) # black on the right ",
      "keywords": [
        "SPACESIZE",
        "PALETTESIZE",
        "board",
        "WINDOWHEIGHT",
        "WINDOWWIDTH",
        "computer",
        "int",
        "DISPLAYSURF",
        "boardWidth",
        "boardHeight",
        "top",
        "DISPLAYSURF.blit",
        "turn",
        "xmargin",
        "moves"
      ],
      "concepts": [
        "board",
        "draw",
        "left",
        "black",
        "boxes",
        "random",
        "turns",
        "tokens",
        "players",
        "returns"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 37,
          "title": "",
          "score": 0.867,
          "base_score": 0.717,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 16,
          "title": "",
          "score": 0.861,
          "base_score": 0.711,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 24,
          "title": "",
          "score": 0.849,
          "base_score": 0.699,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 10,
          "title": "",
          "score": 0.815,
          "base_score": 0.665,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 5,
          "title": "",
          "score": 0.768,
          "base_score": 0.618,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "board",
          "newcolor",
          "oldcolor",
          "spacesize",
          "board oldcolor"
        ],
        "semantic": [],
        "merged": [
          "board",
          "newcolor",
          "oldcolor",
          "spacesize",
          "board oldcolor"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.4888791129283068,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.262182+00:00"
      }
    },
    {
      "chapter_number": 39,
      "title": "Segment 39 (pages 340-347)",
      "start_page": 340,
      "end_page": 347,
      "summary": "322    http://inventwithpython.com/pygame \ndef getHumanMove(board, isFirstMove): \nif isValidMove(board, column): \nanimateDroppingToken(board, column, RED) \nboard[column][getLowestEmptySpace(board, column)] \ndrawBoard(board) \ndrawBoard(board, {'x':tokenx - int(SPACESIZE / 2), 'y':tokeny \ndrawBoard(board) \ndef animateDroppingToken(board, column, color): \nlowestEmptySpace = getLowestEmptySpace(board, column) \ndrawBoard(board, {'x':x, 'y':y, 'color':color}) \ndef animateComputerMoving(board, column): \ndrawBoard(board, {'x':x, 'y':y, 'color':BLACK}) \ndrawBoard(board, {'x':x, 'y':y, 'color':BLACK}) \nanimateDroppingToken(board, column, BLACK) \ndef getComputerMove(board): \npotentialMoves = getPotentialMoves(board, BLACK, DIFFICULTY) \n324    http://inventwithpython.com/pygame \nif potentialMoves[i] > bestMoveFitness and isValidMove(board, i): \nif potentialMoves[i] == bestMoveFitness and isValidMove(board, i): \ndef getPotentialMoves(board, tile, lookAhead): \nif lookAhead == 0 or isBoardFull(board): \ndupeBoard = copy.deepcopy(board) \ndef getLowestEmptySpace(board, column): \nif board[column][y] == EMPTY: \nreturn y \ndef isValidMove(board, column): \n# Returns True if there is an empty space in the given column.\nif column < 0 or column >= (BOARDWIDTH) or board[column][0] != EMPTY: \ndef isBoardFull(board): \n# Returns True if there are no empty spaces anywhere on the board.\nif board[x][y] == EMPTY: \ndef isWinner(board, tile): \nif board[x][y] == tile and board[x+1][y] == tile and \nboard[x+2][y] == tile and board[x+3][y] == tile: \nif board[x][y] == tile and board[x][y+1] == tile and \nboard[x][y+2] == tile and board[x][y+3] == tile: \n326    http://inventwithpython.com/pygame \nif board[x][y] == tile and board[x+1][y-1] == tile and \nboard[x+2][y-2] == tile and board[x+3][y-3] == tile: \nif board[x][y] == tile and board[x+1][y+1] == tile and \nboard[x+2][y+2] == tile and board[x+3][y+3] == tile: \n―Bejeweled‖ is a game where gems fall to fill up a board.\ngame ends when no possible match can be made on the board.\n3. # http://inventwithpython.com/pygame \n9.   'x' and 'y' - The location of the gem on the board.\nto indicate that it is above the board.\n328    http://inventwithpython.com/pygame \nBOARDWIDTH = 8 # how many columns in the board \nBOARDHEIGHT = 8 # how many rows in the board \nGRIDCOLOR = BLUE # color of the game board \n# The amount of space to the sides of the board to the edge of the window \npygame.display.set_caption('Gemgem') \ngemImage = pygame.image.load('gem%s.png' % i) \nGAMESOUNDS['match'].append(pygame.mixer.Sound('match%s.wav' % i)) \n# Create pygame.Rect objects for each board space to \nr = pygame.Rect((XMARGIN + (x * GEMIMAGESIZE), ",
      "keywords": [
        "board",
        "BOARDWIDTH",
        "tile",
        "range",
        "return True",
        "GEMIMAGESIZE",
        "SPACESIZE",
        "column",
        "black",
        "red",
        "BOARDHEIGHT",
        "black tile",
        "color",
        "XMARGIN",
        "YMARGIN"
      ],
      "concepts": [
        "board",
        "gems",
        "returns",
        "column",
        "red",
        "event",
        "color",
        "match",
        "types",
        "games"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 41,
          "title": "",
          "score": 0.872,
          "base_score": 0.722,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 36,
          "title": "",
          "score": 0.854,
          "base_score": 0.704,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 21,
          "title": "",
          "score": 0.809,
          "base_score": 0.659,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 12,
          "title": "",
          "score": 0.761,
          "base_score": 0.611,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 14,
          "title": "",
          "score": 0.756,
          "base_score": 0.606,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "board",
          "board tile",
          "column",
          "tile board",
          "tile"
        ],
        "semantic": [],
        "merged": [
          "board",
          "board tile",
          "column",
          "tile board",
          "tile"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5174162700097026,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.262228+00:00"
      }
    },
    {
      "chapter_number": 40,
      "title": "Segment 40 (pages 348-355)",
      "start_page": 348,
      "end_page": 355,
      "summary": "fillBoardAndAnimate(gameBoard, [], score) # Drop the initial gems.\n# This was the first gem clicked on.\nSwap the gems.\nfirstSelectedGem = None # deselect the first gem \n# Swap the gems in the board data structure.\ngameBoard[firstSwappingGem['x']][firstSwappingGem['y']] = \ngameBoard[secondSwappingGem['x']][secondSwappingGem['y']] = \n# Was not a matching move; swap the gems back \ngameBoard[firstSwappingGem['x']][firstSwappingGem['y']] = \ngameBoard[secondSwappingGem['x']][secondSwappingGem['y']] \n# Remove matched gems, then pull down the board.\nfor gem in gemSet: \ngameBoard[gem[0]][gem[1]] = EMPTY_SPACE \n'x': gem[0] * GEMIMAGESIZE + \n'y': gem[1] * GEMIMAGESIZE + \n# Drop the new gems.\nhighlightSpace(firstSelectedGem['x'], firstSelectedGem['y']) \n# If the gems at the (X, Y) coordinates of the two gems are adjacent, \nfirstGem = {'imageNum': board[firstXY['x']][firstXY['y']], \nsecondGem = {'imageNum': board[secondXY['x']][secondXY['y']], \nif firstGem['x'] == secondGem['x'] + 1 and firstGem['y'] == \nelif firstGem['x'] == secondGem['x'] - 1 and firstGem['y'] == \nelif firstGem['y'] == secondGem['y'] + 1 and firstGem['x'] == \nelif firstGem['y'] == secondGem['y'] - 1 and firstGem['x'] == \n# The x and y variables iterate over each space on the board.\n# by (1,0), and gem C is offset by (2,0).\nif (getGemAt(board, x+pat[0][0], y+pat[0][1]) == \\ \ngetGemAt(board, x+pat[1][0], y+pat[1][1]) == \\ \ngetGemAt(board, x+pat[2][0], y+pat[2][1]) != None) or \n(getGemAt(board, x+pat[0][1], y+pat[0][0]) == \\ \ngetGemAt(board, x+pat[1][1], y+pat[1][0]) == \\ \ngetGemAt(board, x+pat[2][1], y+pat[2][0]) != None): \ndef drawMovingGem(gem, progress): \nif gem['direction'] == UP: \nelif gem['direction'] == DOWN: \nelif gem['direction'] == RIGHT: \nelif gem['direction'] == LEFT: \nbasex = gem['x'] \nbasey = gem['y'] \n# pulls down gems on the board to the bottom to fill in any gaps \nif board[x][y] != EMPTY_SPACE: \ngemsInColumn.append(board[x][y]) \nboard[x] = ([EMPTY_SPACE] * (BOARDHEIGHT - len(gemsInColumn))) + \ndef getGemAt(board, x, y): \nreturn board[x][y] \nif boardCopy[x][y] == EMPTY_SPACE: \n# the same gems next to each other when they drop.\nneighborGem = getGemAt(boardCopy, x + offsetX, y + \nboardCopy[x][y] = newGem \n== getGemAt(boardCopy, x + 2, y) and getGemAt(boardCopy, x, y) != EMPTY_SPACE: \ntargetGem = boardCopy[x][y] \nwhile getGemAt(boardCopy, x + offset, y) == targetGem: \nremoveSet.append((x + offset, y)) \nboardCopy[x + offset][y] = EMPTY_SPACE \n== getGemAt(boardCopy, x, y + 2) and getGemAt(boardCopy, x, y) != EMPTY_SPACE: \ntargetGem = boardCopy[x][y] \nwhile getGemAt(boardCopy, x, y + offset) == targetGem: \nremoveSet.append((x, y + offset)) \nboardCopy[x][y + offset] = EMPTY_SPACE \ndef highlightSpace(x, y): \npygame.draw.rect(DISPLAYSURF, HIGHLIGHTCOLOR, BOARDRECTS[x][y], 4) \n# Find all the gems that have an empty space below them \nif boardCopy[x][y + 1] == EMPTY_SPACE and boardCopy[x][y] != ",
      "keywords": [
        "board",
        "boardCopy",
        "gems",
        "SPACE",
        "gem",
        "getGemAt",
        "EMPTY",
        "gameBoard",
        "GEMIMAGESIZE",
        "secondGem",
        "firstGem",
        "range",
        "direction",
        "firstSelectedGem",
        "BOARDWIDTH"
      ],
      "concepts": [
        "gems",
        "gem",
        "board",
        "score",
        "returns",
        "gameboard",
        "space",
        "matching",
        "matches",
        "game"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 41,
          "title": "",
          "score": 0.781,
          "base_score": 0.631,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 13,
          "title": "",
          "score": 0.676,
          "base_score": 0.526,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 12,
          "title": "",
          "score": 0.65,
          "base_score": 0.5,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 36,
          "title": "",
          "score": 0.648,
          "base_score": 0.498,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 14,
          "title": "",
          "score": 0.637,
          "base_score": 0.487,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "getgemat",
          "boardcopy",
          "gem",
          "pat",
          "firstgem"
        ],
        "semantic": [],
        "merged": [
          "getgemat",
          "boardcopy",
          "gem",
          "pat",
          "firstgem"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.36760332475274987,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.262278+00:00"
      }
    },
    {
      "chapter_number": 41,
      "title": "Segment 41 (pages 356-363)",
      "start_page": 356,
      "end_page": 363,
      "summary": "338    http://inventwithpython.com/pygame \ndroppingGems.append( {'imageNum': boardCopy[x][y], 'x': x, \nboardCopy[x][y] = EMPTY_SPACE \ndef animateMovingGems(board, gems, pointsText, score): \n# pointsText is a dictionary with keys 'x', 'y', and 'points' \n# movingGems is a list of dicts with keys x, y, direction, imageNum \nif gem['y'] != ROWABOVEBOARD: \nboard[gem['x']][gem['y']] = EMPTY_SPACE \nboard[gem['x'] + movex][gem['y'] + movey] = gem['imageNum'] \nboard[gem['x']][0] = gem['imageNum'] # move to top row \nboard[x][0] = dropSlots[x][0] \nreturn {'x': x, 'y': y} \npygame.draw.rect(DISPLAYSURF, GRIDCOLOR, BOARDRECTS[x][y], 1) \ngemToDraw = board[x][y] \nDISPLAYSURF.blit(GEMIMAGES[gemToDraw], BOARDRECTS[x][y]) \n340    http://inventwithpython.com/pygame \ndef getBoardCopyMinusGems(board, gems): \n# Gems is a list of dicts, with keys x, y, direction, imageNum \n# Remove some of the gems from this board data structure copy.\nif gem['y'] != ROWABOVEBOARD: \nboardCopy[gem['x']][gem['y']] = EMPTY_SPACE \nI hope these game programs have given you your own ideas about what games you’d like to make \nHere are several websites that can teach you more about programming Python: \nhttp://pygame.org – The official Pygame website has the source code to hundreds of \ngames that people have written that make use of the Pygame library.\nhttp://pygame.org/docs/ - Complete documentation on the modules and functions for \nhttp://inventwithpython.com/pygame - This book's website, which includes all the source \nsound files used in the Pygame programs.\nGames with Python‖, which covers basic Python programming.\nhttp://invpy.com/wiki - A wiki that covers individual Python programming concepts that \nhttp://invpy.com/videos - Videos that accompany the programs in this book.\nhttp://gamedevlessons.com - A helpful website about how to design and program video \nabout this book or about Python programming.\nweb sites that can teach you more about Python programming.\n342    http://inventwithpython.com/pygame \npossible to write Python 3 programs that are backwards-compatible with Python 2.\nprogramming in general, it means to copy one image to another image.\ncaption can be set with the pygame.display.set_caption() function.\nCommand Line Interface - A program that the user can use by seeing text on the screen and \nIn Python, these functions have \nwith the Pygame drawing or blitting functions will appear on the screen when \nDrawing Primitives - The name for the basic shape-drawing functions in Pygame.\nFrame - A single image that is displayed on the screen as part of an animation.\nIt is common for games to be run at 30 frames per second or more.\nGame Loop - The game loop contains code that performs event handling, updates the game \nGraphical User Interface - A program that displays graphics to the user for output and can \nIn Python, list values are mutable and tuple values \nInteractive Shell - A program (part of IDLE) that executes Python instructions one at a time.\n344    http://inventwithpython.com/pygame \nInterpreter - The software that executes instructions written in the Python programming \nWhen someone says, \"Python runs this program\", they \nmean \"the Python interpreter software runs this program.\" \nMagic Numbers - Integers or floating-point values used in a program without explanation.\nIn Python, list values are mutable and tuple values are \nPoints - A point in Python is usually represented as a tuple of two integers (or float values) to \nrepresent the X and Y coordinates of a position on a 2D surface.\nReal-time - A program that runs continuously and does not wait for the player to do something is \nIn Pygame, an RGB value is a tuple of three integers (all between 0 and 255) which \nof object in the game.\nSyntactic Sugar - A bit of code that is written to make the program more readable, even though ",
      "keywords": [
        "Python",
        "gem",
        "board",
        "Python programming",
        "gems",
        "game",
        "Pygame",
        "function",
        "program",
        "game world",
        "Game Loop",
        "code",
        "programming",
        "loop",
        "direction"
      ],
      "concepts": [
        "python",
        "board",
        "gems",
        "gem",
        "program",
        "programming",
        "games",
        "functions",
        "function",
        "event"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 39,
          "title": "",
          "score": 0.872,
          "base_score": 0.722,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 40,
          "title": "",
          "score": 0.781,
          "base_score": 0.631,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 36,
          "title": "",
          "score": 0.764,
          "base_score": 0.614,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 13,
          "title": "",
          "score": 0.737,
          "base_score": 0.587,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 12,
          "title": "",
          "score": 0.721,
          "base_score": 0.571,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "python",
          "gem",
          "programming",
          "python programming",
          "http"
        ],
        "semantic": [],
        "merged": [
          "python",
          "gem",
          "programming",
          "python programming",
          "http"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.5036997071845974,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.262324+00:00"
      }
    },
    {
      "chapter_number": 42,
      "title": "Segment 42 (pages 364-365)",
      "start_page": 364,
      "end_page": 365,
      "summary": "346    http://inventwithpython.com/pygame \nEmail questions to the author: al@inventwithpython.com \nhttp://inventwithpython.com.\nEmail: al@inventwithpython.com ",
      "keywords": [
        "AUTHOR Albert Sweigart",
        "haunting coffee shops",
        "Albert Sweigart",
        "San Francisco",
        "AUTHOR Albert",
        "California who enjoys",
        "developer in San",
        "Games with Python",
        "enjoys bicycling",
        "haunting coffee",
        "coffee shops",
        "software developer",
        "Author",
        "Making Games",
        "Sweigart"
      ],
      "concepts": [
        "email",
        "book",
        "software",
        "bicycling",
        "twitter",
        "albert",
        "texas",
        "houston",
        "author",
        "blog"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 1,
          "title": "",
          "score": 0.698,
          "base_score": 0.548,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 4,
          "title": "",
          "score": 0.634,
          "base_score": 0.484,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 18,
          "title": "",
          "score": 0.601,
          "base_score": 0.451,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 3,
          "title": "",
          "score": 0.582,
          "base_score": 0.432,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "makinggames",
          "chapter": 19,
          "title": "",
          "score": 0.581,
          "base_score": 0.431,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "author",
          "coffee",
          "sweigart",
          "albert",
          "inventwithpython com"
        ],
        "semantic": [],
        "merged": [
          "author",
          "coffee",
          "sweigart",
          "albert",
          "inventwithpython com"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.3321535749095037,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:06:37.262364+00:00"
      }
    }
  ],
  "total_chapters": 42,
  "enrichment_provenance": {
    "taxonomy_id": "none",
    "taxonomy_version": "none",
    "taxonomy_path": "none",
    "taxonomy_checksum": "sha256:none",
    "source_metadata_file": "makinggames_metadata.json",
    "enrichment_date": "2025-12-17T23:06:37.276836+00:00",
    "enrichment_method": "msep",
    "model_version": "ai-agents-msep-v1",
    "processing_time_ms": 4716.634668999177,
    "total_similar_chapters": 210
  }
}