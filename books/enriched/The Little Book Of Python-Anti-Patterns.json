{
  "metadata": {
    "title": "The Little Book Of Python-Anti-Patterns",
    "author": "Unknown Author",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 65,
    "conversion_date": "2025-11-28T12:58:42.522711",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "The Little Book Of Python-Anti-Patterns.pdf",
    "extraction_method": "Unstructured"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "detection_method": "topic_boundary",
      "content": "Python Anti-Patterns\n\nThe Little Book of Python Anti-Patterns and Worst Practice\n\nQuantiﬁedCode\n\ni\n\nContents\n\nWhy did we write this?\n\nWho are we?\n\nHow is this book organized?\n\nReferences\n\nLicensing\n\nContributing\n\nList of Maintainers\n\nIndex Of Patterns 1\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Correctness . Accessing a protected member from outside the class . . . . . . . . . . . . . . . . . . 1.1 Assigning a lambda expression to a variable . . . . . . . . . . . . . . . . . . . . . . . . 1.2 . Assigning to built-in function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.3 . Bad except clauses order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.4 Bad ﬁrst argument given to super() . . . . . . . . . . . . . . 1.5 else clause on loop without a break statement . . . . . . . . . . . . . . . . . . 1.6 __exit__ must accept 3 arguments: type, value, traceback . . . . . . . . . . . . . . 1.7 Explicit return in __init__ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.8 __future__ import is not the ﬁrst non-docstring statement . . . . . . . . . . . . . . 1.9 Implementing Java-style getters and setters . . . . . . . . . . . . . . . . . . . . . . . . 1.10 Indentation contains mixed spaces and tabs . . . . . . . . . . . . . . . . . . . . . . . . 1.11 1.12 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Indentation contains tabs 1.13 Method could be a function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.14 Method has no argument 1.15 Missing argument to super() . . . . . . . . . . . . . . . . . . . . . Using a mutable default value as an argument 1.16 . . . . . . . . . . . . . . . . . . . . . . No exception type(s) speciﬁed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.17 Not using defaultdict() . . . . . 1.18 . . . . . . . . . . . . . . . . . . . . Not using else where appropriate in a loop . . . . . . . . . . . . . . . . . . . . . . . 1.19 Not using explicit unpacking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.20 Not using get() to return a default value from a dict . . . . . . . . . . . . . . . . . . 1.21 Not using setdefault() to initialize a dictionary . 1.22 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Maintainability . . using wildcard imports (from ... import *) . . . 2.1 . Not using with to open ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . 2.2 Returning more than one variable type from function call . . . . . . . . . . . . . . . . 2.3 Using the global statement . . . . . . . . . . . . . . . . . . . . . . . . 2.4 . . . . Using single letter to name your variables . . . . . . . . . . . . . . . . . . . . . . . . 2.5 . . . . . . . . . . . . . . . . Dynamically creating variable/method/function names 2.6 Readability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Asking for permission instead of forgiveness . . . . . . . . . . . . . . . . . . . . . . . 3.1 Comparing things to None the wrong way . . . . . . . . . . . . . . . . . . . . . . 3.2 Comparing things to True the wrong way . 3.3 . . . . . . . . . . . . . . . . . . . . . Using type() to compare types . . . . . 3.4 Not using dict comprehensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.5 Not using dict keys when formatting strings . . . . . . . . . . . . . . . . . . . . . . . 3.6\n\n. . . . .\n\n. . .\n\n. . . . .\n\n. . .\n\n. . . . . . .\n\n. . .\n\n. . .\n\n. . . . .\n\n2\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n. . . . . .\n\n. . . . .\n\n. . . . . . . . . .\n\n. . .\n\n. . . .\n\n. . . . .\n\n3\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n. . .\n\n. . .\n\n. . .\n\n. . . . . . . . . . . . . . . . . . . . . . . .\n\nii\n\n1\n\n1\n\n2\n\n2\n\n2\n\n2\n\n3\n\n3 4 4 4 5 6 7 9 10 12 13 14 15 16 17 18 20 21 22 24 25 26 27 28 29 29 30 31 32 33 34 36 36 37 37 39 40 41\n\n4\n\n5\n\n6\n\nNot using items() to iterate over a dictionary . . . . . . . . . . . . . . . . . . . . . . Not using named tuples when returning more than one value from a function . . . . Not using unpacking for updating multiple values at once . . . . . . . . . . . . . . . Not using zip() to iterate over a pair of lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Putting type information in a variable name Test for object identity should be is . . . . . . . . . . . . . . . . . . . . . . . Using an unpythonic loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Using map() or filter() where list comprehension is possible . . . . . . . . . . . Using CamelCase in function names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Using key in list to check if key is contained in list . . . . . . . . . . . . . . . . . Not using iteritems() to iterate over a large dictionary in Python 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n3.7 3.8 3.9 3.10 3.11 3.12 3.13 3.14 3.15 Security . 4.1 Performance . 5.1 5.2 Django . 6.1 6.2 6.3 6.4 6.5\n\n. . . . .\n\n.\n\n.\n\n. . .\n\n.\n\n. . .\n\n. . . use of exec . .\n\n. . .\n\n.\n\n.\n\n. . . . . .\n\n. . . . . .\n\n.\n\n.\n\n. . Maintainability . . Security . . . Correctness . Performance . . Migration to 1.8 .\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n. . .\n\n.\n\n42 44 44 45 46 47 47 48 49 50 50 51 51 51 53 53 54 56 57 59\n\niii\n\nPython Anti-Patterns\n\nWelcome, fellow Pythoneer! This is a small book of Python anti-patterns and worst practices.\n\nLearning about these anti-patterns will help you to avoid them in your own code and make you a better programmer (hopefully). Each pattern comes with a small description, examples and possible solutions. You can check many of them for free against your project at QuantiﬁedCode.\n\nYou can also download this book as a PDF.\n\nWhy did we write this?\n\nShort answer: We think that you can learn as much from reading bad code as you can from reading good one.\n\nLong answer: There is an overwhelming amount of Python books that show you how to do things by focusing on best practices and examples of good code. There are only very few books out there that show you how not to do things. We wanted to change that by providing you with an anti-book that teaches you things which you should never do in practice.\n\nWho are we?\n\nWe’re QuantiﬁedCode, a Berlin-based startup. Our mission is to help programmers write better code! Our ﬁrst product is an online tool for automated, data-driven code review. When building this tool we learned a lot about code quality in Python and decided to compile our knowledge into this book.\n\n1\n\nPython Anti-Patterns\n\nHow is this book organized?\n\nThis book contains anti- and migrations pattern for Python and for popular Python frameworks, such as Django. We categorized the patterns as follows:\n\nCorrectness: Anti-patterns that will literally break your code or make it do the wrong things.\n\nMaintainability: Anti-patterns that will make your code hard to maintain or extend.\n\nReadability: Anti-patterns that will make your code hard to read or understand.\n\nPerformance: Anti-patterns that will unnecessarily slow your code down.\n\nSecurity: Anti-patterns that will pose a security risk to your program.\n\nMigration: Patterns that help you migrate faster to new versions of a framework\n\nSome patterns can belong in more than one category, so please don’t take the choice that we’ve made too serious. If you think a pattern is grossly misplaced in its category, feel free to create an issue on Github.\n\nReferences\n\nWhenever we cite content from another source we tried including the link to the original article on the bottom of the page. If you should have missed one, please feel free to add it and make a pull request on Github. Thanks!\n\nLicensing\n\nThis document is licensed under a creative-commons NC license, so you can use the text freely for non- commercial purposes and adapt it to your needs. The only thing we ask in return is the inclusion of a link to this page on the top of your website, so that your readers will be able to ﬁnd the content in its original form and possibly even contribute to it.\n\nContributing\n\nIf you think this collection can be improved or extended, please contribute! You can do this by simply forking our Github project and sending us a pull request once you’re done adding your changes. We will review and merge all pull requests as fast as possible and be happy to include your name on the list of authors of this document.\n\nWe would also like to thank all contributors to this book for their effort. A full list of contributors can be found at Github.\n\n2\n\nList of Maintainers\n\nIf you have any questions concerning this project, please contact one of the maintainers:\n\nAndreas Dewes\n\nChristoph Neumann\n\nIndex Of Patterns\n\nHere’s the full index of all anti-patterns in this book.\n\nPython Anti-Patterns\n\n3\n\nPython Anti-Patterns\n\n1 Correctness\n\n1.1 Accessing a protected member from outside the class\n\nAccessing a protected member (a member preﬁxed with _) of a class from outside that class usually calls for trouble, since the creator of that class did not intend this member to be exposed.\n\n1.1.1 Anti-pattern\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself._width = width self._height = height\n\nr = Rectangle(5, 6) # direct access of protected member print(\"Width: {:d}\".format(r._width))\n\n1.1.2 Best practice\n\nIf you are absolutely sure that you need to access the protected member from the outside, do the following:\n\nMake sure that accessing the member from outside the class does not cause any inadvertent side effects.\n\nRefactor it such that it becomes part of the public interface of the class.\n\n1.1.3 References\n\nPyLint - W0212, protected-access\n\n1.2 Assigning a lambda expression to a variable\n\nThe sole advantage that a lambda expression has over a def is that the lambda can be anonymously embedded within a larger expression. If you are going to assign a name to a lambda, you are better off just deﬁning it as a def.\n\nFrom the PEP 8 Style Guide:\n\nYes:\n\ndef f(x): return 2*x\n\nNo:\n\nf = lambda x: 2*x\n\nThe ﬁrst form means that the name of the resulting function object is speciﬁcally ‘f’ instead of the generic ‘<lambda>’. This is more useful for tracebacks and string representations in general. The use of the assign- ment statement eliminates the sole beneﬁt a lambda expression can offer over an explicit def statement (i.e. that it can be embedded inside a larger expression)\n\n4\n\n1. Correctness\n\nPython Anti-Patterns\n\n1.2.1 Anti-pattern\n\nThe following code assigns a lambda function which returns the double of its input to a variable. This is functionally identical to creating a def.\n\nf = lambda x: 2 * x\n\n1.2.2 Best practice\n\nUse a def for named expressions\n\nRefactor the lambda expression into a named def expression.\n\ndef f(x): return 2 * x\n\n1.2.3 References\n\nPEP 8 Style Guide - Programming Recommendations\n\nStack Overﬂow - Do not assign a lambda expression\n\n1.3 Assigning to built-in function\n\nPython has a number of built-in functions that are always accessible in the interpreter. Unless you have a special reason, you should neither overwrite these functions nor assign a value to a variable that has the same name as a built-in function. Overwriting a built-in might have undesired side effects or can cause runtime errors. Python developers usually use built-ins ‘as-is’. If their behaviour is changed, it can be very tricky to trace back the actual error.\n\n1.3.1 Anti-pattern\n\nIn the code below, the list built-in is overwritten. This makes it impossible, to use list to deﬁne a variable as a list. As this is a very concise example, it is easy to spot what the problem is. However, if there are hundreds of lines between the assignment to list and the assignment to cars, it might become difﬁcult to identify the problem.\n\n# Overwriting built-in 'list' by assigning values to a variable called 'list' list = [1, 2, 3] # Defining a list 'cars', will now raise an error cars = list() # Error: TypeError: 'list' object is not callable\n\n1. Correctness\n\n5",
      "page_number": 1,
      "chapter_number": 1,
      "summary": "This chapter covers segment 1 (pages 1-8). Key topics include python, list, and code. Covers lambda, function.",
      "keywords": [
        "Python Anti-Patterns",
        "Anti-Patterns",
        "Python",
        "List",
        "lambda",
        "code",
        "function",
        "Book",
        "lambda expression",
        "expression",
        "variable",
        "member",
        "Correctness",
        "built-in",
        "Assigning"
      ],
      "concepts": [
        "python",
        "list",
        "code",
        "anti",
        "statement",
        "function",
        "functionally",
        "correctness",
        "type",
        "maintainers"
      ],
      "similar_chapters": [
        {
          "book": "Python Distilled",
          "chapter": 2,
          "title": "Segment 2 (pages 9-18)",
          "relevance_score": 0.74,
          "method": "sentence_transformers"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.73,
          "method": "sentence_transformers"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.73,
          "method": "sentence_transformers"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 49,
          "title": "Segment 49 (pages 993-1010)",
          "relevance_score": 0.73,
          "method": "sentence_transformers"
        },
        {
          "book": "Effective-Python",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 0.72,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 9-16)",
      "start_page": 9,
      "end_page": 16,
      "detection_method": "topic_boundary",
      "content": "Python Anti-Patterns\n\n1.3.2 Best practice\n\nUnless you have a very speciﬁc reason to use variable names that have the same name as built-in functions, it is recommended to use a variable name that does not interfere with built-in function names.\n\n# Numbers used as variable name instead of 'list' numbers = [1, 2, 3] # Defining 'cars' as list, will work just fine cars = list()\n\n1.3.3 References\n\nPython Documentation: Built-in functions\n\n1.4 Bad except clauses order\n\nWhen an exception occurs, Python will search for the ﬁrst exception clause which matches the exception type that occurred. It doesn’t need to be an exact match. If the exception clause represents a base class of the raised exception, then Python considers that exception clause to be a match. E.g. if a ZeroDivisionError exception is raised and the ﬁrst exception clause is Exception, then the Exception clause will execute because ZeroDivisionError is a sub class of Exception. Therefore, more speciﬁc exception clauses of sub classes should always be placed before the exception clauses of their base classes to ensure that exception handling is as speciﬁc and as helpful as possible.\n\n1.4.1 Anti-pattern\n\nThe code below performs a division operation that results in a ZeroDivisionError. The code contains an except clause for this type of error, which would be really useful because it pinpoints the exact cause of the problem. However, the ZeroDivisionError exception clause is unreachable because there is a Exception exception clause placed before it. When Python experiences an exception, it will linearly test each exception clause and execute the ﬁrst clause that matches the raised exception. The match does not need to be identical. So long as the raised exception is a sub class of the exception listed in the exception clause, then Python will execute that clause and will skip all other clauses. This defeats the purpose of exception clauses, which is to identify and handle exceptions with as much precision as possible.\n\ntry:\n\n5 / 0\n\nexcept Exception as e: print(\"Exception\")\n\n# unreachable code! except ZeroDivisionError as e: print(\"ZeroDivisionError\")\n\n6\n\n1. Correctness\n\nPython Anti-Patterns\n\n1.4.2 Best practice\n\nMove sub class exception clause before its ancestor’s clause\n\nThe modiﬁed code below places the ZeroDivisionError exception clause in front of the Exception exception clause. Now when the exception is triggered the ZeroDivisionError exception clause will execute, which is much more optimal because it is more speciﬁc.\n\ntry:\n\n5 / 0\n\nexcept ZeroDivisionError as e: print(\"ZeroDivisionError\")\n\nexcept Exception as e: print(\"Exception\")\n\n1.4.3 References\n\nPylint - E0701, bad-except-order\n\n1.5 Bad ﬁrst argument given to super()\n\nsuper() enables you to access the methods and members of a parent class without referring to the parent class by name. For a single inheritance situation the ﬁrst argument to super() should be the name of the current child class calling super(), and the second argument should be self (that is, a reference to the current object calling super()).\n\nNote: This anti-pattern only applies to Python versions 2.x, see “Super in Python 3” at the bottom of the page for the correct way of calling super() in Python 3.x.\n\n1.5.1 Anti-pattern\n\nPython raises a TypeError when it attempts to execute the call to super() below. The ﬁrst argument should be the name of the child class that is calling super(). The author of the code mistakenly provided self as the ﬁrst argument.\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\nclass Square(Rectangle):\n\ndef __init__(self, length):\n\n# bad first argument to super() super(self, Square).__init__(length, length)\n\ns = Square(5) print(s.area) # does not execute\n\n1. Correctness\n\n7\n\nPython Anti-Patterns\n\n1.5.2 Best practice\n\nInsert name of child class as ﬁrst argument to super()\n\nIn the modiﬁed code below the author has ﬁxed the call to super() so that the name of the child class which is calling super() (Square in this case) is the ﬁrst argument to the method.\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\nclass Square(Rectangle):\n\ndef __init__(self, length):\n\n# super() executes fine now super(Square, self).__init__(length, length)\n\ns = Square(5) print(s.area) # 25\n\n1.5.3 Super in Python 3\n\nPython 3 adds a new simpler super(), which requires no arguments. The correct way to call super() in Python 3 code is as follows.\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\nclass Square(Rectangle):\n\ndef __init__(self, length):\n\n# This is equivalent to super(Square, self).__init__(length, length) super().__init__(length, length)\n\ns = Square(5) print(s.area) # 25\n\n1.5.4 References\n\nPython Standard Library - super([type[, object-or-type]])\n\nStack Overﬂow - What is a basic example of single inheritance using super()?\n\nStack Overﬂow - Python super() inheritance and arguments needed\n\nPyLint - E1003, bad-super-call\n\nPEP 3135 - New Super\n\n8\n\n1. Correctness\n\nPython Anti-Patterns\n\n1.6 else clause on loop without a break statement\n\nThe else clause of a loop is executed when the loop sequence is empty. When a loop speciﬁes no break statement, the else clause will always execute, because the loop sequence will eventually always become empty. Sometimes this is the intended behavior, in which case you can ignore this error. But most times this is not the intended behavior, and you should therefore review the code in question.\n\n1.6.1 Anti-pattern\n\nThe code below demonstrates some potential unintended behavior that can result when a loop contains an else statement yet never speciﬁes a break statement. contains_magic_number() iterates through a list of numbers and compares each number to the magic number. If the magic number is found then the function prints The list contains the magic number. If it doesn’t then the function prints This list does NOT contain the magic number. When the code calls the function with a list of range(10) and a magic number of 5, you would expect the code to only print The list contains the magic number. However, the code also prints This list does NOT contain the magic number. This is because the range(10) list eventually becomes empty, which prompts Python to execute the else clause.\n\ndef contains_magic_number(numbers, magic_number):\n\nfor i in numbers:\n\nif i == magic_number:\n\nprint(\"This list contains the magic number\")\n\nelse:\n\nprint(\"This list does NOT contain the magic number\")\n\ncontains_magic_number(range(10), 5) # This list contains the magic number. # This list does NOT contain the magic number.\n\n1.6.2 Best practices\n\nInsert a break statement into the loop\n\nIf the else clause should not always execute at the end of a loop clause, then the code should add a break statement within the loop block.\n\ndef contains_magic_number(numbers, magic_number):\n\nfor i in numbers:\n\nif i == magic_number:\n\nprint(\"This list contains the magic number.\") # added break statement here break\n\nelse:\n\nprint(\"This list does NOT contain the magic number.\")\n\ncontains_magic_number(range(10), 5) # This list contains the magic number.\n\n1. Correctness\n\n9\n\nPython Anti-Patterns\n\n1.6.3 References\n\nPyLint - W0120, useless-else-on-loop\n\nPython Standard Library - else Clauses on Loops\n\n1.7 __exit__ must accept 3 arguments: type, value, traceback\n\nA contextmanager class is any class that implements the __enter__ and __exit__ methods according to the Python Language Reference’s context management protocol. Implementing the context management protocol enables you to use the with statement with instances of the class. The with statement is used to ensure that setup and teardown operations are always executed before and after a given block of code. It is functionally equivalent to try...finally blocks, except that with statements are more concise.\n\nFor example, the following block of code using a with statement...\n\nwith EXPRESSION:\n\nBLOCK\n\n... is equivalent to the following block of code using try and finally statements.\n\nEXPRESSION.__enter__() try:\n\nBLOCK\n\nfinally:\n\nEXPRESSION.__exit__(exception_type, exception_value, traceback)\n\nIn order for __exit__ to work properly it must have exactly three arguments: exception_type, exception_value, and traceback. The formal argument names in the method deﬁnition do not need to correspond directly to these names, but they must appear in this order. If any exceptions occur while at- tempting to execute the block of code nested after the with statement, Python will pass information about the exception into the __exit__ method. You can then modify the deﬁnition of __exit__ to gracefully handle each type of exception.\n\n1.7.1 Anti-pattern\n\nThe __exit__ method deﬁned in the Rectangle class below does not conform to Python’s context management protocol. The method is supposed to take four arguments: self, exception type, ex- ception value, and traceback. Because the method signature does not match what Python expects, __exit__ is never called even though it should have been, because the method divide_by_zero cre- ates a ZeroDivisionError exception.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height\n\ndef __enter__(self):\n\nprint(\"in __enter__\") return self def __exit__(self):\n\n# never called because # argument signature is wrong print(\"in __exit__\")\n\ndef divide_by_zero(self):\n\n# causes ZeroDivisionError exception\n\n(continues on next page)\n\n10\n\n1. Correctness\n\nPython Anti-Patterns\n\n(continued from previous page)\n\nreturn self.width / 0\n\nwith Rectangle(3, 4) as r: r.divide_by_zero() # __exit__ should be called but isn't\n\n# Output: # \"in __enter__\" # Traceback (most recent call last): # # # TypeError: __exit__() takes exactly 1 argument (4 given)\n\nFile \"e0235.py\", line 27, in <module>\n\nr.divide_by_zero()\n\n1.7.2 Best practices\n\nModifying __exit__ to accept four arguments ensures that __exit__ is properly called when an excep- tion is raised in the indented block of code following the with statement. Note that the argument names do not have to exactly match the names provided below. But they must occur in the order provided below.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height\n\ndef __enter__(self):\n\nprint(\"in __enter__\") return self\n\ndef __exit__(self, exception_type, exception_value, traceback):\n\nprint(\"in __exit__\")\n\ndef divide_by_zero(self):\n\n# causes ZeroDivisionError exception return self.width / 0\n\nwith Rectangle(3, 4) as r:\n\n# exception successfully pass to __exit__ r.divide_by_zero()\n\n# Output: # \"in __enter__\" # \"in __exit__\" # Traceback (most recent call last): # #\n\nFile \"e0235.py\", line 27, in <module>\n\nr.divide_by_zero()\n\n1.7.3 References\n\nPyLint - E0235,unexpected-special-method-signature\n\nPython Language Reference - The with statement\n\nPython Language Reference - With Statement Context Managers\n\nStack Overﬂow - Python with...as\n\n1. Correctness\n\n11\n\nPython Anti-Patterns\n\n1.8 Explicit return in __init__\n\n__init__ is a special Python method that is automatically called when memory is allocated for a new object. The sole purpose of __init__ is to initialize the values of instance members for the new object. Using __init__ to return a value implies that a program is using __init__ to do something other than initialize the object. This logic should be moved to another instance method and called by the program later, after initialization.\n\n1.8.1 Anti-pattern\n\nThe __init__ method of the Rectangle class below attempts to return the area of the rectangle within the __init__ method. This violates the rule of only using __init__ to initialize instance members.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height # causes \"Explicit return in __init__\" error return self.area\n\n1.8.2 Best practices\n\nRemove the return statement from the __init__ method\n\nRemove the return statement in the __init__ method that is returning a value.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height # return statement removed from here\n\nMove the program logic to another instance method\n\nThere is no reason why the Rectangle class MUST return the area immediately upon initialization. This program logic should be moved to a separate method of the Rectangle class. The program can call the method later, after the object has successfully initialized.\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self._area = width * height\n\n@property # moved the logic for returning area to a separate method def area(self):\n\nreturn self._area\n\nNote that the class must inherit from object now, since the property decorator only works for new style classes.\n\n12\n\n1. Correctness\n\nPython Anti-Patterns\n\n1.8.3 References\n\nPyLint - E0101, return-in-init\n\nPython Language Reference - object.__init__(self[, ...])\n\n1.9 __future__ import is not the ﬁrst non-docstring statement\n\nThe __future__ module enables a module to use functionality that is mandatory in future Python ver- sions. If it was possible to place the __future__ module in the middle of a module, then that would mean that one half of the module could use the old Python functionality for a given feature, and the other half (after the __future__ import) could use the new Python functionality of the feature. This could create many strange and hard-to-ﬁnd bugs, so Python does not allow it.\n\n1.9.1 Anti-pattern\n\nThe code below attempts to place a __future__ import statement in the middle of the module. When Python encounters the from __future__ import division statement it raises a SyntaxError and halts execution. However, if the code were to execute, the ﬁrst print statement would print out 1 (which is how the division operator behaves in Python versions 2 and below), but the second print statement would print out a decimal value, which is how the division operator functions in Python versions 3 and later. As you can see, this could create very strange behavior, so Python does not allow __future__ import statements in the middle of a module. The module can use either version of the division operator, but it can’t use both.\n\nprint(8 / 7) # 1\n\n# SyntaxError from __future__ import division\n\n# 1.1428571428571428 print(8 / 7)\n\n1.9.2 Best practice\n\nRemove __future__ import\n\nIn the modiﬁed code below, the author decides that the module needs to use the old functionality of the division operator. The only solution in this case is to remove the __future__ import statement from the module.\n\n# removed __future__ import statement print(8 / 7) # 1\n\nPlace __future__ import before all other statements\n\nIn the modiﬁed code below, the author decides that the module needs the new functionality of the division operator. The only solution then is to place the __future__ import statement at the beginning of the module\n\n1. Correctness\n\n13",
      "page_number": 9,
      "chapter_number": 2,
      "summary": "If the exception clause represents a base class of the raised exception, then Python considers that exception clause to be a match Key topics include python, classes, and exception. Covers exception.",
      "keywords": [
        "Python",
        "exception",
        "Python Language Reference",
        "exception clause",
        "Python Anti-Patterns",
        "References Python Documentation",
        "class Rectangle",
        "Rectangle",
        "ZeroDivisionError exception clause",
        "magic number",
        "super",
        "clause",
        "init",
        "ZeroDivisionError exception",
        "statement"
      ],
      "concepts": [
        "python",
        "classes",
        "exception",
        "exceptions",
        "super",
        "methods",
        "prints",
        "argument",
        "arguments",
        "statement"
      ],
      "similar_chapters": [
        {
          "book": "Python Distilled",
          "chapter": 10,
          "title": "Segment 10 (pages 79-89)",
          "relevance_score": 0.67,
          "method": "sentence_transformers"
        },
        {
          "book": "Python Distilled",
          "chapter": 11,
          "title": "Segment 11 (pages 90-99)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "More Effective C++",
          "chapter": 9,
          "title": "Segment 9 (pages 76-97)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 36,
          "title": "Segment 36 (pages 718-737)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Effective-Python",
          "chapter": 41,
          "title": "Segment 41 (pages 429-441)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 17-26)",
      "start_page": 17,
      "end_page": 26,
      "detection_method": "topic_boundary",
      "content": "Python Anti-Patterns\n\nfrom __future__ import division\n\n# 1.1428571428571428 print(8 / 7)\n\n1.9.3 References\n\nPyLint - W0410, misplaced-future\n\nSimeon Visser - How does ‘from __future__ import ...’ work?\n\nPython Standard Library - __future__\n\n1.10 Implementing Java-style getters and setters\n\nPython is not Java. If you need to set or get the members of a class or object, just expose the member publicly and access it directly. If you need to perform some computations before getting or setting the member, then use Python’s built-in property decorator.\n\n1.10.1 Anti-pattern\n\nThe programmer below comes to Python from a long career as a Java programmer. For every class member that he wants to expose publicly, he deﬁnes a get and set method for that member. This is common practice in Java, but is frowned upon in Python as a waste of time and a cause of unnecessary code.\n\nclass Square(object):\n\ndef __init__(self, length):\n\nself._length = length\n\n# Java-style def get_length(self):\n\nreturn self._length\n\n# Java-style def set_length(self, length): self._length = length\n\nr = Square(5) r.get_length() r.set_length(6)\n\n1.10.2 Best practice\n\nAccess the members directly\n\nIn Python it is acceptable to simply access class or object members directly. The modiﬁed code below exposes the length member as a public member. This is signiﬁed by the fact that there is no underscore character at the beginning of the member name. The get_length() and set_length() methods are no longer necessary so they have been deleted.\n\nclass Square(object):\n\ndef __init__(self, length): self.length = length\n\n(continues on next page)\n\n14\n\n1. Correctness\n\nPython Anti-Patterns\n\n(continued from previous page)\n\nr = Square(5) r.length r.length = 6\n\nUse built-in property decorator\n\nWhen a member needs to be slightly protected and cannot be simply exposed as a public member, use Python’s property decorator to accomplish the functionality of getters and setters.\n\nclass Square(object):\n\ndef __init__(self, length):\n\nself._length = length\n\n@property def length(self):\n\nreturn self._length\n\n@length.setter def length(self, value): self._length = value\n\n@length.deleter def length(self):\n\ndel self._length\n\nr = Square(5) r.length # automatically calls getter r.length = 6 # automatically calls setter\n\n1.10.3 References\n\nPython Built-in Functions - property\n\ndirtSimple - Python Is Not Java\n\nStack Overﬂow - What’s the Pythonic Way to use getters and setters?\n\n1.11 Indentation contains mixed spaces and tabs\n\nPer the PEP 8 Style Guide, all Python code should be consistently indented with 4 spaces, never tabs.\n\n1.11.1 Anti-pattern\n\nThe following code mixes spaces and tabs for indentation. The print(\"Hello, World!\") statement is indented with a tab. The print(\"Goodybye, World!\") statement is indented with 4 spaces.\n\ndef print_hello_world(): # indented with tab\n\nprint(\"Hello, World!\") def print_goodbye_world():\n\n# indented with 4 spaces print(\"Goodbye, World!\")\n\n1. Correctness\n\n15\n\nPython Anti-Patterns\n\n1.11.2 Solutions\n\nConsistently indent with spaces\n\nAll Python code should be consistently indented with 4 spaces.\n\ndef print_hello_world():\n\nprint(\"Hello, World!\") # indented with 4 spaces\n\ndef print_goodbye_world():\n\nprint(\"Goodbye, World!\")\n\n# indented with 4 spaces\n\n1.11.3 References\n\nPEP 8 Style Guide - Tabs or Spaces?\n\nPEP 8 Style Guide - Indentation\n\n1.12 Indentation contains tabs\n\nPer the PEP 8 Style Guide, all Python code should be consistently indented with 4 spaces for each level of indentation, not tabs.\n\n1.12.1 Anti-pattern\n\nThe following code uses tabs for indentation. Python code should be indented with four spaces for each level of indentation.\n\ndef print_hello_world():\n\n# indented with tab print(\"Hello, World!\") def print_goodbye_world(): # indented with tab print(\"Goodbye, World!\")\n\n1.12.2 Best practice\n\nConsistently indent with spaces\n\nAll Python code should be consistently indented with 4 spaces.\n\ndef print_hello_world():\n\n# indented with 4 spaces print(\"Hello, World!\") def print_goodbye_world():\n\n# indented with 4 spaces print(\"Goodbye, World!\")\n\n16\n\n1. Correctness\n\nPython Anti-Patterns\n\n1.12.3 References\n\nPEP 8 Style Guide - Tabs or Spaces?\n\nPEP 8 Style Guide - Indentation\n\n1.13 Method could be a function\n\nWhen a method is not preceded by the @staticmethod or @classmethod decorators and does not con- tain any references to the class or instance (via keywords like cls or self), Python raises the Method could be a function error. This is not a critical error, but you should check the code in question in order to determine if this section of code really needs to be deﬁned as a method of this class.\n\n1.13.1 Anti-pattern\n\nIn the Rectangle class below the area method calculates the area of any rectangle given a width and a height.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\n# should be preceded by @staticmethod here def area(width, height):\n\nreturn width * height\n\narea causes the Method could be a function error because it is ambiguous. It does not reference the instance or class using the self or cls keywords and it is not preceded by the @staticmethod decorator.\n\nClass method is not preceded by @classmethod decorator\n\nIn the Rectangle class below the print_class_name method prints the name of the class. Again, Python raises the Method could be a function error because the method does not reference any class members or methods and is not preceded by the @classmethod decorator.\n\nFurthermore, the ﬁrst argument of a class method must be a reference to the class itself.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\n# should be preceded by @classmethod here # missing required first argument \"cls\" def print_class_name():\n\nprint(\"class name: Rectangle\")\n\n1. Correctness\n\n17\n\nPython Anti-Patterns\n\n1.13.2 Best practices\n\nAdd the @staticmethod decorator before the static method\n\nAll static methods must be preceded by the @staticmethod decorator.\n\nclass Rectangle:\n\n# clarifies that this is a static method and belongs here @staticmethod def area(width, height):\n\nreturn width * height\n\nAdd the @classmethod decorator before the class method\n\nAll class methods must be preceded by the @classmethod decorator. Furthermore, the ﬁrst argument of any class method must be cls, which is a reference to the class itself.\n\nclass Rectangle: @classmethod def print_class_name(cls):\n\n# \"class name: Rectangle\" print(\"class name: {0}\".format(cls))\n\n1.13.3 References\n\nPyLint - R0201, no-self-use\n\n1.14 Method has no argument\n\nUnlike some programming languages, Python does not pass references to instance or class objects auto- matically behind the scenes. So the program must explicitly pass them as arguments whenever it wants to access any members of the instance or class within a method.\n\n1.14.1 Anti-pattern\n\nIn the Rectangle class below the area method attempts to return the value of the area instance variable. However, self.area is undeﬁned because a reference to the instance object has not been explicitly passed as an argument to the method.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\n# missing first argument \"self\" def area():\n\n# self is undefined here return self.area\n\n18\n\n1. Correctness\n\nPython Anti-Patterns\n\nClass method is missing the cls keyword\n\nThe method print_class_name attempts to print the name of the class. However, to programmatically access a class name, a method needs to have a reference to the class object. This is accomplished by passing the keyword cls as the ﬁrst argument to the method. Because print_class_name does not do this, its reference to cls in the body of the method is undeﬁned.\n\nclass Rectangle: @classmethod # missing first argument \"cls\" def print_class_name():\n\n# cls is undefined here print(\"Hello, I am {0}!\".format(cls))\n\nThe method area computes the value of any rectangle. Currently this method is ambiguous. It is deﬁned as a method of the Rectangle class, yet it does not reference any instance or class members. The method needs to explicitly state that it is a static method via the @staticmethod decorator.\n\nclass Rectangle:\n\n# \"@staticmethod\" should be here def area(width, height):\n\nreturn width * height\n\n1.14.2 Best practices\n\nAdd the self parameter to instance methods\n\nTo access the area member of a Rectangle instance the ﬁrst argument of the area method needs to be a reference to the instance object, signiﬁed by the keyword self.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\n# instance members now accessible because of \"self\" def area(self):\n\nreturn self.area\n\nAdd the cls parameter to class methods\n\nTo access the name of the class the print_class_name method needs to explicitly pass an argument to the class object. This is done by adding the keyword cls as the ﬁrst argument of the method.\n\nclass Rectangle: @classmethod # class members now accessible, thanks to \"cls\" def print_class_name(cls):\n\nprint(\"Hello, I am {0}!\".format(cls))\n\nAdd the @staticmethod decorator to static methods\n\nIf the method is a static method that does not need access to any instance members, then the method should be preceded by the @staticmethod decorator. This improves readability by helping clarify that\n\n1. Correctness\n\n19\n\nPython Anti-Patterns\n\nthe method should never rely on any instance members.\n\nclass Rectangle:\n\n# clarifies that the method does not need any instance members @staticmethod def area(width, height):\n\nreturn width * height\n\n1.14.3 References\n\nPyLint - E0211, no-method-argument\n\n1.15 Missing argument to super()\n\nsuper() enables you to access the methods and members of a parent class without referring to the parent class by name. For a single inheritance situation the ﬁrst argument to super() should be the name of the current child class calling super(), and the second argument should be self, that is, a reference to the current object calling super().\n\nNote: This error is only raised for Python versions 2.x which don’t support new-style classes.\n\n1.15.1 Anti-pattern\n\nThe author of the code below provides no arguments for the child class’ call to super(). Python raises a TypeError at runtime because it expects at least 1 argument for super().\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\nclass Square(Rectangle):\n\ndef __init__(self, length):\n\n# no arguments provided to super() super().__init__(length, length)\n\ns = Square(5) print(s.area) # does not execute\n\n1.15.2 Best practice\n\nInsert name of child class as ﬁrst argument to super()\n\nIn the modiﬁed code below the author has ﬁxed the call to super() so that the name of the child class which is calling super() (Square in this case) is the ﬁrst argument to the method, and a reference to the object calling super() is the second argument.\n\n20\n\n1. Correctness\n\nPython Anti-Patterns\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\nclass Square(Rectangle):\n\ndef __init__(self, length):\n\n# super() executes fine now super(Square, self).__init__(length, length)\n\ns = Square(5) print(s.area) # 25\n\n1.15.3 References\n\nPyLint - E1004, missing-super-argument\n\nPython Standard Library - super([type[, object-or-type]])\n\nStack Overﬂow - What is a basic example of single inheritance using super()?\n\nStack Overﬂow - Python super() inheritance and arguments needed\n\n1.16 Using a mutable default value as an argument\n\nPassing mutable lists or dictionaries as default arguments to a function can have unforeseen consequences. Usually when a programmer uses a list or dictionary as the default argument to a function, the programmer wants the program to create a new list or dictionary every time that the function is called. However, this is not what Python does. The ﬁrst time that the function is called, Python creates a persistent object for the list or dictionary. Every subsequent time the function is called, Python uses that same persistent object that was created from the ﬁrst call to the function.\n\n1.16.1 Anti-pattern\n\nA programmer wrote the append function below under the assumption that the append function would return a new list every time that the function is called without the second argument. In reality this is not what happens. The ﬁrst time that the function is called, Python creates a persistent list. Every subsequent call to append appends the value to that original list.\n\ndef append(number, number_list=[]): number_list.append(number) print(number_list) return number_list\n\nappend(5) # expecting: [5], actual: [5] append(7) # expecting: [7], actual: [5, 7] append(2) # expecting: [2], actual: [5, 7, 2]\n\n1. Correctness\n\n21\n\nPython Anti-Patterns\n\n1.16.2 Best practice\n\nUse a sentinel value to denote an empty list or dictionary\n\nIf, like the programmer who implemented the append function above, you want the function to return a new, empty list every time that the function is called, then you can use a sentinel value to represent this use case, and then modify the body of the function to support this scenario. When the function receives the sentinel value, it knows that it is supposed to return a new list.\n\n# the keyword None is the sentinel value representing empty list def append(number, number_list=None):\n\nif number_list is None: number_list = []\n\nnumber_list.append(number) print(number_list) return number_list\n\nappend(5) # expecting: [5], actual: [5] append(7) # expecting: [7], actual: [7] append(2) # expecting: [2], actual: [2]\n\n1.16.3 References\n\nPyLint - W0102, dangerous-default-value\n\nStack Overﬂow - Hidden Features of Python\n\n1.17 No exception type(s) speciﬁed\n\nThe function divide simply divides a by b. To avoid invalid calculations (e.g., a division by zero), a try-except block is added. This is valid and ensures that the function always returns a result. However, by securing your code with the try clause, you might hide actual programming errors, e.g., that you pass a string or an object as b, instead of a number. By not specifying an exception type, you not only hide this error but you also lose information about the error itself.\n\n1.17.1 Anti-pattern\n\ndef divide(a, b):\n\ntry:\n\nresult = a / b\n\nexcept:\n\nresult = None\n\nreturn result\n\n22\n\n1. Correctness\n\nPython Anti-Patterns\n\n1.17.2 Best practice\n\nHandle exceptions with Python’s built in exception types.\n\ndef divide(a, b):\n\nresult = None\n\ntry:\n\nresult = a / b\n\nexcept ZeroDivisionError:\n\nprint(\"Type error: division by 0.\")\n\nexcept TypeError:\n\n# E.g., if b is a string print(\"Type error: division by '{0}'.\".format(b))\n\nexcept Exception as e:\n\n# handle any other exception print(\"Error '{0}' occured. Arguments {1}.\".format(e.message, e.args))\n\nelse:\n\n# Excecutes if no exception occured print(\"No errors\")\n\nfinally:\n\n# Executes always if result is None: result = 0\n\nreturn result\n\nWith this pattern, you are able to handle exceptions based on their actual exception-type. The ﬁrst exception type that matches the current error is handled ﬁrst. Thus, it is recommended to handle speciﬁc exception types ﬁrst (e.g., ZeroDivisionError) and generic error types (e.g., Exception) towards the end of the try- except block.\n\nCleanup actions (optional): The else-clause executes only, if no exception occurred. It is useful to log the success of your code. The ﬁnally-block executes under all circumstances — no matter if an error occured or not. It is useful to clean up the try-except block.\n\n1.17.3 Implement user deﬁned exceptions\n\nIn addition to Python’s standard exceptions, you can implement your own exception classes.\n\nclass DivisorTooSmallError(StandardError):\n\ndef __init__(self, arg): self.args = arg\n\ndef divide(a, b): if b < 1:\n\nraise DivisorTooSmallError\n\nreturn a / b\n\ntry:\n\ndivide(10, 0)\n\nexcept DivisorTooSmallError:\n\nprint(\"Unable to divide these numbers!\")\n\n1. Correctness\n\n23",
      "page_number": 17,
      "chapter_number": 3,
      "summary": "This chapter covers segment 3 (pages 17-26). Key topics include prints, classes, and python. Covers method. Python Standard Library - __future__\n\n1.10 Implementing Java-style getters and setters\n\nPython is not Java.",
      "keywords": [
        "misplaced-future Simeon Visser",
        "class Rectangle",
        "Python",
        "Python Anti-Patterns",
        "Simeon Visser",
        "method",
        "Rectangle",
        "Python Anti-Patterns Class",
        "length",
        "class Square",
        "World",
        "def print",
        "width",
        "Class method",
        "Square"
      ],
      "concepts": [
        "prints",
        "classes",
        "python",
        "pythonic",
        "argument",
        "arguments",
        "super",
        "method",
        "length",
        "uses"
      ],
      "similar_chapters": [
        {
          "book": "Python Distilled",
          "chapter": 2,
          "title": "Segment 2 (pages 9-18)",
          "relevance_score": 0.68,
          "method": "sentence_transformers"
        },
        {
          "book": "Effective-Python",
          "chapter": 2,
          "title": "Segment 2 (pages 10-18)",
          "relevance_score": 0.67,
          "method": "sentence_transformers"
        },
        {
          "book": "Effective-Python",
          "chapter": 24,
          "title": "Segment 24 (pages 241-248)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 46,
          "title": "Segment 46 (pages 930-951)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        },
        {
          "book": "Python Distilled",
          "chapter": 12,
          "title": "Segment 12 (pages 100-107)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 27-34)",
      "start_page": 27,
      "end_page": 34,
      "detection_method": "topic_boundary",
      "content": "Python Anti-Patterns\n\n1.17.4 References\n\nPyLint W0702, bare-except\n\nPython Built-in Exceptions<https://docs.python.org/2/library/exceptions.html#exceptions.BaseException>\n\nPython Errors and Exceptions<https://docs.python.org/2/tutorial/errors.html>\n\n1.18 Not using defaultdict()\n\nWhen a dict is created using defaultdict(), the value for each key in the dict will default to the value provided as the ﬁrst argument of defaultdict(). This is more concise and less error-prone than manu- ally setting the value of each key.\n\n1.18.1 Anti-pattern\n\nThe code below deﬁnes an empty dict and then manually initializes the keys of the dict. Although there is nothing wrong with this code, there is a more concise and less error-prone way to achieve the same idea, as explained in the solution below.\n\nd = {}\n\nif \"k\" not in d:\n\nd[\"k\"] = 6\n\nd[\"k\"] += 1\n\nprint(d[\"k\"]) # 7\n\n1.18.2 Best practice\n\nUse defaultdict() to initialize dict keys\n\nThe modiﬁed code below uses defaultdict to initialize the dict. Whenever a new key is created, the default value for that key is 6. This code is functionally equivalent to the previous code, but this one is more concise and less error-prone, because every key automatically initializes to 6 with no work on the part of the programmer.\n\nfrom collections import defaultdict\n\nd = defaultdict(lambda : 6) d[\"k\"] += 1\n\nprint(d[\"k\"]) # 7\n\n24\n\n1. Correctness\n\nPython Anti-Patterns\n\n1.18.3 References\n\nPython Standard Library - collections.defaultdict\n\n1.19 Not using else where appropriate in a loop\n\nThe Python language provides a built-in else clause for for loops. If a for loop completes without being prematurely interrupted by a break or return statement, then the else clause of the loop is executed.\n\n1.19.1 Anti-pattern\n\nThe code below searches a list for a magic number. If the magic number is found in the list, then the code prints Magic number found. If the magic number is not found, then the code prints Magic number not found.\n\nThe code uses a ﬂag variable called found to keep track of whether or not the magic number was found in the list.\n\nThe logic in this code is valid; it will accomplish its task. But the Python language has built-in language constructs for handling this exact scenario and which can express the same idea much more concisely and without the need for ﬂag variables that track the state of the code.\n\nl = [1, 2, 3] magic_number = 4 found = False\n\nfor n in l:\n\nif n == magic_number: found = True print(\"Magic number found\") break\n\nif not found:\n\nprint(\"Magic number not found\")\n\n1.19.2 Best practice\n\nUse else clause with for loop\n\nIn Python, you can declare an else loop in conjunction with a for loop. If the for loop iterates to com- pletion without being prematurely interrupted by a break or return statement, then Python executes the else clause of the loop.\n\nIn the modiﬁed code below, the for loop will iterate through all three items in the list. Because the magic number is not contained in the list, the if statement always evaluates to False, and therefore the break statement is never encountered. Because Python never encounters a break statement while iterating over the loop, it executes the else clause.\n\nThe modiﬁed code below is functionally equivalent to the original code above, but this modiﬁed code is more concise than the original code and does not require any ﬂag variables for monitoring the state of the code.\n\n1. Correctness\n\n25\n\nPython Anti-Patterns\n\nl = [1, 2, 3] magic_number = 4\n\nfor n in l:\n\nif n == magic_number:\n\nprint(\"Magic number found\") break\n\nelse:\n\nprint(\"Magic number not found\")\n\nNote: Since else on a for loop is so unintuitive and error-prone, even some experienced Python devel- opers suggest not using this feature at all.\n\n1.19.3 References\n\nPython Language Reference - else Clauses on Loops\n\n1.20 Not using explicit unpacking\n\nWhen you see multiple variables being deﬁned followed by an assignment to a list (e.g. elem0, elem1, elem2 = elems, where elem0, elem1, and elem2 are variables and elems is a list), Python will auto- matically iterate through the list and assign elems[0] to elem0, elems[1] to elem1, and so on.\n\n1.20.1 Anti-pattern\n\nThe code below manually creates multiple variables to access the items in a list. This code is error-prone and unnecessarily verbose, as well as tedious to write.\n\nelems = [4, 7, 18]\n\nelem0 = elems[0] elem1 = elems[1] elem2 = elems[2]\n\n1.20.2 Best practice\n\nUse unpacking\n\nThe modiﬁed code below is functionally equivalent to the original code, but this code is more concise and less prone to error.\n\nelems = [4, 7, 18]\n\nelem0, elem1, elem2 = elems\n\n26\n\n1. Correctness\n\nPython Anti-Patterns\n\n1.21 Not using get() to return a default value from a dict\n\nFrequently you will see code create a variable, assign a default value to the variable, and then check a dict for a certain key. If the key exists, then the value of the key is copied into the value for the variable. While there is nothing wrong this, it is more concise to use the built-in method dict.get(key[, default]) from the Python Standard Library. If the key exists in the dict, then the value for that key is returned. If it does not exist, then the default value speciﬁed as the second argument to get() is returned. Note that the default value defaults to None if a second argument is not provided.\n\n1.21.1 Anti-pattern\n\nThe code below initializes a variable called data to an empty string. Then it checks if a certain key called message exists in a dict called dictionary. If the key exists, then the value of that key is copied into the data variable.\n\nAlthough there is nothing wrong with this code, it is verbose and inefﬁcient because it queries the dictionary twice. The solution below demonstrates how to express the same idea in a more concise manner by using dict.get(key[, default]).\n\ndictionary = {\"message\": \"Hello, World!\"}\n\ndata = \"\"\n\nif \"message\" in dictionary:\n\ndata = dictionary[\"message\"]\n\nprint(data)\n\n# Hello, World!\n\n1.21.2 Best practice\n\nUse dict.get(key[, default]) to assign default values\n\nThe code below is functionally equivalent to the original code above, but this solution is more concise.\n\nWhen get() is called, Python checks if the speciﬁed key exists in the dict. If it does, then get() returns the value of that key. If the key does not exist, then get() returns the value speciﬁed in the second argument to get().\n\ndictionary = {\"message\": \"Hello, World!\"}\n\ndata = dictionary.get(\"message\", \"\")\n\nprint(data)\n\n# Hello, World!\n\n1. Correctness\n\n27\n\nPython Anti-Patterns\n\n1.21.3 References\n\nPython Standard Library - dict.get\n\n1.22 Not using setdefault() to initialize a dictionary\n\nWhen initializing a dictionary, it is common to see a code check for the existence of a key and then create the key if it does not exist. Although there is nothing wrong with this, the exact same idea can be accomplished more concisely by using the built-in dictionary method setdefault().\n\n1.22.1 Anti-pattern\n\nThe code below checks if a key named list exists in a dictionary called dictionary. If it does not exist, then the code creates the key and then sets its value to an empty list. The code then proceeds to append a value to the list.\n\nAlthough there is nothing wrong with this code, it is unnecessarily verbose. Later you will see how you can use setdefault() to accomplish the same idea more concisely.\n\ndictionary = {}\n\nif \"list\" not in dictionary:\n\ndictionary[\"list\"] = []\n\ndictionary[\"list\"].append(\"list_item\")\n\n1.22.2 Best practice\n\nUse setdefault() to initialize a dictionary\n\nThe modiﬁed code below uses setdefault() to initialize the dictionary. When setdefault() is called, it will check if the key already exists. If it does exist, then setdefault() does nothing. If the key does not exist, then setdefault() creates it and sets it to the value speciﬁed in the second argument.\n\ndictionary = {}\n\ndictionary.setdefault(\"list\", []).append(\"list_item\")\n\n1.22.3 References\n\nStack Overﬂow - Use cases for the setdefault dict method\n\n28\n\n1. Correctness\n\nPython Anti-Patterns\n\n2 Maintainability\n\nA program is maintainable if it is easy to understand and modify the code even for someone that is unfa- miliar with the code base.\n\nAvoid the following anti-patterns to increase maintainability and avoid creating spaghetti code.\n\n2.1 using wildcard imports (from ... import *)\n\nWhen an import statement in the pattern of from MODULE import * is used it may become difﬁcult for a Python validator to detect undeﬁned names in the program that imported the module. Furthermore, as a general best practice, import statements should be as speciﬁc as possible and should only import what they need.\n\n2.1.1 Anti-pattern\n\nThe following code imports everything from the math built-in Python module.\n\n# wildcard import = bad from math import *\n\n2.1.2 Best practices\n\nMake the import statement more speciﬁc\n\nThe import statement should be refactored to be more speciﬁc about what functions or variables it is using from the math module. The modiﬁed code below speciﬁes exactly which module member it is using, which happens to be ceil in this example.\n\nfrom math import ceil\n\nImport the whole module\n\nThere are some cases where making the import statement speciﬁc is not a good solution:\n\nIt may be unpractical or cumbersome to create or maintain the list of objects to be imported from a module\n\nA direct import would bind to the same name as that of another object (e.g. from asyncio import TimeoutError)\n\nThe module that the object is imported from would provide valuable contextual information if it is right next to the object when it’s used.\n\nIn these cases, use one of these idioms:\n\nimport math x = math.ceil(y)\n\n# or\n\nimport multiprocessing as mp pool = mp.Pool(8)\n\n2. Maintainability\n\n29\n\nPython Anti-Patterns\n\n2.1.3 References\n\nStack Overﬂow - Importing Modules\n\nStack Overﬂow - ‘import module’ or ‘from module import’\n\n2.2 Not using with to open ﬁles\n\nIn Python 2.5, the file class was equipped with special methods that are automatically called whenever a ﬁle is opened via a with statement (e.g. with open(\"file.txt\", \"r\") as file). These special methods ensure that the ﬁle is properly and safely opened and closed.\n\n2.2.1 Anti-pattern\n\nThe code below does not use with to open a ﬁle. This code depends on the programmer remembering to manually close the ﬁle via close() when ﬁnished. Even if the programmer remembers to call close() the code is still dangerous, because if an exception occurs before the call to close() then close() will not be called and the memory issues can occur, or the ﬁle can be corrupted.\n\nf = open(\"file.txt\", \"r\") content = f.read() 1 / 0 # never executes, possible memory issues or file corruption f.close()\n\n# ZeroDivisionError\n\n2.2.2 Best practice\n\nUse with to open a ﬁle\n\nThe modiﬁed code below is the safest way to open a ﬁle. The file class has some special built-in methods called __enter__() and __exit__() which are automatically called when the ﬁle is opened and closed, respectively. Python guarantees that these special methods are always called, even if an exception occurs.\n\nwith open(\"file.txt\", \"r\") as f:\n\ncontent = f.read() # Python still executes f.close() even though an exception occurs 1 / 0\n\n2.2.3 References\n\neffbot - Understanding Python’s with statement\n\n30\n\n2. Maintainability\n\nPython Anti-Patterns\n\n2.3 Returning more than one variable type from function call\n\nIf a function that is supposed to return a given type (e.g. list, tuple, dict) suddenly returns something else (e.g. None) the caller of that function will always need to check the type of the return value before proceeding. This makes for confusing and complex code. If the function is unable to produce the supposed return value it is better to raise an exception that can be caught by the caller instead.\n\n2.3.1 Anti-pattern\n\nIn the code below, the function get_secret_code() returns a secret code when the code calling the If the password is incorrect, the function returns None. This function provides the correct password. leads to hard-to-maintain code, because the caller will have to check the type of the return value before proceeding.\n\ndef get_secret_code(password):\n\nif password != \"bicycle\":\n\nreturn None\n\nelse:\n\nreturn \"42\"\n\nsecret_code = get_secret_code(\"unicycle\")\n\nif secret_code is None:\n\nprint(\"Wrong password.\")\n\nelse:\n\nprint(\"The secret code is {}\".format(secret_code))\n\n2.3.2 Best practice\n\nRaise an exception when an error is encountered or a precondition is unsatisﬁed\n\nWhen invalid data is provided to a function, a precondition to a function is not satisﬁed, or an error occurs during the execution of a function, the function should not return any data. Instead, the function should raise an exception. In the modiﬁed version of get_secret_code() shown below, ValueError is raised when an incorrect value is given for the password argument.\n\ndef get_secret_code(password):\n\nif password != \"bicycle\": raise ValueError\n\nelse:\n\nreturn \"42\"\n\ntry:\n\nsecret_code = get_secret_code(\"unicycle\") print(\"The secret code is {}\".format(secret_code))\n\nexcept ValueError:\n\nprint(\"Wrong password.\")\n\n2. Maintainability\n\n31",
      "page_number": 27,
      "chapter_number": 4,
      "summary": "Correctness Python Anti-Patterns\n\n1.18.3 References\n\nPython Standard Library - collections.defaultdict\n\n1.19 Not using else where appropriate in a loop\n\nThe Python language provides a built-in else clause for for loops Key topics include python, code, and imports.",
      "keywords": [
        "code",
        "Python Anti-Patterns",
        "Python",
        "magic number",
        "References Python Standard",
        "Python Standard Library",
        "key",
        "code prints Magic",
        "magic",
        "modiﬁed code",
        "References Python",
        "Magic number found",
        "list",
        "number",
        "dictionary"
      ],
      "concepts": [
        "python",
        "code",
        "imports",
        "prints",
        "returned",
        "calling",
        "key",
        "keys",
        "anti",
        "dictionary"
      ],
      "similar_chapters": [
        {
          "book": "Fluent Python 2nd",
          "chapter": 7,
          "title": "Segment 7 (pages 128-146)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 36,
          "title": "Segment 36 (pages 718-737)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        },
        {
          "book": "Python Distilled",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 5,
          "title": "Segment 5 (pages 84-106)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 10,
          "title": "Introducing Python Statements",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 35-42)",
      "start_page": 35,
      "end_page": 42,
      "detection_method": "topic_boundary",
      "content": "Python Anti-Patterns\n\n2.4 Using the global statement\n\nGlobal variables are dangerous because they can be simultaneously accessed from multiple sections of a program. This frequently results in bugs. Most bugs involving global variables arise from one function reading and acting on the value of a global variable before another function has the chance to set it to an appropriate value.\n\nGlobal variables also make code difﬁcult to read, because they force you to search through multiple func- tions or even modules just to understand all the different locations where the global variable is used and modiﬁed.\n\n2.4.1 Examples\n\nThe code below uses global variables and a function to compute the area and perimeter of a rectangle. As you can see, even with two functions it becomes difﬁcult to keep track of how the global variables are used and modiﬁed.\n\nWIDTH = 0 # global variable HEIGHT = 0 # global variable\n\ndef area(w, h):\n\nglobal WIDTH # global statement global HEIGHT # global statement WIDTH = w HEIGHT = h return WIDTH * HEIGHT\n\ndef perimeter(w, h):\n\nglobal WIDTH # global statement global HEIGHT # global statement WIDTH = w HEIGHT = h return ((WIDTH * 2) + (HEIGHT * 2))\n\nprint(\"WIDTH:\" , WIDTH) # \"WIDTH: 0\" print(\"HEIGHT:\" , HEIGHT) # \"HEIGHT: 0\"\n\nprint(\"area():\" , area(3, 4)) # \"area(): 12\"\n\nprint(\"WIDTH:\" , WIDTH) # \"WIDTH: 3\" print(\"HEIGHT:\" , HEIGHT) # \"HEIGHT: 4\"\n\n2.4.2 Solutions\n\nEncapsulate the global variables into objects\n\nOne common solution for avoiding global variables is to create a class and store related global variables as members of an instantiated object of that class. This results in more compact and safer code.\n\nIn the modiﬁed code below, the author eliminates the need for the global variables WIDTH and HEIGHT by encapsulating this data into a class called Rectangle.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width\n\n(continues on next page)\n\n32\n\n2. Maintainability\n\nPython Anti-Patterns\n\n(continued from previous page)\n\nself.height = height\n\ndef area(self):\n\nreturn self.width * self.height\n\ndef circumference(self):\n\nreturn ((self.width * 2) + (self.height * 2))\n\nr = Rectangle(3, 4) print(\"area():\" , r.area())\n\n2.4.3 References\n\nCunningham & Cunningham, Inc. - Global Variables Are Bad\n\nPyLint - W0603, global-statement\n\n2.5 Using single letter to name your variables\n\nSometimes you see programmers trying to shorten the amount of text needed to write a piece of code, but when this goes to extremes, it will result in extremely ugly and unreadable code.\n\n2.5.1 Anti-pattern\n\nd = {'data': [{'a': 'b'}, {'b': 'c'}, {'c': 'd'}], 'texts': ['a', 'b', 'c']}\n\nfor k, v in d.iteritems():\n\nif k == 'data': for i in v:\n\n# Do you know what are you iterating now? for k2, v2 in i.iteritems():\n\nprint(k2, v2)\n\n2.5.2 Best practice\n\nUse more verbose names for your variables for clarity\n\nIt is much better to write more text and to be much more precise about what each variable means.\n\ndata_dict = {\n\n'data': [{'a': 'b'}, {'b': 'c'}, {'c': 'd'}], 'texts': ['a', 'b', 'c']\n\n}\n\nfor key, value in data_dict.iteritems():\n\nif key == 'data':\n\nfor data_item in value:\n\n# Do you know what are you iterating now? for data_key, data_value in data_item.iteritems():\n\nprint(data_key, data_value)\n\n2. Maintainability\n\n33\n\nPython Anti-Patterns\n\n2.6 Dynamically creating variable/method/function names\n\nSometimes a programmer gets an idea to make his/her work easier by creating magically working code that uses setattr() and getattr() functions to set some variable. While this may look like a good idea, because there is no need to write all the methods by hand, you are asking for trouble down the road.\n\n2.6.1 Example\n\nConsider the following code. You have some data and want to update the class with all of the data. Of course you don’t want to do this by hand, especially if there are tons of items in data_dict. However, when refactoring this kind of code after several years, and you’d like to know where some variable is added to this class, you’d usually use grep or ack_grep to ﬁnd it. But when setting variables/methods/functions like this, you’re screwed.\n\ndata_dict = {'var1': 'Data1', 'var2': 'Data2'}\n\nclass MyAwesomeClass:\n\ndef __init__(self, data_dict):\n\nfor key, value in data_dict.iteritems():\n\nsetattr(self, key, value)\n\nWhile previous example may look easy to ﬁnd and debug, consider this:\n\ndata_list = ['dat1', 'dat2', 'dat3'] data_dict = {'dat1': [1, 2, 3], 'dat2': [4, 5, 6], 'dat3': [7, 8, 9], 'dat4': [0, 4, 6]}\n\nclass MyAwesomeClass:\n\ndef __init__(self, data_list, data_dict):\n\ncounter = 0\n\nfor key, value in data_dict.iteritems():\n\nif key in data_list:\n\nsetattr(self, key, value)\n\nelse:\n\nsetattr(self, 'unknown' + str(counter), value) counter += 1\n\nNow the class contains also unknownX variables indexed by their count. Well, what a nice mess we created here. Try to ﬁnd a year later where these variables come from.\n\n34\n\n2. Maintainability\n\nPython Anti-Patterns\n\n2.6.2 Solutions\n\nFind another way\n\nWhile the approach in the examples above may be the easiest to write, it is the worst to maintain later. You should always try to ﬁnd another way to solve your problem.\n\nTypical examples:\n\nUse function to parse incoming data\n\nUse the data dict/list itself without class\n\nThis however depends on the task at hand.\n\n2. Maintainability\n\n35\n\nPython Anti-Patterns\n\n3 Readability\n\n3.1 Asking for permission instead of forgiveness\n\nThe Python community uses an EAFP (easier to ask for forgiveness than permission) coding style. This coding style assumes that needed variables, ﬁles, etc. exist. Any problems are caught as exceptions. This results in a generally clean and concise style containing a lot of try and except statements.\n\n3.1.1 Anti-pattern\n\nThe code below uses an if statement to check if a ﬁle exists before attempting to use the ﬁle. This is not the preferred coding style in the Python community. The community prefers to assume that a ﬁle exists and you have access to it, and to catch any problems as exceptions.\n\nimport os\n\n# violates EAFP coding style if os.path.exists(\"file.txt\"): os.unlink(\"file.txt\")\n\n3.1.2 Best practice\n\nAssume the ﬁle can be used and catch problems as exceptions\n\nThe updated code below is a demonstration of the EAFP coding style, which is the preferred style in the Python community. Unlike the original code, the modiﬁed code below simply assumes that the needed ﬁle exists, and catches any problems as exceptions. For example, if the ﬁle does not exist, the problem will be caught as an OSError exception.\n\nimport os\n\ntry:\n\nos.unlink(\"file.txt\")\n\n# raised when file does not exist except OSError:\n\npass\n\n3.1.3 References\n\nPython 2.7.8 - Glossary\n\n36\n\n3. Readability\n\nPython Anti-Patterns\n\n3.2 Comparing things to None the wrong way\n\nPer the PEP 8 Style Guide, the preferred way to compare something to None is the pattern if Cond is None. This is only a guideline. It can be ignored if needed. But the purpose of the PEP 8 style guidelines is to improve the readability of code.\n\n3.2.1 Anti-pattern\n\nThe statement below uses the equality operator to compare a variable to None. This is not the PEP 8 preferred approach to comparing values to None.\n\nnumber = None\n\nif number == None:\n\nprint(\"This works, but is not the preferred PEP 8 pattern\")\n\n3.2.2 Best practice\n\nCompare values to None using the pattern if cond is None\n\nThe code below uses the PEP 8 preferred pattern of if cond is None.\n\nnumber = None\n\nif number is None:\n\nprint(\"PEP 8 Style Guide prefers this pattern\")\n\nHere the identity operator is is used. It will check whether number is identical to None. is will return to True only if the two variables point to the same object.\n\n3.2.3 References\n\nPEP 8 Style Guide - Programming Recommendations\n\nstackoverﬂow\n\n3.3 Comparing things to True the wrong way\n\nPer the PEP 8 Style Guide, the preferred ways to compare something to True are the patterns if cond is True: or if cond:. This is only a guideline. It can be ignored if needed. But the purpose of the PEP 8 Style Guide is to improve the readability of code.\n\n3. Readability\n\n37\n\nPython Anti-Patterns\n\n3.3.1 Anti-pattern\n\nThe statement below uses the equality operator to compare a boolean variable to True. This is not the PEP 8 preferred approach to comparing values to True. For sure, it is an anti-pattern not only in Python but in almost every programming language.\n\nflag = True\n\n# Not PEP 8's preferred pattern if flag == True:\n\nprint(\"This works, but is not the preferred PEP 8 pattern\")\n\n3.3.2 Best practices\n\nEvaluating conditions without comparing to True:\n\nThe code below uses the PEP 8 preferred pattern of if condition:. If the type of the condition is Boolean, it is obvious that comparing to True is redundant. But in Python, every non-empty value is treated as true in context of condition checking, see Python documentation:\n\nIn the context of Boolean operations, and also when expressions are used by control ﬂow state- ments, the following values are interpreted as false: False, None, numeric zero of all types, and empty strings and containers (including strings, tuples, lists, dictionaries, sets and frozensets). All other values are interpreted as true.\n\nflag = True\n\nif flag:\n\nprint(\"PEP 8 Style Guide prefers this pattern\")\n\nCompare values to True using the pattern if cond is True:\n\nThe code below uses the pattern described in PEP 8 as worse:\n\nflag = True\n\nif flag is True:\n\nprint(\"PEP 8 Style Guide abhors this pattern\")\n\nThis pattern is useful, when you make actual distinction between True value and every other that could be treated as true. The same applies to if cond is False. This expression is true only if cond has actual value of False - not empty list, empty tuple, empty set, zero etc.\n\n3.3.3 References\n\nPEP 8 Style Guide - Programming Recommendations\n\n38\n\n3. Readability\n\nPython Anti-Patterns\n\n3.4 Using type() to compare types\n\nThe function isinstance is the best-equipped to handle type checking because it supports inheritance (e.g. an instance of a derived class is an instance of a base class, too). Therefore isinstance should be used whenever type comparison is required.\n\n3.4.1 Anti-pattern\n\nThe if statement below uses the pattern if type(OBJECT) is types.TYPE to compare a Rectangle object to a built-in type (ListType in this example). This is not the preferred pattern for comparing types.\n\nimport types\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height\n\nr = Rectangle(3, 4)\n\n# bad if type(r) is types.ListType:\n\nprint(\"object r is a list\")\n\nNote that the following situation will not raise the error, although it should.\n\nimport types\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height\n\nclass Circle(object):\n\ndef __init__(self, radius): self.radius = radius\n\nc = Circle(2) r = Rectangle(3, 4)\n\n# bad if type(r) is not type(c):\n\nprint(\"object types do not match\")\n\n3.4.2 Best practice\n\nUse isinstance to compare types\n\nThe preferred pattern for comparing types is the built-in function isinstance.\n\nimport types\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width\n\n(continues on next page)\n\n3. Readability\n\n39",
      "page_number": 35,
      "chapter_number": 5,
      "summary": "This chapter covers segment 5 (pages 35-42). Key topics include code, coding, and variables. Most bugs involving global variables arise from one function reading and acting on the value of a global variable before another function has the chance to set it to an appropriate value.",
      "keywords": [
        "Global variables",
        "global",
        "HEIGHT",
        "PEP",
        "WIDTH",
        "Style Guide",
        "Python Anti-Patterns",
        "statement global HEIGHT",
        "data",
        "global variable HEIGHT",
        "global statement WIDTH",
        "style",
        "global variables WIDTH",
        "variables",
        "Python"
      ],
      "concepts": [
        "code",
        "coding",
        "variables",
        "variable",
        "pattern",
        "global",
        "uses",
        "useful",
        "style",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 8,
          "title": "Segment 8 (pages 60-68)",
          "relevance_score": 0.72,
          "method": "sentence_transformers"
        },
        {
          "book": "makinggames",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        },
        {
          "book": "Python Distilled",
          "chapter": 15,
          "title": "Segment 15 (pages 124-132)",
          "relevance_score": 0.67,
          "method": "sentence_transformers"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Python Distilled",
          "chapter": 29,
          "title": "Segment 29 (pages 258-268)",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 43-52)",
      "start_page": 43,
      "end_page": 52,
      "detection_method": "topic_boundary",
      "content": "Python Anti-Patterns\n\n(continued from previous page)\n\nself.height = height\n\nr = Rectangle(3, 4)\n\n# good if isinstance(r, types.ListType):\n\nprint(\"object r is a list\")\n\n3.4.3 References\n\nStack Overﬂow: Differences between isinstance() and type() in Python\n\n3.5 Not using dict comprehensions\n\nYou may encounter the old style of initializing a dict (passing an iterable of key-value pairs) in older Python code written before version 2.7. The new dict comprehension style is functionally equivalent and is much more readable. Consider refactoring the old-style code to use the new style (but only if you are using Python 2.7 or higher).\n\n3.5.1 Anti-pattern\n\nThe code below demonstrates the old syntax of dict initialization. Although there is nothing syntactically wrong with this code, it is somewhat hard to read.\n\nnumbers = [1,2,3]\n\n# hard to read my_dict = dict([(number,number*2) for number in numbers])\n\nprint(my_dict) # {1: 2, 2: 4, 3: 6}\n\n3.5.2 Best practice\n\nThe modiﬁed code below uses the new dict comprehension syntax which was introduced in Python 2.7.\n\nnumbers = [1, 2, 3]\n\nmy_dict = {number: number * 2 for number in numbers}\n\nprint(my_dict) # {1: 2, 2: 4, 3: 6}\n\n40\n\n3. Readability\n\nPython Anti-Patterns\n\n3.5.3 References\n\nStack Overﬂow - Create a dictionary with list comprehesion\n\n3.6 Not using dict keys when formatting strings\n\nWhen formatting a string with values from a dictionary, you can use the dictionary keys instead of explicity deﬁning all of the format parameters. Consider this dictionary that stores the name and age of a person.\n\nperson = {\n\n'first': 'Tobin', 'age': 20\n\n}\n\n3.6.1 Anti-pattern\n\nHere is an example of formatting the string with values from the person. This is bad! If we added another key-value pair to the person dictionary, we would have to change the string and the format arguments\n\nperson = {\n\n'first': 'Tobin', 'age':20\n\n}\n\nprint('{0} is {1} years old'.format(\n\nperson['first'], person['age'])\n\n) # Output: Tobin is 20 years old\n\nperson = {\n\n'first': 'Tobin', 'last': 'Brown', 'age':20\n\n}\n\n# Bad: we have to change the replacement fields within # our string, once we add new values print('{0} {1} is {2} years old'.format(\n\nperson['first'], person['last'], person['age'])\n\n) # bad # Output: Tobin Brown is 20 years old\n\n3. Readability\n\n41\n\nPython Anti-Patterns\n\n3.6.2 Best practice\n\nBy using the dictionary keys in the string we are formatting, the code is much more readable and explicit.\n\nperson = {\n\n'first': 'Tobin', 'age':20\n\n}\n\nprint('{first} is {age} years old'.format(**person)) # Output: Tobin is 20 years old\n\nperson = {\n\n'first':'Tobin', 'last': 'Brown', 'age':20\n\n} print('{first} {last} is {age} years old'.format(**person)) # Output: Tobin Brown is 20 years old\n\nGoing even further, the same result can be achieved with your own objects by using obj.__dict__.\n\nclass Person(object):\n\ndef __init__(self, first, last, age):\n\nself.first = first self.last = last self.age = age\n\ndef __str__(self):\n\nreturn '{first} {last} is {age} years old'.format(**self.__dict__)\n\nperson = Person('Tobin', 'Brown', 20) print(person) # Output: Tobin Brown is 20 years old\n\n3.7 Not using items() to iterate over a dictionary\n\nPEP 20 states “There should be one– and preferably only one –obvious way to do it.” The preferred way to iterate over the key-value pairs of a dictionary is to declare two variables in a for loop, and then call dictionary.items(), where dictionary is the name of your variable representing a dictionary. For each loop iteration, Python will automatically assign the ﬁrst variable as the key and the second variable as the value for that key.\n\n42\n\n3. Readability\n\nPython Anti-Patterns\n\n3.7.1 Anti-pattern\n\nThe code below deﬁnes a for loop that iterates over a dictionary named d. For each loop iteration Python automatically assigns the value of key to the name of the next key in the dictionary. Inside of the for loop the code uses key to access the value of each key of the dictionary. This is a common way for iterating over a dictionary, but it is not the preferred way in Python.\n\nd = {\"first_name\": \"Alfred\", \"last_name\":\"Hitchcock\"}\n\nfor key in d:\n\nprint(\"{} = {}\".format(key, d[key]))\n\n3.7.2 Best-practice\n\nUse items() to iterate across dictionary\n\nThe updated code below demonstrates the Pythonic style for iterating through a dictionary. When you deﬁne two variables in a for loop in conjunction with a call to items() on a dictionary, Python auto- matically assigns the ﬁrst variable as the name of a key in that dictionary, and the second variable as the corresponding value for that key.\n\nd = {\"first_name\": \"Alfred\", \"last_name\":\"Hitchcock\"}\n\nfor key,val in d.items():\n\nprint(\"{} = {}\".format(key, val))\n\n3.7.3 Difference Python 2 and Python 3\n\nIn python 2.x the above examples using items would return a list with tuples containing the copied key- value pairs of the dictionary. In order to not copy and with that load the whole dictionary’s keys and values inside a list to the memory you should prefer the iteritems method which simply returns an iterator instead of a list. In Python 3.x the iteritems is removed and the items method returns view objects. The beneﬁt of these view objects compared to the tuples containing copies is that every change made to the dictionary is reﬂected in the view objects.\n\n3.7.4 References\n\nPEP 20 - The Zen of Python\n\nPython 2 dict.iteritems\n\nPython 3 dict.items\n\n3. Readability\n\n43\n\nPython Anti-Patterns\n\n3.8 Not using named tuples when returning more than one value from a function\n\nNamed tuples can be used anywhere where normal tuples are acceptable, but their values can be accessed through their names in addition to their indexes. This makes the code more verbose and readable.\n\n3.8.1 Anti-pattern\n\nThe code below returns a ﬁrst name, middle name, and last name using a normal, unnamed tuple. After calling the tuple, each value can only be returned via an index. This code is difﬁcult to use: the caller of the function has to know that the ﬁrst element is the ﬁrst name, the second is the middle name, and the third is the last name.\n\ndef get_name():\n\nreturn \"Richard\", \"Xavier\", \"Jones\"\n\nname = get_name()\n\n# no idea what these indexes map to! print(name[0], name[1], name[2])\n\n3.8.2 Best practice\n\nUse named tuples to return multiple values\n\nThe modiﬁed code below uses named tuples to return multiple values. This code is easier to use and easier to read, as now the caller can access each piece of data via a straightforward name (like name.first).\n\nfrom collections import namedtuple\n\ndef get_name():\n\nname = namedtuple(\"name\", [\"first\", \"middle\", \"last\"]) return name(\"Richard\", \"Xavier\", \"Jones\")\n\nname = get_name()\n\n# much easier to read print(name.first, name.middle, name.last)\n\n3.8.3 References\n\nPython Standard Libary - collections.namedtuple\n\n3.9 Not using unpacking for updating multiple values at once\n\nIn general, the Python programming community prefers concise code over verbose code. Using unpacking to update the values of multiple variables simultaneously is more concise than using assignments to update each variable individually.\n\n44\n\n3. Readability\n\nPython Anti-Patterns\n\n3.9.1 Anti-pattern\n\nThe function below implements the classical Euclid algorithm for greatest common divisor. The updates of the variables a and b are made using variable temp and three lines of code.\n\ndef gcd(a, b):\n\nwhile b != 0:\n\ntemp = b b = a % b a = temp\n\nreturn a\n\n3.9.2 Best practice\n\nUse unpacking to update multiple values simultaneously\n\nThe modiﬁed code below is functionally equivalent to the original code above, but this code is more concise.\n\ndef gcd(a, b):\n\nwhile b != 0:\n\na, b = b, a % b\n\nreturn a\n\n3.9.3 Gotchas\n\nThe unpacking can be sometimes quite misleading. Figure out what is the outcome of the code below.\n\nb = \"1984\" a = b, c = \"AB\" print(a, b, c)\n\n3.10 Not using zip() to iterate over a pair of lists\n\nPEP 20 states “There should be one– and preferably only one –obvious way to do it.” The preferred way to iterate through a pair of lists is to declare two variables in a loop expression, and then call zip(list_one, list_two), where list_one and list_two are the two lists you wish to iterate through. For each loop iteration, Python will automatically assign the ﬁrst variable as the next value in the ﬁrst list, and the second variable as the next value in the second list.\n\n3.10.1 Anti-pattern\n\nThe code below deﬁnes a variable index which serves as an index variable for iterating through two lists. Within the for loop the code accesses the corresponding value for each list by using the index variable. This is a common way for iterating through two lists, but it is not the preferred way in Python.\n\nnumbers = [1, 2, 3] letters = [\"A\", \"B\", \"C\"]\n\nfor index in range(len(numbers)):\n\nprint(numbers[index], letters[index])\n\n3. Readability\n\n45\n\nPython Anti-Patterns\n\n3.10.2 Best-practice\n\nUse zip() to iterate through a pair of lists\n\nThe updated code below demonstrates the Pythonic style for iterating through a pair of lists. When the code deﬁnes two variables in its for loop in conjunction with a call to zip(numbers, letters) on the pair of lists, Python automatically assigns the ﬁrst variable as the next value in the ﬁrst list, and the second variable as the next value in the second list.\n\nnumbers = [1, 2, 3] letters = [\"A\", \"B\", \"C\"]\n\nfor numbers_value, letters_value in zip(numbers, letters):\n\nprint(numbers_value, letters_value)\n\n3.10.3 References\n\nPEP 20 - The Zen of Python\n\nBuilt-in Functions > zip(*iterables)\n\n3.11 Putting type information in a variable name\n\nPython is a duck-typed language. Just because a variable is described as an integer does not mean that it actually is an integer. This can be very dangerous for any programmer who acts on the variable assuming that it is an integer. Note that the practice of including type notation in variable names is also called Hungarian Notation.\n\n3.11.1 Anti-pattern\n\nThe code below demonstrates the dangers of variables whose names include type notation. Just because a variable is called n_int does not mean that the variable is actually an integer.\n\nn_int = \"Hello, World!\"\n\n# mistakenly assuming that n_int is a number 4 / n_int\n\n3.11.2 Best practice\n\nRemove type notation\n\nAlthough the modifed code below does not ﬁx the underlying problem of attempting to divide a number by a string, the code is generally less misleading, because there is no misleading description in the variable name n that n is a number.\n\nn = \"Hello, World!\"\n\n# still a problem, but less misleading now 4 / n\n\n46\n\n3. Readability\n\nPython Anti-Patterns\n\n3.11.3 References\n\nStack Overﬂow - Hungarian Notation\n\n3.12 Test for object identity should be is\n\nTesting the identity of two objects can be achieved in python with a special operator called is. Most prominently it is used to check whether a variable points to None. But the operator can examine any kind of identity. This often leads to confusion because equality of two different objects will return False.\n\n3.12.1 Anti-pattern\n\na = range(10) b = range(10)\n\nprint((a is b))\n\nThis code snippet will print False even though a and b have equal values. This can occur because a and b are references that point to different objects which happen to have the same value. To verify the equality of two variables the == operator should be used.\n\n3.12.2 Best practice\n\nOnly use the is operator if you want to check the exact identity of two references.\n\nsome_list = None\n\nif some_list is None:\n\ndo_somthing_with_the_list()\n\n3.12.3 References\n\nPEP8 Style Guide - Programming Recommendations\n\n3.13 Using an unpythonic loop\n\nPEP 20 states “There should be one– and preferably only one –obvious way to do it.” Creating a loop that uses an incrementing index to access each element of a list within the loop construct is not the preferred style for accessing each element in a list. The preferred style is to use enumerate() to simultaneously retrieve the index and list element.\n\n3. Readability\n\n47\n\nPython Anti-Patterns\n\n3.13.1 Anti-pattern\n\nThe code below uses an index variable i in a for loop to iterate through the elements of a list. This is not the preferred style for iterating through a list in Python.\n\nl = [1,2,3]\n\n# creating index variable for i in range(0,len(l)):\n\n# using index to access list le = l[i] print(i,le)\n\n3.13.2 Best practice\n\nRetrieve index and element when deﬁning loop\n\nThe updated code below demonstrates the Pythonic style for iterating through a list. When you deﬁne two variables in a for loop in conjunction with a call to enumerate() on a list, Python automatically assigns the ﬁrst variable as an index variable, and the second variable as the corresponding list element value for that index location in the list.\n\nfor i, le in enumerate(l):\n\nprint(i, le)\n\n3.13.3 References\n\nPEP 20 - The Zen of Python\n\n3.14 Using map() or filter() where list comprehension is possible\n\nFor simple transformations that can be expressed as a list comprehension, use list comprehensions over map() or filter(). Use map() or filter() for expressions that are too long or complicated to express with a list comprehension. Although a map() or filter() expression may be functionally equivalent to a list comprehension, the list comprehension is generally more concise and easier to read.\n\n3.14.1 Anti-pattern\n\nThe code below deﬁnes a list, and then uses map() to create a second list which is just the doubles of each value from the ﬁrst list.\n\nvalues = [1, 2, 3] doubles = map(lambda x: x * 2, values)\n\n48\n\n3. Readability\n\nPython Anti-Patterns\n\n3.14.2 Best practice\n\nUse list comprehension instead of map()\n\nIn the modiﬁed code below, the code uses a list comprehension to generate the second list containing the doubled values from the ﬁrst list. Although this is functionally equivalent to the ﬁrst code, the list compre- hension is generally agreed to be more concise and easier to read.\n\nvalues = [1, 2, 3] doubles = [x * 2 for x in values]\n\n3.14.3 References\n\nPyLint - W0110, deprecated-lambda\n\nOliver Fromme - List Comprehensions\n\n3.15 Using CamelCase in function names\n\nPer the PEP 8 Style Guide, function names should be lowercase, with words separated by underscores.\n\n3.15.1 Anti-pattern\n\ndef someFunction():\n\nprint(\"Is not the preferred PEP 8 pattern for function names\")\n\n3.15.2 Best practice\n\nUsing lowercase with underscores\n\nThe code below uses the PEP 8 preferred pattern of function names.\n\ndef some_function():\n\nprint(\"PEP 8 Style Guide prefers this pattern\")\n\n3.15.3 References\n\nPEP8 Style Guide - Function names\n\n3. Readability\n\n49",
      "page_number": 43,
      "chapter_number": 6,
      "summary": "3.5.1 Anti-pattern\n\nThe code below demonstrates the old syntax of dict initialization Key topics include python, pythonic, and list. The new dict comprehension style is functionally equivalent and is much more readable.",
      "keywords": [
        "Python Anti-Patterns",
        "Python",
        "list",
        "code",
        "variable",
        "References Stack Overﬂow",
        "person",
        "dictionary",
        "Tobin",
        "Tobin Brown",
        "Anti-pattern",
        "list comprehension",
        "References",
        "older Python code",
        "Python code written"
      ],
      "concepts": [
        "python",
        "pythonic",
        "list",
        "code",
        "values",
        "variables",
        "variable",
        "types",
        "readable",
        "readability"
      ],
      "similar_chapters": [
        {
          "book": "Python Distilled",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        },
        {
          "book": "Python Distilled",
          "chapter": 29,
          "title": "Segment 29 (pages 258-268)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 7,
          "title": "Segment 7 (pages 128-146)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Learning Python Ed6",
          "chapter": 8,
          "title": "Lists and Dictionaries",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 6,
          "title": "Segment 6 (pages 107-127)",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 53-61)",
      "start_page": 53,
      "end_page": 61,
      "detection_method": "topic_boundary",
      "content": "Python Anti-Patterns\n\n4 Security\n\nPython is a highly dynamic language that gives the programmer many ways to change the runtime be- havior of his code and even dynamically execute new code. This is powerful but can be a security risk as well.\n\nUse the following patterns to increase the security of your code.\n\n4.1 use of exec\n\nThe exec statement enables you to dynamically execute arbitrary Python code which is stored in literal strings. Building a complex string of Python code and then passing that code to exec results in code that is hard to read and hard to test. Anytime the Use of exec error is encountered, you should go back to the code and check if there is a clearer, more direct way to accomplish the task.\n\n4.1.1 Anti-pattern\n\nProgram uses exec to execute arbitrary Python code\n\nThe sample code below composes a literal string containing Python code and then passes that string to exec for execution. This is an indirect and confusing way to program in Python.\n\ns = \"print(\\\"Hello, World!\\\")\" exec s\n\n4.1.2 Best practice\n\nRefactor the code to avoid exec\n\nIn most scenarios, you can easily refactor the code to avoid the use of exec. In the example below, the use of exec has been removed and replaced by a function.\n\ndef print_hello_world():\n\nprint(\"Hello, World!\")\n\nprint_hello_world()\n\n4.1.3 References\n\nPyLint - W0122, exec-used\n\nPython Language Reference - The exec statement\n\nStack Overﬂow - Why should exec() and eval() be avoided?\n\n50\n\n4. Security\n\nPython Anti-Patterns\n\n5 Performance\n\nIn Python, large performance gains can be obtained by using appropriate functions and directives. Avoid the following anti-patterns to reduce overhead and make your code more performant.\n\n5.1 Using key in list to check if key is contained in list\n\nUsing key in list to iterate through a list can potentially take n iterations to complete, where n is the number of items in the list. If possible, you should change the list to a set or dictionary instead, because Python can search for items in a set or dictionary by attempting to directly accessing them without itera- tions, which is much more efﬁcient.\n\n5.1.1 Anti-pattern\n\nThe code below deﬁnes a list l and then calls if 3 in l to check if the number 3 exists in the list. This is inefﬁcient. Behind the scenes, Python iterates through the list until it ﬁnds the number or reaches the end of the list.\n\nl = [1, 2, 3, 4]\n\n# iterates over three elements in the list if 3 in l:\n\nprint(\"The number 3 is in the list.\")\n\nelse:\n\nprint(\"The number 3 is NOT in the list.\")\n\n5.1.2 Best practice\n\nUse a set or dictionary instead of a list\n\nIn the modiﬁed code below, the list has been changed to a set. This is much more efﬁcient behind the scenes, as Python can attempt to directly access the target number in the set, rather than iterate through every item in the list and compare every item to the target number.\n\ns = set([1, 2, 3, 4])\n\nif 3 in s:\n\nprint(\"The number 3 is in the list.\")\n\nelse:\n\nprint(\"The number 3 is NOT in the list.\")\n\n5.2 Not using iteritems() to iterate over a large dictionary in Python 2\n\nPEP 234 deﬁnes iteration interface for objects. It also states it has signiﬁcant impact on performance of dict iteration.\n\nNote: This anti-pattern only applies to Python versions 2.x. In Python 3.x items() returns an iterator (consequently, iteritems() and Python 2’s iterative range() function, xrange(), have been removed from Python 3.x).\n\n5. Performance\n\n51\n\nPython Anti-Patterns\n\n5.2.1 Anti-pattern\n\nThe code below deﬁnes one large dictionary (created with dictionary comprehension) that generates large amounts of data. When using items() method, the iteration needs to be completed and stored in-memory before for loop can begin iterating. The prefered way is to use iteritems. This uses (~1.6GB).\n\nd = {i: i * 2 for i in xrange(10000000)}\n\n# Slow and memory hungry. for key, value in d.items():\n\nprint(\"{0} = {1}\".format(key, value))\n\n5.2.2 Best-practice\n\nUse iteritems() to iterate over large dictionary\n\nThe updated code below uses iteritems() instead of items() method. Note how the code is exactly the same, but memory usage is 50% less (~800MB). This is the preferred way to iterate over large dictionaries.\n\nd = {i: i * 2 for i in xrange(10000000)}\n\n# Memory efficient. for key, value in d.iteritems():\n\nprint(\"{0} = {1}\".format(key, value))\n\n5.2.3 References\n\nPEP 234 Iterators\n\n52\n\n5. Performance\n\nPython Anti-Patterns\n\n6 Django\n\nDjango is a great framework to create fast and scalable web applications. To help you write great Django apps from the start, we started to compile a set of anti- and migration patterns. They’ll help you to avoid common mistakes or to migrate to a new version faster. Some patterns are simply (more elaborate) explana- tions of tips and best practices that can be found in Django’s docs. Others stem from our own experiences. Feel free to contribute your ideas or share your pattern via email.\n\n6.1 Maintainability\n\nAvoid the following anti-patterns to increase maintainability of your Django code base—for you, and for others.\n\n6.1.1 Importing django.db.models.ﬁelds\n\nIn Django, models are deﬁned in django.db.models.fields. However, for convenience they are im- ported into django.db.models. Django’s standard convention is to use from django.db import models and refer to ﬁelds as models<some>Field. To improve readability and maintainability of your code, change your import statement and model deﬁnition.\n\nAnti-pattern\n\nfrom django.db.models import fields\n\nclass Person(models.Model):\n\nfirst_name = fields.CharField(max_length=30) last_name = fields.CharField(max_length=30)\n\nBest practice\n\nStick to standard conventions and use from django.db import models instead.\n\nfrom django.db import models\n\nclass Person(models.Model):\n\nfirst_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30)\n\nReferences\n\nDjango documentation - Model ﬁeld reference\n\n6. Django\n\n53\n\nPython Anti-Patterns\n\n6.2 Security\n\nMost Django applications contain a lot of proprietory or even conﬁdential information. Hence, it is crucial to take all possible measures to take your Django application secure and to recude the possibility of being hacked.\n\nUse the following patterns to increase the security of your code.\n\n6.2.1 ALLOWED_HOSTS setting missing\n\nIn Django, you need to properly set the ALLOWED_HOSTS setting when DEBUG = False. This is a security mechanism. It prevents attackers from poisoning caches or password reset emails with links to malicious hosts by submitting requests with a fake HTTP Host header, which is possible even under many seemingly- safe web server conﬁgurations.\n\nAnti-Pattern\n\nALLOWED_HOSTS not set or empty, when DEBUG = False.\n\n\"\"\" settings.py \"\"\"\n\nDEBUG = False # ... ALLOWED_HOSTS = []\n\nBest practice\n\nMake sure, an appropriate host is set in ALLOWED_HOSTS, whenever DEBUG = False.\n\nDEBUG = False # ... ALLOWED_HOSTS = ['djangoproject.com']\n\nReferences\n\nDjango documentation - Settings: The Basics\n\nDjango documentation - Settings: ALLOWED_HOSTS\n\n6.2.2 SECRET_KEY published\n\nA secret key has to be be kept secret. Make sure it is only used in production, but nowhere else. Especially, avoid committing it to source control. This increases security and makes it less likely that an attacker may acquire the key.\n\nAnti-pattern\n\nThis settings.py contains a SECRET_KEY. You should not do this!\n\n\"\"\" settings.py \"\"\" SECRET_KEY = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n\n54\n\n6. Django\n\nPython Anti-Patterns\n\nBetter Practices\n\nLoad key from environment variable\n\nInstead of publishing your secret key, you can use an environment variable to set your secret key.\n\nimport os SECRET_KEY = os.environ['SECRET_KEY']\n\nLoad secret key from ﬁle\n\nAlternatively, you can read the secret key from a ﬁle.\n\nwith open('/etc/secret_key.txt') as f: SECRET_KEY = f.read().strip()\n\nReferences\n\nDjango\n\n6.2.3 Same value for MEDIA_ROOT and STATIC_ROOT\n\nAccording to Django’s documentation, MEDIA_ROOT and STATIC_ROOT must have different values. Before STATIC_ROOT was introduced, MEDIA_ROOT was also used (as fallback) to also serve static ﬁles. As this can have serious security implications, Django has validation checks to prevent it.\n\nAnti-pattern\n\nMEDIA_ROOT and STATIC_ROOT point to the same folder.\n\n\"\"\" settings.py \"\"\"\n\n# Media and static root are identical STATIC_ROOT = '/path/to/my/static/files' MEDIA_ROOT = '/path/to/my/static/files'\n\nBest practice\n\nEnsure, STATIC_ROOT and MEDIA_ROOT point to different folders.\n\n\"\"\" settings.py \"\"\"\n\nSTATIC_ROOT = '/path/to/my/static/files' MEDIA_ROOT = '/path/to/my/media/files'\n\nReferences\n\nDjango documentation - Settings: MEDIA_ROOT\n\n6. Django\n\n55\n\nPython Anti-Patterns\n\n6.2.4 Same value for MEDIA_URL and STATIC_URL\n\nAccording to Django’s documentation, MEDIA_URL and STATIC_URL must have different values.\n\nAnti-pattern\n\nMEDIA_URL and STATIC_URL point to the same URL.\n\n\"\"\" settings.py \"\"\"\n\n# Media and static root are identical STATIC_URL = 'http://www.mysite.com/static' MEDIA_URL = 'http://www.mysite.com/static'\n\nBest practice\n\nEnsure, STATIC_URL and MEDIA_URL point to different URL’s.\n\n\"\"\" settings.py \"\"\"\n\nSTATIC_URL = 'http://www.mysite.com/static' MEDIA_URL = 'http://www.mysite.com/media'\n\nReferences\n\nDjango documentation - Settings: MEDIA_URL\n\nDjango documentation - Settings: MEDIA_ROOT\n\n6.3 Correctness\n\n6.3.1 Not using forward slashes\n\nDjango requires you to use forward slashes / whenever you indicate a path, even on Windows. In your settings, this is true for the following variables.\n\nSTATICFILES_DIRS\n\nTEMPLATE_DIRS\n\nDATABASES['<your database>'][NAME]\n\nFIXTURE_DIRS\n\nAnti-pattern\n\nThis pattern is exemplary for any of the above mentioned settings. It uses backslashes, instead of forward slashes.\n\n\"\"\" settings.py \"\"\"\n\nSTATICFILES_DIRS = [\n\n\"\\\\path\\\\to\\\\my\\\\static\\\\files\",\n\n]\n\n56\n\n6. Django\n\nPython Anti-Patterns\n\nBest practice\n\nDjango requires you to use forward slashes /, even on Windows.\n\n\"\"\" settings.py \"\"\"\n\nSTATICFILES_DIRS = [\n\n\"/path/to/my/static/files\",\n\n]\n\nReferences\n\nDjango documentation - Settings: TEMPLATE_DIRS\n\nDjango documentation - Settings: FIXTURE_DIRS\n\nDjango documentation - Settings: STATIC_FILES_DIRS\n\nDjango documentation - Settings: HOST\n\n6.4 Performance\n\nDjango has a lot of mechanisms built-in to build fast and efﬁcient web applications. Still, there are several things to watch out for, especially when you start to scale your Django application. This chapter contains anti-patterns that can potentially harm the performance of your application and hence, should be avoided.\n\n6.4.1 Inefﬁcient database queries\n\nDjango’s models make it easy for you, to ﬁlter the data of your application without using any SQL state- ments. This is a great thing, however, it sometimes hides that you are using object ﬁlters inefﬁciently. Unless you append .values() to your ﬁlter, your QuerySet will always query all columns within your database. This can be uncritical until you scale your application or once your tables grow bigger. Therefore, make sure you only retrieve the columns your really need within your program.\n\nAnti-Pattern\n\nLet’s assume we have a an app vehicle which contains a model Cars to store plenty of information about a car:\n\n\"\"\" models.py \"\"\"\n\nclass Cars(models.Model):\n\nmake = models.CharField(max_length=50) model = models.CharField(max_length=50) wheels = models.CharField(max_length=2) # ...\n\nWe import this model into one of your views to do something will make names within our database:\n\n\"\"\" views.py \"\"\" from models import Cars\n\n# ...\n\n(continues on next page)\n\n6. Django\n\n57\n\nPython Anti-Patterns\n\n(continued from previous page)\n\ncars = Cars.objects.all() for car in cars:\n\ndo_something(car.make)\n\nEven though this code works and looks harmless, it can kill you in production. You think, you are actually just accessing the make ﬁeld, but you are actually retrieving ALL data from your database, once you start iterating over the retrieved QuerySet:\n\nSELECT make, model, wheels, ... FROM vehicles_cars;\n\nEspecially, if you have many ﬁelds on your model and/or if you got millions of records in your table, this slows down the response time of your applications signiﬁcantly. As QuerySets are cached upon evaluation, it will hit your database only once, but you’d better be carful.\n\nBest practice\n\nUse .values()\n\nTo avoid such a scenario, make sure you only query the data you really need for your program. Use . values() to restrict the underlying SQL query to required ﬁelds only.\n\n\"\"\" views.py \"\"\" from cars.models import Cars\n\ncars = Cars.objects.all().values('make')\n\n# Print all makes for car in cars:\n\ndo_something(car['make'])\n\nSELECT make from vehicles_cars;\n\nUse .values_list()\n\nAlternatively, you can use .value_list(). It is similar to values() except that instead of returning dictionaries, it returns tuples when you iterate over it.\n\n\"\"\" views.py \"\"\" from cars.models import Cars\n\ncars = Cars.objects.all().values_list('make', flat=True)\n\n# Print all makes for make in cars:\n\ndo_something(make)\n\nReferences\n\nDjango documentation - Models: Querysets (values)\n\nDjango documentation - Models: Querysets (values_list)\n\n58\n\n6. Django",
      "page_number": 53,
      "chapter_number": 7,
      "summary": "This chapter covers segment 7 (pages 53-61). Key topics include django, iterate, and iterations. Use the following patterns to increase the security of your code.",
      "keywords": [
        "References Django documentation",
        "Django",
        "Django documentation",
        "References Django",
        "Python",
        "Python Anti-Patterns",
        "DIRS Django documentation",
        "STATIC",
        "MEDIA",
        "ROOT",
        "code",
        "key",
        "URL",
        "DIRS Django",
        "Python code"
      ],
      "concepts": [
        "django",
        "iterate",
        "iterations",
        "iteration",
        "iterative",
        "settings",
        "python",
        "models",
        "make",
        "code"
      ],
      "similar_chapters": [
        {
          "book": "Python Microservices Development",
          "chapter": 9,
          "title": "Segment 9 (pages 65-73)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "Building Python Microservices with FastAPI",
          "chapter": 44,
          "title": "Segment 44 (pages 400-407)",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        },
        {
          "book": "Effective-Python",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 2,
          "title": "Segment 2 (pages 20-40)",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        },
        {
          "book": "Python Microservices Development",
          "chapter": 3,
          "title": "Segment 3 (pages 17-24)",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 62-65)",
      "start_page": 62,
      "end_page": 65,
      "detection_method": "topic_boundary",
      "content": "Python Anti-Patterns\n\n6.5 Migration to 1.8\n\nMigrating to a new Django version can be time consuming. To make this process easier, this chapter lists deprecated features and shows potential migration patterns/pathes.\n\n6.5.1 TEMPLATE_DIRS deprecated\n\nThis setting is deprecated since Django version 1.8. Set the DIRS option of a [DjangoTemplates back- end](https://docs.djangoproject.com/en/1.8/topics/templates/#module-django.template.backends. django) instead.\n\nDeprecated feature\n\nDeprecated TEMPLATE_DIRS setting used.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATE_DIRS = [\n\n\"path/to/my/templates\",\n\n]\n\nMigration path\n\nAs of Django 1.8 you should set DIRS option within TEMPLATES setting. It deﬁnes where the engine should look for template source ﬁles, in search order.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATES = [\n\n{\n\n'BACKEND': 'django.template.backends.django.DjangoTemplates', 'APP_DIRS': True, 'DIRS': '/path/to/my/templates',\n\n},\n\n]\n\nReferences\n\nDjango documentation - Settings: TEMPLATES\n\nDjango documentation - Settings: TEMPLATE_DIRS\n\nDjango documentation - Templates: Built-in backends\n\n6. Django\n\n59\n\nPython Anti-Patterns\n\n6.5.2 TEMPLATE_DEBUG deprecated\n\nThis setting sets the output that the template system should use for invalid (e.g. misspelled) variables. The default value is an empty string ''. This setting is deprecated since Django version 1.8. Set the TEM- PLATE_DEBUG option in the OPTIONS of a DjangoTemplates backend instead.\n\nDeprecated feature\n\nDeprecated TEMPLATE_DEBUG setting used.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATE_DEBUG = True\n\nMigration path\n\nAs of Django 1.8 you should set debug option in the OPTIONS of a DjangoTemplates backend instead.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATES = [\n\n{\n\n'BACKEND': 'django.template.backends.django.DjangoTemplates', 'APP_DIRS': True, 'DIRS': '/path/to/my/templates', 'OPTIONS': {\n\n'debug': True,\n\n}\n\n},\n\n]\n\nReferences\n\nDjango documentation - Settings: TEMPLATE_DEBUG\n\nDjango documentation - Settings: TEMPLATES\n\nDjango documentation - Templates: Built-in backends\n\n6.5.3 TEMPLATE_LOADERS deprecated\n\nThis setting is deprecated since Django version 1.8. Set the LOADERS option of a DjangoTemplates backend instead.\n\nDeprecated feature\n\nDeprecated TEMPLATE_LOADERS setting used.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATE_LOADERS = (\n\n'django.template.loaders.filesystem.Loader',\n\n(continues on next page)\n\n60\n\n6. Django\n\nPython Anti-Patterns\n\n(continued from previous page)\n\n'django.template.loaders.app_directories.Loader',\n\n)\n\nMigration path\n\nAs of Django 1.8 you should set loaders option in the TEMPLATES setting. It deﬁnes where the engine should look for template source ﬁles, in search order.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATES = [\n\n{\n\n'BACKEND': 'django.template.backends.django.DjangoTemplates', 'APP_DIRS': True, 'DIRS': '/path/to/my/templates', 'OPTIONS': {\n\n'loaders': (\n\n'django.template.loaders.filesystem.Loader', 'django.template.loaders.app_directories.Loader',\n\n),\n\n}\n\n},\n\n]\n\nReferences\n\nDjango documentation - Settings: TEMPLATES]\n\nDjango documentation - Settings: TEMPLATE_DIRS]\n\nDjango documentation - Templates: Built-in backends]\n\n6.5.4 TEMPLATE_STRING_IF_INVALID deprecated\n\nThis setting sets the output that the template system should use for invalid (e.g. misspelled) variables. The default value is an empty string ''. This setting is deprecated since Django version 1.8. Set the string_if_invalid option in the OPTIONS of a DjangoTemplates backend instead.\n\nDeprecated feature\n\nDeprecated TEMPLATE_STRING_IF_INVALID setting used.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATE_STRING_IF_INVALID = 'Invalid variable'\n\nMigration path\n\nAs of Django 1.8 you should set string_if_invalid option in the OPTIONS of a DjangoTemplates backend instead.\n\n6. Django\n\n61\n\nPython Anti-Patterns\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATES = [\n\n{\n\n'BACKEND': 'django.template.backends.django.DjangoTemplates', 'APP_DIRS': True, 'DIRS': '/path/to/my/templates', 'OPTIONS': {\n\n'string_if_invalid': 'Invalid varialbe!',\n\n}\n\n},\n\n]\n\nReferences\n\nDjango documentation - Settings: TEMPLATES\n\nDjango documentation - Settings: TEMPLATE_STRING_IF_INVALID\n\nDjango documentation - Templates: Built-in backends\n\nDjango documentation - Templates: How invalid variables are handled\n\n62\n\n6. Django",
      "page_number": 62,
      "chapter_number": 8,
      "summary": "To make this process easier, this chapter lists deprecated features and shows potential migration patterns/pathes Key topics include django, setting, and sets.",
      "keywords": [
        "Django",
        "TEMPLATES Django documentation",
        "Django documentation",
        "References Django documentation",
        "TEMPLATE",
        "TEMPLATES Django",
        "DIRS",
        "References Django",
        "feature Deprecated TEMPLATE",
        "Deprecated TEMPLATE",
        "DIRS Django documentation",
        "deprecated",
        "setting",
        "Django version",
        "Built-in backends Django"
      ],
      "concepts": [
        "django",
        "setting",
        "sets",
        "templates",
        "loaders",
        "migration",
        "migrating",
        "options",
        "patterns",
        "backend"
      ],
      "similar_chapters": [
        {
          "book": "Effective-Python",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        },
        {
          "book": "Release It! Design and Deploy Production-Ready Software",
          "chapter": 32,
          "title": "Segment 32 (pages 256-265)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "AntiPatterns",
          "chapter": 4,
          "title": "Segment 4 (pages 30-37)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Concurrency in Action",
          "chapter": 40,
          "title": "Segment 40 (pages 397-404)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 31,
          "title": "Segment 31 (pages 981-1014)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        }
      ]
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "content": "Python Anti-Patterns\n\nThe Little Book of Python Anti-Patterns and Worst Practice\n\nQuantiﬁedCode\n\ni",
      "content_length": 98,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 2,
      "content": "Contents\n\nWhy did we write this?\n\nWho are we?\n\nHow is this book organized?\n\nReferences\n\nLicensing\n\nContributing\n\nList of Maintainers\n\nIndex Of Patterns 1\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Correctness . Accessing a protected member from outside the class . . . . . . . . . . . . . . . . . . 1.1 Assigning a lambda expression to a variable . . . . . . . . . . . . . . . . . . . . . . . . 1.2 . Assigning to built-in function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.3 . Bad except clauses order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.4 Bad ﬁrst argument given to super() . . . . . . . . . . . . . . 1.5 else clause on loop without a break statement . . . . . . . . . . . . . . . . . . 1.6 __exit__ must accept 3 arguments: type, value, traceback . . . . . . . . . . . . . . 1.7 Explicit return in __init__ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.8 __future__ import is not the ﬁrst non-docstring statement . . . . . . . . . . . . . . 1.9 Implementing Java-style getters and setters . . . . . . . . . . . . . . . . . . . . . . . . 1.10 Indentation contains mixed spaces and tabs . . . . . . . . . . . . . . . . . . . . . . . . 1.11 1.12 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Indentation contains tabs 1.13 Method could be a function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.14 Method has no argument 1.15 Missing argument to super() . . . . . . . . . . . . . . . . . . . . . Using a mutable default value as an argument 1.16 . . . . . . . . . . . . . . . . . . . . . . No exception type(s) speciﬁed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.17 Not using defaultdict() . . . . . 1.18 . . . . . . . . . . . . . . . . . . . . Not using else where appropriate in a loop . . . . . . . . . . . . . . . . . . . . . . . 1.19 Not using explicit unpacking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.20 Not using get() to return a default value from a dict . . . . . . . . . . . . . . . . . . 1.21 Not using setdefault() to initialize a dictionary . 1.22 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Maintainability . . using wildcard imports (from ... import *) . . . 2.1 . Not using with to open ﬁles . . . . . . . . . . . . . . . . . . . . . . . . . 2.2 Returning more than one variable type from function call . . . . . . . . . . . . . . . . 2.3 Using the global statement . . . . . . . . . . . . . . . . . . . . . . . . 2.4 . . . . Using single letter to name your variables . . . . . . . . . . . . . . . . . . . . . . . . 2.5 . . . . . . . . . . . . . . . . Dynamically creating variable/method/function names 2.6 Readability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Asking for permission instead of forgiveness . . . . . . . . . . . . . . . . . . . . . . . 3.1 Comparing things to None the wrong way . . . . . . . . . . . . . . . . . . . . . . 3.2 Comparing things to True the wrong way . 3.3 . . . . . . . . . . . . . . . . . . . . . Using type() to compare types . . . . . 3.4 Not using dict comprehensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3.5 Not using dict keys when formatting strings . . . . . . . . . . . . . . . . . . . . . . . 3.6\n\n. . . . .\n\n. . .\n\n. . . . .\n\n. . .\n\n. . . . . . .\n\n. . .\n\n. . .\n\n. . . . .\n\n2\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n. . . . . .\n\n. . . . .\n\n. . . . . . . . . .\n\n. . .\n\n. . . .\n\n. . . . .\n\n3\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n. . .\n\n. . .\n\n. . .\n\n. . . . . . . . . . . . . . . . . . . . . . . .\n\nii\n\n1\n\n1\n\n2\n\n2\n\n2\n\n2\n\n3\n\n3 4 4 4 5 6 7 9 10 12 13 14 15 16 17 18 20 21 22 24 25 26 27 28 29 29 30 31 32 33 34 36 36 37 37 39 40 41",
      "content_length": 3887,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 3,
      "content": "4\n\n5\n\n6\n\nNot using items() to iterate over a dictionary . . . . . . . . . . . . . . . . . . . . . . Not using named tuples when returning more than one value from a function . . . . Not using unpacking for updating multiple values at once . . . . . . . . . . . . . . . Not using zip() to iterate over a pair of lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Putting type information in a variable name Test for object identity should be is . . . . . . . . . . . . . . . . . . . . . . . Using an unpythonic loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Using map() or filter() where list comprehension is possible . . . . . . . . . . . Using CamelCase in function names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Using key in list to check if key is contained in list . . . . . . . . . . . . . . . . . Not using iteritems() to iterate over a large dictionary in Python 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n3.7 3.8 3.9 3.10 3.11 3.12 3.13 3.14 3.15 Security . 4.1 Performance . 5.1 5.2 Django . 6.1 6.2 6.3 6.4 6.5\n\n. . . . .\n\n.\n\n.\n\n. . .\n\n.\n\n. . .\n\n. . . use of exec . .\n\n. . .\n\n.\n\n.\n\n. . . . . .\n\n. . . . . .\n\n.\n\n.\n\n. . Maintainability . . Security . . . Correctness . Performance . . Migration to 1.8 .\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n. . .\n\n.\n\n42 44 44 45 46 47 47 48 49 50 50 51 51 51 53 53 54 56 57 59\n\niii",
      "content_length": 2048,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 4,
      "content": "Python Anti-Patterns\n\nWelcome, fellow Pythoneer! This is a small book of Python anti-patterns and worst practices.\n\nLearning about these anti-patterns will help you to avoid them in your own code and make you a better programmer (hopefully). Each pattern comes with a small description, examples and possible solutions. You can check many of them for free against your project at QuantiﬁedCode.\n\nYou can also download this book as a PDF.\n\nWhy did we write this?\n\nShort answer: We think that you can learn as much from reading bad code as you can from reading good one.\n\nLong answer: There is an overwhelming amount of Python books that show you how to do things by focusing on best practices and examples of good code. There are only very few books out there that show you how not to do things. We wanted to change that by providing you with an anti-book that teaches you things which you should never do in practice.\n\nWho are we?\n\nWe’re QuantiﬁedCode, a Berlin-based startup. Our mission is to help programmers write better code! Our ﬁrst product is an online tool for automated, data-driven code review. When building this tool we learned a lot about code quality in Python and decided to compile our knowledge into this book.\n\n1",
      "content_length": 1231,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 5,
      "content": "Python Anti-Patterns\n\nHow is this book organized?\n\nThis book contains anti- and migrations pattern for Python and for popular Python frameworks, such as Django. We categorized the patterns as follows:\n\nCorrectness: Anti-patterns that will literally break your code or make it do the wrong things.\n\nMaintainability: Anti-patterns that will make your code hard to maintain or extend.\n\nReadability: Anti-patterns that will make your code hard to read or understand.\n\nPerformance: Anti-patterns that will unnecessarily slow your code down.\n\nSecurity: Anti-patterns that will pose a security risk to your program.\n\nMigration: Patterns that help you migrate faster to new versions of a framework\n\nSome patterns can belong in more than one category, so please don’t take the choice that we’ve made too serious. If you think a pattern is grossly misplaced in its category, feel free to create an issue on Github.\n\nReferences\n\nWhenever we cite content from another source we tried including the link to the original article on the bottom of the page. If you should have missed one, please feel free to add it and make a pull request on Github. Thanks!\n\nLicensing\n\nThis document is licensed under a creative-commons NC license, so you can use the text freely for non- commercial purposes and adapt it to your needs. The only thing we ask in return is the inclusion of a link to this page on the top of your website, so that your readers will be able to ﬁnd the content in its original form and possibly even contribute to it.\n\nContributing\n\nIf you think this collection can be improved or extended, please contribute! You can do this by simply forking our Github project and sending us a pull request once you’re done adding your changes. We will review and merge all pull requests as fast as possible and be happy to include your name on the list of authors of this document.\n\nWe would also like to thank all contributors to this book for their effort. A full list of contributors can be found at Github.\n\n2",
      "content_length": 1998,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 6,
      "content": "List of Maintainers\n\nIf you have any questions concerning this project, please contact one of the maintainers:\n\nAndreas Dewes\n\nChristoph Neumann\n\nIndex Of Patterns\n\nHere’s the full index of all anti-patterns in this book.\n\nPython Anti-Patterns\n\n3",
      "content_length": 246,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 7,
      "content": "Python Anti-Patterns\n\n1 Correctness\n\n1.1 Accessing a protected member from outside the class\n\nAccessing a protected member (a member preﬁxed with _) of a class from outside that class usually calls for trouble, since the creator of that class did not intend this member to be exposed.\n\n1.1.1 Anti-pattern\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself._width = width self._height = height\n\nr = Rectangle(5, 6) # direct access of protected member print(\"Width: {:d}\".format(r._width))\n\n1.1.2 Best practice\n\nIf you are absolutely sure that you need to access the protected member from the outside, do the following:\n\nMake sure that accessing the member from outside the class does not cause any inadvertent side effects.\n\nRefactor it such that it becomes part of the public interface of the class.\n\n1.1.3 References\n\nPyLint - W0212, protected-access\n\n1.2 Assigning a lambda expression to a variable\n\nThe sole advantage that a lambda expression has over a def is that the lambda can be anonymously embedded within a larger expression. If you are going to assign a name to a lambda, you are better off just deﬁning it as a def.\n\nFrom the PEP 8 Style Guide:\n\nYes:\n\ndef f(x): return 2*x\n\nNo:\n\nf = lambda x: 2*x\n\nThe ﬁrst form means that the name of the resulting function object is speciﬁcally ‘f’ instead of the generic ‘<lambda>’. This is more useful for tracebacks and string representations in general. The use of the assign- ment statement eliminates the sole beneﬁt a lambda expression can offer over an explicit def statement (i.e. that it can be embedded inside a larger expression)\n\n4\n\n1. Correctness",
      "content_length": 1624,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 8,
      "content": "Python Anti-Patterns\n\n1.2.1 Anti-pattern\n\nThe following code assigns a lambda function which returns the double of its input to a variable. This is functionally identical to creating a def.\n\nf = lambda x: 2 * x\n\n1.2.2 Best practice\n\nUse a def for named expressions\n\nRefactor the lambda expression into a named def expression.\n\ndef f(x): return 2 * x\n\n1.2.3 References\n\nPEP 8 Style Guide - Programming Recommendations\n\nStack Overﬂow - Do not assign a lambda expression\n\n1.3 Assigning to built-in function\n\nPython has a number of built-in functions that are always accessible in the interpreter. Unless you have a special reason, you should neither overwrite these functions nor assign a value to a variable that has the same name as a built-in function. Overwriting a built-in might have undesired side effects or can cause runtime errors. Python developers usually use built-ins ‘as-is’. If their behaviour is changed, it can be very tricky to trace back the actual error.\n\n1.3.1 Anti-pattern\n\nIn the code below, the list built-in is overwritten. This makes it impossible, to use list to deﬁne a variable as a list. As this is a very concise example, it is easy to spot what the problem is. However, if there are hundreds of lines between the assignment to list and the assignment to cars, it might become difﬁcult to identify the problem.\n\n# Overwriting built-in 'list' by assigning values to a variable called 'list' list = [1, 2, 3] # Defining a list 'cars', will now raise an error cars = list() # Error: TypeError: 'list' object is not callable\n\n1. Correctness\n\n5",
      "content_length": 1568,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 9,
      "content": "Python Anti-Patterns\n\n1.3.2 Best practice\n\nUnless you have a very speciﬁc reason to use variable names that have the same name as built-in functions, it is recommended to use a variable name that does not interfere with built-in function names.\n\n# Numbers used as variable name instead of 'list' numbers = [1, 2, 3] # Defining 'cars' as list, will work just fine cars = list()\n\n1.3.3 References\n\nPython Documentation: Built-in functions\n\n1.4 Bad except clauses order\n\nWhen an exception occurs, Python will search for the ﬁrst exception clause which matches the exception type that occurred. It doesn’t need to be an exact match. If the exception clause represents a base class of the raised exception, then Python considers that exception clause to be a match. E.g. if a ZeroDivisionError exception is raised and the ﬁrst exception clause is Exception, then the Exception clause will execute because ZeroDivisionError is a sub class of Exception. Therefore, more speciﬁc exception clauses of sub classes should always be placed before the exception clauses of their base classes to ensure that exception handling is as speciﬁc and as helpful as possible.\n\n1.4.1 Anti-pattern\n\nThe code below performs a division operation that results in a ZeroDivisionError. The code contains an except clause for this type of error, which would be really useful because it pinpoints the exact cause of the problem. However, the ZeroDivisionError exception clause is unreachable because there is a Exception exception clause placed before it. When Python experiences an exception, it will linearly test each exception clause and execute the ﬁrst clause that matches the raised exception. The match does not need to be identical. So long as the raised exception is a sub class of the exception listed in the exception clause, then Python will execute that clause and will skip all other clauses. This defeats the purpose of exception clauses, which is to identify and handle exceptions with as much precision as possible.\n\ntry:\n\n5 / 0\n\nexcept Exception as e: print(\"Exception\")\n\n# unreachable code! except ZeroDivisionError as e: print(\"ZeroDivisionError\")\n\n6\n\n1. Correctness",
      "content_length": 2157,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 10,
      "content": "Python Anti-Patterns\n\n1.4.2 Best practice\n\nMove sub class exception clause before its ancestor’s clause\n\nThe modiﬁed code below places the ZeroDivisionError exception clause in front of the Exception exception clause. Now when the exception is triggered the ZeroDivisionError exception clause will execute, which is much more optimal because it is more speciﬁc.\n\ntry:\n\n5 / 0\n\nexcept ZeroDivisionError as e: print(\"ZeroDivisionError\")\n\nexcept Exception as e: print(\"Exception\")\n\n1.4.3 References\n\nPylint - E0701, bad-except-order\n\n1.5 Bad ﬁrst argument given to super()\n\nsuper() enables you to access the methods and members of a parent class without referring to the parent class by name. For a single inheritance situation the ﬁrst argument to super() should be the name of the current child class calling super(), and the second argument should be self (that is, a reference to the current object calling super()).\n\nNote: This anti-pattern only applies to Python versions 2.x, see “Super in Python 3” at the bottom of the page for the correct way of calling super() in Python 3.x.\n\n1.5.1 Anti-pattern\n\nPython raises a TypeError when it attempts to execute the call to super() below. The ﬁrst argument should be the name of the child class that is calling super(). The author of the code mistakenly provided self as the ﬁrst argument.\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\nclass Square(Rectangle):\n\ndef __init__(self, length):\n\n# bad first argument to super() super(self, Square).__init__(length, length)\n\ns = Square(5) print(s.area) # does not execute\n\n1. Correctness\n\n7",
      "content_length": 1665,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 11,
      "content": "Python Anti-Patterns\n\n1.5.2 Best practice\n\nInsert name of child class as ﬁrst argument to super()\n\nIn the modiﬁed code below the author has ﬁxed the call to super() so that the name of the child class which is calling super() (Square in this case) is the ﬁrst argument to the method.\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\nclass Square(Rectangle):\n\ndef __init__(self, length):\n\n# super() executes fine now super(Square, self).__init__(length, length)\n\ns = Square(5) print(s.area) # 25\n\n1.5.3 Super in Python 3\n\nPython 3 adds a new simpler super(), which requires no arguments. The correct way to call super() in Python 3 code is as follows.\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\nclass Square(Rectangle):\n\ndef __init__(self, length):\n\n# This is equivalent to super(Square, self).__init__(length, length) super().__init__(length, length)\n\ns = Square(5) print(s.area) # 25\n\n1.5.4 References\n\nPython Standard Library - super([type[, object-or-type]])\n\nStack Overﬂow - What is a basic example of single inheritance using super()?\n\nStack Overﬂow - Python super() inheritance and arguments needed\n\nPyLint - E1003, bad-super-call\n\nPEP 3135 - New Super\n\n8\n\n1. Correctness",
      "content_length": 1347,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 12,
      "content": "Python Anti-Patterns\n\n1.6 else clause on loop without a break statement\n\nThe else clause of a loop is executed when the loop sequence is empty. When a loop speciﬁes no break statement, the else clause will always execute, because the loop sequence will eventually always become empty. Sometimes this is the intended behavior, in which case you can ignore this error. But most times this is not the intended behavior, and you should therefore review the code in question.\n\n1.6.1 Anti-pattern\n\nThe code below demonstrates some potential unintended behavior that can result when a loop contains an else statement yet never speciﬁes a break statement. contains_magic_number() iterates through a list of numbers and compares each number to the magic number. If the magic number is found then the function prints The list contains the magic number. If it doesn’t then the function prints This list does NOT contain the magic number. When the code calls the function with a list of range(10) and a magic number of 5, you would expect the code to only print The list contains the magic number. However, the code also prints This list does NOT contain the magic number. This is because the range(10) list eventually becomes empty, which prompts Python to execute the else clause.\n\ndef contains_magic_number(numbers, magic_number):\n\nfor i in numbers:\n\nif i == magic_number:\n\nprint(\"This list contains the magic number\")\n\nelse:\n\nprint(\"This list does NOT contain the magic number\")\n\ncontains_magic_number(range(10), 5) # This list contains the magic number. # This list does NOT contain the magic number.\n\n1.6.2 Best practices\n\nInsert a break statement into the loop\n\nIf the else clause should not always execute at the end of a loop clause, then the code should add a break statement within the loop block.\n\ndef contains_magic_number(numbers, magic_number):\n\nfor i in numbers:\n\nif i == magic_number:\n\nprint(\"This list contains the magic number.\") # added break statement here break\n\nelse:\n\nprint(\"This list does NOT contain the magic number.\")\n\ncontains_magic_number(range(10), 5) # This list contains the magic number.\n\n1. Correctness\n\n9",
      "content_length": 2128,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 13,
      "content": "Python Anti-Patterns\n\n1.6.3 References\n\nPyLint - W0120, useless-else-on-loop\n\nPython Standard Library - else Clauses on Loops\n\n1.7 __exit__ must accept 3 arguments: type, value, traceback\n\nA contextmanager class is any class that implements the __enter__ and __exit__ methods according to the Python Language Reference’s context management protocol. Implementing the context management protocol enables you to use the with statement with instances of the class. The with statement is used to ensure that setup and teardown operations are always executed before and after a given block of code. It is functionally equivalent to try...finally blocks, except that with statements are more concise.\n\nFor example, the following block of code using a with statement...\n\nwith EXPRESSION:\n\nBLOCK\n\n... is equivalent to the following block of code using try and finally statements.\n\nEXPRESSION.__enter__() try:\n\nBLOCK\n\nfinally:\n\nEXPRESSION.__exit__(exception_type, exception_value, traceback)\n\nIn order for __exit__ to work properly it must have exactly three arguments: exception_type, exception_value, and traceback. The formal argument names in the method deﬁnition do not need to correspond directly to these names, but they must appear in this order. If any exceptions occur while at- tempting to execute the block of code nested after the with statement, Python will pass information about the exception into the __exit__ method. You can then modify the deﬁnition of __exit__ to gracefully handle each type of exception.\n\n1.7.1 Anti-pattern\n\nThe __exit__ method deﬁned in the Rectangle class below does not conform to Python’s context management protocol. The method is supposed to take four arguments: self, exception type, ex- ception value, and traceback. Because the method signature does not match what Python expects, __exit__ is never called even though it should have been, because the method divide_by_zero cre- ates a ZeroDivisionError exception.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height\n\ndef __enter__(self):\n\nprint(\"in __enter__\") return self def __exit__(self):\n\n# never called because # argument signature is wrong print(\"in __exit__\")\n\ndef divide_by_zero(self):\n\n# causes ZeroDivisionError exception\n\n(continues on next page)\n\n10\n\n1. Correctness",
      "content_length": 2310,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 14,
      "content": "Python Anti-Patterns\n\n(continued from previous page)\n\nreturn self.width / 0\n\nwith Rectangle(3, 4) as r: r.divide_by_zero() # __exit__ should be called but isn't\n\n# Output: # \"in __enter__\" # Traceback (most recent call last): # # # TypeError: __exit__() takes exactly 1 argument (4 given)\n\nFile \"e0235.py\", line 27, in <module>\n\nr.divide_by_zero()\n\n1.7.2 Best practices\n\nModifying __exit__ to accept four arguments ensures that __exit__ is properly called when an excep- tion is raised in the indented block of code following the with statement. Note that the argument names do not have to exactly match the names provided below. But they must occur in the order provided below.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height\n\ndef __enter__(self):\n\nprint(\"in __enter__\") return self\n\ndef __exit__(self, exception_type, exception_value, traceback):\n\nprint(\"in __exit__\")\n\ndef divide_by_zero(self):\n\n# causes ZeroDivisionError exception return self.width / 0\n\nwith Rectangle(3, 4) as r:\n\n# exception successfully pass to __exit__ r.divide_by_zero()\n\n# Output: # \"in __enter__\" # \"in __exit__\" # Traceback (most recent call last): # #\n\nFile \"e0235.py\", line 27, in <module>\n\nr.divide_by_zero()\n\n1.7.3 References\n\nPyLint - E0235,unexpected-special-method-signature\n\nPython Language Reference - The with statement\n\nPython Language Reference - With Statement Context Managers\n\nStack Overﬂow - Python with...as\n\n1. Correctness\n\n11",
      "content_length": 1471,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 15,
      "content": "Python Anti-Patterns\n\n1.8 Explicit return in __init__\n\n__init__ is a special Python method that is automatically called when memory is allocated for a new object. The sole purpose of __init__ is to initialize the values of instance members for the new object. Using __init__ to return a value implies that a program is using __init__ to do something other than initialize the object. This logic should be moved to another instance method and called by the program later, after initialization.\n\n1.8.1 Anti-pattern\n\nThe __init__ method of the Rectangle class below attempts to return the area of the rectangle within the __init__ method. This violates the rule of only using __init__ to initialize instance members.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height # causes \"Explicit return in __init__\" error return self.area\n\n1.8.2 Best practices\n\nRemove the return statement from the __init__ method\n\nRemove the return statement in the __init__ method that is returning a value.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height # return statement removed from here\n\nMove the program logic to another instance method\n\nThere is no reason why the Rectangle class MUST return the area immediately upon initialization. This program logic should be moved to a separate method of the Rectangle class. The program can call the method later, after the object has successfully initialized.\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self._area = width * height\n\n@property # moved the logic for returning area to a separate method def area(self):\n\nreturn self._area\n\nNote that the class must inherit from object now, since the property decorator only works for new style classes.\n\n12\n\n1. Correctness",
      "content_length": 1895,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 16,
      "content": "Python Anti-Patterns\n\n1.8.3 References\n\nPyLint - E0101, return-in-init\n\nPython Language Reference - object.__init__(self[, ...])\n\n1.9 __future__ import is not the ﬁrst non-docstring statement\n\nThe __future__ module enables a module to use functionality that is mandatory in future Python ver- sions. If it was possible to place the __future__ module in the middle of a module, then that would mean that one half of the module could use the old Python functionality for a given feature, and the other half (after the __future__ import) could use the new Python functionality of the feature. This could create many strange and hard-to-ﬁnd bugs, so Python does not allow it.\n\n1.9.1 Anti-pattern\n\nThe code below attempts to place a __future__ import statement in the middle of the module. When Python encounters the from __future__ import division statement it raises a SyntaxError and halts execution. However, if the code were to execute, the ﬁrst print statement would print out 1 (which is how the division operator behaves in Python versions 2 and below), but the second print statement would print out a decimal value, which is how the division operator functions in Python versions 3 and later. As you can see, this could create very strange behavior, so Python does not allow __future__ import statements in the middle of a module. The module can use either version of the division operator, but it can’t use both.\n\nprint(8 / 7) # 1\n\n# SyntaxError from __future__ import division\n\n# 1.1428571428571428 print(8 / 7)\n\n1.9.2 Best practice\n\nRemove __future__ import\n\nIn the modiﬁed code below, the author decides that the module needs to use the old functionality of the division operator. The only solution in this case is to remove the __future__ import statement from the module.\n\n# removed __future__ import statement print(8 / 7) # 1\n\nPlace __future__ import before all other statements\n\nIn the modiﬁed code below, the author decides that the module needs the new functionality of the division operator. The only solution then is to place the __future__ import statement at the beginning of the module\n\n1. Correctness\n\n13",
      "content_length": 2126,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 17,
      "content": "Python Anti-Patterns\n\nfrom __future__ import division\n\n# 1.1428571428571428 print(8 / 7)\n\n1.9.3 References\n\nPyLint - W0410, misplaced-future\n\nSimeon Visser - How does ‘from __future__ import ...’ work?\n\nPython Standard Library - __future__\n\n1.10 Implementing Java-style getters and setters\n\nPython is not Java. If you need to set or get the members of a class or object, just expose the member publicly and access it directly. If you need to perform some computations before getting or setting the member, then use Python’s built-in property decorator.\n\n1.10.1 Anti-pattern\n\nThe programmer below comes to Python from a long career as a Java programmer. For every class member that he wants to expose publicly, he deﬁnes a get and set method for that member. This is common practice in Java, but is frowned upon in Python as a waste of time and a cause of unnecessary code.\n\nclass Square(object):\n\ndef __init__(self, length):\n\nself._length = length\n\n# Java-style def get_length(self):\n\nreturn self._length\n\n# Java-style def set_length(self, length): self._length = length\n\nr = Square(5) r.get_length() r.set_length(6)\n\n1.10.2 Best practice\n\nAccess the members directly\n\nIn Python it is acceptable to simply access class or object members directly. The modiﬁed code below exposes the length member as a public member. This is signiﬁed by the fact that there is no underscore character at the beginning of the member name. The get_length() and set_length() methods are no longer necessary so they have been deleted.\n\nclass Square(object):\n\ndef __init__(self, length): self.length = length\n\n(continues on next page)\n\n14\n\n1. Correctness",
      "content_length": 1631,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 18,
      "content": "Python Anti-Patterns\n\n(continued from previous page)\n\nr = Square(5) r.length r.length = 6\n\nUse built-in property decorator\n\nWhen a member needs to be slightly protected and cannot be simply exposed as a public member, use Python’s property decorator to accomplish the functionality of getters and setters.\n\nclass Square(object):\n\ndef __init__(self, length):\n\nself._length = length\n\n@property def length(self):\n\nreturn self._length\n\n@length.setter def length(self, value): self._length = value\n\n@length.deleter def length(self):\n\ndel self._length\n\nr = Square(5) r.length # automatically calls getter r.length = 6 # automatically calls setter\n\n1.10.3 References\n\nPython Built-in Functions - property\n\ndirtSimple - Python Is Not Java\n\nStack Overﬂow - What’s the Pythonic Way to use getters and setters?\n\n1.11 Indentation contains mixed spaces and tabs\n\nPer the PEP 8 Style Guide, all Python code should be consistently indented with 4 spaces, never tabs.\n\n1.11.1 Anti-pattern\n\nThe following code mixes spaces and tabs for indentation. The print(\"Hello, World!\") statement is indented with a tab. The print(\"Goodybye, World!\") statement is indented with 4 spaces.\n\ndef print_hello_world(): # indented with tab\n\nprint(\"Hello, World!\") def print_goodbye_world():\n\n# indented with 4 spaces print(\"Goodbye, World!\")\n\n1. Correctness\n\n15",
      "content_length": 1327,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 19,
      "content": "Python Anti-Patterns\n\n1.11.2 Solutions\n\nConsistently indent with spaces\n\nAll Python code should be consistently indented with 4 spaces.\n\ndef print_hello_world():\n\nprint(\"Hello, World!\") # indented with 4 spaces\n\ndef print_goodbye_world():\n\nprint(\"Goodbye, World!\")\n\n# indented with 4 spaces\n\n1.11.3 References\n\nPEP 8 Style Guide - Tabs or Spaces?\n\nPEP 8 Style Guide - Indentation\n\n1.12 Indentation contains tabs\n\nPer the PEP 8 Style Guide, all Python code should be consistently indented with 4 spaces for each level of indentation, not tabs.\n\n1.12.1 Anti-pattern\n\nThe following code uses tabs for indentation. Python code should be indented with four spaces for each level of indentation.\n\ndef print_hello_world():\n\n# indented with tab print(\"Hello, World!\") def print_goodbye_world(): # indented with tab print(\"Goodbye, World!\")\n\n1.12.2 Best practice\n\nConsistently indent with spaces\n\nAll Python code should be consistently indented with 4 spaces.\n\ndef print_hello_world():\n\n# indented with 4 spaces print(\"Hello, World!\") def print_goodbye_world():\n\n# indented with 4 spaces print(\"Goodbye, World!\")\n\n16\n\n1. Correctness",
      "content_length": 1123,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 20,
      "content": "Python Anti-Patterns\n\n1.12.3 References\n\nPEP 8 Style Guide - Tabs or Spaces?\n\nPEP 8 Style Guide - Indentation\n\n1.13 Method could be a function\n\nWhen a method is not preceded by the @staticmethod or @classmethod decorators and does not con- tain any references to the class or instance (via keywords like cls or self), Python raises the Method could be a function error. This is not a critical error, but you should check the code in question in order to determine if this section of code really needs to be deﬁned as a method of this class.\n\n1.13.1 Anti-pattern\n\nIn the Rectangle class below the area method calculates the area of any rectangle given a width and a height.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\n# should be preceded by @staticmethod here def area(width, height):\n\nreturn width * height\n\narea causes the Method could be a function error because it is ambiguous. It does not reference the instance or class using the self or cls keywords and it is not preceded by the @staticmethod decorator.\n\nClass method is not preceded by @classmethod decorator\n\nIn the Rectangle class below the print_class_name method prints the name of the class. Again, Python raises the Method could be a function error because the method does not reference any class members or methods and is not preceded by the @classmethod decorator.\n\nFurthermore, the ﬁrst argument of a class method must be a reference to the class itself.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\n# should be preceded by @classmethod here # missing required first argument \"cls\" def print_class_name():\n\nprint(\"class name: Rectangle\")\n\n1. Correctness\n\n17",
      "content_length": 1783,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 21,
      "content": "Python Anti-Patterns\n\n1.13.2 Best practices\n\nAdd the @staticmethod decorator before the static method\n\nAll static methods must be preceded by the @staticmethod decorator.\n\nclass Rectangle:\n\n# clarifies that this is a static method and belongs here @staticmethod def area(width, height):\n\nreturn width * height\n\nAdd the @classmethod decorator before the class method\n\nAll class methods must be preceded by the @classmethod decorator. Furthermore, the ﬁrst argument of any class method must be cls, which is a reference to the class itself.\n\nclass Rectangle: @classmethod def print_class_name(cls):\n\n# \"class name: Rectangle\" print(\"class name: {0}\".format(cls))\n\n1.13.3 References\n\nPyLint - R0201, no-self-use\n\n1.14 Method has no argument\n\nUnlike some programming languages, Python does not pass references to instance or class objects auto- matically behind the scenes. So the program must explicitly pass them as arguments whenever it wants to access any members of the instance or class within a method.\n\n1.14.1 Anti-pattern\n\nIn the Rectangle class below the area method attempts to return the value of the area instance variable. However, self.area is undeﬁned because a reference to the instance object has not been explicitly passed as an argument to the method.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\n# missing first argument \"self\" def area():\n\n# self is undefined here return self.area\n\n18\n\n1. Correctness",
      "content_length": 1497,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 22,
      "content": "Python Anti-Patterns\n\nClass method is missing the cls keyword\n\nThe method print_class_name attempts to print the name of the class. However, to programmatically access a class name, a method needs to have a reference to the class object. This is accomplished by passing the keyword cls as the ﬁrst argument to the method. Because print_class_name does not do this, its reference to cls in the body of the method is undeﬁned.\n\nclass Rectangle: @classmethod # missing first argument \"cls\" def print_class_name():\n\n# cls is undefined here print(\"Hello, I am {0}!\".format(cls))\n\nThe method area computes the value of any rectangle. Currently this method is ambiguous. It is deﬁned as a method of the Rectangle class, yet it does not reference any instance or class members. The method needs to explicitly state that it is a static method via the @staticmethod decorator.\n\nclass Rectangle:\n\n# \"@staticmethod\" should be here def area(width, height):\n\nreturn width * height\n\n1.14.2 Best practices\n\nAdd the self parameter to instance methods\n\nTo access the area member of a Rectangle instance the ﬁrst argument of the area method needs to be a reference to the instance object, signiﬁed by the keyword self.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\n# instance members now accessible because of \"self\" def area(self):\n\nreturn self.area\n\nAdd the cls parameter to class methods\n\nTo access the name of the class the print_class_name method needs to explicitly pass an argument to the class object. This is done by adding the keyword cls as the ﬁrst argument of the method.\n\nclass Rectangle: @classmethod # class members now accessible, thanks to \"cls\" def print_class_name(cls):\n\nprint(\"Hello, I am {0}!\".format(cls))\n\nAdd the @staticmethod decorator to static methods\n\nIf the method is a static method that does not need access to any instance members, then the method should be preceded by the @staticmethod decorator. This improves readability by helping clarify that\n\n1. Correctness\n\n19",
      "content_length": 2060,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 23,
      "content": "Python Anti-Patterns\n\nthe method should never rely on any instance members.\n\nclass Rectangle:\n\n# clarifies that the method does not need any instance members @staticmethod def area(width, height):\n\nreturn width * height\n\n1.14.3 References\n\nPyLint - E0211, no-method-argument\n\n1.15 Missing argument to super()\n\nsuper() enables you to access the methods and members of a parent class without referring to the parent class by name. For a single inheritance situation the ﬁrst argument to super() should be the name of the current child class calling super(), and the second argument should be self, that is, a reference to the current object calling super().\n\nNote: This error is only raised for Python versions 2.x which don’t support new-style classes.\n\n1.15.1 Anti-pattern\n\nThe author of the code below provides no arguments for the child class’ call to super(). Python raises a TypeError at runtime because it expects at least 1 argument for super().\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\nclass Square(Rectangle):\n\ndef __init__(self, length):\n\n# no arguments provided to super() super().__init__(length, length)\n\ns = Square(5) print(s.area) # does not execute\n\n1.15.2 Best practice\n\nInsert name of child class as ﬁrst argument to super()\n\nIn the modiﬁed code below the author has ﬁxed the call to super() so that the name of the child class which is calling super() (Square in this case) is the ﬁrst argument to the method, and a reference to the object calling super() is the second argument.\n\n20\n\n1. Correctness",
      "content_length": 1607,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 24,
      "content": "Python Anti-Patterns\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height self.area = width * height\n\nclass Square(Rectangle):\n\ndef __init__(self, length):\n\n# super() executes fine now super(Square, self).__init__(length, length)\n\ns = Square(5) print(s.area) # 25\n\n1.15.3 References\n\nPyLint - E1004, missing-super-argument\n\nPython Standard Library - super([type[, object-or-type]])\n\nStack Overﬂow - What is a basic example of single inheritance using super()?\n\nStack Overﬂow - Python super() inheritance and arguments needed\n\n1.16 Using a mutable default value as an argument\n\nPassing mutable lists or dictionaries as default arguments to a function can have unforeseen consequences. Usually when a programmer uses a list or dictionary as the default argument to a function, the programmer wants the program to create a new list or dictionary every time that the function is called. However, this is not what Python does. The ﬁrst time that the function is called, Python creates a persistent object for the list or dictionary. Every subsequent time the function is called, Python uses that same persistent object that was created from the ﬁrst call to the function.\n\n1.16.1 Anti-pattern\n\nA programmer wrote the append function below under the assumption that the append function would return a new list every time that the function is called without the second argument. In reality this is not what happens. The ﬁrst time that the function is called, Python creates a persistent list. Every subsequent call to append appends the value to that original list.\n\ndef append(number, number_list=[]): number_list.append(number) print(number_list) return number_list\n\nappend(5) # expecting: [5], actual: [5] append(7) # expecting: [7], actual: [5, 7] append(2) # expecting: [2], actual: [5, 7, 2]\n\n1. Correctness\n\n21",
      "content_length": 1860,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 25,
      "content": "Python Anti-Patterns\n\n1.16.2 Best practice\n\nUse a sentinel value to denote an empty list or dictionary\n\nIf, like the programmer who implemented the append function above, you want the function to return a new, empty list every time that the function is called, then you can use a sentinel value to represent this use case, and then modify the body of the function to support this scenario. When the function receives the sentinel value, it knows that it is supposed to return a new list.\n\n# the keyword None is the sentinel value representing empty list def append(number, number_list=None):\n\nif number_list is None: number_list = []\n\nnumber_list.append(number) print(number_list) return number_list\n\nappend(5) # expecting: [5], actual: [5] append(7) # expecting: [7], actual: [7] append(2) # expecting: [2], actual: [2]\n\n1.16.3 References\n\nPyLint - W0102, dangerous-default-value\n\nStack Overﬂow - Hidden Features of Python\n\n1.17 No exception type(s) speciﬁed\n\nThe function divide simply divides a by b. To avoid invalid calculations (e.g., a division by zero), a try-except block is added. This is valid and ensures that the function always returns a result. However, by securing your code with the try clause, you might hide actual programming errors, e.g., that you pass a string or an object as b, instead of a number. By not specifying an exception type, you not only hide this error but you also lose information about the error itself.\n\n1.17.1 Anti-pattern\n\ndef divide(a, b):\n\ntry:\n\nresult = a / b\n\nexcept:\n\nresult = None\n\nreturn result\n\n22\n\n1. Correctness",
      "content_length": 1563,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 26,
      "content": "Python Anti-Patterns\n\n1.17.2 Best practice\n\nHandle exceptions with Python’s built in exception types.\n\ndef divide(a, b):\n\nresult = None\n\ntry:\n\nresult = a / b\n\nexcept ZeroDivisionError:\n\nprint(\"Type error: division by 0.\")\n\nexcept TypeError:\n\n# E.g., if b is a string print(\"Type error: division by '{0}'.\".format(b))\n\nexcept Exception as e:\n\n# handle any other exception print(\"Error '{0}' occured. Arguments {1}.\".format(e.message, e.args))\n\nelse:\n\n# Excecutes if no exception occured print(\"No errors\")\n\nfinally:\n\n# Executes always if result is None: result = 0\n\nreturn result\n\nWith this pattern, you are able to handle exceptions based on their actual exception-type. The ﬁrst exception type that matches the current error is handled ﬁrst. Thus, it is recommended to handle speciﬁc exception types ﬁrst (e.g., ZeroDivisionError) and generic error types (e.g., Exception) towards the end of the try- except block.\n\nCleanup actions (optional): The else-clause executes only, if no exception occurred. It is useful to log the success of your code. The ﬁnally-block executes under all circumstances — no matter if an error occured or not. It is useful to clean up the try-except block.\n\n1.17.3 Implement user deﬁned exceptions\n\nIn addition to Python’s standard exceptions, you can implement your own exception classes.\n\nclass DivisorTooSmallError(StandardError):\n\ndef __init__(self, arg): self.args = arg\n\ndef divide(a, b): if b < 1:\n\nraise DivisorTooSmallError\n\nreturn a / b\n\ntry:\n\ndivide(10, 0)\n\nexcept DivisorTooSmallError:\n\nprint(\"Unable to divide these numbers!\")\n\n1. Correctness\n\n23",
      "content_length": 1587,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 27,
      "content": "Python Anti-Patterns\n\n1.17.4 References\n\nPyLint W0702, bare-except\n\nPython Built-in Exceptions<https://docs.python.org/2/library/exceptions.html#exceptions.BaseException>\n\nPython Errors and Exceptions<https://docs.python.org/2/tutorial/errors.html>\n\n1.18 Not using defaultdict()\n\nWhen a dict is created using defaultdict(), the value for each key in the dict will default to the value provided as the ﬁrst argument of defaultdict(). This is more concise and less error-prone than manu- ally setting the value of each key.\n\n1.18.1 Anti-pattern\n\nThe code below deﬁnes an empty dict and then manually initializes the keys of the dict. Although there is nothing wrong with this code, there is a more concise and less error-prone way to achieve the same idea, as explained in the solution below.\n\nd = {}\n\nif \"k\" not in d:\n\nd[\"k\"] = 6\n\nd[\"k\"] += 1\n\nprint(d[\"k\"]) # 7\n\n1.18.2 Best practice\n\nUse defaultdict() to initialize dict keys\n\nThe modiﬁed code below uses defaultdict to initialize the dict. Whenever a new key is created, the default value for that key is 6. This code is functionally equivalent to the previous code, but this one is more concise and less error-prone, because every key automatically initializes to 6 with no work on the part of the programmer.\n\nfrom collections import defaultdict\n\nd = defaultdict(lambda : 6) d[\"k\"] += 1\n\nprint(d[\"k\"]) # 7\n\n24\n\n1. Correctness",
      "content_length": 1378,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 28,
      "content": "Python Anti-Patterns\n\n1.18.3 References\n\nPython Standard Library - collections.defaultdict\n\n1.19 Not using else where appropriate in a loop\n\nThe Python language provides a built-in else clause for for loops. If a for loop completes without being prematurely interrupted by a break or return statement, then the else clause of the loop is executed.\n\n1.19.1 Anti-pattern\n\nThe code below searches a list for a magic number. If the magic number is found in the list, then the code prints Magic number found. If the magic number is not found, then the code prints Magic number not found.\n\nThe code uses a ﬂag variable called found to keep track of whether or not the magic number was found in the list.\n\nThe logic in this code is valid; it will accomplish its task. But the Python language has built-in language constructs for handling this exact scenario and which can express the same idea much more concisely and without the need for ﬂag variables that track the state of the code.\n\nl = [1, 2, 3] magic_number = 4 found = False\n\nfor n in l:\n\nif n == magic_number: found = True print(\"Magic number found\") break\n\nif not found:\n\nprint(\"Magic number not found\")\n\n1.19.2 Best practice\n\nUse else clause with for loop\n\nIn Python, you can declare an else loop in conjunction with a for loop. If the for loop iterates to com- pletion without being prematurely interrupted by a break or return statement, then Python executes the else clause of the loop.\n\nIn the modiﬁed code below, the for loop will iterate through all three items in the list. Because the magic number is not contained in the list, the if statement always evaluates to False, and therefore the break statement is never encountered. Because Python never encounters a break statement while iterating over the loop, it executes the else clause.\n\nThe modiﬁed code below is functionally equivalent to the original code above, but this modiﬁed code is more concise than the original code and does not require any ﬂag variables for monitoring the state of the code.\n\n1. Correctness\n\n25",
      "content_length": 2036,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 29,
      "content": "Python Anti-Patterns\n\nl = [1, 2, 3] magic_number = 4\n\nfor n in l:\n\nif n == magic_number:\n\nprint(\"Magic number found\") break\n\nelse:\n\nprint(\"Magic number not found\")\n\nNote: Since else on a for loop is so unintuitive and error-prone, even some experienced Python devel- opers suggest not using this feature at all.\n\n1.19.3 References\n\nPython Language Reference - else Clauses on Loops\n\n1.20 Not using explicit unpacking\n\nWhen you see multiple variables being deﬁned followed by an assignment to a list (e.g. elem0, elem1, elem2 = elems, where elem0, elem1, and elem2 are variables and elems is a list), Python will auto- matically iterate through the list and assign elems[0] to elem0, elems[1] to elem1, and so on.\n\n1.20.1 Anti-pattern\n\nThe code below manually creates multiple variables to access the items in a list. This code is error-prone and unnecessarily verbose, as well as tedious to write.\n\nelems = [4, 7, 18]\n\nelem0 = elems[0] elem1 = elems[1] elem2 = elems[2]\n\n1.20.2 Best practice\n\nUse unpacking\n\nThe modiﬁed code below is functionally equivalent to the original code, but this code is more concise and less prone to error.\n\nelems = [4, 7, 18]\n\nelem0, elem1, elem2 = elems\n\n26\n\n1. Correctness",
      "content_length": 1203,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 30,
      "content": "Python Anti-Patterns\n\n1.21 Not using get() to return a default value from a dict\n\nFrequently you will see code create a variable, assign a default value to the variable, and then check a dict for a certain key. If the key exists, then the value of the key is copied into the value for the variable. While there is nothing wrong this, it is more concise to use the built-in method dict.get(key[, default]) from the Python Standard Library. If the key exists in the dict, then the value for that key is returned. If it does not exist, then the default value speciﬁed as the second argument to get() is returned. Note that the default value defaults to None if a second argument is not provided.\n\n1.21.1 Anti-pattern\n\nThe code below initializes a variable called data to an empty string. Then it checks if a certain key called message exists in a dict called dictionary. If the key exists, then the value of that key is copied into the data variable.\n\nAlthough there is nothing wrong with this code, it is verbose and inefﬁcient because it queries the dictionary twice. The solution below demonstrates how to express the same idea in a more concise manner by using dict.get(key[, default]).\n\ndictionary = {\"message\": \"Hello, World!\"}\n\ndata = \"\"\n\nif \"message\" in dictionary:\n\ndata = dictionary[\"message\"]\n\nprint(data)\n\n# Hello, World!\n\n1.21.2 Best practice\n\nUse dict.get(key[, default]) to assign default values\n\nThe code below is functionally equivalent to the original code above, but this solution is more concise.\n\nWhen get() is called, Python checks if the speciﬁed key exists in the dict. If it does, then get() returns the value of that key. If the key does not exist, then get() returns the value speciﬁed in the second argument to get().\n\ndictionary = {\"message\": \"Hello, World!\"}\n\ndata = dictionary.get(\"message\", \"\")\n\nprint(data)\n\n# Hello, World!\n\n1. Correctness\n\n27",
      "content_length": 1873,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 31,
      "content": "Python Anti-Patterns\n\n1.21.3 References\n\nPython Standard Library - dict.get\n\n1.22 Not using setdefault() to initialize a dictionary\n\nWhen initializing a dictionary, it is common to see a code check for the existence of a key and then create the key if it does not exist. Although there is nothing wrong with this, the exact same idea can be accomplished more concisely by using the built-in dictionary method setdefault().\n\n1.22.1 Anti-pattern\n\nThe code below checks if a key named list exists in a dictionary called dictionary. If it does not exist, then the code creates the key and then sets its value to an empty list. The code then proceeds to append a value to the list.\n\nAlthough there is nothing wrong with this code, it is unnecessarily verbose. Later you will see how you can use setdefault() to accomplish the same idea more concisely.\n\ndictionary = {}\n\nif \"list\" not in dictionary:\n\ndictionary[\"list\"] = []\n\ndictionary[\"list\"].append(\"list_item\")\n\n1.22.2 Best practice\n\nUse setdefault() to initialize a dictionary\n\nThe modiﬁed code below uses setdefault() to initialize the dictionary. When setdefault() is called, it will check if the key already exists. If it does exist, then setdefault() does nothing. If the key does not exist, then setdefault() creates it and sets it to the value speciﬁed in the second argument.\n\ndictionary = {}\n\ndictionary.setdefault(\"list\", []).append(\"list_item\")\n\n1.22.3 References\n\nStack Overﬂow - Use cases for the setdefault dict method\n\n28\n\n1. Correctness",
      "content_length": 1500,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 32,
      "content": "Python Anti-Patterns\n\n2 Maintainability\n\nA program is maintainable if it is easy to understand and modify the code even for someone that is unfa- miliar with the code base.\n\nAvoid the following anti-patterns to increase maintainability and avoid creating spaghetti code.\n\n2.1 using wildcard imports (from ... import *)\n\nWhen an import statement in the pattern of from MODULE import * is used it may become difﬁcult for a Python validator to detect undeﬁned names in the program that imported the module. Furthermore, as a general best practice, import statements should be as speciﬁc as possible and should only import what they need.\n\n2.1.1 Anti-pattern\n\nThe following code imports everything from the math built-in Python module.\n\n# wildcard import = bad from math import *\n\n2.1.2 Best practices\n\nMake the import statement more speciﬁc\n\nThe import statement should be refactored to be more speciﬁc about what functions or variables it is using from the math module. The modiﬁed code below speciﬁes exactly which module member it is using, which happens to be ceil in this example.\n\nfrom math import ceil\n\nImport the whole module\n\nThere are some cases where making the import statement speciﬁc is not a good solution:\n\nIt may be unpractical or cumbersome to create or maintain the list of objects to be imported from a module\n\nA direct import would bind to the same name as that of another object (e.g. from asyncio import TimeoutError)\n\nThe module that the object is imported from would provide valuable contextual information if it is right next to the object when it’s used.\n\nIn these cases, use one of these idioms:\n\nimport math x = math.ceil(y)\n\n# or\n\nimport multiprocessing as mp pool = mp.Pool(8)\n\n2. Maintainability\n\n29",
      "content_length": 1728,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 33,
      "content": "Python Anti-Patterns\n\n2.1.3 References\n\nStack Overﬂow - Importing Modules\n\nStack Overﬂow - ‘import module’ or ‘from module import’\n\n2.2 Not using with to open ﬁles\n\nIn Python 2.5, the file class was equipped with special methods that are automatically called whenever a ﬁle is opened via a with statement (e.g. with open(\"file.txt\", \"r\") as file). These special methods ensure that the ﬁle is properly and safely opened and closed.\n\n2.2.1 Anti-pattern\n\nThe code below does not use with to open a ﬁle. This code depends on the programmer remembering to manually close the ﬁle via close() when ﬁnished. Even if the programmer remembers to call close() the code is still dangerous, because if an exception occurs before the call to close() then close() will not be called and the memory issues can occur, or the ﬁle can be corrupted.\n\nf = open(\"file.txt\", \"r\") content = f.read() 1 / 0 # never executes, possible memory issues or file corruption f.close()\n\n# ZeroDivisionError\n\n2.2.2 Best practice\n\nUse with to open a ﬁle\n\nThe modiﬁed code below is the safest way to open a ﬁle. The file class has some special built-in methods called __enter__() and __exit__() which are automatically called when the ﬁle is opened and closed, respectively. Python guarantees that these special methods are always called, even if an exception occurs.\n\nwith open(\"file.txt\", \"r\") as f:\n\ncontent = f.read() # Python still executes f.close() even though an exception occurs 1 / 0\n\n2.2.3 References\n\neffbot - Understanding Python’s with statement\n\n30\n\n2. Maintainability",
      "content_length": 1547,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 34,
      "content": "Python Anti-Patterns\n\n2.3 Returning more than one variable type from function call\n\nIf a function that is supposed to return a given type (e.g. list, tuple, dict) suddenly returns something else (e.g. None) the caller of that function will always need to check the type of the return value before proceeding. This makes for confusing and complex code. If the function is unable to produce the supposed return value it is better to raise an exception that can be caught by the caller instead.\n\n2.3.1 Anti-pattern\n\nIn the code below, the function get_secret_code() returns a secret code when the code calling the If the password is incorrect, the function returns None. This function provides the correct password. leads to hard-to-maintain code, because the caller will have to check the type of the return value before proceeding.\n\ndef get_secret_code(password):\n\nif password != \"bicycle\":\n\nreturn None\n\nelse:\n\nreturn \"42\"\n\nsecret_code = get_secret_code(\"unicycle\")\n\nif secret_code is None:\n\nprint(\"Wrong password.\")\n\nelse:\n\nprint(\"The secret code is {}\".format(secret_code))\n\n2.3.2 Best practice\n\nRaise an exception when an error is encountered or a precondition is unsatisﬁed\n\nWhen invalid data is provided to a function, a precondition to a function is not satisﬁed, or an error occurs during the execution of a function, the function should not return any data. Instead, the function should raise an exception. In the modiﬁed version of get_secret_code() shown below, ValueError is raised when an incorrect value is given for the password argument.\n\ndef get_secret_code(password):\n\nif password != \"bicycle\": raise ValueError\n\nelse:\n\nreturn \"42\"\n\ntry:\n\nsecret_code = get_secret_code(\"unicycle\") print(\"The secret code is {}\".format(secret_code))\n\nexcept ValueError:\n\nprint(\"Wrong password.\")\n\n2. Maintainability\n\n31",
      "content_length": 1818,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 35,
      "content": "Python Anti-Patterns\n\n2.4 Using the global statement\n\nGlobal variables are dangerous because they can be simultaneously accessed from multiple sections of a program. This frequently results in bugs. Most bugs involving global variables arise from one function reading and acting on the value of a global variable before another function has the chance to set it to an appropriate value.\n\nGlobal variables also make code difﬁcult to read, because they force you to search through multiple func- tions or even modules just to understand all the different locations where the global variable is used and modiﬁed.\n\n2.4.1 Examples\n\nThe code below uses global variables and a function to compute the area and perimeter of a rectangle. As you can see, even with two functions it becomes difﬁcult to keep track of how the global variables are used and modiﬁed.\n\nWIDTH = 0 # global variable HEIGHT = 0 # global variable\n\ndef area(w, h):\n\nglobal WIDTH # global statement global HEIGHT # global statement WIDTH = w HEIGHT = h return WIDTH * HEIGHT\n\ndef perimeter(w, h):\n\nglobal WIDTH # global statement global HEIGHT # global statement WIDTH = w HEIGHT = h return ((WIDTH * 2) + (HEIGHT * 2))\n\nprint(\"WIDTH:\" , WIDTH) # \"WIDTH: 0\" print(\"HEIGHT:\" , HEIGHT) # \"HEIGHT: 0\"\n\nprint(\"area():\" , area(3, 4)) # \"area(): 12\"\n\nprint(\"WIDTH:\" , WIDTH) # \"WIDTH: 3\" print(\"HEIGHT:\" , HEIGHT) # \"HEIGHT: 4\"\n\n2.4.2 Solutions\n\nEncapsulate the global variables into objects\n\nOne common solution for avoiding global variables is to create a class and store related global variables as members of an instantiated object of that class. This results in more compact and safer code.\n\nIn the modiﬁed code below, the author eliminates the need for the global variables WIDTH and HEIGHT by encapsulating this data into a class called Rectangle.\n\nclass Rectangle:\n\ndef __init__(self, width, height):\n\nself.width = width\n\n(continues on next page)\n\n32\n\n2. Maintainability",
      "content_length": 1934,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 36,
      "content": "Python Anti-Patterns\n\n(continued from previous page)\n\nself.height = height\n\ndef area(self):\n\nreturn self.width * self.height\n\ndef circumference(self):\n\nreturn ((self.width * 2) + (self.height * 2))\n\nr = Rectangle(3, 4) print(\"area():\" , r.area())\n\n2.4.3 References\n\nCunningham & Cunningham, Inc. - Global Variables Are Bad\n\nPyLint - W0603, global-statement\n\n2.5 Using single letter to name your variables\n\nSometimes you see programmers trying to shorten the amount of text needed to write a piece of code, but when this goes to extremes, it will result in extremely ugly and unreadable code.\n\n2.5.1 Anti-pattern\n\nd = {'data': [{'a': 'b'}, {'b': 'c'}, {'c': 'd'}], 'texts': ['a', 'b', 'c']}\n\nfor k, v in d.iteritems():\n\nif k == 'data': for i in v:\n\n# Do you know what are you iterating now? for k2, v2 in i.iteritems():\n\nprint(k2, v2)\n\n2.5.2 Best practice\n\nUse more verbose names for your variables for clarity\n\nIt is much better to write more text and to be much more precise about what each variable means.\n\ndata_dict = {\n\n'data': [{'a': 'b'}, {'b': 'c'}, {'c': 'd'}], 'texts': ['a', 'b', 'c']\n\n}\n\nfor key, value in data_dict.iteritems():\n\nif key == 'data':\n\nfor data_item in value:\n\n# Do you know what are you iterating now? for data_key, data_value in data_item.iteritems():\n\nprint(data_key, data_value)\n\n2. Maintainability\n\n33",
      "content_length": 1330,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 37,
      "content": "Python Anti-Patterns\n\n2.6 Dynamically creating variable/method/function names\n\nSometimes a programmer gets an idea to make his/her work easier by creating magically working code that uses setattr() and getattr() functions to set some variable. While this may look like a good idea, because there is no need to write all the methods by hand, you are asking for trouble down the road.\n\n2.6.1 Example\n\nConsider the following code. You have some data and want to update the class with all of the data. Of course you don’t want to do this by hand, especially if there are tons of items in data_dict. However, when refactoring this kind of code after several years, and you’d like to know where some variable is added to this class, you’d usually use grep or ack_grep to ﬁnd it. But when setting variables/methods/functions like this, you’re screwed.\n\ndata_dict = {'var1': 'Data1', 'var2': 'Data2'}\n\nclass MyAwesomeClass:\n\ndef __init__(self, data_dict):\n\nfor key, value in data_dict.iteritems():\n\nsetattr(self, key, value)\n\nWhile previous example may look easy to ﬁnd and debug, consider this:\n\ndata_list = ['dat1', 'dat2', 'dat3'] data_dict = {'dat1': [1, 2, 3], 'dat2': [4, 5, 6], 'dat3': [7, 8, 9], 'dat4': [0, 4, 6]}\n\nclass MyAwesomeClass:\n\ndef __init__(self, data_list, data_dict):\n\ncounter = 0\n\nfor key, value in data_dict.iteritems():\n\nif key in data_list:\n\nsetattr(self, key, value)\n\nelse:\n\nsetattr(self, 'unknown' + str(counter), value) counter += 1\n\nNow the class contains also unknownX variables indexed by their count. Well, what a nice mess we created here. Try to ﬁnd a year later where these variables come from.\n\n34\n\n2. Maintainability",
      "content_length": 1645,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 38,
      "content": "Python Anti-Patterns\n\n2.6.2 Solutions\n\nFind another way\n\nWhile the approach in the examples above may be the easiest to write, it is the worst to maintain later. You should always try to ﬁnd another way to solve your problem.\n\nTypical examples:\n\nUse function to parse incoming data\n\nUse the data dict/list itself without class\n\nThis however depends on the task at hand.\n\n2. Maintainability\n\n35",
      "content_length": 393,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 39,
      "content": "Python Anti-Patterns\n\n3 Readability\n\n3.1 Asking for permission instead of forgiveness\n\nThe Python community uses an EAFP (easier to ask for forgiveness than permission) coding style. This coding style assumes that needed variables, ﬁles, etc. exist. Any problems are caught as exceptions. This results in a generally clean and concise style containing a lot of try and except statements.\n\n3.1.1 Anti-pattern\n\nThe code below uses an if statement to check if a ﬁle exists before attempting to use the ﬁle. This is not the preferred coding style in the Python community. The community prefers to assume that a ﬁle exists and you have access to it, and to catch any problems as exceptions.\n\nimport os\n\n# violates EAFP coding style if os.path.exists(\"file.txt\"): os.unlink(\"file.txt\")\n\n3.1.2 Best practice\n\nAssume the ﬁle can be used and catch problems as exceptions\n\nThe updated code below is a demonstration of the EAFP coding style, which is the preferred style in the Python community. Unlike the original code, the modiﬁed code below simply assumes that the needed ﬁle exists, and catches any problems as exceptions. For example, if the ﬁle does not exist, the problem will be caught as an OSError exception.\n\nimport os\n\ntry:\n\nos.unlink(\"file.txt\")\n\n# raised when file does not exist except OSError:\n\npass\n\n3.1.3 References\n\nPython 2.7.8 - Glossary\n\n36\n\n3. Readability",
      "content_length": 1368,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 40,
      "content": "Python Anti-Patterns\n\n3.2 Comparing things to None the wrong way\n\nPer the PEP 8 Style Guide, the preferred way to compare something to None is the pattern if Cond is None. This is only a guideline. It can be ignored if needed. But the purpose of the PEP 8 style guidelines is to improve the readability of code.\n\n3.2.1 Anti-pattern\n\nThe statement below uses the equality operator to compare a variable to None. This is not the PEP 8 preferred approach to comparing values to None.\n\nnumber = None\n\nif number == None:\n\nprint(\"This works, but is not the preferred PEP 8 pattern\")\n\n3.2.2 Best practice\n\nCompare values to None using the pattern if cond is None\n\nThe code below uses the PEP 8 preferred pattern of if cond is None.\n\nnumber = None\n\nif number is None:\n\nprint(\"PEP 8 Style Guide prefers this pattern\")\n\nHere the identity operator is is used. It will check whether number is identical to None. is will return to True only if the two variables point to the same object.\n\n3.2.3 References\n\nPEP 8 Style Guide - Programming Recommendations\n\nstackoverﬂow\n\n3.3 Comparing things to True the wrong way\n\nPer the PEP 8 Style Guide, the preferred ways to compare something to True are the patterns if cond is True: or if cond:. This is only a guideline. It can be ignored if needed. But the purpose of the PEP 8 Style Guide is to improve the readability of code.\n\n3. Readability\n\n37",
      "content_length": 1377,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 41,
      "content": "Python Anti-Patterns\n\n3.3.1 Anti-pattern\n\nThe statement below uses the equality operator to compare a boolean variable to True. This is not the PEP 8 preferred approach to comparing values to True. For sure, it is an anti-pattern not only in Python but in almost every programming language.\n\nflag = True\n\n# Not PEP 8's preferred pattern if flag == True:\n\nprint(\"This works, but is not the preferred PEP 8 pattern\")\n\n3.3.2 Best practices\n\nEvaluating conditions without comparing to True:\n\nThe code below uses the PEP 8 preferred pattern of if condition:. If the type of the condition is Boolean, it is obvious that comparing to True is redundant. But in Python, every non-empty value is treated as true in context of condition checking, see Python documentation:\n\nIn the context of Boolean operations, and also when expressions are used by control ﬂow state- ments, the following values are interpreted as false: False, None, numeric zero of all types, and empty strings and containers (including strings, tuples, lists, dictionaries, sets and frozensets). All other values are interpreted as true.\n\nflag = True\n\nif flag:\n\nprint(\"PEP 8 Style Guide prefers this pattern\")\n\nCompare values to True using the pattern if cond is True:\n\nThe code below uses the pattern described in PEP 8 as worse:\n\nflag = True\n\nif flag is True:\n\nprint(\"PEP 8 Style Guide abhors this pattern\")\n\nThis pattern is useful, when you make actual distinction between True value and every other that could be treated as true. The same applies to if cond is False. This expression is true only if cond has actual value of False - not empty list, empty tuple, empty set, zero etc.\n\n3.3.3 References\n\nPEP 8 Style Guide - Programming Recommendations\n\n38\n\n3. Readability",
      "content_length": 1733,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 42,
      "content": "Python Anti-Patterns\n\n3.4 Using type() to compare types\n\nThe function isinstance is the best-equipped to handle type checking because it supports inheritance (e.g. an instance of a derived class is an instance of a base class, too). Therefore isinstance should be used whenever type comparison is required.\n\n3.4.1 Anti-pattern\n\nThe if statement below uses the pattern if type(OBJECT) is types.TYPE to compare a Rectangle object to a built-in type (ListType in this example). This is not the preferred pattern for comparing types.\n\nimport types\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height\n\nr = Rectangle(3, 4)\n\n# bad if type(r) is types.ListType:\n\nprint(\"object r is a list\")\n\nNote that the following situation will not raise the error, although it should.\n\nimport types\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width self.height = height\n\nclass Circle(object):\n\ndef __init__(self, radius): self.radius = radius\n\nc = Circle(2) r = Rectangle(3, 4)\n\n# bad if type(r) is not type(c):\n\nprint(\"object types do not match\")\n\n3.4.2 Best practice\n\nUse isinstance to compare types\n\nThe preferred pattern for comparing types is the built-in function isinstance.\n\nimport types\n\nclass Rectangle(object):\n\ndef __init__(self, width, height):\n\nself.width = width\n\n(continues on next page)\n\n3. Readability\n\n39",
      "content_length": 1385,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 43,
      "content": "Python Anti-Patterns\n\n(continued from previous page)\n\nself.height = height\n\nr = Rectangle(3, 4)\n\n# good if isinstance(r, types.ListType):\n\nprint(\"object r is a list\")\n\n3.4.3 References\n\nStack Overﬂow: Differences between isinstance() and type() in Python\n\n3.5 Not using dict comprehensions\n\nYou may encounter the old style of initializing a dict (passing an iterable of key-value pairs) in older Python code written before version 2.7. The new dict comprehension style is functionally equivalent and is much more readable. Consider refactoring the old-style code to use the new style (but only if you are using Python 2.7 or higher).\n\n3.5.1 Anti-pattern\n\nThe code below demonstrates the old syntax of dict initialization. Although there is nothing syntactically wrong with this code, it is somewhat hard to read.\n\nnumbers = [1,2,3]\n\n# hard to read my_dict = dict([(number,number*2) for number in numbers])\n\nprint(my_dict) # {1: 2, 2: 4, 3: 6}\n\n3.5.2 Best practice\n\nThe modiﬁed code below uses the new dict comprehension syntax which was introduced in Python 2.7.\n\nnumbers = [1, 2, 3]\n\nmy_dict = {number: number * 2 for number in numbers}\n\nprint(my_dict) # {1: 2, 2: 4, 3: 6}\n\n40\n\n3. Readability",
      "content_length": 1194,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 44,
      "content": "Python Anti-Patterns\n\n3.5.3 References\n\nStack Overﬂow - Create a dictionary with list comprehesion\n\n3.6 Not using dict keys when formatting strings\n\nWhen formatting a string with values from a dictionary, you can use the dictionary keys instead of explicity deﬁning all of the format parameters. Consider this dictionary that stores the name and age of a person.\n\nperson = {\n\n'first': 'Tobin', 'age': 20\n\n}\n\n3.6.1 Anti-pattern\n\nHere is an example of formatting the string with values from the person. This is bad! If we added another key-value pair to the person dictionary, we would have to change the string and the format arguments\n\nperson = {\n\n'first': 'Tobin', 'age':20\n\n}\n\nprint('{0} is {1} years old'.format(\n\nperson['first'], person['age'])\n\n) # Output: Tobin is 20 years old\n\nperson = {\n\n'first': 'Tobin', 'last': 'Brown', 'age':20\n\n}\n\n# Bad: we have to change the replacement fields within # our string, once we add new values print('{0} {1} is {2} years old'.format(\n\nperson['first'], person['last'], person['age'])\n\n) # bad # Output: Tobin Brown is 20 years old\n\n3. Readability\n\n41",
      "content_length": 1093,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 45,
      "content": "Python Anti-Patterns\n\n3.6.2 Best practice\n\nBy using the dictionary keys in the string we are formatting, the code is much more readable and explicit.\n\nperson = {\n\n'first': 'Tobin', 'age':20\n\n}\n\nprint('{first} is {age} years old'.format(**person)) # Output: Tobin is 20 years old\n\nperson = {\n\n'first':'Tobin', 'last': 'Brown', 'age':20\n\n} print('{first} {last} is {age} years old'.format(**person)) # Output: Tobin Brown is 20 years old\n\nGoing even further, the same result can be achieved with your own objects by using obj.__dict__.\n\nclass Person(object):\n\ndef __init__(self, first, last, age):\n\nself.first = first self.last = last self.age = age\n\ndef __str__(self):\n\nreturn '{first} {last} is {age} years old'.format(**self.__dict__)\n\nperson = Person('Tobin', 'Brown', 20) print(person) # Output: Tobin Brown is 20 years old\n\n3.7 Not using items() to iterate over a dictionary\n\nPEP 20 states “There should be one– and preferably only one –obvious way to do it.” The preferred way to iterate over the key-value pairs of a dictionary is to declare two variables in a for loop, and then call dictionary.items(), where dictionary is the name of your variable representing a dictionary. For each loop iteration, Python will automatically assign the ﬁrst variable as the key and the second variable as the value for that key.\n\n42\n\n3. Readability",
      "content_length": 1341,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 46,
      "content": "Python Anti-Patterns\n\n3.7.1 Anti-pattern\n\nThe code below deﬁnes a for loop that iterates over a dictionary named d. For each loop iteration Python automatically assigns the value of key to the name of the next key in the dictionary. Inside of the for loop the code uses key to access the value of each key of the dictionary. This is a common way for iterating over a dictionary, but it is not the preferred way in Python.\n\nd = {\"first_name\": \"Alfred\", \"last_name\":\"Hitchcock\"}\n\nfor key in d:\n\nprint(\"{} = {}\".format(key, d[key]))\n\n3.7.2 Best-practice\n\nUse items() to iterate across dictionary\n\nThe updated code below demonstrates the Pythonic style for iterating through a dictionary. When you deﬁne two variables in a for loop in conjunction with a call to items() on a dictionary, Python auto- matically assigns the ﬁrst variable as the name of a key in that dictionary, and the second variable as the corresponding value for that key.\n\nd = {\"first_name\": \"Alfred\", \"last_name\":\"Hitchcock\"}\n\nfor key,val in d.items():\n\nprint(\"{} = {}\".format(key, val))\n\n3.7.3 Difference Python 2 and Python 3\n\nIn python 2.x the above examples using items would return a list with tuples containing the copied key- value pairs of the dictionary. In order to not copy and with that load the whole dictionary’s keys and values inside a list to the memory you should prefer the iteritems method which simply returns an iterator instead of a list. In Python 3.x the iteritems is removed and the items method returns view objects. The beneﬁt of these view objects compared to the tuples containing copies is that every change made to the dictionary is reﬂected in the view objects.\n\n3.7.4 References\n\nPEP 20 - The Zen of Python\n\nPython 2 dict.iteritems\n\nPython 3 dict.items\n\n3. Readability\n\n43",
      "content_length": 1773,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 47,
      "content": "Python Anti-Patterns\n\n3.8 Not using named tuples when returning more than one value from a function\n\nNamed tuples can be used anywhere where normal tuples are acceptable, but their values can be accessed through their names in addition to their indexes. This makes the code more verbose and readable.\n\n3.8.1 Anti-pattern\n\nThe code below returns a ﬁrst name, middle name, and last name using a normal, unnamed tuple. After calling the tuple, each value can only be returned via an index. This code is difﬁcult to use: the caller of the function has to know that the ﬁrst element is the ﬁrst name, the second is the middle name, and the third is the last name.\n\ndef get_name():\n\nreturn \"Richard\", \"Xavier\", \"Jones\"\n\nname = get_name()\n\n# no idea what these indexes map to! print(name[0], name[1], name[2])\n\n3.8.2 Best practice\n\nUse named tuples to return multiple values\n\nThe modiﬁed code below uses named tuples to return multiple values. This code is easier to use and easier to read, as now the caller can access each piece of data via a straightforward name (like name.first).\n\nfrom collections import namedtuple\n\ndef get_name():\n\nname = namedtuple(\"name\", [\"first\", \"middle\", \"last\"]) return name(\"Richard\", \"Xavier\", \"Jones\")\n\nname = get_name()\n\n# much easier to read print(name.first, name.middle, name.last)\n\n3.8.3 References\n\nPython Standard Libary - collections.namedtuple\n\n3.9 Not using unpacking for updating multiple values at once\n\nIn general, the Python programming community prefers concise code over verbose code. Using unpacking to update the values of multiple variables simultaneously is more concise than using assignments to update each variable individually.\n\n44\n\n3. Readability",
      "content_length": 1698,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 48,
      "content": "Python Anti-Patterns\n\n3.9.1 Anti-pattern\n\nThe function below implements the classical Euclid algorithm for greatest common divisor. The updates of the variables a and b are made using variable temp and three lines of code.\n\ndef gcd(a, b):\n\nwhile b != 0:\n\ntemp = b b = a % b a = temp\n\nreturn a\n\n3.9.2 Best practice\n\nUse unpacking to update multiple values simultaneously\n\nThe modiﬁed code below is functionally equivalent to the original code above, but this code is more concise.\n\ndef gcd(a, b):\n\nwhile b != 0:\n\na, b = b, a % b\n\nreturn a\n\n3.9.3 Gotchas\n\nThe unpacking can be sometimes quite misleading. Figure out what is the outcome of the code below.\n\nb = \"1984\" a = b, c = \"AB\" print(a, b, c)\n\n3.10 Not using zip() to iterate over a pair of lists\n\nPEP 20 states “There should be one– and preferably only one –obvious way to do it.” The preferred way to iterate through a pair of lists is to declare two variables in a loop expression, and then call zip(list_one, list_two), where list_one and list_two are the two lists you wish to iterate through. For each loop iteration, Python will automatically assign the ﬁrst variable as the next value in the ﬁrst list, and the second variable as the next value in the second list.\n\n3.10.1 Anti-pattern\n\nThe code below deﬁnes a variable index which serves as an index variable for iterating through two lists. Within the for loop the code accesses the corresponding value for each list by using the index variable. This is a common way for iterating through two lists, but it is not the preferred way in Python.\n\nnumbers = [1, 2, 3] letters = [\"A\", \"B\", \"C\"]\n\nfor index in range(len(numbers)):\n\nprint(numbers[index], letters[index])\n\n3. Readability\n\n45",
      "content_length": 1696,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 49,
      "content": "Python Anti-Patterns\n\n3.10.2 Best-practice\n\nUse zip() to iterate through a pair of lists\n\nThe updated code below demonstrates the Pythonic style for iterating through a pair of lists. When the code deﬁnes two variables in its for loop in conjunction with a call to zip(numbers, letters) on the pair of lists, Python automatically assigns the ﬁrst variable as the next value in the ﬁrst list, and the second variable as the next value in the second list.\n\nnumbers = [1, 2, 3] letters = [\"A\", \"B\", \"C\"]\n\nfor numbers_value, letters_value in zip(numbers, letters):\n\nprint(numbers_value, letters_value)\n\n3.10.3 References\n\nPEP 20 - The Zen of Python\n\nBuilt-in Functions > zip(*iterables)\n\n3.11 Putting type information in a variable name\n\nPython is a duck-typed language. Just because a variable is described as an integer does not mean that it actually is an integer. This can be very dangerous for any programmer who acts on the variable assuming that it is an integer. Note that the practice of including type notation in variable names is also called Hungarian Notation.\n\n3.11.1 Anti-pattern\n\nThe code below demonstrates the dangers of variables whose names include type notation. Just because a variable is called n_int does not mean that the variable is actually an integer.\n\nn_int = \"Hello, World!\"\n\n# mistakenly assuming that n_int is a number 4 / n_int\n\n3.11.2 Best practice\n\nRemove type notation\n\nAlthough the modifed code below does not ﬁx the underlying problem of attempting to divide a number by a string, the code is generally less misleading, because there is no misleading description in the variable name n that n is a number.\n\nn = \"Hello, World!\"\n\n# still a problem, but less misleading now 4 / n\n\n46\n\n3. Readability",
      "content_length": 1730,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 50,
      "content": "Python Anti-Patterns\n\n3.11.3 References\n\nStack Overﬂow - Hungarian Notation\n\n3.12 Test for object identity should be is\n\nTesting the identity of two objects can be achieved in python with a special operator called is. Most prominently it is used to check whether a variable points to None. But the operator can examine any kind of identity. This often leads to confusion because equality of two different objects will return False.\n\n3.12.1 Anti-pattern\n\na = range(10) b = range(10)\n\nprint((a is b))\n\nThis code snippet will print False even though a and b have equal values. This can occur because a and b are references that point to different objects which happen to have the same value. To verify the equality of two variables the == operator should be used.\n\n3.12.2 Best practice\n\nOnly use the is operator if you want to check the exact identity of two references.\n\nsome_list = None\n\nif some_list is None:\n\ndo_somthing_with_the_list()\n\n3.12.3 References\n\nPEP8 Style Guide - Programming Recommendations\n\n3.13 Using an unpythonic loop\n\nPEP 20 states “There should be one– and preferably only one –obvious way to do it.” Creating a loop that uses an incrementing index to access each element of a list within the loop construct is not the preferred style for accessing each element in a list. The preferred style is to use enumerate() to simultaneously retrieve the index and list element.\n\n3. Readability\n\n47",
      "content_length": 1409,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 51,
      "content": "Python Anti-Patterns\n\n3.13.1 Anti-pattern\n\nThe code below uses an index variable i in a for loop to iterate through the elements of a list. This is not the preferred style for iterating through a list in Python.\n\nl = [1,2,3]\n\n# creating index variable for i in range(0,len(l)):\n\n# using index to access list le = l[i] print(i,le)\n\n3.13.2 Best practice\n\nRetrieve index and element when deﬁning loop\n\nThe updated code below demonstrates the Pythonic style for iterating through a list. When you deﬁne two variables in a for loop in conjunction with a call to enumerate() on a list, Python automatically assigns the ﬁrst variable as an index variable, and the second variable as the corresponding list element value for that index location in the list.\n\nfor i, le in enumerate(l):\n\nprint(i, le)\n\n3.13.3 References\n\nPEP 20 - The Zen of Python\n\n3.14 Using map() or filter() where list comprehension is possible\n\nFor simple transformations that can be expressed as a list comprehension, use list comprehensions over map() or filter(). Use map() or filter() for expressions that are too long or complicated to express with a list comprehension. Although a map() or filter() expression may be functionally equivalent to a list comprehension, the list comprehension is generally more concise and easier to read.\n\n3.14.1 Anti-pattern\n\nThe code below deﬁnes a list, and then uses map() to create a second list which is just the doubles of each value from the ﬁrst list.\n\nvalues = [1, 2, 3] doubles = map(lambda x: x * 2, values)\n\n48\n\n3. Readability",
      "content_length": 1537,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 52,
      "content": "Python Anti-Patterns\n\n3.14.2 Best practice\n\nUse list comprehension instead of map()\n\nIn the modiﬁed code below, the code uses a list comprehension to generate the second list containing the doubled values from the ﬁrst list. Although this is functionally equivalent to the ﬁrst code, the list compre- hension is generally agreed to be more concise and easier to read.\n\nvalues = [1, 2, 3] doubles = [x * 2 for x in values]\n\n3.14.3 References\n\nPyLint - W0110, deprecated-lambda\n\nOliver Fromme - List Comprehensions\n\n3.15 Using CamelCase in function names\n\nPer the PEP 8 Style Guide, function names should be lowercase, with words separated by underscores.\n\n3.15.1 Anti-pattern\n\ndef someFunction():\n\nprint(\"Is not the preferred PEP 8 pattern for function names\")\n\n3.15.2 Best practice\n\nUsing lowercase with underscores\n\nThe code below uses the PEP 8 preferred pattern of function names.\n\ndef some_function():\n\nprint(\"PEP 8 Style Guide prefers this pattern\")\n\n3.15.3 References\n\nPEP8 Style Guide - Function names\n\n3. Readability\n\n49",
      "content_length": 1028,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 53,
      "content": "Python Anti-Patterns\n\n4 Security\n\nPython is a highly dynamic language that gives the programmer many ways to change the runtime be- havior of his code and even dynamically execute new code. This is powerful but can be a security risk as well.\n\nUse the following patterns to increase the security of your code.\n\n4.1 use of exec\n\nThe exec statement enables you to dynamically execute arbitrary Python code which is stored in literal strings. Building a complex string of Python code and then passing that code to exec results in code that is hard to read and hard to test. Anytime the Use of exec error is encountered, you should go back to the code and check if there is a clearer, more direct way to accomplish the task.\n\n4.1.1 Anti-pattern\n\nProgram uses exec to execute arbitrary Python code\n\nThe sample code below composes a literal string containing Python code and then passes that string to exec for execution. This is an indirect and confusing way to program in Python.\n\ns = \"print(\\\"Hello, World!\\\")\" exec s\n\n4.1.2 Best practice\n\nRefactor the code to avoid exec\n\nIn most scenarios, you can easily refactor the code to avoid the use of exec. In the example below, the use of exec has been removed and replaced by a function.\n\ndef print_hello_world():\n\nprint(\"Hello, World!\")\n\nprint_hello_world()\n\n4.1.3 References\n\nPyLint - W0122, exec-used\n\nPython Language Reference - The exec statement\n\nStack Overﬂow - Why should exec() and eval() be avoided?\n\n50\n\n4. Security",
      "content_length": 1469,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 54,
      "content": "Python Anti-Patterns\n\n5 Performance\n\nIn Python, large performance gains can be obtained by using appropriate functions and directives. Avoid the following anti-patterns to reduce overhead and make your code more performant.\n\n5.1 Using key in list to check if key is contained in list\n\nUsing key in list to iterate through a list can potentially take n iterations to complete, where n is the number of items in the list. If possible, you should change the list to a set or dictionary instead, because Python can search for items in a set or dictionary by attempting to directly accessing them without itera- tions, which is much more efﬁcient.\n\n5.1.1 Anti-pattern\n\nThe code below deﬁnes a list l and then calls if 3 in l to check if the number 3 exists in the list. This is inefﬁcient. Behind the scenes, Python iterates through the list until it ﬁnds the number or reaches the end of the list.\n\nl = [1, 2, 3, 4]\n\n# iterates over three elements in the list if 3 in l:\n\nprint(\"The number 3 is in the list.\")\n\nelse:\n\nprint(\"The number 3 is NOT in the list.\")\n\n5.1.2 Best practice\n\nUse a set or dictionary instead of a list\n\nIn the modiﬁed code below, the list has been changed to a set. This is much more efﬁcient behind the scenes, as Python can attempt to directly access the target number in the set, rather than iterate through every item in the list and compare every item to the target number.\n\ns = set([1, 2, 3, 4])\n\nif 3 in s:\n\nprint(\"The number 3 is in the list.\")\n\nelse:\n\nprint(\"The number 3 is NOT in the list.\")\n\n5.2 Not using iteritems() to iterate over a large dictionary in Python 2\n\nPEP 234 deﬁnes iteration interface for objects. It also states it has signiﬁcant impact on performance of dict iteration.\n\nNote: This anti-pattern only applies to Python versions 2.x. In Python 3.x items() returns an iterator (consequently, iteritems() and Python 2’s iterative range() function, xrange(), have been removed from Python 3.x).\n\n5. Performance\n\n51",
      "content_length": 1957,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 55,
      "content": "Python Anti-Patterns\n\n5.2.1 Anti-pattern\n\nThe code below deﬁnes one large dictionary (created with dictionary comprehension) that generates large amounts of data. When using items() method, the iteration needs to be completed and stored in-memory before for loop can begin iterating. The prefered way is to use iteritems. This uses (~1.6GB).\n\nd = {i: i * 2 for i in xrange(10000000)}\n\n# Slow and memory hungry. for key, value in d.items():\n\nprint(\"{0} = {1}\".format(key, value))\n\n5.2.2 Best-practice\n\nUse iteritems() to iterate over large dictionary\n\nThe updated code below uses iteritems() instead of items() method. Note how the code is exactly the same, but memory usage is 50% less (~800MB). This is the preferred way to iterate over large dictionaries.\n\nd = {i: i * 2 for i in xrange(10000000)}\n\n# Memory efficient. for key, value in d.iteritems():\n\nprint(\"{0} = {1}\".format(key, value))\n\n5.2.3 References\n\nPEP 234 Iterators\n\n52\n\n5. Performance",
      "content_length": 949,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 56,
      "content": "Python Anti-Patterns\n\n6 Django\n\nDjango is a great framework to create fast and scalable web applications. To help you write great Django apps from the start, we started to compile a set of anti- and migration patterns. They’ll help you to avoid common mistakes or to migrate to a new version faster. Some patterns are simply (more elaborate) explana- tions of tips and best practices that can be found in Django’s docs. Others stem from our own experiences. Feel free to contribute your ideas or share your pattern via email.\n\n6.1 Maintainability\n\nAvoid the following anti-patterns to increase maintainability of your Django code base—for you, and for others.\n\n6.1.1 Importing django.db.models.ﬁelds\n\nIn Django, models are deﬁned in django.db.models.fields. However, for convenience they are im- ported into django.db.models. Django’s standard convention is to use from django.db import models and refer to ﬁelds as models<some>Field. To improve readability and maintainability of your code, change your import statement and model deﬁnition.\n\nAnti-pattern\n\nfrom django.db.models import fields\n\nclass Person(models.Model):\n\nfirst_name = fields.CharField(max_length=30) last_name = fields.CharField(max_length=30)\n\nBest practice\n\nStick to standard conventions and use from django.db import models instead.\n\nfrom django.db import models\n\nclass Person(models.Model):\n\nfirst_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30)\n\nReferences\n\nDjango documentation - Model ﬁeld reference\n\n6. Django\n\n53",
      "content_length": 1524,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 57,
      "content": "Python Anti-Patterns\n\n6.2 Security\n\nMost Django applications contain a lot of proprietory or even conﬁdential information. Hence, it is crucial to take all possible measures to take your Django application secure and to recude the possibility of being hacked.\n\nUse the following patterns to increase the security of your code.\n\n6.2.1 ALLOWED_HOSTS setting missing\n\nIn Django, you need to properly set the ALLOWED_HOSTS setting when DEBUG = False. This is a security mechanism. It prevents attackers from poisoning caches or password reset emails with links to malicious hosts by submitting requests with a fake HTTP Host header, which is possible even under many seemingly- safe web server conﬁgurations.\n\nAnti-Pattern\n\nALLOWED_HOSTS not set or empty, when DEBUG = False.\n\n\"\"\" settings.py \"\"\"\n\nDEBUG = False # ... ALLOWED_HOSTS = []\n\nBest practice\n\nMake sure, an appropriate host is set in ALLOWED_HOSTS, whenever DEBUG = False.\n\nDEBUG = False # ... ALLOWED_HOSTS = ['djangoproject.com']\n\nReferences\n\nDjango documentation - Settings: The Basics\n\nDjango documentation - Settings: ALLOWED_HOSTS\n\n6.2.2 SECRET_KEY published\n\nA secret key has to be be kept secret. Make sure it is only used in production, but nowhere else. Especially, avoid committing it to source control. This increases security and makes it less likely that an attacker may acquire the key.\n\nAnti-pattern\n\nThis settings.py contains a SECRET_KEY. You should not do this!\n\n\"\"\" settings.py \"\"\" SECRET_KEY = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n\n54\n\n6. Django",
      "content_length": 1540,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 58,
      "content": "Python Anti-Patterns\n\nBetter Practices\n\nLoad key from environment variable\n\nInstead of publishing your secret key, you can use an environment variable to set your secret key.\n\nimport os SECRET_KEY = os.environ['SECRET_KEY']\n\nLoad secret key from ﬁle\n\nAlternatively, you can read the secret key from a ﬁle.\n\nwith open('/etc/secret_key.txt') as f: SECRET_KEY = f.read().strip()\n\nReferences\n\nDjango\n\n6.2.3 Same value for MEDIA_ROOT and STATIC_ROOT\n\nAccording to Django’s documentation, MEDIA_ROOT and STATIC_ROOT must have different values. Before STATIC_ROOT was introduced, MEDIA_ROOT was also used (as fallback) to also serve static ﬁles. As this can have serious security implications, Django has validation checks to prevent it.\n\nAnti-pattern\n\nMEDIA_ROOT and STATIC_ROOT point to the same folder.\n\n\"\"\" settings.py \"\"\"\n\n# Media and static root are identical STATIC_ROOT = '/path/to/my/static/files' MEDIA_ROOT = '/path/to/my/static/files'\n\nBest practice\n\nEnsure, STATIC_ROOT and MEDIA_ROOT point to different folders.\n\n\"\"\" settings.py \"\"\"\n\nSTATIC_ROOT = '/path/to/my/static/files' MEDIA_ROOT = '/path/to/my/media/files'\n\nReferences\n\nDjango documentation - Settings: MEDIA_ROOT\n\n6. Django\n\n55",
      "content_length": 1192,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 59,
      "content": "Python Anti-Patterns\n\n6.2.4 Same value for MEDIA_URL and STATIC_URL\n\nAccording to Django’s documentation, MEDIA_URL and STATIC_URL must have different values.\n\nAnti-pattern\n\nMEDIA_URL and STATIC_URL point to the same URL.\n\n\"\"\" settings.py \"\"\"\n\n# Media and static root are identical STATIC_URL = 'http://www.mysite.com/static' MEDIA_URL = 'http://www.mysite.com/static'\n\nBest practice\n\nEnsure, STATIC_URL and MEDIA_URL point to different URL’s.\n\n\"\"\" settings.py \"\"\"\n\nSTATIC_URL = 'http://www.mysite.com/static' MEDIA_URL = 'http://www.mysite.com/media'\n\nReferences\n\nDjango documentation - Settings: MEDIA_URL\n\nDjango documentation - Settings: MEDIA_ROOT\n\n6.3 Correctness\n\n6.3.1 Not using forward slashes\n\nDjango requires you to use forward slashes / whenever you indicate a path, even on Windows. In your settings, this is true for the following variables.\n\nSTATICFILES_DIRS\n\nTEMPLATE_DIRS\n\nDATABASES['<your database>'][NAME]\n\nFIXTURE_DIRS\n\nAnti-pattern\n\nThis pattern is exemplary for any of the above mentioned settings. It uses backslashes, instead of forward slashes.\n\n\"\"\" settings.py \"\"\"\n\nSTATICFILES_DIRS = [\n\n\"\\\\path\\\\to\\\\my\\\\static\\\\files\",\n\n]\n\n56\n\n6. Django",
      "content_length": 1164,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 60,
      "content": "Python Anti-Patterns\n\nBest practice\n\nDjango requires you to use forward slashes /, even on Windows.\n\n\"\"\" settings.py \"\"\"\n\nSTATICFILES_DIRS = [\n\n\"/path/to/my/static/files\",\n\n]\n\nReferences\n\nDjango documentation - Settings: TEMPLATE_DIRS\n\nDjango documentation - Settings: FIXTURE_DIRS\n\nDjango documentation - Settings: STATIC_FILES_DIRS\n\nDjango documentation - Settings: HOST\n\n6.4 Performance\n\nDjango has a lot of mechanisms built-in to build fast and efﬁcient web applications. Still, there are several things to watch out for, especially when you start to scale your Django application. This chapter contains anti-patterns that can potentially harm the performance of your application and hence, should be avoided.\n\n6.4.1 Inefﬁcient database queries\n\nDjango’s models make it easy for you, to ﬁlter the data of your application without using any SQL state- ments. This is a great thing, however, it sometimes hides that you are using object ﬁlters inefﬁciently. Unless you append .values() to your ﬁlter, your QuerySet will always query all columns within your database. This can be uncritical until you scale your application or once your tables grow bigger. Therefore, make sure you only retrieve the columns your really need within your program.\n\nAnti-Pattern\n\nLet’s assume we have a an app vehicle which contains a model Cars to store plenty of information about a car:\n\n\"\"\" models.py \"\"\"\n\nclass Cars(models.Model):\n\nmake = models.CharField(max_length=50) model = models.CharField(max_length=50) wheels = models.CharField(max_length=2) # ...\n\nWe import this model into one of your views to do something will make names within our database:\n\n\"\"\" views.py \"\"\" from models import Cars\n\n# ...\n\n(continues on next page)\n\n6. Django\n\n57",
      "content_length": 1731,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 61,
      "content": "Python Anti-Patterns\n\n(continued from previous page)\n\ncars = Cars.objects.all() for car in cars:\n\ndo_something(car.make)\n\nEven though this code works and looks harmless, it can kill you in production. You think, you are actually just accessing the make ﬁeld, but you are actually retrieving ALL data from your database, once you start iterating over the retrieved QuerySet:\n\nSELECT make, model, wheels, ... FROM vehicles_cars;\n\nEspecially, if you have many ﬁelds on your model and/or if you got millions of records in your table, this slows down the response time of your applications signiﬁcantly. As QuerySets are cached upon evaluation, it will hit your database only once, but you’d better be carful.\n\nBest practice\n\nUse .values()\n\nTo avoid such a scenario, make sure you only query the data you really need for your program. Use . values() to restrict the underlying SQL query to required ﬁelds only.\n\n\"\"\" views.py \"\"\" from cars.models import Cars\n\ncars = Cars.objects.all().values('make')\n\n# Print all makes for car in cars:\n\ndo_something(car['make'])\n\nSELECT make from vehicles_cars;\n\nUse .values_list()\n\nAlternatively, you can use .value_list(). It is similar to values() except that instead of returning dictionaries, it returns tuples when you iterate over it.\n\n\"\"\" views.py \"\"\" from cars.models import Cars\n\ncars = Cars.objects.all().values_list('make', flat=True)\n\n# Print all makes for make in cars:\n\ndo_something(make)\n\nReferences\n\nDjango documentation - Models: Querysets (values)\n\nDjango documentation - Models: Querysets (values_list)\n\n58\n\n6. Django",
      "content_length": 1566,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 62,
      "content": "Python Anti-Patterns\n\n6.5 Migration to 1.8\n\nMigrating to a new Django version can be time consuming. To make this process easier, this chapter lists deprecated features and shows potential migration patterns/pathes.\n\n6.5.1 TEMPLATE_DIRS deprecated\n\nThis setting is deprecated since Django version 1.8. Set the DIRS option of a [DjangoTemplates back- end](https://docs.djangoproject.com/en/1.8/topics/templates/#module-django.template.backends. django) instead.\n\nDeprecated feature\n\nDeprecated TEMPLATE_DIRS setting used.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATE_DIRS = [\n\n\"path/to/my/templates\",\n\n]\n\nMigration path\n\nAs of Django 1.8 you should set DIRS option within TEMPLATES setting. It deﬁnes where the engine should look for template source ﬁles, in search order.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATES = [\n\n{\n\n'BACKEND': 'django.template.backends.django.DjangoTemplates', 'APP_DIRS': True, 'DIRS': '/path/to/my/templates',\n\n},\n\n]\n\nReferences\n\nDjango documentation - Settings: TEMPLATES\n\nDjango documentation - Settings: TEMPLATE_DIRS\n\nDjango documentation - Templates: Built-in backends\n\n6. Django\n\n59",
      "content_length": 1089,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 63,
      "content": "Python Anti-Patterns\n\n6.5.2 TEMPLATE_DEBUG deprecated\n\nThis setting sets the output that the template system should use for invalid (e.g. misspelled) variables. The default value is an empty string ''. This setting is deprecated since Django version 1.8. Set the TEM- PLATE_DEBUG option in the OPTIONS of a DjangoTemplates backend instead.\n\nDeprecated feature\n\nDeprecated TEMPLATE_DEBUG setting used.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATE_DEBUG = True\n\nMigration path\n\nAs of Django 1.8 you should set debug option in the OPTIONS of a DjangoTemplates backend instead.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATES = [\n\n{\n\n'BACKEND': 'django.template.backends.django.DjangoTemplates', 'APP_DIRS': True, 'DIRS': '/path/to/my/templates', 'OPTIONS': {\n\n'debug': True,\n\n}\n\n},\n\n]\n\nReferences\n\nDjango documentation - Settings: TEMPLATE_DEBUG\n\nDjango documentation - Settings: TEMPLATES\n\nDjango documentation - Templates: Built-in backends\n\n6.5.3 TEMPLATE_LOADERS deprecated\n\nThis setting is deprecated since Django version 1.8. Set the LOADERS option of a DjangoTemplates backend instead.\n\nDeprecated feature\n\nDeprecated TEMPLATE_LOADERS setting used.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATE_LOADERS = (\n\n'django.template.loaders.filesystem.Loader',\n\n(continues on next page)\n\n60\n\n6. Django",
      "content_length": 1252,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 64,
      "content": "Python Anti-Patterns\n\n(continued from previous page)\n\n'django.template.loaders.app_directories.Loader',\n\n)\n\nMigration path\n\nAs of Django 1.8 you should set loaders option in the TEMPLATES setting. It deﬁnes where the engine should look for template source ﬁles, in search order.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATES = [\n\n{\n\n'BACKEND': 'django.template.backends.django.DjangoTemplates', 'APP_DIRS': True, 'DIRS': '/path/to/my/templates', 'OPTIONS': {\n\n'loaders': (\n\n'django.template.loaders.filesystem.Loader', 'django.template.loaders.app_directories.Loader',\n\n),\n\n}\n\n},\n\n]\n\nReferences\n\nDjango documentation - Settings: TEMPLATES]\n\nDjango documentation - Settings: TEMPLATE_DIRS]\n\nDjango documentation - Templates: Built-in backends]\n\n6.5.4 TEMPLATE_STRING_IF_INVALID deprecated\n\nThis setting sets the output that the template system should use for invalid (e.g. misspelled) variables. The default value is an empty string ''. This setting is deprecated since Django version 1.8. Set the string_if_invalid option in the OPTIONS of a DjangoTemplates backend instead.\n\nDeprecated feature\n\nDeprecated TEMPLATE_STRING_IF_INVALID setting used.\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATE_STRING_IF_INVALID = 'Invalid variable'\n\nMigration path\n\nAs of Django 1.8 you should set string_if_invalid option in the OPTIONS of a DjangoTemplates backend instead.\n\n6. Django\n\n61",
      "content_length": 1345,
      "extraction_method": "Unstructured"
    },
    {
      "page_number": 65,
      "content": "Python Anti-Patterns\n\n\"\"\" settings.py \"\"\"\n\nTEMPLATES = [\n\n{\n\n'BACKEND': 'django.template.backends.django.DjangoTemplates', 'APP_DIRS': True, 'DIRS': '/path/to/my/templates', 'OPTIONS': {\n\n'string_if_invalid': 'Invalid varialbe!',\n\n}\n\n},\n\n]\n\nReferences\n\nDjango documentation - Settings: TEMPLATES\n\nDjango documentation - Settings: TEMPLATE_STRING_IF_INVALID\n\nDjango documentation - Templates: Built-in backends\n\nDjango documentation - Templates: How invalid variables are handled\n\n62\n\n6. Django",
      "content_length": 493,
      "extraction_method": "Unstructured"
    }
  ],
  "enrichment": {
    "version": "1.0.0",
    "generated_by": "generate_chapter_metadata.py",
    "contains": [
      "keywords",
      "concepts",
      "summary"
    ]
  }
}