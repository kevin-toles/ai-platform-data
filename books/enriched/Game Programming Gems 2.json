{
  "metadata": {
    "title": "Game Programming Gems 2",
    "source_file": "Game Programming Gems 2_metadata.json"
  },
  "chapters": [
    {
      "chapter_number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "summary": "Optimization for C++ Games\nObject Construction and Destruction\nThe creation and destruction of objects is a central concept in C++, and is the main\ngrams can spend substantial time calling constructors, copying objects, and generat-\ning costly temporary objects.\nmake object-heavy code run within a hair's breadth of the speed of C.\n• Delay construction of objects until they're needed.\nThe fastest code is that which never runs; why create an object if you're not\nObject obj;\neven when arg is zero, we pay the cost of calling Object's constructor and destruc-\nIf arg is often zero, and especially if Object itself allocates memory, this waste\nBe careful about declaring nontrivial objects in loops, however.\nstruction of an object until it's needed in a loop, you'll pay for the construction\nIt's better to declare the object\ninner loop, and the function creates an object on the stack, you could instead cre-\nate the object outside the loop and pass it by reference to the function.\nclass Vehicle\ninvoked, this code calls the constructor for the string mName, and then calls the\n= operator to copy in the object's name.\nple is that the default constructor for string may well allocate memory — in fact,\nefficient, and the compiler may be able to optimize away the Vehicle constructor\nclass Vehicle\n1.1 Optimization for C++ Games\nThus, postincrement involves the construction of a temporary object, while\nThis operator must return a new Vector object, and furthermore, it must return\nthat the compiler is able to optimize away the temporary object (this is known\nShould the constructor for the Vector class in the previous example initialize its\nA good compiler may well optimize away some of the extra code, but why take\nAs a general rule, you want an object's constructor to initialize each of\nclass Vehicle\nSimilarly, it's cheaper to use copy constructors than to construct an\nobject and then call operator=.\nPrefer constructing an object this way — Vehicle\nIf you want to prevent the compiler from automatically copying an object for\nyou, declare a private copy constructor and operator= for the object's class, but\nvents the compiler from generating hidden temporary objects when converting\nPreallocate and cache objects.\nA game will typically have a few classes that it allocates and frees frequently, such\nIn a C game, you'd typically allocate a big array up front\nCode for a sample cache class template is on the accompany-\nYou can either allocate objects to fill the cache as you need them, or preallocate\nall of the objects up front.\ncated after X), you can allocate the cache in a contiguous block of memory.\n1.1 Optimization for C++Games \nfreeQ, while C++ can implicitly allocate memory while constructing temporary\nobjects and member variables.\nBecause a C++ game is likely to perform many allocations, it must be especially\nwastes a substantial amount of memory for those blocks that are not currently in use;\nVirtual Functions\nCritics of C++ in games often point to virtual functions as a mysterious feature\nfunction call on an object, the compiler accesses the objects virtual function table,\nThis is to be compared with a function call in C, where the com-\nAny substantial C++ program will make heavy use of virtual functions, so the idea\nOptimization for C++Games \nAlthough each new virtual function adds only the size of a pointer to a per-class\ntable (usually a negligible cost), the yzrtf virtual function in a class requires a pointer to\nthe virtual function table on a pet-object basis.\nany virtual functions at all in small, frequently used classes where this extra overhead\nfunctions (a virtual destructor if nothing else), you don't want any hierarchy for small,\nCompilers have a somewhat deserved reputation for generating bloated code for C++.\nsure the linker is configured to strip out unused functions and classes.\n(Be sure to verify that intrinsic functions are still enabled if you use\nthat objects on the stack don't wind up generating lots of inline code.",
      "keywords": [
        "Object",
        "Function",
        "virtual function",
        "code",
        "Virtual",
        "virtual function call",
        "vector",
        "Vehicle",
        "Functions",
        "Games",
        "constructor",
        "memory",
        "objects virtual function",
        "function call",
        "compiler"
      ],
      "concepts": [
        "object",
        "function",
        "functions",
        "code",
        "block",
        "allocates",
        "allocations",
        "virtual",
        "generate",
        "generating"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.744,
          "base_score": 0.594,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 26,
          "title": "",
          "score": 0.558,
          "base_score": 0.408,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 8,
          "title": "",
          "score": 0.497,
          "base_score": 0.347,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 10,
          "title": "",
          "score": 0.495,
          "base_score": 0.345,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 13,
          "title": "",
          "score": 0.492,
          "base_score": 0.342,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "object",
          "virtual",
          "constructor",
          "objects",
          "vehicle"
        ],
        "semantic": [],
        "merged": [
          "object",
          "virtual",
          "constructor",
          "objects",
          "vehicle"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24976256318763462,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284121+00:00"
      }
    },
    {
      "chapter_number": 2,
      "title": "Segment 2 (pages 9-16)",
      "start_page": 9,
      "end_page": 16,
      "summary": "Get to know your compiler's settings for inlin-\nneed to have different behavior based on type, add a virtual function that behaves dif-\nThe Standard Template Library (STL) is a set of templates that implement common\ndata structures and algorithms, such as dynamic arrays (called vectors), sets, and\ntain performance guarantees; for example, insertion into a set takes O(log n) time.\nAn alternative solution uses an STL vector to store elements.\nmeans in practice is that a vector typically reallocates memory only on occasion, say,\nChecking the entire vector will take O(n) time, but the con-\nThat's because all of the elements of a vector are\ntypically stored contiguously in memory, so checking the entire vector is a cache-\nIf all you're storing is object pointers, a set can easily require three to four times the\nmemory of a vector to store the same objects.\nfrom the deleted element to the end of the vector must be copied over one position.\nHowever, if the elements of the vector are just pointers, the copying can all be done in\nvector, add elements to the vector as the game progresses, and then call clear() when\nthe player restarts, the vector may not actually free its memory at all.\nexplicitly force the vector to free its memory this way:\nvector<int>().swap(v); // causes v to free its memory\nFunction (\"hello\");\nimplementation's strings are reference counted) followed by a freeQ- The memory\nIf you have a vector of\nfunctions that are actually called have any code generated for them.\nYou'll generally find that in the vector example given previously, only a single copy of\nhow blindly trusting in a function's documented algorithmic running time can lead\nInline Functions Versus Macros\nien it comes to game programming, the need for fast, efficient functions cannot\nbe overstated, especially functions that are executed multiple times per frame.\nroutines because they eliminate the calling/returning sequence required by functions\nto implement macros diat look like functions is more problematic than it is worth.\nAdvantages of Inline Functions\nThrough the use of inline functions, many of the inherent disadvantages of macros\nthis problem, we could have used an inline function to accomplish die same goal:\nAnother problem that plagues macros, operator precedence, follows from die\n1.2 Inline Functions Versus Macros \nproblem, it could have easily been avoided through the use of inline functions.\nIf we were to use the macro within the following loop:\nWhile replacing the macro with an inline function to perform the same\nadvantages of inline functions:\n• Inline functions follow all the protocols of type safety enforced on normal func-\n• Inline functions are specified using the same syntax as any other function, except\nfor the inline keyword in the function declaration.\n• Expressions passed as arguments to inline functions are evaluated prior to enter-\ning the function body; thus, expressions are evaluated only once.\n• It is possible to debug inline functions using debuggers such as Microsoft's Visual\n• Inline functions arguably increase the procedure's readability and maintainability\nInline functions also outperform ordinary functions by eliminating the overhead\nof function calls.\ninline functions also provide the compiler with the ability to perform improved code\nBy replacing inline functions with code, the inserted code is subject to\nThe only limitation to inline functions that is not present within macros is the\nMacros allow for any possible type to be passed as a\nparameter; however, inline functions only allow for the specified parameter type in\ntemplate functions, which allow us to accept any parameter type and enforce type\nsafety, yet still provide all the benefits associated with inline functions.\nWhen to Use Inline Functions\n..;„„..,,,....,.....™?i[.^,,.,.,.,..„,..,...\nWhy don't we make every function an inline function?\nfunction overhead for the entire program, resulting in faster fill rates and response\nimprove speed by eliminating function overhead and allowing for interprocedural\nIncreasing code size takes up more memory, which is a pre-\nIf inline functions are not always a win, then when exactly should we use them?\ninline functions work well:\n• Functions returning state information about an object.\n• Small functions, typically three lines or less.\n• Small functions that are called repeatedly; for example, within a time-critical ren-\nLonger functions that spend proportionately less time in the calling/returning\n1.2 Inline Functions Versus Macros \nstringizing operator that converts macro parameters to string constants [MSDN].\nBesides the standard inline keyword, Microsoft's Visual C++ compiler provides sup-\ngenerate a cost/benefit analysis and to only inline the function if it proves beneficial.\nforceinline keyword instructs the compiler to always inline the function.\n[Heller99] Heller, Martin, Developing Optimized Code with Microsoft Visual C++ 6.0,",
      "keywords": [
        "Inline Functions",
        "functions",
        "inline",
        "Inline Functions Versus",
        "Functions Versus Macros",
        "vector",
        "function",
        "memory",
        "Macros",
        "STL",
        "code",
        "inline template functions",
        "function calls",
        "collection",
        "Functions Versus"
      ],
      "concepts": [
        "functions",
        "function",
        "functionality",
        "macros",
        "performance",
        "perform",
        "memory",
        "type",
        "operation",
        "operations"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "",
          "score": 0.744,
          "base_score": 0.594,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 8,
          "title": "",
          "score": 0.564,
          "base_score": 0.414,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 13,
          "title": "",
          "score": 0.548,
          "base_score": 0.398,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 10,
          "title": "",
          "score": 0.538,
          "base_score": 0.388,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 26,
          "title": "",
          "score": 0.488,
          "base_score": 0.338,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "inline",
          "inline functions",
          "functions",
          "vector",
          "macros"
        ],
        "semantic": [],
        "merged": [
          "inline",
          "inline functions",
          "functions",
          "vector",
          "macros"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.26763853906925567,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284184+00:00"
      }
    },
    {
      "chapter_number": 3,
      "title": "Segment 3 (pages 17-24)",
      "start_page": 17,
      "end_page": 24,
      "summary": "Abstract Interfaces\nhe concept of abstract interfaces is simple yet powerful.\nseparate the interface from its implementation.\nTenderer is implemented through an abstract interface, it is possible to choose\n• The implementation details are completely hidden from the user of the interface.\n• New implementations of existing interfaces can be added to the game effortlessly,\nAbstract Interfaces\nIn C++, an abstract interface is nothing more than a base class that has only public\nAny derived class must implement those functions, or\nThe following is an example of an abstract interface for a minimal sound system.\nThis interface would be declared in a header file by itself:\nclass ISoundSystem {\n1.3 Programming with Abstract Interfaces \nThe abstract interface provides no implementation whatsoever.\nthe users of the interface know about ISoundSystem, they can use any sound system\ninterface:\n// The rest of the functions in the implementation\nAll that is needed is to create a new class that inherits from\nclass of the specific implementation they want to use.\nthey need to #include the header file with the declaration of the implementation.\nalso get a lot of extra information on the implementation details of that class that they\nthe class.\nTo make matters worse, the users of the interface now know exactly what type of\nclass their interface pointer points to, and they could be tempted to cast it to its real\nour design into abstract interfaces, so this is something that should be avoided as\npurpose is to instantiate a specific implementation for an interface when asked for it.\nclass ISoundSystem;\n1.3 Programming with Abstract Interfaces \nWe need to always include a virtual destructor in our abstract interfaces.\nAbstract Interfaces as Traits\nA slightly different way to think of abstract interfaces is to consider an interface as a\nIf a class implements an interface, that class is making a promise that\nFor example, the following is an interface used by\nclass IRenderable {\nWe can design a class to represent 3D objects that inherits from IRenderable and\nterrain class that also inherits from IRenderable and provides a completely different\ning the real implementation from the interface: now it is possible to add a completely\nnew type of object, and as long as it presents the IRenderable interface, the rendering\nWithout abstract interfaces, the\nrender loop would have to know about the specific types of object (generic 3D object,\nating a new type of render-capable object would require changing the render loop\nWe can check whether an object inherits from IRenderable to know if it can be\nIf the object in question implements a particular interface, then Querylnterface\nInterface function, we need to have a base class from which all of the related objects\nthat inherit from a set of interfaces derive.\nThe implementation of Querylnterface for a plain game object would be trivial.\nBecause it's not implementing any interface, it will always return false.\n1.3 Programming with Abstract Interfaces \nThe implementation of a 3D object class is different from that of GameObject,\nbecause it will implement the IRenderable interface.\ning about the type of objects it is rendering.\nder loop, if we give it new types of objects and some of them implemented the IRen-\nderable interface, everything would work as expected without the need to change the\nNotice that nothing is stopping us from inheriting from multiple interfaces.\nwill mean is that the class that inherits from multiple interfaces is now providing all\nidable interface for objects that need to have collision detection done.\nA word of warning, however: while using multiple abstract interfaces is a power-\nmost one real parent class and multiple interface functions should not result in the\nthe same class) or many of the other usual drawbacks of multiple inheritance.\nfaces, the extra classes and the querying of interfaces could look confusing at first\nWith the abstract interfaces, we did such a good job hiding all of the private\nUnfortunately, we don't have access to the class implementation any more, and\nexisting interface or provide a new interface using a derived class, but it will all have to\nbe done from the implementation side, and not from within the game code.\n1.3 Programming with Abstract Interfaces \nFinally, notice that every single function in an abstract interface is a virtual func-\navoid using interfaces for functions that are called from within inner loops.\nAbstract interfaces are a powerful technique that can be put to good use with very lit-",
      "keywords": [
        "Abstract Interfaces",
        "interface",
        "Abstract",
        "implementation",
        "virtual",
        "sound",
        "IRenderable",
        "type",
        "sound system",
        "object",
        "virtual bool",
        "Render",
        "functions",
        "virtual bool Render",
        "game"
      ],
      "concepts": [
        "interfaces",
        "classes",
        "implementation",
        "implement",
        "object",
        "virtual",
        "type",
        "game",
        "functions",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 6,
          "title": "",
          "score": 0.529,
          "base_score": 0.529,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 50,
          "title": "",
          "score": 0.524,
          "base_score": 0.524,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 14,
          "title": "",
          "score": 0.452,
          "base_score": 0.452,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 5,
          "title": "",
          "score": 0.387,
          "base_score": 0.387,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 7,
          "title": "",
          "score": 0.35,
          "base_score": 0.35,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "interfaces",
          "abstract",
          "interface",
          "abstract interfaces",
          "class"
        ],
        "semantic": [],
        "merged": [
          "interfaces",
          "abstract",
          "interface",
          "abstract interfaces",
          "class"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19397889740089078,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:23.284334+00:00"
      }
    },
    {
      "chapter_number": 4,
      "title": "Segment 4 (pages 25-33)",
      "start_page": 25,
      "end_page": 33,
      "summary": "xporting a C++ class from a Dynamic Link Library (DLL) for use by another\napplication is an easy way to encapsulate instanced functionality or to share\nderivable functionality without having to share the source code of the exported class.\nExporting a Function\nAt the most basic level, there is little difference between exporting a function or a class\nfrom a DLL.\nTo export myExportedFunction from a DLL, the value _BUILDING_\n// DLL\nExporting a C++ class from a DLL is slightly more complicated because there are sev-\nAs before, the DLL-\nFUNCTION macro is used to declare the class exported by the DLL, or imported by\n_BUILDING_MY_DLL\nIf the DLL containing the class is implicitly linked (in other words, the project\nlinks with the DLL's lib file), then using the class is as simple as declaring an instance\nThere is one potential problem with declaring or allocating a class exported from\na DLL in an application: it may confuse some memory-tracking programs and cause\nDLL.\nAll users of the exported class should call the allocation function to create an\nis that it prevents deriving from the exported class in the application.\napplication-side class from the exported class is important, and the project uses a\nExporting Class Member Functions\nEven with the helper functions added, because the class itself is being exported from\nthe DLL, it is still possible that users could create instances of the class without calling\nexport specification from the class level to the individual functions to which the users\nmember function, it can no longer be called by users of the class outside the DLL, as\nneeds to make some functions publicly accessible to users of the class outside the\nDLL, yet still needs to have other public functions for use inside the DLL itself.\nof the classes have a mix of exported and nonexported functions.\nof the SDK to access or derive functionality as needed from the exported member\nExporting Virtual Class Member Functions\nare attempting to export the member functions of a class, and you are not linking\nwith the lib file of the DLL that exports the class (you're using LoadLibrary to load\nthe DLL at runtime), you will get an \"unresolved external symbol\" for each function\nAn alternate fix is to declare the functions virtual.\ndeclare exported member functions virtual anyway, so that you can both work around\nthe potential Visual C++ problem and allow the user to override member functions as\nWith exported virtual member functions, deriving from the exported class on the\napplication side is the same as if the exported class were declared completely in the\nExporting a class from a DLL is an easy and powerful way to share functionality with-\nIf an application relies on a DLL that doesn't exist on the user's\nIf the DLL does exist on the user's computer, there's no\nBad DLL versions can easily find their way onto a system as the user installs and\nThis is known as implicit DLL loading, or implicit linking.\nincluding a DLL's lib file directly into a project is just like adding it on the link line.\nthe DLL.\nThis is done by not linking to the DLL's lib file in the link line, and remov-\nVisual C++ builds a DLL, the link property page of the subproject should be changed\nBy explicitly loading the DLL, the\nWhen a DLL is implicitly loaded using a lib file, the functions can be called directly\nWhen switching to explicit linking, the functions must\nthe DLL that contains the function must be explicitly loaded using the LoadLibrary\nLoadLibrary searches for the specified DLL, loads it into the applications process\nused to create a function pointer to each function in the DLL that will be used by the\nWhen an explicitly loaded DLL is no longer needed, it should be freed using\nloaded either implicitly by the executable or another DLL, or by calling LoadLibrary.\n1.5 Protect Yourself from DLL Hell and Missing OS Functions \nThe explicit DLL loading case effectively adds two more lines of code, but the\napplication is now protected against dinput8.dll not being found, or of it being cor-\nHMODULE hDInputLib = LoadLibrary( \"dinput8.dll\") ;\nThe DLL is then loaded using LoadLibrary.\nGetProcAddress returns a pointer to the function if it is found, or\nNULL if the function cannot be found.\nIf there were more functions that needed to be retrieved from the DLL, a func-\nonly check for NULL when mapping the first function pointer using GetProcAddress.\nAnother issue that explicit DLL loading can resolve is when an application wants to\nInstead of calling it directly, kernel32.dll can be loaded\nusing LoadLibrary and the function again mapped with GetProcAddress.\nkernel32.dll and find CopyFileEx, we use it.",
      "keywords": [
        "DLL",
        "Function",
        "DLL tfdefine DLLFUNCTION",
        "DLLs",
        "DLL lib file",
        "Functions",
        "class DLLFUNCTION CMyExportedClass",
        "DLL lib",
        "DLLFUNCTION",
        "void",
        "Member Functions",
        "DLL Hell",
        "exported class",
        "Class Member Functions",
        "long"
      ],
      "concepts": [
        "functionality",
        "function",
        "functions",
        "classes",
        "void",
        "exporting",
        "link",
        "windows",
        "long",
        "programs"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 7,
          "title": "",
          "score": 0.621,
          "base_score": 0.471,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 14,
          "title": "",
          "score": 0.543,
          "base_score": 0.393,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 5,
          "title": "",
          "score": 0.52,
          "base_score": 0.37,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 6,
          "title": "",
          "score": 0.413,
          "base_score": 0.263,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "",
          "score": 0.316,
          "base_score": 0.316,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "dll",
          "class",
          "exported",
          "functions",
          "loadlibrary"
        ],
        "semantic": [],
        "merged": [
          "dll",
          "class",
          "exported",
          "functions",
          "loadlibrary"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15912191830369657,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284397+00:00"
      }
    },
    {
      "chapter_number": 5,
      "title": "Segment 5 (pages 34-41)",
      "start_page": 34,
      "end_page": 41,
      "summary": "Dynamic Type Information\ntems now regularly contain many different types and classes; counts of over 1000 are\nCoping with so many different types in a game engine can be a chal-\nA type can really mean anything from a class, to a struct, to a standard\ndata type.\nIntroducing the Dynamic Type Information Class\nof one class in particular: the dynamic type information (DTI) class.\nThis class will\nstore any information that we may need to know about the type of any given object or\nclass dtiClass\n1.6 Dynamic Type Information \nIn order to instill DTI into our engine, all our classes will need a dtiClass as a sta-\nquery the dtiClass member of the class's parent.\ntree all the way from the root class down, thus ensuring that all game objects have\nstatic dtiClass member, a basic root class, and simple initialization of the class's type\nstatic dtiClass Type;\nclass CRootClass\ndtiClass CRootClass::Type( \"CRootClass\", NULL );\nBy including the EXPOSE_TYPE macro in all of our class definitions and initial-\ninstilling dynamic type info in our game engine.\nWe pass our class name and a pointer\nto the class's parent's dtiClass member.\nWe can now query for an object's class name at runtime for debug purposes of\nother type-related cases, such as saving or loading a game.\njust need to specify the name of the parent class.\nclass CChildClass : public CRootClass\ndtiClass CChildClass::Type( \"CChildClass\", &CRootClass::Type );\n// Let's see what kind of class this object is derived from\nimplementing a useful method for safeguarding type casts, or simply querying an\nobject about its roots or general type.\nphism, the ability for all our objects to be just one of many types at any one time.\nmany cases, polymorphism is put to use in game programming to handle many types\nobjects are of compatible types before we cast them, thus preventing undefined\nIt also means we like to be able to check what type an object conforms to at\nImagine that our game involves a number of different types of robots, some\nwith varying types of specialist child classes, we need to query their roots.\nnew member function IsA, because inheritance can be seen to translate to \"is a type\n1.6 Dynamic Type Information \nclass, we just need to call IsA from the object's own dtiClass member, passing in the\nstatic dtiClass member of the root class.\nif ( pChild->Type.IsA( &CRootClass::Type ) )\njust use the check to filter out certain types of game objects in a given area, given that\npRoot = (CRootClass*)pChild->SafeCast( &CRootClass::Type );\nvast array of game objects, all stored as pointers to a given base class.\nthat can query what general type an object is, and cast it safely up the class tree.\neach really points to a specific type of subclass, we need to make use of the dynamic\nThe dynamic casting operator is used to convert among polymorphic types and is\ndynamic_cast< type-id >(expression)\nThe dynamic_cast operator lets us determine what type is really hidden behind a\nsafely down-cast too, which completes our runtime type information solution.\n1.6 Dynamic Type information \nImplementing Persistent Type Information\nout or load die basic data types of the language.\nTo let our classes know how to work with the object repositories we need to add\nNote that it is virtual and needs to be overridden for all child classes that have\nAll types would thus know how to save themselves,\nHowever, child classes need to write out their data and that of their parents.\nadding it to each class's Serialize member, we need to give each class access to its par-\nThis allows child classes to write (or load) their inherited data\nThis farther extends our type solution by allowing our classes to call their imme-\nClass::Serialize calls CRootClass:Serialize before dealing with some of its own data\nA friend operator for the float data type was added to support the above.\nAs long as object types are serialized in the same order both ways, their attributes\nthe CdtiBin class adds support for basic data types.\nstructures to our class members, we just need to write an operator for coping with that\nWith this in place, all objects and types in the engine will know precisely how\nApplying Persistent Type Information to a Game\nAs mentioned previously, objects need to be serialized out and loaded back in the\nencompassing containment class, calling just the one Serialize routine when needed.",
      "keywords": [
        "Type",
        "Dynamic Type Information",
        "Type Information",
        "Dynamic Type",
        "game",
        "object",
        "dtiClass",
        "DLL Hell",
        "Type Information Class",
        "Serialize",
        "Persistent Type Information",
        "Dynamic",
        "Information",
        "runtime type information",
        "CRootClass"
      ],
      "concepts": [
        "type",
        "classes",
        "object",
        "member",
        "functions",
        "functionality",
        "game",
        "data",
        "examples",
        "mechanical"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 14,
          "title": "",
          "score": 0.705,
          "base_score": 0.555,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 6,
          "title": "",
          "score": 0.662,
          "base_score": 0.512,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 7,
          "title": "",
          "score": 0.622,
          "base_score": 0.472,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 4,
          "title": "",
          "score": 0.52,
          "base_score": 0.37,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 3,
          "title": "",
          "score": 0.387,
          "base_score": 0.387,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "type",
          "class",
          "dticlass",
          "type information",
          "crootclass"
        ],
        "semantic": [],
        "merged": [
          "type",
          "class",
          "dticlass",
          "type information",
          "crootclass"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24519724577781246,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284445+00:00"
      }
    },
    {
      "chapter_number": 6,
      "title": "Segment 6 (pages 42-52)",
      "start_page": 42,
      "end_page": 52,
      "summary": "and would allow us to enforce special cases such as abstract base classes or objects we\nA Property Class for Generic\nractically every game has a unique set of game objects, and any code that has to\nand edit object properties.\nclass.\nThe interface is broken into two classes: a Property class and a PropertySet class.\ndata types, an enumeration for the type of data, and a string for the property name.\n1.7 A Property Class for Generic C++ Member Access \nclass Property\nvoid Register(int* value);\nProperty () ;\nProperty(std: :string const& name);\nProperty(std: :string const& name, int* value);\nProperty (std :: string const& name, float* value);\nProperty (std :: string const& name, std::string* value);\nProperty (std :: string const& name, bool* value);\n-Property () ;\nbool SetUnknownValue(std: :string const& value);\nbool Set(std: :string const& value);\nThe example code shows basic data types being used and stored, although these\nProperties do not actually declare their own objects, or allocate\ntype of the property.\nProperties are constructed and manipulated through a PropertySet class.\nPropertySet class contains the list of registered properties, the registration methods,\nclass PropertySet\nvoid Register(std::string const& name, int* value);\nvoid Register(std::string const& name, float* value);\nvoid Register(std::string const& name, std::string* value);\nvoid Register(std::string const& name, bool* value);\nProperty* Lookup(std::string const& name);\nbool SetValue(std::string const& name, std::string* value);\nbool Set(std::string const& name, std::string const& value);\nbool Set(std::string const& name, int value);\nbool Set(std::string const& name, float value);\nbool Set(std::string const& name, bool value);\nbool Set(std::string const& name, char* value);\nWe derive the game object from the PropertySet class:\nclass GameObject : public PropertySet\nAny properties or flags that need to be publicly exposed or used by other objects\n1.7 A Property Class for Generic C++ Member Access \nCalling objects can use the Lookup method to access the registered data.\nvoid Update(PropertySet& property_set)\nproperty_set.Lookup(\"test_value\");\nAs all of the game objects are now of type PropertySet, and as all objects are usu-\nNew derived object types simply have to register\ncannot be used without the Property class.\nHowever, the Property class can be used on\nrewriting the Property class itself.\nclass as well.\nmore reusable than large classes with many methods to handle every possible use.\nThe Property class can also be used to publicly expose methods that can be called\nProperty!PropertySet classes could also be rewritten as templates to support different\nproperty types.\nIsolating the property data using \"get\" and \"set\" methods will allow for format\nneeding to know anything about the data type of the property, making it more versa-\na hierarchy of C++ classes and a set of techniques that support data-driven develop-\ntakes surprisingly little time), new game entity classes can be added to the frame-\nclasses and an object factory method.\nFlyweight, Behavior, and Exported Classes\n\"classes\" to which a game entity will belong in this framework: its flyweight, behav-\n• The flyweight class is the look and feel of the entity.\nbetween an entity and its flyweight class is implemented through object composi-\n• The behavioral class defines how the object interacts with the rest of the game\nBehavioral classes are implemented as a traditional inheritance hierarchy,\nwith class Entity serving as abstract superclass for all others.\n• The exported class is how the object represents itself to the world.\nstant and allows an entity to advertise itself as several different object classes\nFor a game entity, the flyweight-friendly information con-\nMuch of a game entity's finite state machine deals with animation loops, deciding\nclass StateAndMediaManager\nclass hierarchy, which can take care of it with a minute amount of code.\nBehavioral Class Hierarchy\nThese are the actual C++ classes to which our entities will belong.\n• An abstract base class Entity that defines the interface and commonalities\n• Concrete subclasses that derive from Entity and implement actual objects\nclass Entity\n// Flyweight and Exported Class information\nin addition to constructors, at most three, and possibly only two, of the base class\nIf your game features several related behavioral classes whose differences are easy to\nFor example, all types of PlayerEntity objects will need to query an input device\nclasses.\nclass PlayerDevice : public Entity",
      "keywords": [
        "string const",
        "Property",
        "Property Class",
        "Entity",
        "string",
        "std",
        "Game Entity",
        "bool Set",
        "Game Entity Factory",
        "Game",
        "const",
        "object",
        "bool",
        "void",
        "Dynamic Type Information"
      ],
      "concepts": [
        "classes",
        "object",
        "void",
        "entity",
        "entities",
        "property",
        "properties",
        "code",
        "coding",
        "type"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 14,
          "title": "",
          "score": 0.699,
          "base_score": 0.549,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 5,
          "title": "",
          "score": 0.662,
          "base_score": 0.512,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 7,
          "title": "",
          "score": 0.56,
          "base_score": 0.41,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 3,
          "title": "",
          "score": 0.529,
          "base_score": 0.529,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 4,
          "title": "",
          "score": 0.413,
          "base_score": 0.263,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "std",
          "std string",
          "string const",
          "property",
          "string"
        ],
        "semantic": [],
        "merged": [
          "std",
          "std string",
          "string const",
          "property",
          "string"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20404022014662782,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284486+00:00"
      }
    },
    {
      "chapter_number": 7,
      "title": "Segment 7 (pages 53-62)",
      "start_page": 53,
      "end_page": 62,
      "summary": "The exported class is a convenience trick that you can use to make your entities' inter-\nvoid PacMan: :HandleInteractions( Entity * target )\nvoid PacMan: :HandleInteractions( Entity * target )\ncept of the exported class, a value that can be queried from an Entity object and\nexported class instead of an actual internal FSM state, a Ghost object can advertise\ndifferent entity classes at will from the outside world's perspective, all for the cost of\npossible exported classes for an Entity is usually small and easy to determine early on,\nentity's behavioral class, flyweight class, exported class, starting position and velocity,\nthe need to specify the behavioral class in the level file, and isolate the class hierarchy\n</ENTITY>\nNow, let's add a factory method to the Entity class.\nthe game and a list of the exported classes that belong to each behavioral class.\nCalling the method with an exported class as parameter returns a\nbehavioral classes, or when entity actions are easy enough to define without scripts.\nWhat if you need a way to change an entity's strategy at runtime, without necessarily\nto connect the C function created by the compiler with your behavioral class (or indi-\nThis is where function pointers come into play.\nUsing Function Pointers within C++ Classes\nA quick refresher: A C/C++ function pointer is a variable containing a\nHere is an example of a declaration of a pointer to a function taking\ntwo Entity objects and returning a Boolean value:\nAssuming that there is a function with the appropriate signature in the code, for\nthen the variable interactPtr can be assigned to it, and the function called by deref-\nUsing function pointers inside classes is a little trickier, but not by much.\nidea is to declare the function generated by the script compiler to be a friend of the\nclass SomeEntity : public Entity\n// The function pointer\nvoid ( * friendptr )( Entity * me, Entity * target );\n// Declare one or more strategy functions as friends,\nvoid Handlelnteractions( Entity * target )\nwhen calling class methods: the C++ viable secretly adds \"this\" as a first parameter to\nBecause any modern compiler will inline the function calls, there\nNote that picking and choosing strategies at runtime through function pointers is\nextreme cases, a single Entity class containing nothing but function pointer derefer-\nuring the lifetime of a piece of software, function interfaces are bound to change,\nWhen a function that interfaces to the rest of the project changes, the game (or tools,\nupdate the code that calls the changed functions before work can proceed.\n• Don't change any interface functions.\nand ends up resulting in functions or classes with names completely unrelated to\nWhat we really want is to be able to write a new interface function, but keep the old\ninterface function around for a while.\nnew function right away.\nThey may change their old code to use the new function\nThe problem with this is how to let everybody know which functions have\nchanged and which functions they are supposed to use.\nThis is where deprecating a function comes in.\nWe write the new function, and then\nflag the old function as deprecated.\nThen, every time the old function is used, the\ncompiler will generate a message explaining that a deprecated function is being called\nand mentioning which function should be used in its place.\nUsing and Assigning Deprecated Functions\nin C++ to flag specific functions as deprecated.\nSay we have a function that every-\ninterface of FunctionAQ has to change, so we write a new function called NeivFunc-\nYou are using the following deprecated functions:\n- Function FunctionA() called from 3 different places.\nImplementing Deprecation in C++\nEverything is implemented in one simple singleton class [Gamma95]: Deprecation-\nof the deprecated functions found so far.\nthe debug window, listing what deprecated functions were used in that session.\nUsually, we won't have to deal with this class directly because the DEPRECATE\nthe DeprecationMgr and add the function that is being executed to the list.\ntion is called, if there are no deprecated functions, it will never be created and it will\nMgr keeps a small structure for each deprecated function, indexed by the function\nOnly the first call to a deprecated function will\nber of different places from which each deprecated function was called.\ndecide to stop using the deprecated function.\nThen, if a function is called multiple times from the same place (in a loop for\nTypically, the address [EBP-4] contains the return address for the current function.\ntions are turned on, for particularly simple functions.\nthat deprecated functions were called from when optimizations are turned on, but at\nleast it won't cause the program to crash, and all the other functionality of the depre-\nThis is necessary because the deprecated functions may exist\nback of only reporting the deprecated functions at runtime is that it is possible for the\nprogram to still be using a deprecated function that gets called rarely enough that it\nThe use of the deprecated function might not be detected until it",
      "keywords": [
        "Entity",
        "function",
        "Game Entity Factory",
        "Deprecated Functions",
        "Entity Factory",
        "functions",
        "deprecated",
        "Game Entity",
        "target",
        "Entity class",
        "ghost",
        "behavioral class",
        "entity behavioral class",
        "function pointers",
        "exported class"
      ],
      "concepts": [
        "entities",
        "entity",
        "function",
        "functions",
        "functionality",
        "classes",
        "deprecation",
        "deprecating",
        "deprecate",
        "void"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 5,
          "title": "",
          "score": 0.622,
          "base_score": 0.472,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 4,
          "title": "",
          "score": 0.621,
          "base_score": 0.471,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 6,
          "title": "",
          "score": 0.56,
          "base_score": 0.41,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 14,
          "title": "",
          "score": 0.415,
          "base_score": 0.265,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 33,
          "title": "",
          "score": 0.373,
          "base_score": 0.373,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "deprecated",
          "entity",
          "function",
          "class",
          "deprecated functions"
        ],
        "semantic": [],
        "merged": [
          "deprecated",
          "entity",
          "function",
          "class",
          "deprecated functions"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1901641966763485,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284527+00:00"
      }
    },
    {
      "chapter_number": 8,
      "title": "Segment 8 (pages 63-70)",
      "start_page": 63,
      "end_page": 70,
      "summary": "ith the increasing complexity of game programming, the minimum memory\nlikelihood of memory leaks, memory bounds violations, and allocating more memory\nThis is where a memory manager comes into play.\nsimple memory management routines, we will be able to track all dynamically allo-\nOur goal is to ensure a reasonable memory footprint by reporting memory leaks,\ntracking the percentage of allocated memory that is actually used, and alerting die pro-\nvantages of creating a memory manager include die overhead time required for die man-\nager to allocate memory, deallocate memory, and interrogate die memory for statistical\nory manager during debug builds, or if the symbol ACTIVATE_MEMORY_MANAGER\nThe heart of the memory manager centers on overloading the standard new and delete\nBy overloading the memory allocation and deallocation routines, we\nwill be able to replace the standard routines with our own memory-tracking module.\nThese routines will log the file and line number on which the allocation is being\n1.10 A Drop-in Debug Memory Manager \nThe first step is to create the overloaded new and delete operators.\nearlier, we would like to log the file and line number requesting the memory alloca-\nThis information will become priceless when trying to resolve memory leaks,\noperator new(size_t size, const char *file, int line);\noperator new[](size_t size, const char *file, int\nthe routines that will use the memory manager to seamlessly pass the new operator the\ntfdefine delete setOwner(_FILE_,_LINE_) .false ?\npredefined macros, which include our required __FILE_ and \nfreeO methods with our own memory allocation and deallocation routines.\nmemory allocation and deallocation.\ndesired allocation, and initialize or interrogate the memory, based on the desired\nanalyze the memory requirements for any given program.\nMemory Manager Logging\nbeginning of this gem, we will concentrate on memory leaks, bounds violations, and\nthe actual memory requirements.\nThis structure contains the size of memory allocated not only for the user, but\nFor example, if the memory was allocated using the new[] operator and deal-\nlocated using the delete operator instead of the delete[] operator, a memory leak may\ndon't want to create a memory manager that uses more memory than the actual appli-\nthere are any memory leaks in the program.\nof all the allocated memory.\ning of allocated memory.\nthe hash table, a memory leak has occurred.\ninterrogated to report the details of the memory leak to the user.\n1.10 A Drop-in Debug Memory Manager \nused to allocate the memory matches the deallocation method; if not, we will note the\npotential memory leak.\noccur when applications exceed the memory allocated to them.\nand back of the memory allocated.\nThe only information remaining to be gathered is the actual memory require-\nWe would like to know how much memory was allocated, how\nmuch of the allocated memory was actually used, and perhaps peak memory alloca-\nmine how much of the allocated memory is actually used, we will need to perform a\nmemory within the AllocateMemoryO routine to a predefined value and interrogating\nbecause there is no predefined value to which we could initialize the memory and\nensure uniqueness, initializing the memory on 32-bit boundaries will generate far bet-\nOnce the user has enabled the memory manager\nall the memory leaks, bounds violations, and the final statistical report.\nThe problem before us is to ensure that the memory manager is the first object to\nated a static object that allocated dynamic memory within its constructor, before the\nmemory manager object is allocated, the memory manager will not be available for\nmemory tracking.\nresponsible for releasing allocated memory, the memory manager object will be\nreleased before the ::atexit() method is called, thus resulting in bogus memory leaks.\nFirst, by creating the InitMemoryManager object within the header file of the memory\n1.10 A Drop-In Debug Memory Manager \nThis holds true as long as we #include that memory manager header before any static\nMicrosoft states that static objects are allocated in the order in which they\nthat the memory manager is always available we are going to call the InitializeMemo-\nroutines, guaranteeing that the memory manager is active.\nthat the memory manager is the last object to be deallocated, we will use the ::atexit()\nthat must be placed on the memory manager is that it is the first method to call the\nmake sure that the memory manager is present.\nWhile this is not a problem if the memory manager is active before the declara-\nThe key to the solution is to ensure that the memory\nBesides the additional memory and time required to perform memory tracking, there\ngenerate syntax errors due to other files redefining the new and delete operators.\n#include <A11 other headers overloading the new/delete operators>\n// Contains the Memory Manager Module\nclasses use their own memory manager, and have non-MFC shared game code use our\nmemory manager.\n// Turn off our memory manager\nThis method will allow us to keep the advantages of MFC's memory manager,\nof the code with a memory manager.\nFile 1: line 1: class B { B() {a = new int;} ~B() {delete a;} };\nFile 2: line 2: delete objects;\n1. new( objects, File2, 1\n1.10 A Drop-in Debug Memory Manager \n.com/library/devprods/vs6/visualc/vccore/core_memory_management_with_mf",
      "keywords": [
        "memory manager",
        "Memory",
        "Debug Memory Manager",
        "Drop-in Debug Memory",
        "Manager",
        "file",
        "memory manager object",
        "memory leaks",
        "Debug Memory",
        "allocated memory",
        "line",
        "delete",
        "MFC memory manager",
        "information",
        "die memory manager"
      ],
      "concepts": [
        "memory",
        "information",
        "files",
        "manager",
        "routines",
        "die",
        "including",
        "include",
        "method",
        "line"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.564,
          "base_score": 0.414,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 9,
          "title": "",
          "score": 0.524,
          "base_score": 0.374,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "",
          "score": 0.497,
          "base_score": 0.347,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 10,
          "title": "",
          "score": 0.485,
          "base_score": 0.335,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 13,
          "title": "",
          "score": 0.474,
          "base_score": 0.324,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "memory",
          "memory manager",
          "manager",
          "allocated",
          "delete"
        ],
        "semantic": [],
        "merged": [
          "memory",
          "memory manager",
          "manager",
          "allocated",
          "delete"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2014494273439574,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284571+00:00"
      }
    },
    {
      "chapter_number": 9,
      "title": "Segment 9 (pages 71-80)",
      "start_page": 71,
      "end_page": 80,
      "summary": "A Built-in Game Profiling Module\nhis gem describes the architecture and implementation of a profiling module for\nlow-overhead, real-time analysis that supports performance counter organization\nIt is designed from a game\ntypically found in games.\nAt the time of this writing, the described module is in use\nby a commercially available game engine.\nProfiling the performance of a game or engine is one of those things that everyone\nWe need a high-resolution counter - the Win-\n1.11 A Built-in Game Profiling Module\nTo convert this number into seconds, we need to know the counter frequency.\ncounters are enabled — take a time sample, sleep for at least 500ms, and then take\ngame console.\nPC that sample an application as it runs, then offline allow profile data to be viewed\nCPU hardware counters to generate post-processed profiles of runtime sections of a\ngame.\nChanging the order or the way in which the game renders can sometimes signifi-\nNvidia releases special drivers and a real-time data viewing application\ning a significant percentage of CPU time, this application will allow us to look inside\nSome of the game consoles also provide this ability.\nGames typically have a fairly high frame-to-frame\nThe game engine is running through\nallows focusing on one problem at a time.\nAt the end of a PC game\nner of level three grinds the game to a slow crawl\" types of problems.\nover to that test machine and pop up a few counter groups, we would quickly nail\nModern game engines are complicated.\nProfile Module Requirements\nRequirement one: allow users to quickly and accurately profile the application.\nframe time, it can actually change the application's behavior within the system.\nA performance counter manager (IPerfCounterMan) keeps track of all active and inac-\na counter needs to be sampled, and for enabling and disabling groups of counters to\nWe will make use of four-character codes (FourCC's) for the group ID\nThe basic component is a counter that is identified by a group ID (its\n1.11 A Built-in Game Profiling Module \nIn typical usage, the game code creates counters on initializa-\ntion and puts start/stop counter calls around the code to be profiled.\n// Add new counter (returns the ID, 0 is failure)\nDeleteCounter(uint32 Counter-ID);\nStartCounter(uint32 Counter-ID);\n// Draw the Counters onto the Screen (to be called once\nOn DrawCounters, all the running counters are\nIt is a very convenient way to enable and disable counter groups and to\nIt is very helpful to allow as much configuration in the counter display as possi-\nWe will most likely not want to refresh the counter display every frame (updates\nThe interface to the performance counter manager should be flexible and easy to use.\ning the counter ID at some one-time initialization point.\nformance out of a game, profiling code is often one of the first things to go.\nWhen the counters are being displayed,\nThe game should be profiled in the areas that have performance problems as well\nas during typical game play.\nbecause a function is called the most often or takes the most CPU time doesn't mean\nchanges the behavior of your game.\nThere should be a counter around the profiler's\ndraw functions will mostly likely need to be implemented in platform-dependent\n1.11 A Built-in Game Profiling Module \nThis same system can be used to take long running profiles of a game server to\nWindows-based Games\nn the past, when DOS ruled the earth, we programmed our games in a mostly lin-\nadequate for game programming.\nsulate the message pump, provide a linear programming model and, as a very desir-\nIf your experience in game\nprogramming started with Windows, then you might find the message pump\na natural environment for game programming, but once you try linear pro-\nlot of design, programming, debugging time, and thinking if you start work-\nModern games often have some sort of UpdateWorld function, located in the heart of\nthe application in the message pump, and invoked whenever it is not receiving any\nwe plan that our game will have only one screen, no cut-scenes, no menus, and no\nAs old DOS games didn't have to return con-\n1.12 Linear Programming Model for Windows-based Games \nThe way to work around this is to make every subroutine of the application a\nwhen it finishes, must reset its state to 0, to allow the application to invoke it again.\nHere is a simple multithreading model that frees the game programmer from the mes-\npump in one thread and the game into another one.\nin the initial thread, so we can take out the UpdateWorld function from the message\nneed to add to the dolnit function the code necessary to initiate the game thread.\ninitialization code) in the dolnit function or directly into our RunGame function.\nhand, we could include all the initialization code in the RunGame function, which\nlinear game-programming function.\nissues in game programming.\nwhich some games attempt to disallow, but we will try to make things work correcdy.\nOur game thread will check if it must continue, or if it must wait for\nTo create and set the event, we need to include the following code during initial-\n1.12 Linear Programming Model for Windows-based Games \nMost games have a function in their main loop that is called every time the game\ntion to make the thread wait for the event in an idle state, using this code:\ntion has gone to an inactive state, we must suspend the game execution, which\nWith this simple implementation, when the user hits alt-tab, the game will tem-\nThis event model can be used with any number of threads that the application may\nin our game, which is a surface loaded from a file.",
      "keywords": [
        "Game Profiling Module",
        "Built-in Game Profiling",
        "Game",
        "counter",
        "Linear Programming Model",
        "Game Profiling",
        "game programming",
        "code",
        "application",
        "Built-in Game",
        "Programming Model",
        "Profiling Module",
        "Programming",
        "message pump",
        "Profiling"
      ],
      "concepts": [
        "game",
        "counters",
        "code",
        "coding",
        "profiling",
        "profiles",
        "programming",
        "program",
        "functions",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 8,
          "title": "",
          "score": 0.524,
          "base_score": 0.374,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 13,
          "title": "",
          "score": 0.476,
          "base_score": 0.326,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "",
          "score": 0.454,
          "base_score": 0.454,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.451,
          "base_score": 0.301,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 10,
          "title": "",
          "score": 0.441,
          "base_score": 0.291,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "counter",
          "game",
          "profiling",
          "application",
          "game profiling"
        ],
        "semantic": [],
        "merged": [
          "counter",
          "game",
          "profiling",
          "application",
          "game profiling"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22678605945104185,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284616+00:00"
      }
    },
    {
      "chapter_number": 10,
      "title": "Segment 10 (pages 81-89)",
      "start_page": 81,
      "end_page": 89,
      "summary": "// Push the function\nthe subroutine functionality.\n// Pop the function\nWe are using a stack so that each nested subroutine can add all the surface load-\nits nested functionality, and so a stack works best here.\nwww.gamedev.net/reference/articles/articlel249.asp.\nStack Winding\nIn this gem, we cover one particular type of stack winding that I call the \"tempo-\nThe code examples have been\nStack winding, as its name implies, is a technique for modifying the stack to make it\nThe term stack winding comes from the idea of inserting values\nListing 1.13.1 The TempRet routine\n.code\nIn Listing 1.13.1, we see the first building block of stack winding: the TempRet rou-\nLet's take a function (call it MyFunc) and say it calls _TempRetEg. The latter\nthen calls two functions: fnO and fnl.\n15 pops that address off the stack and stores it in a CPU register.\nThis pushes line 20 onto the stack and executes a JUMP to line 25.\nter does nothing but execute a CPU return, which pops an address off the stack and\nfunctions FNO through FN3.\nLet's say that FNO opens a file, FN1 allocates a buffer and reads the file into\nFunctionally the process of opening a\nThe TempRet example comes of age when we chain functions together.\n1.13 Stack Winding \nListing 1.13.2 Winding multiple routines onto the stack\n2 .code\nTempRet\nTempRet\nTempRet\nTempRet\nroutines onto the stack so that when _SomeUserRunFunc returns, we will bounce\nVisual C++ in the final section that aid us in stack winding: inline assembly and\nnaked functions.\nThunking is a technique popularized by Microsoft for slipping a piece of code\nThunks are a great way of implementing a stack-\nListing 1.13.3 Visual C++ example using TempRet\nTempRet\nTempRet\nTempRet\nTempRet\n1.13 Stack Winding \nAs a final example of the power of stack winding, we will explore a solution for a clas-\njust as well from a C++ object as a global function.\nListing 1.13.4 The SafeEnter and SafeExit functions that aid\n.code\npop edx ; return address\nmov eax,[esp] ; safe\nmov [eax].safe.\nmov [eax].safe.\nmov [eax].safe.\nmov [eax].safe.\nmov [eax].safe.\neax ; safe pointer\nedx ; call function\npush eax ; safe pointer\npop edx \npop eax \nmov edi,[eax].safe.\nmov esi,[eax].safe.\nmov esp,[eax].safe.\nmov ebp,[eax].safe.\nmov ebx,[eax].safe.\nmov edx,[eax].safe.\nmov eax,[eax].safe.\nSafeEnter works by saving off to a SAFE structure a copy of crucial CPU regis-\nIt then calls our recursive function.\ncriteria, then the function can simply return in the normal way, all the way up the chain.\nListing 1.13.5 Recursive example using SafeEnter and SafeExit\nSafeExit(safe);\nsafe,\nelf-modifying code, also known as \"RAM-code,\" is a fascinating technique that\nRAM-code is a simple idea, but one that can take an inordinate amount of time to get\nId hl,ptr_var \nLoad HL register with the address ptr_var\nId h,(hl)\nLoad L register with high byte of ptr_var\nand loading an address, we just load HL.\nwrite the value ahead into the code.\nthis code can be optimized down to:\ncan then use RAM-code techniques to construct an execute-buffer—a piece of code\nThe blitter works by taking a routine that knows how to read 16-bit (565) RGB",
      "keywords": [
        "Stack Winding",
        "stack",
        "call",
        "SAFE",
        "ret",
        "TempRet",
        "eax",
        "Winding",
        "code",
        "General Programming",
        "ret static NAKED",
        "pop edx",
        "edx",
        "mov",
        "call edx"
      ],
      "concepts": [
        "function",
        "functionality",
        "functions",
        "code",
        "ret",
        "returns",
        "stack",
        "safe",
        "examples",
        "pop"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 26,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.538,
          "base_score": 0.388,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 13,
          "title": "",
          "score": 0.499,
          "base_score": 0.349,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "",
          "score": 0.495,
          "base_score": 0.345,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 8,
          "title": "",
          "score": 0.485,
          "base_score": 0.335,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "safe",
          "eax",
          "stack",
          "eax safe",
          "tempret"
        ],
        "semantic": [],
        "merged": [
          "safe",
          "eax",
          "stack",
          "eax safe",
          "tempret"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24864390019163993,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284659+00:00"
      }
    },
    {
      "chapter_number": 11,
      "title": "Segment 11 (pages 90-100)",
      "start_page": 90,
      "end_page": 100,
      "summary": "04h\n08h\n10h\nmov edi,ecx \nmov esi,[ebp+8] \nmov eax,[esi].bitmap.pxf\nmov edx,[edi].bitmap.pxf\ncmp eax,edx\nmov ecx,[esi].bitmap._size\ncmp ecx,[edi].bitmap._size\necx,[edi].image.stride\nmov edx,[esi].image.stride\njne @f\nmov edx,[edi].image.h\nmov eax,[esi].image.h\ncmp eax,edx\nmov eax,edx\nmov ecx,eax\nk3: mov esi,[esi].image.Ifb\nmov edi,[edi].image.Ifb\nrep movsd\njmp ou\nmov eax,[edi].image.h\nmov ebx,[esi].image.h\ncmp ebx,eax\nmov ebx,eax\neax, [ebp].rectangle.w\n[esi].image.depth; edx corrupts\nedx,[esi].image.stride\necx,eax\nedx,eax\neax\neax\nedi,[edi+eax]\neax,execute_buffer\neax\nedi,eax\nwrite \"mov ebx,h\"\neax,[ebp].rectangle.h\nwrite \"mov ecx.w\"\neax,[ebp].rectangle.w\neax\n, eax\neax\n, eax\neax\neax\neax\n,eax\neax, ecx\neax ,[esp+4]\neax,6\n[esp+4] ,eax\neax\necx, [ebx] .image.\necx, eax\nmov eax, ecx\neax\neax\neax, 6\neax, 16\neax,[ebp-12].point.x\necx,eax\neax,[ebp-12].point.y\n[edi].image.stride\nedi,eax\neax,[ebp].rectangle.x\necx,eax\neax,[ebp].rectangle.y\n[esi].image.stride\nedx,[esi].image.pal\nesi,ecx\nesi,eax\nmov ecx,0\nmov ebx.eax\nadd eax,ebx\nadd eax,edx\nmov eax,[eax]\nand eax,-1\nand eax,-1\nshr eax,8\nax,bx\neax,13h\nax.bx\nFile Management Using\nResource Files\ngems2@fireworks-interactive.com\nHaving 10 files in\nfiles come into play.\nResource files give us the power to encapsulate files and directo-\nries into a single file, with a useful organization.\nWhat Is a Resource File?\nWe already use resource files all the time in our daily work—examples of these are\nA resource file is nothing\nmore than a representation of data, usually from multiple files, but stored in just one\nfile (see Listing 1.15.1).\nUsing directories, we can make a resource file work just like a\nhard drive's file system does.\nListing 1.15.1 Resource file structure.\nNumber of Files \nOffset of First File = 19\n[File 1]\n[File 2]\n[File 3]\n[File .]\n[File .]\n[File .]\n[File Number Of Files - 1]\n[File Number Of Files]\n1.15 File Management Using Resource Files \nEach lump (we will start calling files \"lumps\" from now on) in the resource file\nListing 1.15.2 File lump structure.\nFile Size = 14,340\n[Byte File Size - 1]\n[Byte File Size]\nLet's call this system the \"Seal Resource File Sys-\nFirst, we need a resource file header.\nOur resource file header gives us all the relevant information about the system.\nMultiple file types are used in games, and for each type, there is usually a file header\ndifferent, so the first data in its header is the file signature.\ncharacter string, and is required so that we can identify the file as a valid Seal resource\nfile.\nfile's version, which is required for a very simple reason: if we decide to upgrade our\nsystem by adding new features or sorting the lumps differently, we need a way to ver-\nify if the file being used supports these new features, and if so, use the latest code.\nFor our first version of the file system, we won't use this, so\nFollowing this is the number of lumps contained in the resource file,\nand the offset to the first lump.\nthe resource file if we happen to get lost, and can also be used to support future ver-\nsions, and the offset will point to the first lump.\nWe now move to our lump header, which holds the information we need to start\nWe start with the lump size in bytes, followed by name and direc-\nOur system has only two modules: a resource file module and a lump module.\nbe able to use a lump, we need to load it from the resource file and possibly decrypt or\nprefer to encapsulate all functionality into the resource file module, and even allow\ndirect access to lump data from within this module.\nresource in memory at once, unless we use only raw data or complicated algorithms to\nWe need functions to open the resource file, read the header, open individual\nlumps, read information from lumps, and get data from lumps.\nOur lump module is similar to file streams in C++ or other language implementations\nof files in that we can write to it.\nUnfortunately, updating the resource file with a\nresource file.\nSTRING \nlump, szLumpName is a string describing die lump's name, dwLumpPosition keeps the\nlump's pointer position, and abData is an array of bytes with the lump information.\n1.15 File Management Using Resource Files \nThis module has all the functionality needed to load any lump inside the resource.\nThe module members are nearly the same as those in the resource file header.\nFILE \ndwVersion is a double word that specifies the file version, dwFlags is a double\nword containing any special flags for the lump, dwNumberOfLumps is the number of\nlumps in the resource, dwOffiet gives us the position in bytes where the first lump is\nwe use to access each lump individually.\nSTRING GetCurrentDirectory (void);\nIsLumpValid () checks to see if a file with a\nSetCurrentDirectory () sets the resource file\nThis directory name is prepended to each lump's name\nwhen accessing individual lumps within the resource file.\nThis function opens a lump within the resource file,",
      "keywords": [
        "Resource File",
        "File",
        "mov",
        "BGR",
        "mov eax",
        "eax",
        "Resource",
        "lump",
        "resource file header",
        "Byte File Size",
        "esi",
        "resource file module",
        "Seal Resource File",
        "DWORD",
        "size"
      ],
      "concepts": [
        "file",
        "code",
        "string",
        "lump",
        "size",
        "bitmaps",
        "byte",
        "resource",
        "add",
        "writing"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 18,
          "title": "",
          "score": 0.541,
          "base_score": 0.391,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 36,
          "title": "",
          "score": 0.42,
          "base_score": 0.42,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 56,
          "title": "",
          "score": 0.375,
          "base_score": 0.375,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.354,
          "base_score": 0.354,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 38,
          "title": "",
          "score": 0.35,
          "base_score": 0.35,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "eax",
          "file",
          "resource",
          "resource file",
          "lump"
        ],
        "semantic": [],
        "merged": [
          "eax",
          "file",
          "resource",
          "resource file",
          "lump"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22002370397668886,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284700+00:00"
      }
    },
    {
      "chapter_number": 12,
      "title": "Segment 12 (pages 101-108)",
      "start_page": 101,
      "end_page": 108,
      "summary": "Game Input Recording and\nplified universe of a game, Laplace's determinism actually works.\nIf you carefully record everything that can affect the direction of your game uni-\nGame input recording is useful for more things than many people realize: reproduc-\ning rare bugs, replaying interesting games, measuring optimizations, or creating game\nThe crucial step here is that if we are to use input recording to track bugs, we have\nto make sure that the input is recorded even when the game crashes—especially when\nthe game crashes!\never the game crashes.\nIf we add an option to our game engine to \"fast-forward\" through game input\nalso add an option to render frames at the exact same points in the game update loop,\nReproducing bugs is the one time when you will want to record and playback all\nThe most common use of game input recording is for players to record interesting\ngames.\nThese recordings are used to demonstrate how to play the game, to make tuto-\nThe most important thing about recording games for users to play back later is\nthe beginning of the game whether they want to record the game for posterity; they\ngame.\nGame input playback is a great solution.\ntimes, recording detailed information about game performance, you can chart your\nTesting optimizations with game input playback doesn't always work because\nTherefore, when using game input playback\nfor optimization testing, it is crucial that you record critical game state and check for\n1.16 Game Input Recording and Playback \nCreating Game Movies\nWith game input recording, it's trivial to record an interesting game, and then\ngame engine when you are at an interesting part of the playback, at which point you\nengine can render precisely 60 frames for each second of game play, and record each\nGame input recording is simple in theory, and can be simple in practice as well.\nMaking Your Game Predictable\nFor game input recording and playback to work, your game must be predictable.\nFor example, if your game can be affected by the exact timing of task switching,\nthen your game is unpredictable.\nMany games use variably interleaved update and render loops.\nInput is recorded\nA frame is rendered and then the game update loop runs as many\nThis model implies that the number of times that the game update loop is run for\neach frame rendered is unpredictable; however, this needn't make the game itself\nHowever, if the render function does anything to change the state of the game,\nthen the variably interleaved update loop and render function do make the game\nFor many games, this is not a problem because there is no synchronization of the\ngame to the end of these sounds.\nLuckily, many changes to code and data don't affect the way the game will unfold.\nAn example of a code or data change that could affect how your game behaves\n1.16 Game Input Recording and Playback \nRandom numbers can be used in a deterministic game, but there are a few caveats.\ngame.\nIf your rendering code and your game update code are both using rand()—and if the\nnumber of frames rendered per game update varies—then the state of the random\nyour game update loop and your Tenderer get their random numbers from different\nThe third problem with rand() comes if you save a game and continue playing,\nand then want to reload the saved game and replay the future inputs.\nwas in when you saved the game.\nyour render loop, and one for your game update loop.\nOnce you have restored your game's initial state, you need to make sure that you can\nrecord and play back all of the input that will affect your game.\nIf your game update\nframe, and hand out this information as requested by the game update loop.\nInput, a saved game, the network, or a WindowProc, without the update loop know-\nAs a nice bonus, isolating the game input in one place makes your\ngame code cleaner and more portable.\nAnother important input to a multiplayer game is the network.\nable to replay your game, dien you need to record the incoming network data\nThe final \"input\" that a game might use is time.\nIt is a good idea to record inputs throughout the game.\nplayback to track down bugs anywhere in the game, even in the pre-game menus.\nGame input recording should work on any well-written game.\nEven if your game is a\nmultiplayer game, if you record every piece of input that you receive on your\nHowever, if your game playbacks are failing to give consistent results, it can be\nof the game entities.\n1.16 Game Input Recording and Playback \nGame input recording and playback is a valuable part of a game engine with many\n• Route all game input, including keyboard, mouse, joystick, network, and time,\nThis input should always be recorded.\n• Never change the game's state in rendering functions.\n• Store some of your game state along with the input so you can automatically",
      "keywords": [
        "Game Input Recording",
        "Game",
        "Game Input",
        "Input Recording",
        "Input",
        "Game input playback",
        "game update loop",
        "game update",
        "Recording",
        "random number",
        "Playback",
        "number",
        "game state",
        "input playback",
        "code"
      ],
      "concepts": [
        "game",
        "input",
        "code",
        "coding",
        "function",
        "functions",
        "recording",
        "algorithms",
        "randomness",
        "time"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 54,
          "title": "",
          "score": 0.578,
          "base_score": 0.428,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 53,
          "title": "",
          "score": 0.573,
          "base_score": 0.423,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 52,
          "title": "",
          "score": 0.541,
          "base_score": 0.391,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 51,
          "title": "",
          "score": 0.476,
          "base_score": 0.326,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 9,
          "title": "",
          "score": 0.454,
          "base_score": 0.454,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "game",
          "game input",
          "input",
          "recording",
          "playback"
        ],
        "semantic": [],
        "merged": [
          "game",
          "game input",
          "input",
          "recording",
          "playback"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2163894875007122,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284759+00:00"
      }
    },
    {
      "chapter_number": 13,
      "title": "Segment 13 (pages 109-116)",
      "start_page": 109,
      "end_page": 116,
      "summary": "early every modern game requires some sort of text parser.\ning system designed to handle any type of file format.\nText files have a number of advantages when representing data:\n• They are flexible—the same parser can be used for simple variable assignment or\n• They can share constants between code and data (more on this later).\n• Unlike most binary formats, text must first be tokenized and interpreted, slowing\n• Stored text is not space efficient; it wastes disk space and slows file loading.\nof both worlds: the ease of use of text files, and the loading speed of binary data.\ndiscuss a method for compiling text files into a binary format later in the gem.\n• Native support for basic data types: keywords, operators, variables, strings, inte-\n• Unlimited user-definable keyword and operator recognition\n• Debugging support, able to point back to a source file and line number in case of\n• #include file preprocessing support\n• #define support for macro substitution\nsupport may seem a bit out of place when discussing a text parser.\nPreprocessing data files in the same manner as C or C++ code can have some wonder-\nthat we wish to create a number of unique objects using a script file, which will pro-\nvide the necessary data to properly initialize each object and create unique handles for\n{ Data = 10 }\n{ Data = 20 }\n{ Data = 30 }\ncode, we now have three Foo objects in memory, each with unique member data, cre-\nrequires a valid Foo object as a data member, and so we use a reference to the first Foo\nsolved in C and C++ through the use of header files in which variables and other com-\nscript as simply another source file, the advantages of a C-like preprocessor quickly\n- Script File -\n// Directs the parser to scan the header file\nnumbers, both the text script and source code share the same header file, so it's impos-\n#define, it's just one more step to actually parse and use more complex macros.\nognizing generic argument-based macros, we can now make complex script opera-\nprimitive form of templates), we can create custom script-based macros without\nbreaking C++ compatibility in the header file.\nNote diat although we're processing macros and #defines, the parser does not rec-\nThere are five classes in our parsing system: Parser, Token, TokenList, TokenFile, and\nThe Macro class is a helper class used internally in Parser, so we only need to\nheart of the parsing system: Parser, Token, and TokenList.\nThe basic data type of the parsing system is the Token class.\ndata types represented by the class: keywords, operators, variables, strings, integers,\nreal numbers, Booleans, and GUIDs. Keywords, operators, variables, and strings are\nhandy to have a data type that is guaranteed unique, such as for identifying classes to\nThe Token class is comprised of a type field and a union of several different data\nA single class represents all basic data types.\nEach of the data types has a role to play in the parser, and it's important to under-\nKeywords are specially defined words that are stored in the parser.\nA variable is any character-based token that was not found in the keyword list.\nparser will recognize any number with a decimal point as a float.\nBy making use of the macro-expansion code, we can support GUIDs without too\nTokenList class allows viewing of the file and line number that any given token comes\nThe Parser Class\nWe first create a parser object and call\nbeyond the defaults required for the text parsing.\nOften, for simple parsing jobs, #include file processing and\nThe first pass reads the files and translates the text\nProcessHeadersQ, looks for any header files embedded in the source, and then parses\ntion, ProcessMacrosQ, performs both simple and complex C-style macro substitution.\n// Create the parser and reserve some more keywords and tokens\nparser.Create();\n// Now parse the file, any includes, and process macros\nparser.ProcessSource(\"data\\scripts\\somescript.txt\", &toklist);\nBecause parsing and processing human readable text files can be a bit slow, it may be\nnecessary to use a more efficient file format in the shipping code.\ntext file multiple times, doing #include searches, macro substitutions, and so forth.\nCharacter-based values, such as keywords, operators, and variables, are stored in a\nThe class can also store the file in either a case-sensitive or\nReading the file is performed with the Read() function.\nText file processing at its simplest level is a trivial problem requiring only a few lines\ntweak shouldn't contain any additional data and/or functionality, and that the\n• It should be simple to use, meaning that the user should be able to define vari-",
      "keywords": [
        "Text Parsing System",
        "Flexible Text Parsing",
        "data",
        "Parsing System",
        "Text",
        "parser",
        "file",
        "Text Parsing",
        "Text files",
        "data types",
        "header file",
        "Flexible Text",
        "code",
        "System",
        "Token"
      ],
      "concepts": [
        "data",
        "file",
        "text",
        "parser",
        "classes",
        "script",
        "define",
        "defined",
        "function",
        "functionality"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.548,
          "base_score": 0.398,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 10,
          "title": "",
          "score": 0.499,
          "base_score": 0.349,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "",
          "score": 0.492,
          "base_score": 0.342,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 9,
          "title": "",
          "score": 0.476,
          "base_score": 0.326,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 8,
          "title": "",
          "score": 0.474,
          "base_score": 0.324,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "text",
          "parser",
          "file",
          "parsing",
          "data"
        ],
        "semantic": [],
        "merged": [
          "text",
          "parser",
          "file",
          "parsing",
          "data"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23368941335253507,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284805+00:00"
      }
    },
    {
      "chapter_number": 14,
      "title": "Segment 14 (pages 117-128)",
      "start_page": 117,
      "end_page": 128,
      "summary": "We will use template specialization to provide type information that we can store in a\nFirst is our base class TypelDjc that defines the interface for our type\ninformation class with a virtual function that returns a string with the type name:\nclass TypeID_c {\nNext, we create a template class that we can use to retrieve the correct type when\nIn this class, we add a member to get the pointer to our TypeID_c\nclass Identifier_c {\nNow that we have this class declared, we will use template specialization to define\nEach subclass of TypeID_c will exist as a singleton, and the pointer\nclass floatID_c : public TypeID_c {\nstatic TypeID_c* const Getldentification () ;\nclass Identifier_c<float> {\nTo use these classes for type information, we can simply store the base pointer:\nconst TypeID_c* const pcType = TweakableBase_c: :GetTypeID( vMyFloat ) ;\nHere, the TweakableBase_c (more on this class later) has a template member that\nclass to hold the pointer to the tweakable variable.\nwhich specific types of tweakables we have stored in memory.\nthe class is polymorphic by adding a virtual function to get the type info stored (or\nclass TweakableBase_c {\nvirtual const TypeID_c* const GetStoredType() const { return NULL; }\nreturn Identifier_c<T>::GetType();\ndata such as type information, limits for range checking, a pointer for a call-back func-\nclass TweakableType_c : public TweakableBase_c {\nconst TypeID_c* const GetDataType() const { return m_pcType; }\nconst TypeID_c* const m_pcType; \nthe pointer to the actual data type, hiding the casting to void horn the interface.\nclass will store all of our tweakables and give the user functionality for tweaking the\ntemplate<class Value_x>\nTweakableType_c<Value_x>* pcType;\nif( pcType = dynamic_cast< TweakableType_c<Value_x>* >(\nTweakableTypeRange_c<Value_x>* pcTypeRange;\nif ( pcTypeRange = dynamic_cast< TweakableTypeRange_c<Value_x>* >(\na given variable, we have an instance database to hold different tweakers.\nDefining a variable to be tweakable requires us to create a tweaker and add\nTweaker_c* pcTweaker = TweakerInstanceDB_c::AddTweaker( \"Landscape\",\nthe this pointer and makes sure that each instance of the class Landscape gets a unique\nFor tweaking this variable, all we need is the name, data type, and desired\nTweaker_c* pcTweaker =\nTweaker_c::TweakError_e eError;\nFor tweaking values, we have defined input methods that can be assigned to the\n• It takes up less space for the type information, since it is only required for classes\n• One can add specific information to the TypeID_c class; for example, a way to\nload and store the type or a pointer to the GUI control.\nGenuine Random Number\nomputer games use random numbers extensively for rolling dice, shuffling cards,\nComputers are great at generating pseudo-random numbers, but\nnot so good at creating genuine random numbers.\nPseudo-random numbers are num-\nous random number.\nGenuine, or real, random numbers are numbers that not only\ngenerated without the input of the previous random number.\nmethod of creating genuine random numbers in software.\nPseudo-Randomness\nConsider the common case of a game that initializes its random number\nof seed, and the number of bits of randomness in the seed is unacceptably small.\ntems is the generation of unpredictable random numbers.\nThe use of pseudo-random\nnumbers leads to false security, because a pseudo-random number is fully pre-\nGenuine Randomness\nA genuine random number meets the following criteria: it appears random, has\nThe ideal way of creating genuine random numbers is to use a physical source of\nlarge number of uncorrelated sources and mix them with a strong mixing function.\"\nBy taking input from many unrelated sources, each with a few bits of randomness,\nentropy—a truly random number.\nRandom Input Sources\nExamples of random input available on many PCs and game consoles include:\n• Timing between last N keystrokes or controller input\n• Data stored at a semi-random address in main memory, video memory, etc.\n• Hardware identifiers: CPU ID, hard drive ID, BIOS ID, network card ID, video\nor hardware IDs. The reason to include these values is that they're variable across\neach input provides a few bits of randomness.\nrandomness.\n1.19 Genuine Random Number Generation \nIt's useful to buffer sources such as mouse positions, keystrokes, and\nan input source.\nSome gaming platforms have access to physical sources of randomness.\n• Input from sound card (for example, the microphone jack) with no source\n• Input from a video camera\nIn the context of creating genuine random numbers, a strong mixing function is a\nUnlike generating pseudo-random numbers, creating genuine random numbers in\nFor the output to be truly random, many sources must be sam-\nGame consoles have a more limited selection of input sources compared to PCs,\nThe randomness of the results depends solely on the level of entropy in the input\nsion, the less random the output, because the smaller the change in the input bits.\nA C++ example of a genuine random number generator is provided on the accompa-\nIt uses hardware sources of randomness, such as\nthe Intel RNG and sound card input, when those sources are available.\ninput, but uses enough to produce a high level of randomness.\nHere is an example use of GenRand to create a genuine seed value:\nh\" // Genuine random number header\nIt samples the random\ninputs, and then uses a strong mixing function to produce the output.\n1.19 Genuine Random Number Generation \nsystem (drive, sound card) access, we can use the hardware latency as a source of random\ninput; hence, the snapshot of the current time at the beginning and end of the function.\nFinally, here's one of the input sampling functions.\nrandomness.\nHow Random Is GenRand?\nThere are many tests for examining the quality of random numbers.\n^ c \"\"\") \nsources of hardware input (including hard drive seek time), and generating a file of",
      "keywords": [
        "Genuine Random Number",
        "Random Number",
        "Random",
        "const",
        "const TypeID",
        "Genuine Random",
        "Type",
        "input",
        "Type Information",
        "static const TypeID",
        "number",
        "creating genuine random",
        "Tweaker",
        "random input",
        "sources"
      ],
      "concepts": [
        "random",
        "returns",
        "input",
        "classes",
        "function",
        "functions",
        "functionality",
        "useful",
        "uses",
        "buffer"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 5,
          "title": "",
          "score": 0.705,
          "base_score": 0.555,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 6,
          "title": "",
          "score": 0.699,
          "base_score": 0.549,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 4,
          "title": "",
          "score": 0.543,
          "base_score": 0.393,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.455,
          "base_score": 0.455,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 3,
          "title": "",
          "score": 0.452,
          "base_score": 0.452,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "random",
          "genuine",
          "genuine random",
          "const",
          "sources"
        ],
        "semantic": [],
        "merged": [
          "random",
          "genuine",
          "genuine random",
          "const",
          "sources"
        ]
      },
      "topic_id": 4,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21314609444378302,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284845+00:00"
      }
    },
    {
      "chapter_number": 15,
      "title": "Segment 15 (pages 129-137)",
      "start_page": 129,
      "end_page": 137,
      "summary": "Using Bloom Filters to\nThe bit array faithfully represents its relative value with 100-percent\nBloom's\nA Bloom Filter can reduce the time it takes to compute a relatively expensive and rou-\na Bloom Filter is guaranteed to be 100-percent accurate if the Bloom Filter test returns\na false (miss), but is, at best, only probably true if the Bloom Filter returns true (hit).\nA Bloom Filter can store the true result of any function.\nfunction, if a Bloom Filter test returns true.\nThere are two primary functions in a Bloom Filter: a function for storing the Boolean\ntrue value returned from an expensive function, and a function for testing for a previ-\nand modify the Bloom Filter Array accordingly.\nin the same form as the storing function and return a Boolean value.\nfunction returns false, it is guaranteed that the input was never previously stored using\nThe high-quality operation of a Bloom Filter requires a high-quality hash function\narray and produces a 16-byte (128-bit) return value.\nIf we choose a Bloom Filter Index bit size of 16 bits, a 128-bit\nBloom Filter Key can be broken into eight complete 16-bit segments.\n1.20 Using Bloom Filters to Improve Computational Performance \nThe number of Bloom Filter Phases used in a Bloom Filter is the number of\nBloom Filter Indexes used to store the Boolean value from the expensive function.\nexample, three phases might be used from a 128-bit key using a Bloom Filter Index\nA Bloom Filter Array is used to store the expensive function's Boolean value.\nexample, if the Bloom Filter Index bit size is 16 bits, the Bloom Filter Array will be 216\nThe Bloom Filter Saturation of the Bloom Filter Array is the percentage of bits set\nto true in the bit array.\nA Bloom Filter Array is optimal when saturation is 50 percent,\nthree phases with an index bit size of 16 bits into an array 64k bits long (8k bytes).\nThe format of the stored expensive function parameter data\nis independent of the Bloom Filter performance, accuracy, or memory usage.\nLet's assume that the hash function returned the 128-bit value Oxl0027AB30001BF\nThe Bloom Filter Array starts out reset (all false bits), before we begin to populate\nthe bit array with data.\nindex in the Bloom Filter Array to true regardless of its previous value.\nThis is the origin of the possible false positive result when testing the Bloom Fil-\nWhen we wish to examine the Bloom Filter Array to determine if there was a pre-\nstore, except that the bits are read from the Bloom Filter Array instead of written to\nIf any of the read bits are false, then the expensive function parameter was\nabsolutely never previously stored in the Bloom Filter Array.\nthen the expensive function parameter was likely previously stored in the Array.\nTuning the Bloom Filter\nTuning the Bloom Filter involves determining the number of phases and the bit\ncapacity of the Bloom Filter.\nBloom Filter\nboolean test_bloom_data(\"Mikano is in the office \")\nFIGURE 1.20.1 Flow of a Bloom Filter.\n1.20 Using Bloom Filters to Improve Computational Performance\n// tests a bit in the Bloom Filter Array.\n// sets a bit in the Bloom Filter Array\n// if bit is not set, we have a miss so return false\n// if bit is not set, we have a miss so return false\nif ( !is_bit_index_set( nlndexValue ) ) return( false );\nthe bit array is 50 percent.\nOther equations are available to tune the Bloom filter algorithm.\nBy assuming that the Bloom Filter Array is operating at optimum capacity of 50-\nNext, we calculate the Bloom Filter Array bit size.\narray_bit_size = ( number_of_phases * max_stored_input\narray _bit_size = .2*\nFinally, compute the index_bit_size from the array_bit_size.\n1.20 Using Bloom Filters to Improve Computational Performance\nwith at least 95-percent accuracy when the Bloom Filter Array test returns true.\n5 phases * 9000 expensive function parameters / -ln(0.5) = 64,921 bits\nthe expensive function, as Bloom did in his algorithm.\nof the false positive cases that can be returned from testing a Bloom Filter.\nAnother way to improve performance is to dynamically build a Bloom Filter\nIf the range of expensive function parameters is too great, Bloom Filters can be\ndynamically building a Bloom Filter Array, the commonly tested expensive function\nin the bit array.\nStandard Bloom Filter Test Code\nBloom Filter\nBloom Filter configurations.\n• Two Bloom Filter Arrays can be merged together by bitwise ORing them.\n• Bloom Filter Arrays can be shared among parallel clients.\n• Optimized Bloom Filter Arrays are not compressible.\n• Memory corruption in the array can be mended by setting unknown bits to true.\nBloom Filters offer a method of improving performance of repeatedly called expensive\nAdding a Bloom Filter algorithm to a program can\n\"Bloom Filters,\" available online at http://\n[FlipcodeOl] Flipcode, \"Coding Bloom Filters,\" available online at \"www.flipcode",
      "keywords": [
        "Bloom Filter Array",
        "Bloom Filter",
        "Filter Array",
        "Bloom Filter Key",
        "Bloom",
        "Bloom Filter Index",
        "Bloom Filter test",
        "Filter",
        "Bloom Filter Indexes",
        "Bloom filter algorithm",
        "Bloom Filter returns",
        "Filter Index bit",
        "Bloom Filter performance",
        "Bloom Filter Phases",
        "array"
      ],
      "concepts": [
        "bloom",
        "bit",
        "bits",
        "filters",
        "array",
        "returns",
        "value",
        "performance",
        "perform",
        "tested"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.47,
          "base_score": 0.32,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 13,
          "title": "",
          "score": 0.442,
          "base_score": 0.292,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 8,
          "title": "",
          "score": 0.43,
          "base_score": 0.28,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 10,
          "title": "",
          "score": 0.361,
          "base_score": 0.211,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "",
          "score": 0.347,
          "base_score": 0.197,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "bloom",
          "bloom filter",
          "filter",
          "filter array",
          "array"
        ],
        "semantic": [],
        "merged": [
          "bloom",
          "bloom filter",
          "filter",
          "filter array",
          "array"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1558564307306589,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.284886+00:00"
      }
    },
    {
      "chapter_number": 16,
      "title": "Segment 16 (pages 138-146)",
      "start_page": 138,
      "end_page": 146,
      "summary": "3ds max Skin Exporter and\njust after the creation of the animated character in 3ds max (and Character Studio),\nand ending with that object smoothly animating in a game's real-time scenes.\nCharacter Studio 2.2, using Biped and/or bones and the Physique modifier.\n• Mesh information (vertices, normals).\n• Influence values (weighting) of each bone to vertices of the mesh (one\nvertex may be influenced by multiple bones).\n• Bone animation: For each bone, this consists of a set of translation and\ncalculates the current transformation matrix to be applied to each bone.\ninfluence value that each bone has on a particular vertex.\nThe process of exporting the animation data with a plug-in for MAX is not well\nThis gem is based on a hierarchical bone structure: a bone tree or a Biped, created\nmesh should be a single selectable object in MAX.\nvertex weights, and animation keys.\nExporting to MRC with the MAX SDK\nAccessing scene data requires an Interface passed by MAX to the main export rou-\nFor every object in MAX, there is a node in the\ndirectly access a node if the user has selected it in MAX before exporting.\nA node could represent anything, so we need to discriminate among object types\nFor our purposes, we need to check if a node is a geometric object (a mesh)\nor a bone (a Biped node or a bone).\nif(pNode == NULL) return false;\n1.21 3ds max Skin Exporter and Animation Toolkit \nif(pNode == NULL)return false;\nif(os.obj->ClassID() == Class_ID(BONE_CLASS_ID, 0))\nThe previous example explains how to navigate MAX's nodes and check what\nOnce we get a mesh node, we need to acquire the desired vertex data.\nGetting Mesh Data\nobject coordinates are in object space, so we need a transformation matrix to be\napplied to each vertex and normal of the mesh.\nWe can grab this global transformation matrix at any time during the animation\nworld space coordinate of one mesh vertex.\ncoordinate in object space and multiplying it (post-multiply in MAX) by the matrix\nWe are interested in mesh data at the animation start, so\nMatrix3 tm = pNode->6etObjectTM(0)\nMAX has a modifier stack system, where every object is the result of a modifica-\nobject, the final object is built, applying modifiers in sequence along the stack.\nObject and has methods to navigate the stack of modifiers.\nTo get the result at a specified animation time, we must first retrieve an Object-\nMAX apply each modifier in the pipeline from beginning to end.\nobject, we can finally get the mesh data.\nMesh& mesh = *(((GeomObject*)os.obj)->GetRenderMesh(0, pNode, ...));\nListing 1.21.1 illustrates how to export mesh data to a file.\nthe bone's parent, and then we grab the bone orientation matrix.\nmatrix to transform every mesh vertex from world space to related bone space,\nso it can move with the bone.\nGetting the Bone Influences\nNow we are at the most exciting part of this gem: getting the vertex bone assignment\ninfluence the same vertex and the mesh deformation depends on both (see [Wood-\n1.21 3ds max Skin Exporter and Animation Toolkit \nFirst, we must find the Physique modifier on the object's node that we wish to\nexport (this is the same node we used earlier to get the mesh vertex data).\nthe stack until we find the Physique modifier (using a Class_ID check).\nModifier* GetPhysiqueMod(INode *pNode)\nObject *pObj = pNode->GetObjectRef();\nNow we enter the Bone assignment phase (see Listing 1.21.2; a code overview\nand then access the Physique context interface (IPhyContextExporf) for the object.\nWe must check to see if a vertex is influenced by one or more bones (RIGID_TYPE\nhave to find just a single bone (calling GetNode on the i-th vertex interface).\nter case, we have to find every bone assigned to the vertex, and for each bone we must\nNow we are ready for the last phase: bone animation data acquisition.\nGetting Bone Animation Keys\ntransformation matrix of each bone.\nand, for each bone, work out the current transformation matrix by linearly interpo-\nthe current bone animation matrix from the translation and rotation.\n1.21 3ds max Skin Exporter and Animation Toolkit \nOnce the skeleton is moved, it is time to deform the mesh accordingly, with respect to\ninverse orientation matrk), and then transform it via the current bone animation\nTo finish, we draw the computed mesh using vertex\nListing 1.21.1: Exporting the Mesh to a File\nbool ExportMesh (iNode* pNode, FILE *out)\nMatrixS tm = pNode->GetObjectTM(0) ;\nmHdr.vertCnt = mesh.getNumVerts() ;\nmHdr.normCnt = mesh.getNumVerts() ;",
      "keywords": [
        "bone",
        "max",
        "max Skin Exporter",
        "Mesh",
        "Animation",
        "object",
        "vertex",
        "Bone animation",
        "pNode",
        "MAX SDK",
        "MRC file",
        "max Skin",
        "MRC File Format",
        "matrix",
        "file"
      ],
      "concepts": [
        "bones",
        "mesh",
        "object",
        "matrix",
        "vertex",
        "max",
        "data",
        "returned",
        "animation",
        "animated"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "",
          "score": 0.347,
          "base_score": 0.347,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 13,
          "title": "",
          "score": 0.344,
          "base_score": 0.344,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 42,
          "title": "",
          "score": 0.306,
          "base_score": 0.306,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "bone",
          "max",
          "mesh",
          "animation",
          "pnode"
        ],
        "semantic": [],
        "merged": [
          "bone",
          "max",
          "mesh",
          "animation",
          "pnode"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18285464399783183,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:23.284927+00:00"
      }
    },
    {
      "chapter_number": 17,
      "title": "Segment 17 (pages 147-155)",
      "start_page": 147,
      "end_page": 155,
      "summary": "Web cams allow you that functionality, and with high-speed Internet slowly\nThis gem demonstrates a straightforward approach to implementing Web cam\nWe'll be using Video for Windows to capture the Web\ncam data, so Windows is required for the Web cam initialization function.\nBy die end, we will have a fully functional Web cam\nInitializing the Web Cam Capture Window\nThe following code demonstrates how to use Video for Windows to set up a Web\nBOOL cam_driver_on = FALSE;\nint wco_cam_width = 160, wco_cam_height = 120;\nint wco_cam_updates = 400, wco_cam_threshold = 120;\ncam_driver_on = capDriverConnect(hWndCam, 1);\nif(cam_driver_on)\ncapSetCallbackOnFrame(hWndCam, webcam_callback);\ncapPreviewRate(hWndCam, wco_cam_updates);\n= wco_cam_width;\ncapwnd.bmiHeader.biHeight = wco_cam_height;\ncapwnd.bmiHeader.biSizelmage =wco_cam_width*wco_cam_height*3;\ncam_driver_on = FALSE;\nglGenTextures(1, &webcam_tex.gl_bgr);\nglBindTexture(GL_TEXTURE_2D, webcam_tex.gl_bgr);\nglTex!mage2D(GL_TEXTURE_2D, 0, 3, webcam_tex.size,\nwebcam_tex.size, 0, GL_BGR_EXT,\nGL_UNSIGNED_BYTE, webcam_tex.bgr);\n1.22 Using Web Cameras in Video Games\nglGenTextures(1, &webcam_tex.gl_grey);\nglBindTexture(GL_TEXTURE_2D, webcam_tex.gl_grey);\nglTex!mage2D(GL_TEXTURE_2D, 0, 1, webcam_tex.size,\nwebcam_tex.size, 0, GLJ.UMINANCE,\nGL_UNSIGNED_BYTE, webcam_tex.greyscale);\ncam_driver_on = FALSE;\nThe above function retrieves the handle to the Web cam window we're capturing\nsubwindow, but we want to receive the data updates from Windows through the call-\nlater), the number of times per second we want to refresh the Web cam, and then reset\nBased on whatever height we set up our Web cam window to be, we find and\nbigger buffer than the Web cam image, we save ourselves an expensive texture resize\nsmall precision loss in the Web cam image.\nOnce we have our video window initialized, we need a way to retrieve the data from\nthe Web cam every frame.\nWhen Windows decides it's time to update the Web cam, it will pass\nIn our case, we'll make the callback function process all the Web cam data to\nWe can pass all of that data to the web-\ncam_calc_movement () function for further processing, which will determine if enough\ndata has changed since die last frame, after which, we can update the texture.\n// WEBCAM_CALLBACK\nwebcam_tex.delta_buffer,\nwco_cam_width,\nwco_cam_height,\nwebcam^tex.size,\nwco_cam_threshold))\nwebcam_make_texture(videojidr, wco_cam_rendering);\nWindows saves the Web cam data in the buffer called If Data.\nNow that we've captured the data from the Web cam, let's test it to see\n1.22 Using Web Cameras in Video Games \nThe following source code compares delta buffers, and returns true or false if the\nunsigned char wco_cam_threshold=128; // This is a good amount (0-255)\nBOOL webcam_calc_movement(LPVIDEOHDR video_hdr,\nint webcam_width, int webcam_height,\nint gl_size, unsigned char thresh)\nsizeof(unsigned char)* webcam_width * webcam_height);\nwebcam_tex.which_buffer = webcam_tex.which_buffer 7 0 : 1 ;\nfor(i=0; i<webcam_height ;\n&temp_delta[i*(webcam_width)] ,\nsizeof (unsigned char)*webcam_width) ;\nManipulating Web Cam Data\nVIDEOHDR data struct (the native format Windows returns is BGR) into a buffer\nvoid webcam_make_bgr(unsigned char *bgr_tex, unsigned char *vid_data,\nint webcam_width, int webcam_height, int glsize)\nfor(i=0; i<webcam_height; i++)\n&vid_data[i*(webcam_widtn*3)],\nsizeof(unsigned char)*webcam_width*3);",
      "keywords": [
        "Web cam",
        "WEBCAM",
        "Web cam data",
        "Web",
        "TEXTURE",
        "cam",
        "Web cam window",
        "data",
        "int",
        "int webcam",
        "General Programming",
        "Web cam image",
        "Web Cameras",
        "unsigned char",
        "buffer"
      ],
      "concepts": [
        "windows",
        "web",
        "data",
        "buffers",
        "cams",
        "cam",
        "game",
        "returning",
        "texture",
        "unsigned"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 18,
          "title": "",
          "score": 0.434,
          "base_score": 0.434,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "web",
          "web cam",
          "cam",
          "webcam_tex",
          "unsigned char"
        ],
        "semantic": [],
        "merged": [
          "web",
          "web cam",
          "cam",
          "webcam_tex",
          "unsigned char"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1091377628242534,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:23.284967+00:00"
      }
    },
    {
      "chapter_number": 18,
      "title": "Segment 18 (pages 156-172)",
      "start_page": 156,
      "end_page": 172,
      "summary": "grey[j] = (unsigned char)float_to_int(0.30f * color[i] \ncartoon [i+n] = cartoon_tex.min_toll col[n];\ncartoon[i+n] = cartoon_tex.low_toll_col[n] ;\nwebcam_make_cartoon (webcam_tex .\nf ree(webcam_tex.bgr) ;\nf ree(webcam_tex.delta_buffer) ;\nf ree(webcam_tex.back_buffer[0]) ;\nf ree(webcam_tex.back_buffer[1 ] ) ;\nFloating-Point Tricks:\nIEEE Floating Point\nFloating-point numbers have a\n\"floating\" decimal point and arbitrary magnitude.\nfloats were slow, so most game programmers used integers and avoided floats.\ngame consoles can do floating-point add, subtract, multiply, and divide in a few\nGame programmers can now take advantage of the ease of use of floating-point\nAlthough basic floating-point arithmetic has become fast, complex functions are\nFloating-point libraries may be optimized, but they are generally imple-\nThis gem presents various tricks to improve floating-point performance, trading\nTable lookup has long been a standard trick for integer\nmath; this gem shows generalized linear and logarithmic lookup table techniques for\noptimizing arbitrary floating-point functions.\n• The IEEE floating-point standard\n• Tricks for fast float/int conversions, comparisons, and clamping\n• A linear lookup table method to optimize sine and cosine\n• Generalized lookup table methods to optimize arbitrary floating-point functions\nIEEE Floating-Point Format\nThe IEEE standard for floating-point numbers dictates a binary representation and\nless of whether the floating-point handling is fully IEEE compliant.\nThe IEEE standard represents floating-point numbers with a sign bit, a biased\nSingle precision, 32-bit floating-\npoint numbers (a \"float\" in C) are stored as shown in Figure 2.1.1.\nfloating point number is s x 1 .m x 2'6-127)\nFIGURE 2.1.1 IEEE 32-bit floating-point format has a 1-bitsign, 8-bit exponent, and\n23-bit mantissa.\nThe exponent is stored as a positive number in biased form, with 127 added to\nA floating-point number thus consists of a normalized significand representing a\nthe binary point and a sign bit.\nnumbers so tiny that the range of the exponent overflows 8 bits.\n2.1 Floating-Point Tricks: Improving Performance with IEEE Floating Point \nFIGURE 2.1.2 The number -6.25 as stored in memory in 32-bit IEEE floating-point\nDouble precision 64-bit floating-point numbers are stored using the same basic\nformat, but with 11 bits for the exponent and 52 for the significand.\nFloating-Point Tricks\nfloating-point tricks that help explain the games you can play with the bit patterns of\nfloating-point numbers.\nThe lookup table techniques that follow convert a floating-point number to an inte-\nexample, casting a float to an int with \"(int)f' takes about 60 cycles.\nfloating-point number and then discarding the upper exponent bits of the result.\nnumber as either an integer or a float.\nfloat \nit makes access to the bit pattern of numbers look very simple—in practice, the com-\nfloating-point and integer registers are in separate hardware, and data cannot be moved\nHere is how to convert a float to an int:\n// floating-point number to convert\n// some floating-point number\n// add as floating-point\nAdding 1 x 223 as a floating-point number pushes the man-\ntissa into the lower 23 bits, setting the exponent to a known value (23 + 127).\nfloating-point\nFIGURE 2.1.3 The number 43.25 is converted to an integer by manipulating the floating-point\n2.1 Floating-Point Tricks: Improving Performance with IEEE Floating Point \ntracting the known exponent as an integer removes these unwanted upper bits, leav-\ning the desired integer in the low bits of the result.\nget the FPU to convert from float to int without changing the rounding mode—this\nThis trick works as long as the floating-point number to be converted does not\n9, so the range is one bit less than for positive numbers—the number to be converted\nTo convert from a float to a fixed-point format with a desired number of frac-\ntional bits after the binary point, use bias = (23 - bits + 127) « 23.\nNote that you can use the \"inverse\" of this trick to convert from integer to float-\nfloating-point\nFIGURE 2.1.4 To convert a negative float to an integer is slightly different than for positive numbers.\nfloating-point\nFIGURE 2.1.5 Fractional bits can be preserved during the conversion from float to integer.\n192.8125 is converted to a fixed-point number with two bits after the binary point.\n// subtract as floating-point\n// n.f is now 123.0 - the original n.i converted to a float\nUsually, int-to-float conversions using typecasts are fast, and thus less in need of a\nBecause the sign bit of a floating-point number is in bit 31, the same as for integers,\nwe can use the integer unit to test for positive or negative floating-point numbers.\nGiven a floating-point number f, the following two code fragments are (almost)\n// floating-point compare\n2.1 Floating-Point Tricks: Improving Performance with IEEE Floating Point \nSince the floating-point format stores sign, exponent, mantissa in that bit order, we\ncan use the integer unit to compare floating-point numbers—if the exponent of a is\n// floating-point compare\nA floating-point value /can be clamped to 0\n(i.e., set/= 0 if/< 0) by turning the sign bit into a mask, as in the following code\nthroughout all 32 bits.\ntest code, the floating-point compare and clamp took about 18 cycles, while the in-\nint s = ftmp.i » 31; // create sign bit mask\nint s = ftmp.i » 31; // create sign bit mask\nThis one's easy: since floating-point numbers do not use two's complement, taking\nthe absolute value of a floating-point number is as simple as masking the sign bit to 0.\napproach is to use fixed-point math, with angles represented on an integer scale, say, 0\nBy using floating-point tricks for efficient indexing,\nwe can create floating-point trig functions that use standard radians and do not\n2.1 Floating-Point Tricks: Improving Performance with IEEE Floating Point \nwhich simply converts i in the range 0-256 to floating-point radians in the range 0 to\nHowever, this has two problems: first, it uses the slow float-to-int typecast, and\nThis implementation uses the floating-point biasing trick described previously\nfor fast conversion from floating-point to integer.\nexceeds 222, then the float-to-integer conversion trick will fail, so it's still necessary to\nA 256-entry floating-point table takes IK, which should easily stay within cache\nlookup table, but we can take advantage of the fact that cos(0) = sin(9 + n/2), and use\nSquare root optimization is an interesting use of floating-point bit fiddling,\nsider the square root of a floating-point number:\nbit of the exponent to the mantissa, so we have:\nwhere e0 is the low bit of the exponent.\nFloating-Point Tricks: Improving Performance with IEEE Floating Point \nfloat fsqrt( float f )\nThe table index is simply the upper bits of the mantissa and the low bit of the\nThe lookup table contains the mantissa of the computed square roots.\nConsider an arbitrary floating-point function of one variable:\nof x was logarithmically quantized and used as a table index to look up a value.\nvalue was scaled by a function of the exponent of x to get the final value of y.\nThe linear approach rescales a floating-point number and converts it to an integer\nfloating-point value into an integer index.\nThe logarithmic approach uses the floating-\npoint bit pattern directly as a table index, to achieve logarithmic quantization.\ntable for values of x within the range.\nftable[i] = f( (float)i / INDEXSCALE + A );\nwhere /is the full-precision floating implementation of the function.\ntation requires two floating-point operations (multiply and add), one integer bitwise\nThe basic idea is that the bits of the floating-point representation are used directly as\na lookup table index, rather than being manipulated into an integer range.\ning selected bits of the sign, exponent, and mantissa, we can massage the 1:8:23 IEEE\nfloating-point number into our own reduced precision format with as many bits as we\nIn the square root example, we extracted 8 bits to give a logarithmically quantized\nWe used 1 bit of the exponent and 7 bits of the mantissa.\nsign bit was discarded, since the square root of a negative number is undefined.\n2.1 Floating-Point Tricks: Improving Performance with IEEE Floating Point \nresentation) and a 1-bit exponent, so it can represent numbers between [1].\ntized number (a table lookup) and an independent operation on the exponent (divide\nand combine the mantissa and exponent into a 32-bit floating-point result.\nIEEE format makes it easy to extract the least significant bits of the exponent with the\nThis shifts the number n to the right so that the desired bits of the mantissa and\nexponent are the rightmost bits in the number, and then masks off the desired num-\nnumbers (for example, square root), or that your function always returns a positive\nFor functions with a limited range of input values, masking out selected bits of\nthe exponent and mantissa can give you a direct table index.\ncare about your function over the range [1,16), then you can use 2 bits of exponent\nand 4 bits of mantissa (for example).\nuse the bits directly as an index into a precomputed 64-entry table.\nIf your function f(x) can be decomposed as:\nthen you can, for example, approximate fl with a 256-entry lookup table, using 8 bits\nof the mantissa m, and perform the calculation of f2 directly, as an integer operation\nbit fiddling to optimize a particular function.",
      "keywords": [
        "Floating-Point",
        "IEEE Floating Point",
        "WEBCAM",
        "floating-point number",
        "bits",
        "exponent",
        "Floating-Point Tricks",
        "lookup table",
        "number",
        "CARTOON",
        "bit",
        "cam",
        "Integer",
        "sign bit",
        "heat"
      ],
      "concepts": [
        "floating",
        "bit",
        "bits",
        "point",
        "integers",
        "numbers",
        "tables",
        "function",
        "functions",
        "exponent"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 11,
          "title": "",
          "score": 0.541,
          "base_score": 0.391,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 56,
          "title": "",
          "score": 0.458,
          "base_score": 0.458,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 17,
          "title": "",
          "score": 0.434,
          "base_score": 0.434,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "",
          "score": 0.422,
          "base_score": 0.422,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.386,
          "base_score": 0.386,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "floating point",
          "floating",
          "point",
          "exponent",
          "bits"
        ],
        "semantic": [],
        "merged": [
          "floating point",
          "floating",
          "point",
          "exponent",
          "bits"
        ]
      },
      "topic_id": 7,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24193784007010696,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285009+00:00"
      }
    },
    {
      "chapter_number": 19,
      "title": "Segment 19 (pages 173-181)",
      "start_page": 173,
      "end_page": 181,
      "summary": "This gem scratched the surface of floating-point optimization.\nour collision detection routine is running flawlessly now, returning a surface\npoint and a normal back when you feed it a position and velocity vector.\nsion point, but the methods in this gem show how to handle collision results that\nnormal and any point on the plane, you can work your way through the math to find\nData that goes into your collision code would be an initial point Pt and a final\npoint Pf, and the output in the case of a collision would be a plane that is defined by\na unit vector surface normal TV and a point on the surface Ps. The point need not be\nthe actual intersection point as long as it is on the plane.\nculations back into your collision code.\nalready been calculated during the collision tests.\ny, and z are the components of the normal vector N, and D is the dot product N* Ps. Altitude Relative to the Collision Plane\nTypical collision testing code will only return a hit if one of your test points is on\nOnce you have tricked your collision code into returning a surface point and nor-\nline from the point to the surface.\nNearest Point on the Surface\nOnce we have the distance to the surface, it takes just one more step to get the point\non the surface PH that is closest to the initial point Pf as also shown in Figure 2.2.\nalready know the point is distance Ds from die starting point, and that distance is\nmeasure, so it needs to be subtracted from the starting point.\nPinning Down the Collision Point\nWhen you have one point on each side of a test surface, your vector must at some\npoint intersect with it.\nYou know that the collision point must lie somewhere along the line.\nadvantage of the calculation for Ds in finding die collision point Pc. Figure 2.2.2\nFIGURE 2.2.2 Finding the collision pointPc. Since we know the collision is between the two points, we can find it by calculat-\nculation since it results in the point Pf For R = 0, the point is P,-.\nDistance to the Collision Point\nAlthough similar to Ds, this differs from the distance from the collision plane because\nRather than sending your actual velocity for a collision test, you would\nFIGURE 2.2.3 Calculating distance to the collision point.\naltitude relative to the collision plane Pn as calculated earlier would give a very small\nOnce you have the actual collision point, it's very easy to calculate the distance\nusing Euclid's equation to find how far it is from the starting point to the collision\npoint.\nThe distance to the collision point,\nDc, is the magnitude of the vector from our starting point /J to the collision point Pe\nthe collision point as described in the previous section.\nThe distance to the collision\nReflecting Off the Collision Plane\nThe usual result of a collision is to bounce.\nFIGURE 2.2.4 Calculating the reflected vector.\nthe same distance from the plane as Pf. One of the simplest ways to visualize reflecting a point relative to a plane is to\nimagine a vector from the below-ground destination point back up to the surface\nby adding to the final point twice the distance from the final point to the surface.\nAnother way of looking at this is that if you normalize the vectors from your collision\nbe tested all over again with your collision code to see if you have been pushed\nIf you repeat the collision test, but with a vector from\nyour collision point Pc to the newly reflected point Pr, you will get a possible new col-\ntest will be made with an initial point on the edge of the surface.\nsurface for collision purposes.\nputed by normalizing the direction from the last collision to the final reflected loca-\nSometimes, rather than reflect off the collision plane, you want to kick the player\nsimple once you have the collision point.\nThe point to which you are kicked back, /^, is obtained by calculating the vector\nfrom your final point Pf back to your collision point Pe and adding it to the collision\npoint.\nwhere the destination point leads to an additional collision.\nway out of the loop for kickback collisions in some cases.\nIf the collision point is more\nvector from the collision point Pe to the reflected point Pr as shown in Figure 2.2.6,\nIn the case of a collision putting your point into another immediate colli-\nFIGURE 2.2.6 Calculating a damped reflection vector.",
      "keywords": [
        "Collision Point",
        "Point",
        "collision",
        "Vector",
        "surface",
        "Collision Plane",
        "Plane",
        "surface normal",
        "distance",
        "collision code",
        "collisions",
        "final point",
        "surface point",
        "Plane Tricks",
        "actual collision point"
      ],
      "concepts": [
        "point",
        "collision",
        "collisions",
        "vector",
        "timing",
        "time",
        "surface",
        "figuring",
        "reflecting",
        "reflections"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 20,
          "title": "",
          "score": 0.648,
          "base_score": 0.498,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 32,
          "title": "",
          "score": 0.57,
          "base_score": 0.42,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 21,
          "title": "",
          "score": 0.494,
          "base_score": 0.344,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 23,
          "title": "",
          "score": 0.471,
          "base_score": 0.321,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.302,
          "base_score": 0.302,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "collision",
          "point",
          "collision point",
          "surface",
          "plane"
        ],
        "semantic": [],
        "merged": [
          "collision",
          "point",
          "collision point",
          "surface",
          "plane"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.16470848774080896,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285051+00:00"
      }
    },
    {
      "chapter_number": 20,
      "title": "Segment 20 (pages 182-197)",
      "start_page": 182,
      "end_page": 197,
      "summary": "instance, starting with a line, you can assign weights to the end points where the\nweights sum to one, and all possible resulting points are on the line defined by\nthe points.\ning point to be outside the line segment or polygon defined by the points while still\nthe start point P± to the line-based collision point Pc of the vector against the plane, die\nis along the line.\npoint Pc. This ratio is the same when applied to the line from P{ to Pc, which leads to\n3D Line Segments\nhe problem of determining the intersection of two line segments comes up from\nOther common applications for line segment inter-\nbetween two infinite lines or finite-length line segments in three-dimensional space, if\nalong each line segment that is closest to the other line, and a vector between the two\nnearest points.\nany special requirements (for example, the line segments must be coplanar).\nGiven two line segments in three-dimensional space, one that spans between the points\npoint of intersection, P=[PX Py PZ]T, between the two segments, if it exists.\nFIGURE 2.3.1 Two line segments in three-dimensional space.\nThe nearest points, labeled C and D respectively, can be used to find the shortest\nBefore delving into how to solve the line intersection problem, it can be useful to\nan arbitrary plane (if the line is not parallel to the plane, then it intersects the plane);\ndimensional lines are not parallel, they do not necessarily intersect).\nrobust, capable of finding a result for an arbitrary pair of lines or line segments, since\nthe use of an algorithm that finds the nearest points between two lines, within a real-\nintersection of lines in a two-dimensional space, it is useful to consider the relationship\nbetween the three-dimensional line intersection problem and the two-dimensional\nplane that contains both defining points of line A, and die first defining point of line\n2.3 Fast, Robust Intersection of 3D Line Segments \nB. Line A lies within the plane, as does the first defining point of line B.\npoint of intersection of die two lines lies on die plane, since diat point is contained on\nline A.\nThe point of intersection also lies on line B, and so two points of line B lie\nSince two points of line B lie in the plane, the entire line lies in the\ndimensional lines have a true intersection, the problem is equivalent to a two-\npoints.\nnearest points.\nThere are two line segments floating in space.\nis defined by die points (0, 0, 0) and (1, 0, 0), and segment B is defined by (1, 0, 1)\ninto the XY plane, the two-dimensional intersection point is (1, 0, 0), and the three-\ndimensional nearest points are (1, 0, 0) and (1, 0, 1).\ntwo line segments.\ndimensional lines yields an infinite number of \"nearest\" point pairs, which is clearly\nthis problem, as it allows you to rotate the view to see two line segments from differ-\nIn the next section, I derive a closed-form solution to the calculation of points C\nand D that does not make any assumptions about where the two line segments lie in\nCalculating the Nearest Points on Two Infinite Lines\nThe equation of a line in three-dimensional space can be considered a vector function\npoint between two 3D lines, we first write the equation for an arbitrary point,\nCJr, located on the first line segment, as Equation 2.3.1.\nfirst segment are equal to the coordinates of the first defining point plus an arbitrary\nscalar parameter s times a vector pointing along the line from the first defining point\nWe can write a similar equation for an arbitrary point, D = [Dx Dy\nDJT, located on the second line segment, as Equation 2.3.2:\nwith respect to the second line segment.\nlines rather than finite segments.\nFor any point on a.\nfinite line segment, the parame-\nThe two 3D line segments intersect if we can find values of s and t such that\nthe nearest points C and D.\ntion for the vector between points C and D:\n2.3 Fast, Robust Intersection of 3D Line Segments\nHere, since we would like for points C and D to be coincident, we set the vector\n2.3 Fast, Robust Intersection of 3D Line Segments \nEquation 2.3.13 will fail if line segment A has zero length, and Equation 2.3.12\nwill fail if either line segment has zero length or if the line segments are parallel.\nTo summarize from the derivation, given line segment A from point Al to A2 and\nline segment B from point Bl to B2, define the following intermediate variables:\nCompute the parameters ^ and t that define the nearest points as,\nand the point where the second segment comes closest to the first segment is\nsingle point in space that is \"nearest\" to both lines/segments as:\nOf course, when the lines do intersect, point P will be the intersection point.\nWhen we talk about the nearest points of two infinite lines in space, there are only\nIt is easy to relate the degenerate line special case to the equations developed pre-\nthe length of line segment A, and L22 is equal to the square of the length of segment\nWhen segments A and B are both degenerate, then point C can be selected to be\nthe point on segment B that is nearest to point C.\n2.3 Fast, Robust Intersection of 3D Line Segments \nPoint D can be calculated using Equation 2.3.2.\nWhen segment B alone is degenerate, then point D is set equal to B\\, and point C\nis found by computing the point on segment A that is nearest to point D.\nparameters passed in such that the degenerate line is always treated as segment B, and\nthe nondegenerate line is always treated as segment A.\nIt is also easy to relate die parallel line special case to the equations developed pre-\nThus, when the line segments are parallel, Equation 2.3.9\nIn the case of infinite parallel lines, every point on line A is equidistant from line\nlines.\nvariables from Equations 2.3.14 and 2.3.15 when one or both of the lines are degen-\nDealing with Finite Line Segments\nline segments.\nlength line segments?\nLine Segments that Are Not Parallel\n2. Compute the point on the line for the new parameter.\npoint for the first segment.\n3. Find the point on the other line that is nearest to the new point on the first\nline, with the nearest point calculation performed for a finite line segment.\nThis is the nearest point for the second segment.\nlating the point on the other segment.\nif we selected line segment^ in Figure 2.3.2b, step 2 would produce point A2.\nstep 3 would produce point 5ls the nearest point on segment B to point A2.\nis the correct choice for D, but there is a point on segment A that is much closer to\nthe other nearest point by just using the result from step 3.\n2.3 Fast, Robust Intersection of 3D Line Segments \nFIGURE 2.3.2 Finite-length line segments.\n2. Compute the point on the line for the new parameter.\nteed to be the nearest point for the first segment!\n3. Find the point on the other line that is nearest to the new point on the first\nline, with the nearest point calculation performed for a finite line segment.\nThis is the nearest point for the second line segment.\n4. Find the point on the first line segment that is nearest to the point that\nThis is the nearest point for the first line segment.\nLine Segments that Are Parallel\nsegments into a line parallel to both do not overlap.\npossible nearest point pairs, shown in Figure 2.3.3b.\nnearest points to be any pair of nearest points between the two vertical gray lines.\nimplementation provided on the accompanying CD-ROM selects the nearest points\nfor finite length, overlapping parallel line segments to be halfway between the gray\nlines; that is, at the midpoint of the overlapping portion of each segment.\nthe nearest points computed by this algorithm will often move erratically as the lines\nFIGURE 2.3.3 Parallel line segments.\nShown in Figure 2.3.4a, the nearest points will stay at the far left until the lines\nferent approach to selecting the nearest point when lines are parallel or near parallel.\nFor example, you could implement a rule that arbitrarily selects the point nearest A\\\nas the nearest point on segment A when the segments are parallel within, say, 5\nnearest point between, say, 5 and 10 degrees, with the arbitrary solution being 100%\nFIGURE 2.3.4 Erratic movement of nearest points for nearly parallel line segments.\nB) Nearest points at the right.\nIntersectLineSegments, which takes parameters defining the two line segments, and\n2.3 Fast, Robust Intersection of 3D Line Segments \nalso takes a parameter indicating whether you want the line segments to be treated as\nvector is not necessarily normal to either of the line segments if the lines are finite.\n• FindNearestPointOnLineSegment calculates the point on a line segment that is\nnearest to a given point in three-dimensional space.\nunique) values for Cand D for the case of parallel lines/segments.\n• AdjustNearestPoints adjusts the values of C and D from an infinite line solution to\na finite length line segment solution.\nefficient, but in the case where the infinite lines intersect outside of the range of the\nIn fact, the nearest point problem\npoint is found between the finite segment endpoints, and false when the nearest point\nbenefit from this formal discussion of line and line segment intersections, along with",
      "keywords": [
        "Line Segments",
        "Line",
        "point",
        "nearest points",
        "equation",
        "segment",
        "Segments",
        "parallel line segments",
        "finite line segment",
        "nearest",
        "line intersection problem",
        "line segment intersections",
        "Intersection",
        "equations",
        "line intersection"
      ],
      "concepts": [
        "points",
        "equations",
        "equation",
        "line",
        "segment",
        "segments",
        "plane",
        "solution",
        "solutions",
        "intersect"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 32,
          "title": "",
          "score": 0.679,
          "base_score": 0.529,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 19,
          "title": "",
          "score": 0.648,
          "base_score": 0.498,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 23,
          "title": "",
          "score": 0.592,
          "base_score": 0.442,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 21,
          "title": "",
          "score": 0.445,
          "base_score": 0.295,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 35,
          "title": "",
          "score": 0.33,
          "base_score": 0.33,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "line",
          "segments",
          "line segments",
          "nearest",
          "point"
        ],
        "semantic": [],
        "merged": [
          "line",
          "segments",
          "line segments",
          "nearest",
          "point"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1898488069238036,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285092+00:00"
      }
    },
    {
      "chapter_number": 21,
      "title": "Segment 21 (pages 198-206)",
      "start_page": 198,
      "end_page": 206,
      "summary": "In many cases, we also need to solve the inverse of this\nby transforming this planar trajectory into two dimensions (x and_y), we can simplify\nwe can remove the initial x and y values from most of the equations, focusing on the\nIn this case, our variables are initial velocity, angle of elevation, and distance in\nx and y between the points.\nDestination (x, y)\nneed to provide an initial velocity and angle of elevation.\nof elevation 6 in terms of v ,-, x, and y.\nStarting with initial velocity vf, angle\nof elevation ?, and gravity g, we can express initial velocity along the x and y axes as\nNext, we integrate the velocity equations to determine the position at a given\n-> x = vf cos 9 \ny = vf sin 0 \ncial cases is that in which both the start and end points have the same y value.\nIn this case, we know that y, the horizontal displacement\nequation by setting y=0.\nThis allows us to simplify Equation 2.4.4 to solve for time t,\ninitial velocity vt, or angle of elevation 9 as follows:\ny = vf sin 9 -- gf2 =0\nIn addition, this leads to a simplified formula for calculating x for this special case:\nx = v\\ — '- - - cos0\n2v sin 9 cos 9\ntal range of a cannon at angle of elevation 0, given maximum projectile velocity v^:\nwe must determine the angle of elevation or velocity required to propel a projectile\nSince we have expressed x and y in terms of t, we can begin\nby removing t from the equation and defining x and^ in terms of each other.\nx = v-t cos 9 —» t = vf cos 9\nNext, we replace t with x I v, cos 9 in the equation for y to remove t from the\n-> y = x tan 9 -- —\ny = x tan 0 - &—\nPlugging the preceding values of a, b, and c into the quadratic equation and solv-\nThe quadratic form provides us with a way to solve for G, given a known initial\nvelocity vf, horizontal displacement x, and vertical displacement y.\nDestination (x, y)\nFIGURE 2.4.2 Two angle of elevation solutions OC and§ for a given Vj. Solving for Initial Velocity\nNow that we have the problem solved for the case where 0 is unknown, we can change\nEquation 2.4.7 slightly to solve for initial velocity vt, given a known angle of elevation\n9, horizontal displacement x, and vertical displacement y as follows:\n6 + £—r = x tan 6 - y\nWe then multiply both sides by V; /(x tan Q -y), thereby isolating initial velocity.\nSolving for vf, we get the following:\nthe point where vertical velocity vy=0, given 9>0.\ntical velocity equation as follows:\nx(t) = vf cos 6 —» t = vi cos d\nHowever, in the case where v^ = 0 or cos 6 = 0, t is undefined if expressed in terms\nof x In addition, in this case, x will always be zero, and no solutions exist in this case\nif the two points are not at the same x value.\nTo solve for t when vt = 0 or cos 6 = 0, we can use the vertical position equation\ny(t) = vf sin 0 - - gt2\nIf Vi = 0, we can use the following equation to express t in terms of/ and g.\nthe most common case, we are given two points and a maximum initial velocity vmax,\nand need to solve for both v-t and G.\nFor instance, in solving for initial velocity vf, we came across Equations 2.4.9\nv- = x\nthe second equation (and not simplify to terms of tan Q), leaving cos 9 outside of the",
      "keywords": [
        "initial velocity",
        "velocity",
        "case",
        "Inverse Trajectory Determination",
        "equation",
        "Trajectory",
        "problem",
        "initial",
        "angle of elevation",
        "cos",
        "Inverse Trajectory",
        "sin",
        "points",
        "Trajectory Determination",
        "elevation"
      ],
      "concepts": [
        "velocity",
        "equations",
        "equation",
        "cos",
        "trajectory",
        "trajectories",
        "case",
        "sin",
        "problem",
        "tan"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 19,
          "title": "",
          "score": 0.494,
          "base_score": 0.344,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 20,
          "title": "",
          "score": 0.445,
          "base_score": 0.295,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 32,
          "title": "",
          "score": 0.398,
          "base_score": 0.248,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 23,
          "title": "",
          "score": 0.351,
          "base_score": 0.201,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 22,
          "title": "",
          "score": 0.311,
          "base_score": 0.311,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "velocity",
          "initial velocity",
          "elevation",
          "vf",
          "cos"
        ],
        "semantic": [],
        "merged": [
          "velocity",
          "initial velocity",
          "elevation",
          "vf",
          "cos"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.14506995211433185,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285135+00:00"
      }
    },
    {
      "chapter_number": 22,
      "title": "Segment 22 (pages 207-219)",
      "start_page": 207,
      "end_page": 219,
      "summary": "You'd probably want the camera to turn with the path and point along\nWhen the path loops, the orientation of the camera should\nthe path curve.\nthe minimal amount of rotation needed to stay parallel to the curve is applied at each\nUnfortunately, in order to calculate the frame at the end of a curve, you need to\niterate a frame along the path, all the way from the start, rotating it at each step.\nother commonly used methods of curve framing are the Frenet Frame and the Fixed\nFIGURE 2.5.1 The frame at t-1 is rotated about A by Of to calculate the frame at t.\nframes at a coarse sampling along the curve, and then achieve smooth rotation\nbetween the sample frames by using quaternion interpolation.\nUsing quaternions is\ndesirable anyway, since there is an efficient method of generating a quaternion from a\ngenerate a rotation quaternion, and then multiply it with the previous frame's quater-\nYou can orient a moving object with a single parallel transport rotation each time the\ncompares with the Frenet Frame and Fixed Up methods of curve framing.\nfor example, the second derivative points into the curves, flipping sides on the upper\nThe resulting Frenet Frames on the S-shaped curve will flip in con-\nFIGURE 2.5.2 Second derivative on an S-shaped curve, and Frenet Frame generated tube\nFixed Up vector) are used to generate three axes of the resulting frame, the direction\nSmoothly interpolating the positions of a flythrough path can easily be achieved by\napplying a natural cubic spline to the sample points.\nOnce the quaternion is in R4 space, any 4D spline can be applied to\nThe resulting interpolated points can then be transformed back\ninto S3 space and used as a quaternion.\nrotation path between sample point orientations.\nphantom points around the camera cut similar to the way an open spline is padded.\nThese additional points are needed to pad the spline to produce smooth results near\nThe code provided describes cut points as part of a single fly path and\n2.6 Smooth C2 Quaternion-based Flythrough Paths \nA natural cubic spline is an interpolating curve that is a mathematical representa-\nclosed spline, the spline is specified such that the last point is the same as the first\nsible discontinuities in the spline at the loop point, simply replicate the last four\npoints of the spline to the beginning of the array, and the first four sample points to\norientations using the selective negation method as described later (Figure 2.6.1).\nFIGURE 2.6.1 Replicating points for a closed spline.\nFIGURE 2.6.2 Creating phantom points for an open spline.\nIn contrast, an open spline has a different beginning and end point.\nsample the spline, you need to pad the spline with several \"phantom\" points at both\nassumed for the phantom points before and after the open spline path.\nOrientation Interpolation\nUnit quaternions are used as the orientation data at the sample points.\nQuaternions\n2.6 Smooth C2 Quaternion-based Flythrough Paths \nFor orientation, however, there is an ambiguity in using quaternions.\nWhen using quaternions,\nA rotation by 360°-0 about the axis —w also results in the same orientation.\nWhen performing quaternion interpolation, there is one small nuance that needs to\nWhen representing an orientation, either a quaternion or its negation\nHowever, when interpolating orientations (for example, performing a\nrotation), the positive and negative quaternions result in vastly different rotations and\nIn terms of interpolation, this makes the orientation spline path always perform the\nshortest rotation between the orientation key frames.\nThe technique of selectively negating orientation quaternions can be incorpo-\ntraverse the flythrough path from start to end, and for each quaternion q,on the path,\nUsing selective negation as a preprocessing step makes spline interpo-\nTo preprocess a closed spline path, it is necessary to replicate the first four points\nof the spline path and append them to the end of the path prior to the selective nega-\nWhen dealing with an open spline, you need to create phantom quaternions (corre-\nsponding to the phantom control points) to pad the spline.\nin that you want to linearly interpolate the difference between the two quaternions\nGiven quaternions q0 and qt, we need to generate four phantom\nThis effectively gives us a linear change in rotation at our phantom points.\nlation, it is straightforward to perform smooth spline-based quaternion interpolation\nSpline Interpolation for Quaternions\nHowever, spline interpolation for quater-\ntechnique simply interpolates the raw quaternion values, and then renormalizes the\nresulting quaternion.\nHowever, this technique does not result in a smooth path and\nHowever, there is a technique for quaternion spline interpolation that gives very\nTo use this for quaternion spline interpolation is straightforward.\nrotation between control points.\n2.6 Smooth C2 Quaternion-based Flythrough Paths \nNext, the resulting 4-vectors can be interpolated using the spline of your choice.\nquaternion path has the same continuity as die spline used for interpolation in R4\nThis gives us C2 continuous orientation interpolation as well.\nAfter the desired point on the spline in R4 is found, it can be converted back into\nIf your flythrough path contains orientation quaternions close or equal to (1,0,0,0), it\ncamera's up-vector pointing up the y-axis, the orientation quaternion (1,0,0,0) will\n30 degrees of any of the orientation quaternions, and use gy-to rotate all of the quater-\nbasic idea behind this is to perform the spline interpolation on a rotated version of\nyour flythrough path, and then rotate die interpolated orientations back into their\nquaternions by q^ after the selective negation step.\nquaternions from S3 space into R4 space, apply the natural cubic spline, and transform\nrotating each resulting quaternion by qj1 before using it.\nquaternions.\nFIGURE 2.6.3 Creating phantom points for a path cut segment.\na cut point, and process these splines as separate open splines.\nously for both the position- and orientation-based splines.\nwith camera cuts in such a way that you don't need to explicitly create a separate path\ncontrol points manually, reading and writing path files, dealing with cut points, sam-\nthe spline.",
      "keywords": [
        "Parallel Transport Frame",
        "spline",
        "Parallel Transport",
        "Frame",
        "path",
        "points",
        "Frenet Frame",
        "quaternions",
        "Transport Frame",
        "quaternion spline interpolation",
        "orientation",
        "Parallel",
        "spline path",
        "orientation quaternions",
        "flythrough path"
      ],
      "concepts": [
        "quaternion",
        "frame",
        "framing",
        "point",
        "path",
        "spline",
        "rotating",
        "rotation",
        "rotate",
        "rotations"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 21,
          "title": "",
          "score": 0.311,
          "base_score": 0.311,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "spline",
          "quaternion",
          "quaternions",
          "path",
          "orientation"
        ],
        "semantic": [],
        "merged": [
          "spline",
          "quaternion",
          "quaternions",
          "path",
          "orientation"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1362430368262842,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:23.285172+00:00"
      }
    },
    {
      "chapter_number": 23,
      "title": "Segment 23 (pages 220-230)",
      "start_page": 220,
      "end_page": 230,
      "summary": "called Recursive Dimensional Clustering (RDC) can take the typical case from O(rf)\nOne of the benefits of RDC is that it naturally finds groups of objects rather than sin-\nA group is a collection of objects that touch each other or are\nRDC can be used to find simultaneous collisions of several objects or even groups of\nThe RDC Algorithm\ngroups of objects in collision along a single dimension.\ntering algorithm would find two groups: one group containing A, and a second group\nThe basic idea of this algorithm is to mark the boundaries of each object and then\nfind groups of overlapping objects using that data.\nFIGURE 2.7.1 Three objects along one dimension.\nFigure 2.7.2 shows the resulting linked list created from the three objects.\nNow that we have the sorted list of boundaries, we can find the groups.\nalgorithm for finding the groups is very similar to parser algorithms for matching\neach \"bracketed\" group.\nListing 2.7.2 Algorithm for finding groups along one dimension\nif( count == 0 ) { //entire group found\nAt this point, you may have noticed that the algorithm arbitrarily groups objects\nand object B has an open boundary at position 10, then any simple sorting algorithm\nwould inconsistently group these types of cases.\nClearly, this algorithm works well for finding groups along one dimension.\nmultiple dimensions is to first find groups along one axis, and then send each newly\nformed group to the next axis to be subdivided further.\nFigure 2.7.4 shows a set of four objects in two dimensions.\nthe groups visually, but this example will show how the algorithm determines groups\nThe groups in the x-axis are:\nThe first group contains\nobject D, and the second group contains E, F, and G.\ngroup is sent to the y-axis to be divided further.\nSince object Ds group has only one\nshows the ordered linked list for Group, along the y-axis.\nFIGURE 2.7.6 The Groupi y-axis sorted boundary list.\nThe groups in the y-axis are:\nNow that we've gone through each dimension once, the final groups are:\nGroup0 = { D }, Group1a = { G }, Group1b = { E, F }\ndiniension and the resulting groups.\ndimensions, the groups are simply analyzed in one more dimension; namely, the\n2. Construct a linked list of object boundaries in this dimension.\n4. Find groups using the open/close \"bracket matching\" algorithm in Listing\n5. For each group found in that dimension, repeat steps 2-5 in the next\nGroup o\nGroup\nGroup!\nGroup\nFIGURE 2.7.7 A) Groups found in thex-axis.\nB) Group, subdivided in they-axis.\nWhen grouping objects\nalong one axis, objects can get sucked into groups that aren't later separated by other\nGroup Ob\nGroup Oa\nGroup 0\nB) Groups in thex-axis.\nC) Group 0 subdivided in they-axis.\nFigure 2.7.8b shows the first pass along the x-axis and finds that all three objects\nThus, they are all assigned to the same group.\nThis results in two groups being found, but\nit understandably fails to put object A and object C in separate groups.\nThe correct solution would be for each object to be in its own group.\nWhen a group is subdivided along one dimension,\nIn the 2D case, a group that is broken up along the y-axis must be reanalyzed in\nIn 3D, a group that is broken up along the y-axis must be\n2. Construct a linked list of object boundaries in this dimension.\n4. Find groups using the open/close \"bracket matching\" algorithm in Listing\n5. For each group found in that dimension, repeat steps 2-5 in the other\ndimension(s) until the group no longer gets subdivided and all dimensions\nAs presented so far, RDC only identifies groups or clusters of objects that touch each\ntouch every other member in the group.\nous collisions, grouping info), general collision detection usually requires pairs that\nTo find collision pairs, each final cluster group from RDC must be sent to the\nOne way to find collision pairs even faster is to use the brute-force algorithm once\ning to subdivide the group further with continued recursive calls.\nAs described, the algorithm is basically recursive and attempts to break groups up\n3D, the function must at least try to subdivide the group along all three dimensions.\nHowever, if any of those dimensions results in subdivision, each subdivided group\nListing 2.7.3 RDC algorithm (pseudocode)\nvoid RDC( Pairs& pairs, Group& group,\n//\"group\" is the current group of objects to analyze\nif( Size( group ) < 10 || axisl == INVALID_AXIS )\n//for this group, find the boundaries and sort them\nFindOpenCloseBoundaries( axisl, group, boundaries );\nGroup subGroup;\n//subdivide the group if possible and call recursively\n{ //this entity lies within a cluster group\n{ //found the end of a cluster group - take subgroup\n{ //this group is being subdivided - remember\nInstead, the algorithm takes on average O(nlog2n), as long as most objects aren't\ntion causes RDC to recurse very deeply — this is the worst case o^O(n2log2n).\nother is when the objects are all in collision with each other, in which case RDC does\nobject set is split completely asymmetrically, with one object in one group, and n-1\nThe larger group is then sent to the function recursively.\nFor these calls, the average group size m is equal to n/2.\nA more likely bad case for RDC occurs when all objects are in collision with each\nIn this situation, each dimension would be tested, and only one group would\nthe brute-force comparison algorithm in order to find the final collision pairs.\nthat this time complexity is identical to the brute-force method and that no objects\nwill ever be in collision with all other objects, it's almost always faster to use RDC.\nNear worst-case configuration for RDC (24 objects).\nAlthough Recursive Dimensional Clustering (RDC) isn't a complete collision detec-\ntion solution, it's an impressive first-pass filter for determining groups of objects that",
      "keywords": [
        "Quaternion-based Flythrough Paths",
        "group",
        "RDC",
        "Quaternion-based Flythrough",
        "Flythrough Paths",
        "Recursive Dimensional Clustering",
        "Algorithm",
        "objects",
        "RDC Algorithm",
        "pos",
        "axis",
        "open pos",
        "close pos",
        "Recursive Dimensional",
        "Dimensional Clustering"
      ],
      "concepts": [
        "groups",
        "algorithm",
        "recursive",
        "recursion",
        "object",
        "collision",
        "collisions",
        "boundaries",
        "boundary",
        "dimension"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 20,
          "title": "",
          "score": 0.592,
          "base_score": 0.442,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 32,
          "title": "",
          "score": 0.564,
          "base_score": 0.414,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 19,
          "title": "",
          "score": 0.471,
          "base_score": 0.321,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 37,
          "title": "",
          "score": 0.377,
          "base_score": 0.377,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 35,
          "title": "",
          "score": 0.371,
          "base_score": 0.371,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "group",
          "groups",
          "rdc",
          "dimension",
          "axis"
        ],
        "semantic": [],
        "merged": [
          "group",
          "groups",
          "rdc",
          "dimension",
          "axis"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19285475973269484,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285214+00:00"
      }
    },
    {
      "chapter_number": 24,
      "title": "Segment 24 (pages 231-239)",
      "start_page": 231,
      "end_page": 239,
      "summary": "Programming Fractals\nfractals are used to create these landscapes.\nThere are a number of reasons why you might use fractals to make a landscape.\nyou created a completely random landscape, setting the heights of the valleys and hills\nto any height, it would look random, and unlike any real-life landscape.\nIt is possible to use fractals to get a mix between the two: a land-\nThings modeled with fractals are not com-\nFractals are most often used as\nThis gem looks at the more useful fractals, and examines how they are used.\nheight-maps: a rectangular grid with numbers in each cell representing the fractal's\nIn the case of a fractal landscape, the value represents the height;\nin the case of a fractal cloud, it might represent the density.\nsince height is the most frequent case, I shall refer to the \"height\" of a fractal at a\nThe Plasma Fractal\nFIGURE 2.8.1 A small plasma fractal.\nthe only control available over the fractal.\nFirst, very litde control is available over die fractal.\nThe Fault Fractal\nTo create this fractal, we again create an empty height-map.\nseries of \"earthquakes\" as follows: create a random line through the height-map, raise\nThis technique can create some very good fractals, but generating them is a slow\n2.8 Programming Fractals \nTherefore, the fractal cannot be done in real time!\nFault fractals have no control parameters, other than the sequence of random\nThe methods given so far are rather ad hoc approaches to generating fractals.\nFractal\nAn FBM fractal is a combination of noise functions, but each noise function is\nFirst, we have white noise, which is completely random.\nThe heights in white noise change\nSecond, we have pink noise, which has a limit on how much its heights change\nThe fractal is then generated at every point on the\nOnce you have created pink noise of various frequencies, it is easy to create an\nFBM fractal by mixing the heights returned by the noise function.\nis just adding the noise functions together, but they can be multiplied or combined in\nThe FBM has a few more parameters than noise alone.\nmany noises are added together.\nheight of the noise.\nquency on an FBM, we can consider fractal landscapes.\nWhen adding noises together,\nthe lower frequency noise is responsible for hills and mountains, and the higher fre-\nexacdy how the fractal looks.\nchange the frequency differ from section to section of the noise function.\nIt is also possible to multiply the noise functions instead of adding them together.\nDoing this will create more variety in your fractal.\nMultiplying noises together has the\nfoothills—if you just add the noises together, the landscape will have a uniform look.\nment a noise generator.\nTo generate noise, a source of random numbers to be interpo-\nfloat random (int x , int y)\nNext, we need a function that interpolates these random values.\nThis article uses cosine interpolation to build our noise function.\n2.8 Programming Fractals \nNote that this is not the only noise function\nNow that there is a random number function, and an interpolation function, it is\npossible to create a noise function by creating random numbers and interpolating diem.\nfloat noise(float x, float y)\nof your noise, and makes it look less square.\nnoise, call smoothrandom instead of randomnumber in the noise function.\nAfter a noise function has been constructed, it is quite easy to create an FBM.\nfloat FBM(float x, float y, float octaves, float amplitude, float\nret +=( noise (x* frequency, y* frequency)* amplitude);\nWhile the way the values change over each octave in this noise may work fine in\n2.8 Programming Fractals\nfloat Multi-fractal (float x, float y, float octaves, float amplitude\nret *=(offset)*( noise (x* frequency, y* frequency)*\nFIGURE 2.8.4 Various fractal heightmaps: the ground texture is a height-frequency FBM colored by",
      "keywords": [
        "noise",
        "fractal",
        "noise function",
        "float",
        "function",
        "Collision Detection",
        "FBM",
        "random",
        "Practical Collision Detection",
        "Plasma Fractal",
        "Advanced Collision Detection",
        "Programming Fractals",
        "ret",
        "frequency",
        "FBM fractal"
      ],
      "concepts": [
        "fractals",
        "noise",
        "float",
        "randomized",
        "random",
        "function",
        "functions",
        "landscapes",
        "useful",
        "uses"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 46,
          "title": "",
          "score": 0.545,
          "base_score": 0.395,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 49,
          "title": "",
          "score": 0.477,
          "base_score": 0.327,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 44,
          "title": "",
          "score": 0.435,
          "base_score": 0.285,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 47,
          "title": "",
          "score": 0.422,
          "base_score": 0.272,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "",
          "score": 0.407,
          "base_score": 0.257,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "noise",
          "fractal",
          "fractals",
          "float",
          "fbm"
        ],
        "semantic": [],
        "merged": [
          "noise",
          "fractal",
          "fractals",
          "float",
          "fbm"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1781649116912418,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285256+00:00"
      }
    },
    {
      "chapter_number": 25,
      "title": "Segment 25 (pages 240-248)",
      "start_page": 240,
      "end_page": 248,
      "summary": "Strategies for Optimizing Al\ndomains within games deal with scalability, but AI has the extra wrinkle of supporting\nThis parallelism comes from each AI agent running its own\npiece of code with the illusion of all agents thinking at the same time.\nlelism, along with other unique attributes of AI agents, can be manipulated to opti-\nkeep in mind a mental picture of hundreds of AI agents all having unique actions and\nStrategy f 1: Use Event-Driven Behavior Rather than Polling\nEvery frame they might poll the world for events or objects to which they should\nexample, in a baseball game when the ball is initially hit, the ball could simply tell the\nby using an event-driven strategy.\nA good example of an event-driven AI system can be found in the first Game Pro-\ngramming Gems book, in the article \"Designing a General Robust AI Engine\"\nStrategy #2: Reduce Redundant Calculations\nThe goal of this strategy is to reduce redundant calculations by sharing the results\nbetween several AI agents.\nMany times agents will individually recalculate the same\nA simple example of this strategy is apparent in collision detection.\nStrategy #3: Centralize Cooperation with Managers\n3.1 Strategies for Optimizing Al \nAn example of how a manager can simplify the game of\nIt's important to remember that with this strategy, managers don't need to be rep-\ncomplex cooperation among AI agents.\nStrategy #4: Run the Al Less Often\nRarely do AI agents need to run through all of their decision-making routines every\nMany times, agents can run portions of code every couple frames or even every\nSince real creatures have reaction times, it's not unreasonable for AI\nAI processing.\nto implement this strategy.\nThe first Game Program-\nming Gems book has a gem \"Designing a General Robust AI Engine\" [RabinOOa] that\nOne problem with this strategy is the possibility of AI processing peaks.\nFor example, an agent might execute\nStrategy #5: Distribute the Processing over Several Frames\nagent to spread a pathfinding calculation over several frames.\nThis results in a lower per-frame processing load.\nThis strategy can be implemented as a special case in a module, like a pathfinding\n\"Micro-Threads for Game Object AI,\" by Bruce Dawson, explains how you can\nimplement a micro-thread strategy in order to minimize AI loads.\narchitecture makes it easier for an AI agent to spread calculations over many frames\ning AI with Micro-Threads\" by Simon Carter, which describes how to best structure\nStrategy #6: Employ Level-of-Detail AI\nCurrently, most game engines use graphical LODs in order to quickly\nalso be applied to other game programming areas, such as AI.\nPractically, the level-of-detail technique for AI comes down to three strategies.\nThe second is to vary the complexity of an agent's algorithms based\nStrategy #7: Solve Only Part of the Problem\nrest of the problem is irrelevant and never needs to be computed anyway.\nThe best example of this strategy in action is probably hierarchical pathfinding.\n3.1 Strategies for Optimizing Al \nStrategy #8^ Do the Hard Work Offline\nSometimes, a problem is so difficult that you don't even have the CPU time to solve\nIn the early years of game development, problems such as finding the cosine of an\nexemplify this strategy: \"Terrain Reasoning for 3D Action Games\" by William van\nThis is surely one of the most powerful optimization strategies, since\nStrategy #9: Use Emergent Behavior to Avoid Scripting\nThis strategy has the opposite problem of the last strategy.\nenough offline time to create the behavior or scripts for hundreds of background AI\nical AI entities that aren't pivotal to the progress or completion of a game, such as\nInfluence maps are an excellent example of this strategy at work.\nThis strategy is also key in a later gem written by Matt Pritchard entitled \"A\nuses this strategy of continuous bookkeeping to maintain the line-of-sight data for\nhundreds of agents in real time, which is not a simple task.\nStrategy #11; Rethink the Problem\nMichael Abrash is well known as an optimization guru within the game development\nThis strategy is well illustrated later in the book by Michael Zarozinski in his gem\n3.1 Strategies for Optimizing Al \nIt takes a slightly different perspective to optimize the problems that face AI systems.\nDon't be afraid to scan the list of strategies the next time you're faced with trying to\nHere is a recap of all the strategies:\n4. Run the AI less often.\n6. Employ level-of-detail AI.\nAs you read the gems that follow, consider how these optimization strategies have\nit's quite amazing how disparate problems can often be solved with the same strategy.\nFast Code, Game Programming,\n[RabinOOa] Rabin, Steve, \"Designing a General Robust AI Engine,\" Game Program-\ntions,\" Game Programming Gems, Charles River Media, 2000.\nGame AI doesn't have to play championship chess, but it does have to update many\ngame objects per frame, in very little CPU time.\nity\" [Brooks95] introduced by the common methods of implementing AI for game\nAs an example of accidental complexity in most games' code, let's say we want to\nHowever, that doesn't work very well in a game because it doesn't share the CPU\n: m_target(0) , m state (k_NeedsGoal) {\n3.2 Micro-Threads for Game Object Al \nOur AI code has gone from simple and elegant to a huge and unread-\nCentral to die problem is that all of die state now has to be stored in die object.\nWhen we implement AI with callbacks, we have to simulate the instruction pointer\nTo do that we need to let the rest of the game loop and die other\nobjects have some CPU time, and we need to synchronize the objects so they do\nTo do this we need to put each game entity into a",
      "keywords": [
        "Strategy",
        "game",
        "agents",
        "problem",
        "code",
        "Strategies",
        "gem",
        "time",
        "Game Developers Conference",
        "target",
        "Janitor",
        "state",
        "Game Object",
        "game programming",
        "objects"
      ],
      "concepts": [
        "strategies",
        "strategy",
        "games",
        "optimizing",
        "optimized",
        "optimal",
        "optimize",
        "optimizations",
        "gems",
        "gem"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 31,
          "title": "",
          "score": 0.602,
          "base_score": 0.452,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 29,
          "title": "",
          "score": 0.596,
          "base_score": 0.446,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 27,
          "title": "",
          "score": 0.589,
          "base_score": 0.439,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 34,
          "title": "",
          "score": 0.524,
          "base_score": 0.374,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 33,
          "title": "",
          "score": 0.478,
          "base_score": 0.328,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "strategy",
          "ai",
          "agents",
          "game",
          "strategies"
        ],
        "semantic": [],
        "merged": [
          "strategy",
          "ai",
          "agents",
          "game",
          "strategies"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.1850438436047364,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285296+00:00"
      }
    },
    {
      "chapter_number": 26,
      "title": "Segment 26 (pages 249-257)",
      "start_page": 249,
      "end_page": 257,
      "summary": "separate thread and have the WaitOneFrame () function switch to the next thread.\nSwitching threads on\npossible stack.\ndent and allow for stack growth, their allocations are put on separate memory man-\nthreads.\nMicro-Threads\nWhat do we have to do to switch from one thread of execution to another?\nThe instruction pointer is not the only piece of state in a CPU and it is not the\nof the puzzle is the stack pointer.\nfact, the stack pointer is even more important than the instruction pointer, because\nfunction return addresses—instruction pointers—are stored on the stack.\n3.2 Micro-Threads for Game Object Al \npointer onto the stack, then changes the stack pointer, and then pops the instruction\npointer off of the stack.\nstack, changing the stack pointer has also changed the instruction pointer—voilfr,\nand returning from a function pops the instruction pointer, our thread switching\nfunction is just two instructions—move a new value into the stack pointer, then\nFirst, CPUs have more registers than just the stack\nPush them all onto the stack at the beginning, change the stack pointer, and then pop\nCPU that has enough flexibility in where you point the stack pointer can implement\nMicro-threads have even been implemented on a Nintendo GameBoy!\nOn an x86 CPU, a complete thread switch can be implemented in 12 assembly lan-\nIn the micro-thread sample programs on the CD, that is all the\n// Swap stack pointers\nStack Management\nBut what, exactly, are we assigning to our stack pointer when we change threads?\nmemory for each stack.\nWe're trying to avoid allocating 4 KB of stack for each thread, so how much\nof stack per object; after all, we want to have hundreds or thousands of these things.\ngame entity code that uses a bit too much stack, terrible things will happen.\ncorrupt whatever block of memory conies before the thread stack, and your game will\nend of the stack, and check these markers after every thread switch to see if they have\nA slightly different implementation of micro-threads can avoid these strict stack\nIn this variation a large stack is allocated that all micro-threads share.\nWhen a micro-thread goes to sleep, the thread manager copies the contents of the\nthread's stack size increases, so the buffer allocation time is negligible.\nthe only additional overhead of this method is copying the contents of the stack back\nCPU caches and prepares them for running the thread.\nstack for each thread.\nthat uses a lot of stack, they can do this with stack copying micro-threads.\nWith fixed-stack micro-threads you can never use\nIf your AI routines are forced to use a tiny little stack\n3.2 Micro-Threads for Game Object Al \nCompilers will sometimes generate stack frames for each function, which are used for\ntogether in a linked list on the stack.\nIn other words, a typical stack contains pointers\nStacks also contain return addresses—pointers to code.\nEven if you deal with the problems of micro-thread stacks containing pointers to\nthemselves and to code, the stacks will contain local variables, some of which will\nstructure if you are careful, but with micro-thread stacks, you don't know where the\nTherefore, loading and saving of games that use micro-thread stacks is problem-\nnot get called for exceptions that happen inside micro-threads.\nthe current OS thread's known stack range [Pietrek97].\nand you have to make sure that your main thread's stack never goes down far enough\nto be overwritten by the micro-thread stacks.\nOn Windows NT, if you call OutputDebugString () from a micro-thread when you're\nThreads are a simpler method of writing AI code for many independent entities.\nMicro-threads let us implement our game entities using threads without die high\nmemory or CPU cost of other threading methods.\nMicro-threads can be easily imple-\nA sample implementation of micro-threads for Win32 is on the companion CD-\nAlso included is a simple game that uses micro-threads, and a test application\n£or comparmg micro-threads to Fibers and OS threads.\nA micro-thread janitor can clean up your game code.\nThreads\nMicro-threads offer a\nMicro-threads allow us to code up state machines using normal, everyday program-\nMicro-threads allow us to choose the granularity of our modules\nThe more behaviors a particular entity has, the\nA system based on behavioral units will allow us to construct flexible AI out of\nare present for the behavior to run; for example, is there food nearby and is the entity\nbefore the behavior was activated.\nIn general, a particular module of AI behavior will simply be a tree of conditional\nthis code, the game would freeze in the while loop; this is where micro-threads come\nAssuming this behavior class is being run in a micro-thread, all we\n3.3 Managing Al with Micro-Threads \nMicroThreadSleepO ; // a call to suspend the micro thread.\na single module of AI behavior.\nBehaviors;\nvoid AddBehavior(int priority, CAIBehavior& behavior);\nEach AI entity in our game will have its own brain, and each brain has a micro-\nthread.\nwhich can be used to help choose the behavior to run.\nUpdate method of the brain to keep switching control to the micro-thread, which will\nin turn keep pumping the Update method of the active behavior.\nBefore that, however, we must make sure that there is an active behavior.\nour entity has nothing to do, we need to run through all the available behaviors and\ncode, and set it as our active behavior.\nIn this way, a brain will make sure it always keeps an appropriate active behavior\nwants to go and run its Sleep behavior for a couple of minutes, because everything is",
      "keywords": [
        "stack",
        "stack pointer",
        "instruction pointer",
        "behavior",
        "pointer",
        "thread",
        "CPU",
        "Micro-Threads",
        "micro-thread stacks",
        "system",
        "code",
        "thread stack",
        "instruction",
        "function",
        "game"
      ],
      "concepts": [
        "stack",
        "thread",
        "behavior",
        "behavioral",
        "micro",
        "memory",
        "different",
        "pointer",
        "function",
        "functions"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 10,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "",
          "score": 0.558,
          "base_score": 0.408,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.488,
          "base_score": 0.338,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 8,
          "title": "",
          "score": 0.466,
          "base_score": 0.316,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 9,
          "title": "",
          "score": 0.392,
          "base_score": 0.242,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "stack",
          "micro",
          "thread",
          "threads",
          "micro threads"
        ],
        "semantic": [],
        "merged": [
          "stack",
          "micro",
          "thread",
          "threads",
          "micro threads"
        ]
      },
      "topic_id": 1,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19475865549985594,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285339+00:00"
      }
    },
    {
      "chapter_number": 27,
      "title": "Segment 27 (pages 258-267)",
      "start_page": 258,
      "end_page": 267,
      "summary": "Depending on how we handle entity deaths in our game, there are a number of\nThat way, when an entity dies, our game code can\nhave this working, all we have to do in our AI code is make sure we check that the\nour AI code as quickly as possible.\nreturn (AI_TERMINATE) ;\nA special tracking pointer is used to track the food in case it dies.\nbehavior's brain, it returns a value that lets the calling AI behavior know that it should\nLikewise, if the food dies, it returns a code telling the behavior as much.\n• Action functions can be put into the behavior base-class and reused between dif-\n• Using the \"message\" system described in Game Programming Gems to allow AI\n• Data specific to an entity and its behavior can be stored naturally between game\n[RabinOO] Rabin, Steve, \"Designing a General Robust AI Engine,\" Game Program-\nCommand Queuing\ncalled command queuing.\nRTS Commands\nThe basic user interface for an RTS game involves selecting units and commanding\nfairly simple concept that doesn't require any great AI architecture to implement.\n• Patrol to a spot\n• Repair a unit or building\n• Guard a unit or building (attack anyone who attacks it)\nCommand Queuing\nsuccessive move commands that are queued up within a unit.\nThe player queues up\nGenerally, this idea is known as command queuing.\nThe trick is to think of every command as a task and to think of a unit's brain as\na queue of tasks.\nThe unit will always process the task that's at the front of the queue.\nexample of a unit's brain queue.\nFigure 3.4.1 shows the result of queuing the commands attack, repair, and move.\nNew tasks to be queued are placed at the end of the list, but before the\nIf the player commands a unit to do a new task without holding the \"queuing\"\nbutton, all tasks are destroyed and the new task is put in the queue.\ntasks can easily be replaced by a single, new command.\nj-v \nqueued tasks here\n3.4 An Architecture for RTS Command Queuing \nWith this architecture, a common behavior is to allow the player to \"see\" the\ncommand queue by selecting the unit and holding the \"queuing\" button.\nwhat's queued up in the unit and what additions might be appropriate.\nThis simple architecture is also blind to who put the commands in the queue.\nObviously, the player can put commands there, but the game can also preload com-\nThe AI can also make high-level decisions about which units to attack by simply\nputting those commands in the queue.\nallowed to place commands in a unit's queue.\nCyclic Commands\nPatrolling is a cyclic command that presents some interesting consequences for the\nWhen a player takes a unit and tells it to Patrol to a spot, the\nThe player could also queue up several\nFIGURE 3.4.2 Patrol path for a unit.\nQueuing the First Patrol Point\nThe first Patrol click from a player actually ends up placing two patrol commands on\nFigure 3.4.3 shows the brain queue after just one Patrol\ncommand was issued by the player.\nFIGURE 3.4.3 The brain queue after a single Patrol command was issued.\nInterestingly, a Patrol command is identical to a Move command, except that it\nfectly if a simple \"cyclic\" flag is set within a Move task in order to make it a Patrol\nWhen the Patrol task completes, rather than being destroyed (like a Move task),\nit's put onto the back of the queue (but before the default task).\n• .\n;• .: ._\n-..:•-.\n*•\n. , ; • .\n• ; :\nQueuing Additional Commands\nSome tricky issues arise when the player wants to queue extra commands when Patrol\n3.4 An Architecture for RTS Command Queuing\nThe first issue is where to put additional Patrol commands that are to be queued\nthey're put after the first set of Patrol points (regardless of where the unit currently is\nalong the patrol when the second set of Patrol commands are queued.\nThe solution is to mark the last Patrol command ever queued.\nPatrol commands to get queued after it.\nOnce new Patrol commands are added, the\nFigure 3.4.5 shows an example of three Patrol commands\nFIGURE 3.4,5 Three Patrol commands being queued in order.\nThe second issue with queued Patrol commands involves queuing additional\nnon-Patrol commands.\nIn general, the player expects the command to be executed\ncommands must be placed after the current Patrol command, if there is one, and after\nnon-Patrol commands.\nAs shown, Patrol commands throw several wrenches into the command queuing\ninteraction and behavior of the command queuing system.\nFIGURE 3.4.6 Queuing additional commands with Patrol tasks already queued.\nCommand queuing is now a standard power feature that no RTS game can do with-\nBy using the brain queue architecture to store tasks, many of the complexities of\na command queuing system go away.\na simple task list, or you can turn each task into its own neatly wrapped AI system\nqueue up whatever they wish, and easily manage hundreds of units with this simple,",
      "keywords": [
        "patrol commands",
        "Patrol",
        "brain queue",
        "Command Queuing",
        "queue",
        "Commands",
        "RTS Command Queuing",
        "Patrol Click",
        "task",
        "unit",
        "Queuing",
        "brain",
        "queued Patrol commands",
        "game",
        "pos"
      ],
      "concepts": [
        "command",
        "patrol",
        "patrolling",
        "task",
        "queuing",
        "dying",
        "died",
        "dies",
        "die",
        "pos"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 25,
          "title": "",
          "score": 0.589,
          "base_score": 0.439,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 31,
          "title": "",
          "score": 0.516,
          "base_score": 0.366,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 29,
          "title": "",
          "score": 0.452,
          "base_score": 0.302,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 33,
          "title": "",
          "score": 0.45,
          "base_score": 0.3,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "",
          "score": 0.385,
          "base_score": 0.385,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "patrol",
          "commands",
          "queuing",
          "command",
          "queue"
        ],
        "semantic": [],
        "merged": [
          "patrol",
          "commands",
          "queuing",
          "command",
          "queue"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.20096807175201734,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285387+00:00"
      }
    },
    {
      "chapter_number": 28,
      "title": "Segment 28 (pages 268-275)",
      "start_page": 268,
      "end_page": 275,
      "summary": "ing a player's explored and visible maps has generally proven to be adequate.\nThe goals of our player visibility system are as follows:\n• The game's explored, visible, and fogged tiles must be fully accurate at all times.\nTile.\nThe area around a unit that is currently visible because of its\nThe range of a units LOS area, measured in tiles.\nA tile that the player's units have never seen within their LOS.\nA tile that has been explored but is not currently in the LOS of any of\nthe player's units.\nVisible Tile.\nA tile that is currently in the LOS of one or more of the player's units.\nThe concept that if an explored tile is not currently in the LOS\nof a player's unit, then the player can't see other players' units on that tile.\ninto a unit's LOS, those tiles become explored for the player who owns that unit.\nWhen an explored tile is no longer in a unit's LOS, the tile becomes fogged for that\nComponent #1: Individual Player Visibility Maps\nvisibility count map for each player in the game.\ncontains a count of how many of the player's units can see that tile (in other words,\nhow many units' LOS contain that tile).\nWhen the unit is deleted, destroyed, or moves off a tile, all of\nthe visibility counts are decremented by one for the tiles in the unit's LOS.\nin each visibility map element is nonzero if the tile is visible to the player.\nunits that can see a specific tile at one time, which in this case is 254.\nIn most strategy games, a unit's LOS is defined as a circular area around the unit, with\nwhich many games have done, is to take a radius-sized box of tiles around the unit's\nposition and see if the distance from each tile is less than the unit's LOS radius.\nFor units at the edges, clipping the LOS template shape to the game map just requires\nfunction to add a unit's LOS template to the visibility count map.\nWhen a player's unit is removed from the game world, the game decrements the\nIf none of the player's other units have the tile in their\nLOS, it will be zero, indicating that the tile is no longer visible for the player, and is\nonly updates the portions of the player's visibility map where the increment and the\nAnother situation is when a unit's LOS radius changes.\na small game unit may occupy a single tile, larger units, such as immobile structures,\nAn LOS template that appears centered on a one-tile unit would\nVisible tiles\nFIGURE 3.5.1 LOS shapes with the same radius for units of different size.\nVisible tiles\nLike the individual player maps, the combined visibility map is a 2D array, sized\nIn practice, the combined visibility map is initialized to all tiles as unexplored and\n• A tile transitions from unexplored or fogged to visible.\n• A tile transitions from visible to fogged.\nplayer has a visibility mask value that contains the explored and visibility bits shifted\ncurrent player's visibility mask.\nthat tile for the specified player, on which the code can then operate.\nThe first benefit of using the combined visibility map is that the player's visibility\nsearching unit's LOS area.\nas with ranged units or LOS upgrades, the number of tiles searched rises very quickly.\nFor example, a single ranged attack unit with a search radius of 10 tiles would have an\ntask of searching in a unit's LOS for enemy targets or other objects of interest.\nthan search the individual tiles, it's better to keep a running list of the other player's\nunits in a given player's total combined LOS.\nEach unit in the game accesses the combined visibility map\nwhen it moves into and out of the LOS of every other player in the game, even if it is\nfrom a list of units visible to the other player.\nThe following code shows how a unit's update would process the changes in LOS\nvisibility and don't need to be restricted in range to the unit's LOS radius.\ntrated in Figure 3.5.3, each of the player's units at the bottom performs a target search\nwith a search radius greater than its own LOS radius and finds the enemy units visible\nunits in the upper right because they are on tiles that are currently fogged to the\nVisible tiles\nby a Player's unit\nTiles with player's\n. units searching\nFigure 3.5.3 Demonstration of which enemy units can be seen by the player.\nrespecting the total LOS, the searching units will only see the enemy units on the left, even\nORing together the combined visibility map values for each tile occupied, instead of\nentire map area occupied by the unit, even if the player's LOS only falls on a corner of it.\nMirages are another game capability that the combined visibility map makes easy\nout of another player's LOS.\ngame when they detect that they are again fully visible to the other player, by check-\nThis only works because the individual player visibility maps are always kept",
      "keywords": [
        "LOS",
        "unit LOS",
        "Combined Visibility Map",
        "player",
        "unit LOS radius",
        "Tile",
        "Unit",
        "visibility map",
        "LOS Radius",
        "visibility",
        "player visibility",
        "Combined Visibility",
        "player units",
        "game",
        "map"
      ],
      "concepts": [
        "tiles",
        "units",
        "games",
        "visibility",
        "map",
        "search",
        "searches",
        "templates",
        "player",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 36,
          "title": "",
          "score": 0.376,
          "base_score": 0.376,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 29,
          "title": "",
          "score": 0.358,
          "base_score": 0.358,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 32,
          "title": "",
          "score": 0.343,
          "base_score": 0.343,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 56,
          "title": "",
          "score": 0.337,
          "base_score": 0.337,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 37,
          "title": "",
          "score": 0.312,
          "base_score": 0.312,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "los",
          "player",
          "tile",
          "visibility",
          "unit"
        ],
        "semantic": [],
        "merged": [
          "los",
          "player",
          "tile",
          "visibility",
          "unit"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.16847246842803362,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:23.285426+00:00"
      }
    },
    {
      "chapter_number": 29,
      "title": "Segment 29 (pages 276-286)",
      "start_page": 276,
      "end_page": 286,
      "summary": "Influence Mapping\nInfluence Maps\nInfluence mapping is an invaluable and proven game AI technique for performing\nInfluence maps have been used most often in strategy games, but\nThe general concepts of influence mapping are an essential part of any AI devel-\nAn influence map is a spatial representation of an AI agent's knowledge about the\nAn influence map indicates where a computer player's forces\nThe structure of the influence map also makes it possible to make intelligent infer-\nInfluence\nThere is no single, standard algorithm for creating influence maps, nor any single\ninfluence maps will depend heavily on the specific strategic and tactical needs of your\nA Simple Influence Map\nAn influence map can operate in almost any type of game world topography—a\nAll the cells\nFor each cell, we add a certain type of \"influence\"\nThe next step is to spread the influence of each cell to nearby cells.\nassume that we propagate each cell's influence such that each time the influence is\n3.6 Influence Mapping\ntheir influence values will be negative because we hate them.\nFIGURE 3.6.2 A) Influence propagation.\nB) The final influence map.\nInfluence Map Cell Data\nAn influence map in a real game is consider-\nence map's \"cells\" is a repository for some amount of data about the game world.\nthe cell, such as a part of a village or military base in a typical strategy game.\nused to more accurately propagate a cell's influence to neighboring cells, and can\nAn influence map will typically track these variables for each player in die game\nThink of this as maintaining multiple parallel influence maps: each player\nupdates an influence map for its own assets, plus an additional influence map to repre-\nof friendly or enemy influences together as desired.\nOf course, you could also just keep a single influence map for everyone, and let\ncomparing the desirability values of different cells, we can construct a ranking of\n3.6 Influence Mapping \ncell; a high vulnerability score for this AI player means that we have significant\nFor strategy games that use a hidden map or FOW, a good AI\nA good heuristic for exploration is to rank the influence map cells that have gone\nthis decision are the enemy influence in a cell and the area's estimated passability\nbe easily identified on die influence map using precomputed passability values;\nchoke points will be high-passability influence map cells that connect other high-\nThe size of the influence map cells is somewhat arbitrary.\nWith cells that are too large, your influence maps will have a dif-\ngame's standard \"units\" side by side along the width or height of the cell, and carefully\nSome readers may note that the arbitrary positioning of the cells over the map\nA unit straddling two neighboring influence map cells will have\na different effect depending on which of the two cells receives its influence.\nspace offset of the entire influence map on a regular basis (perhaps each time you\nInfluence Propagation\nOnce you have calculated an initial value for each cell of the influence map, the next\nstep is to propagate the value of each cell to some number of nearby cells, as in the\nWe need to propagate the Tanks' influence to the cell the Archers occupy.\nPropagation is just a matter of spreading the influence of each cell to neighboring\ncells using a \"falloff rule\" that determines how the influence of a given cell decreases\nspread influence to a neighboring cell, use this constant as a multiplier.\n3.6 Influence Mapping \nshould be proportional to the cell size: smaller influence map cells require a larger\nfalloff value to spread the influence the same distance.\nOther useful falloff rules include linear falloff (in which a cell's influence\ndecreases by a constant value each time it spreads to a neighboring cell) and Gaussian\nNote that if you use floating-point numbers, your propagated influence values\neach cell will end up spreading its influence to every other cell in the entire influence\nplest solution is to terminate propagation at a certain minimum influence value (usu-\nNote, however, that it's usually a good idea to spread a cell's influence a fair dis-\nIf your influence map consists of many small cells and the cells' influence is not\na lot of zeroes) in the influence map, and it will be difficult to determine exactly where\nUse big cells, and spread their influence a good distance.\nUnfortunately, this approach spreads cells' influence in a somewhat arbi-\nThe distance that a cell's influence is propagated is tightly bound to the\nThe propagation technique will spread the influence of the\nThere are several ways to account for the impact of terrain on the influence map.\nProbably the simplest is to use a precomputed passability value for each cell and use\nWe then spread the influence from the cell in a man-\ndoes not show it, this can also handle cells where influence is merely diminished and\nFor each cell, we perform a pathfinding step during map\nWe consider a cell to be unavailable for influence propaga-\n3.6 Influence Mapping \nthrough the center of the mountains, the influence map propagation will accurately\nvery difficult to update your influence map in real time.\neach cell in the influence map to potentially dozens or hundreds of other cells.\nTherefore, it's important that each influence map cell track such different unit\nA good way to account for this is for each influence map cell to separately track ranged-\nthe width of an influence map cell).\ntance categories using propagation, we then spread the influence an extra TV cells from\neach influenced cell without diminishing the value.\nmap a bit more accurate, particularly if you don't recalculate the influence map very\nRefreshing the Influence Map\nIf your AI needs to analyze large portions of the influence map on a regular basis, it\nmay make sense to recompute the entire influence map on a regular basis, perhaps\nOnce the influence map is com-\nextensive influence map analysis.\ngiven maximum distance to see how their values propagate back to the original cell.\nInfluence Maps in 3D Environments\nUsing a 2D grid for 3D influence mapping is usually a bad idea, as it will not\nWe can use each polygon of the navigation mesh as an influence map cell.\nInfluence\nsible fire locations to and from each cell of the influence map.\njected from each influence map node.\n3.6 Influence Mapping \nThese are the basic precalculated statistics in our influence map cells.\nthen can propagate these values to their neighbors using our standard influence map-\nFinally, note that we can also use the influence map to make inferences about our\n[comp.ai.games95] The seminal 1995 \"influence mapping\" thread on comp.ai.games\nThe seminal article on influence mapping.",
      "keywords": [
        "influence map",
        "influence map cells",
        "Influence",
        "cell",
        "map",
        "Influence Mapping",
        "cell influence",
        "map cells",
        "game",
        "entire influence map",
        "Influence propagation",
        "influence map propagation",
        "neighboring influence map",
        "game world",
        "Simple Influence Map"
      ],
      "concepts": [
        "cells",
        "influence",
        "influenced",
        "game",
        "value",
        "mapping",
        "maps",
        "map",
        "unit",
        "player"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 25,
          "title": "",
          "score": 0.596,
          "base_score": 0.446,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 31,
          "title": "",
          "score": 0.573,
          "base_score": 0.423,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 27,
          "title": "",
          "score": 0.452,
          "base_score": 0.302,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 34,
          "title": "",
          "score": 0.45,
          "base_score": 0.3,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 33,
          "title": "",
          "score": 0.421,
          "base_score": 0.271,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "influence",
          "influence map",
          "map",
          "cell",
          "cells"
        ],
        "semantic": [],
        "merged": [
          "influence",
          "influence map",
          "map",
          "cell",
          "cells"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.14895746790249675,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285465+00:00"
      }
    },
    {
      "chapter_number": 30,
      "title": "Segment 30 (pages 287-294)",
      "start_page": 287,
      "end_page": 294,
      "summary": "The Resource Allocation Tree\nThe resource allocation tree is a tree structure that represents the specific functional\nThe tree breaks down all of the units\nAt the top of the tree is a root node that represents a player's total assets.\nBallistic, Ranged, and Melee to indicate different functional roles for military units.\nEconomic would likely be broken down into Resource Gathering, Unit Production,\ntrates a small slice of the resource allocation tree.\nFIGURE 3.7.1 The resource allocation tree.\nThe leaves of the tree are the specific types of units available.\nThe Pikemen node itself would\nfunctional breakdown of each player's current strategic assets.\nAn AI player will typically dedicate a given unit to only one functional role at any\nDefense, and Exploration should represent the Pikemen that are currently allocated to\nIt's also important to note that at any given moment, the resource allocation tree\nit as a node in the tree.\nThe structure of the resource allocation tree provides us with a very simple and nat-\npriority of each node in the tree by proceeding down the graph from the root.\nAt each node, we split the current value into an appropriate fraction of the\ndesired allocation for each child node.\nallocation\" value for each tree node.\nThe algorithm for determining the numeric breakdown at each node will depend\nSimultaneously, we can use the tree to calculate a \"current allocation\" value for each\nnode.\nWe iterate over all the Pikemen currently allocated to Defense, for\nthis as the current allocation value of the Pikeman node beneath Defense/Melee.\nRevisit each node in the tree and divide its \"current allocation\" value\ncation value in each tree node to the desired allocation value to trivially determine how\nAs the parent node of Elephant receives the resources it needs to fill in new\nThe resource allocation tree is useful primarily for deciding which new units to\nconstruct and how to allocate existing units to the most appropriate roles.\nThe resource allocation tree also gives us a good way to design unique player per-\nWith a little tweaking at different parts of the tree, AI players can be made\nlyzing the functional asset tree that represents your knowledge of a particular enemy,\nFinally, the resource allocation tree is an excellent place to store all types of addi-\ncell are also appropriate to a functional asset tree node.\nIt's also often a good idea to track which nodes in the tree have proven effective in\nthe past, and which nodes have been attacked by enemy players.\nthat my enemy has a proclivity for attacking my resource-gathering units (for exam-\nway to measure each unit's value in its particular branch of the tree.\nunits used in each node need to be commensurate with all other units' values in their\nValues under the Military branch should represent units' contri-\nappropriate way to correlate these values is, like so much else in game AI, a matter of\nThe Dependency Graph\nFIGURE 3.7.2 The dependency graph.\nseveral parallel dependency graphs, one for itself and one for each of the other players.\nDependency Graph Nodes\nA given node in a dependency graph will typically contain several different types of\nUseful categories include the total number of units of that type that the player\ntotal estimated value of those units; and the number of those assets currently in pro-\nconcerns, it may be possible for a \"node\" in the dependency graph to be similar to a\n\"node\" in the functional asset tree, or even be the same physical data structure.\nmain difference between the two is that the resource allocation tree tracks only the\ncurrently available assets, while the dependency graph tracks all possible assets.\nThe first and most obvious use for a dependency graph is building toward a goal.\ncomputer player can use the dependency graph to determine what it needs to build in\ncation tree to rank all the assets it can potentially create immediately and pick the best\nA more planning-oriented AI will analyze all the nodes in the graph to\nfind a long-term goal worth pursuing, query the functional asset tree to determine\nthere are so many optional dependencies that the best route to a given node isn't obvi-\nA dependency graph can be used to analyze strengths and weaknesses in a player's\ndependency graph is \"vulnerable.\"\nGraph nodes whose parents are\ninferences about other players' current assets and likely strategies based on incomplete\ndependency.\nand all the other dependencies leading up to the Grand Mage unit.\nInterestingly, it's also possible to use inference to make certain nodes less probable.\nother players' assets directly.",
      "keywords": [
        "Resource Allocation Tree",
        "Allocation Tree",
        "Tree",
        "Resource Allocation",
        "Dependency Graph",
        "functional asset tree",
        "node",
        "Allocation",
        "player",
        "Strategic Assessment Techniques",
        "Dependency",
        "graph",
        "Resource",
        "assets",
        "tree node"
      ],
      "concepts": [
        "units",
        "depend",
        "dependency",
        "dependencies",
        "node",
        "tree",
        "value",
        "resource",
        "games",
        "allocation"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 31,
          "title": "",
          "score": 0.414,
          "base_score": 0.414,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 38,
          "title": "",
          "score": 0.381,
          "base_score": 0.381,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 25,
          "title": "",
          "score": 0.361,
          "base_score": 0.361,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 56,
          "title": "",
          "score": 0.307,
          "base_score": 0.307,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "tree",
          "node",
          "allocation",
          "resource",
          "dependency"
        ],
        "semantic": [],
        "merged": [
          "tree",
          "node",
          "allocation",
          "resource",
          "dependency"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19849319033998655,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:23.285505+00:00"
      }
    },
    {
      "chapter_number": 31,
      "title": "Segment 31 (pages 295-305)",
      "start_page": 295,
      "end_page": 305,
      "summary": "As with the functional asset tree, we can use the dependency graph to give AI players\ngame AI as well.\nThis helps the AI in picking good locations for its\nFirst, we pick a terrain representation that the AI can handle efficiently: waypoint\nTo illustrate waypoint-based reasoning, an example problem is introduced.\nThen, we identify tactical attributes and relate them to waypoint properties.\nstruct formulas to compute these waypoint properties, using static data such as the\nintegrate terrain reasoning in our game and we look at various other applications of\nwaypoint-based terrain reasoning.\nWaypoints\nMost 3D game AIs already have a terrain representation that is easy to handle.\nEach waypoint is a sample, an\nThe number of waypoints is typically\nReasoning in terms of waypoints is attractive because many game AIs already use\nnear waypoints, capturing gameplay data per waypoint is easy and almost free.\nBefore we start reasoning about the waypoint-based terrain representation, that\nnumber of waypoints than required for AI navigation and pathfinding.\nTerrain reasoning often deals with other inter-waypoint relations than shortest\nwaypoints are best illustrated using an example.\nExample Terrain and AI Needs\nTo illustrate waypoint-based terrain reasoning, let's look at the following example: in\nfor each waypoint and for a number of directions, the offensive and defensive value of\nthat waypoint.\nThis value is computed using the waypoint graph and world geometry\n3.8 Terrain Reasoning for 3D Action Games\ndistribution of waypoint\nwaypoint w.\n(center) The waypoints in the example terrain, and the valid lines of sight\nfrom waypoint w to other waypoints.\nIn assessing the tactical value of a location, many factors need to be considered.\nlarge number of these factors can be translated to properties of a waypoint, which in\nnonlethal weapons, and rocket launchers, the tactical value of a location is largely\n• As within the capture-the-flag game, locations that overlook the objective, and\nFrom Tactical Values to Waypoint Properties\nFirst, we look at the waypoint properties that we can use to express tactical char-\nFigure 3.8.2 illustrates the different types of waypoint properties available.\nA waypoint has properties that are local, such as the light level and the presence of\nAnother category of properties is determined by the waypoints'\nmembership in a larger terrain representation (typically a group of waypoints).\nexample, the waypoint may be part of a room, a street, or a roof.\nThe relations between waypoints, however, are directional.\npoint w (in Figure 3.8.1) can see almost all waypoints to its east, and it will be hard to\napproach waypoint w from the east without being observed.\ndifferences often cause a waypoint to be easily accessed from one direction, and much\nA last, but essential, aspect is the distribution of the waypoints relations.\nexample, if a waypoint overlooks many other locations in primarily one direction, the\nFIGURE 3.8.2 Waypoint properties: (from left to right) local properties, group membership, relations\nwith other waypoints, and focus.\n3.8 Terrain Reasoning for 3D Action Games \nTo compute a useful offensive or defensive rating for a given waypoint and direction,\nwe need to implement each applicable tactical characteristic as a function of waypoint\nthe waypoint graph, in effect dealing with linear distance, travel time, line-of-sight,\nA waypoint with a \"water\" local\nIt is more complicated to compute a directional relation for a waypoint.\ncific relation for waypoint w, such as the availability of nearby cover from another\nwaypoint wu that has a line of sight on w, is computed in the following function.\nFor each of these waypoints, the number of w's relations is incre-\ndistance between the waypoints.\n3.8 Terrain Reasoning for 3D Action Games \nFIGURE 3.8.3 Simple computation of the focus values for waypoint ~w in the example\nThe focus of a waypoint reflects the concentration of relations over the various\nThe function focus ( w, d ) expresses the distribution of relations in one direction\nillustrates an implementation of focus for waypoint w in our example terrain, using sim-\nThe focus() function assumes a more or less uniform distribution of waypoints\nof waypoint property computations, we can combine them as follows:\nexpresses the AI's a-priori understanding of a location and its role in the game.\nrating, the tactical value of a location, is based on die waypoint graph and world geom-\nwaypoints, is an approximation, and so are the evaluation functions used to compute\nBecause the AI uses waypoints for its actions, and thinks of the players as being\nWe can improve, for example, the defensive value of a waypoint in a direction by\nat that waypoint.\nThe captured gameplay data can also be input for our waypoint properties.\nexample, the more \"hostile traffic\" waypoints that can be seen from a location, the\ncomputations, the AI actually gains tactical understanding of the terrain.\nPutting Terrain Reasoning in the Game\ndata, travel time, shortest paths, line-of-sight, line-of-fire, and waypoint-related\ning some of the waypoint-to-waypoint relations, other nearby waypoints are also con-\nwaypoint reasoning is best done when preprocessing a level and possibly between mis-\nIn general, waypoint-based reasoning need not be CPU intensive.\nAI can, for example, efficiently plan paths that avoid locations under fire from threats.\n3.8 Terrain Reasoning for 3D Action Games \nWaypoint-based terrain reasoning is presented here using a simple example, precom-\nputing the offensive and defensive values of the game locations.\nthat will work for many games where the AI needs to reason about locations.\nWaypoints, if placed in a sufficiently dense graph across the terrain, serve many\nnearby waypoints and visible waypoints, they enable the AI to predict out-of-sight\nIf we also tag all waypoints that restrict our movement, the path returned\nwill be even more \"tactical.\" These are just two of the many examples of waypoint-\nWaypoint graphs provide an easy-to-use representation of the game terrain.\ntranslate many of the terrain-related tactics in your game to waypoint-related proper-\nAs an example, this gem shows how to build a per-waypoint evaluation function\nways your AI can reason about terrain using waypoints.\nguidelines to waypoint properties (that fit in a look-up table).",
      "keywords": [
        "waypoint",
        "Terrain Reasoning",
        "Terrain",
        "waypoint properties",
        "game",
        "Reasoning",
        "locations",
        "Location",
        "tactical",
        "Action Games",
        "waypoint-based terrain reasoning",
        "Artificial Intelligence",
        "Sections Artificial Intelligence",
        "relations",
        "waypoint graph"
      ],
      "concepts": [
        "location",
        "locations",
        "game",
        "terrain",
        "ais",
        "tactical",
        "tactics",
        "relate",
        "relations",
        "relation"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 25,
          "title": "",
          "score": 0.602,
          "base_score": 0.452,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 29,
          "title": "",
          "score": 0.573,
          "base_score": 0.423,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 56,
          "title": "",
          "score": 0.521,
          "base_score": 0.521,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 27,
          "title": "",
          "score": 0.516,
          "base_score": 0.366,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 34,
          "title": "",
          "score": 0.465,
          "base_score": 0.315,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "waypoint",
          "waypoints",
          "terrain",
          "reasoning",
          "terrain reasoning"
        ],
        "semantic": [],
        "merged": [
          "waypoint",
          "waypoints",
          "terrain",
          "reasoning",
          "terrain reasoning"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.25250712427095173,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285551+00:00"
      }
    },
    {
      "chapter_number": 32,
      "title": "Segment 32 (pages 306-318)",
      "start_page": 306,
      "end_page": 318,
      "summary": "Points-of-Visibility Pathfinding\npolygonal obstacles, and how to use this to implement points-of-visibility pathfinding.\n• Points of visibility can be extracted directly from the expanded geometry without\nFIGURE 3.9.1 Collision shapes in polygonal environments.\n3.9 Expanded Geometry for Points-of-Visibility Pathfinding \nas a planar set; that is, the set of points inside that polygon.\nOur expanded geometry represents the set of points that can be generated by sub-\ntracting some offset in our collision shape from some point inside the environment.\nThis means that for each position in our expanded geometry, some point in the colli-\nset of points where our character will be obstructed (Figure 3.9.2).\nFIGURE 3.9.2 Collision shape in polygonal environment, point in expanded environment.\nidentical to collision between a point and the expanded geometry.\nFor points-of-visibility pathfinding, the set of convex corners in our expanded\ngeometry gives us our points of visibility.\nTwo points can be connected if the line\nbetween the points doesn't collide against our expanded geometry.\nEdges in the expanded polygon are generated in three ways (see Figure 3.9.3B):\nvertices is used to expand the start and end points of that edge (Figure 3.9.4b).\n3.9 Expanded Geometry for Points-of-Visibility Pathfinding\npoint of one of these edges does not connect to the start point of the next, by inter-\nin C expand the start and end points of diat edge (also Figure 3.9.5).\nexpanded polygons and connect them together to make a single expanded shape.\nexactly on points representable by the numbers we are using for coordinates.\nIf the end point for the edge before the corner is not same as the\nstart point for the edge after the corner, then we get an intersection and a discontinu-\npoints of visibility.\n3.9 Expanded Geometry for Points-of-Visibility Pathfinding \nOptimizing Points-of-Visibility\nhe \"points of visibility\" pathfinding method has a number of advantages (see Steve\npolygonal obstruction set (see \"Expanded Geometry for Points-of-Visibility Pathfind-\nbetween points of visibility, an extremely fast pathfinder can be constructed.\nAs map complexity increases, and with it the number of points of visibility, we\nfind that the number of connections between these points can increase exponentially,\nPoints-of-Visibility Pathfinding\nOur pathfinder uses an A* algorithm with a set of points of visibility as possible\nThe points of visibility are derived directly\n3.10 Optimizing Points-of-Visibility Pathfinding \nStoring the Shortest Path to Each Point\nthat only the shortest path to any intermediate point is retained for further consider-\nThis is not a specific optimization for points-of-visibility pathfinding as it\nend at the current point under consideration.\nOne important difference between tile-based pathfinding and points-of-visibility\nity) to keep a record of the shortest path found so far to each point.\nthe partial path to another point with a line section.\nThe point can be either a point\nof visibility or the goal point.\nBy preprocessing collision between all pairs of points of visibility and building a\nvisibility can be reached from some source point of visibility.\nThe same is true for any points of visibility resulting from dynamic\nOptimization #1: Only Consider Paths to Silhouette Points\nPoint \nSource Point \nSource Point\nFIGURE 3.10.1 Silhouette points.\nsections that connect to nonsilhouette points.\nette point will result in a corner that can be cut to make a shorter path.\npoint.\nI will refer to the point at the end of this partial path as the current point.\npoints we consider using to extend the path are potential next points.\nWe discard nonsilhouette points because the resulting path can always be short-\nI will refer to the point at\nthe start of this line section as the previous point.\nThe point at the end of the partial\npath is our current point.\nAs a result of our first optimization, the current point will\nAny path diat does not go around the silhouette point will result in a cor-\nFigure 3.10.2 shows a silhouette point, a set\n3.10 Optimizing Points-of-VisibilityPathfinding \nof path sections that go around that point, and one example of a path that can be dis-\nprevious point, or via another silhouette point if the direct connection is obstructed.\nTo implement this optimization, we use the vector from the previous point to the\nFor implementation, it is useful to define two zones relating to each point of visibility\nEach point of visibility is positioned at a convex obstruction corner.\nThe zones classify this point of visibility as seen from some arbitrary point.\npoint is in the left silhouette zone, then our point of visibility is classified as left sil-\nTo go \"around\" the silhouette point, the next point must be in the opposite zone\nEach connection in our graph has a source point and a destination point.\ninformation in a simple visibility graph about the position of the previous point.\ntinations becomes the set of points in either of our silhouette zones.\nwhere the destination point is not in one of the source point's silhouette zones.\nous point so we can make a more specific test to possibly discard that connection.\nPoints \n3.10 Optimizing Points-of-Visibility Pathfinding \nFor dynamic points, we\nstill need to test for connection to and from every other point in the world.\npoints that can potentially connect to or from a given dynamic point.\nzones are a good starting point for building this representation.\npoint of visibility give us an area within which dynamic points can potentially con-\nnect to that point of visibility.\nthe corresponding point of visibility.\nenvironment to determine the area in which a given point is visible.\nis known diat a dynamic point is inside that shape.\nThere are many more details involved in building an efficient points-of-visibility\nA final detail is the problem of testing for connection from one dynamic point to\nthe potential connection from start point to goal point.",
      "keywords": [
        "point",
        "Expanded Geometry",
        "collision",
        "Expanded",
        "collision shape",
        "path",
        "Pathfinding",
        "silhouette point",
        "Geometry",
        "visibility",
        "Silhouette",
        "Game Programming Gems",
        "collision model",
        "Minkowski sum",
        "current point"
      ],
      "concepts": [
        "points",
        "path",
        "pathfinder",
        "collision",
        "polygonal",
        "polygonally",
        "expanded",
        "edges",
        "characters",
        "obstructions"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 20,
          "title": "",
          "score": 0.679,
          "base_score": 0.529,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 19,
          "title": "",
          "score": 0.57,
          "base_score": 0.42,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 23,
          "title": "",
          "score": 0.564,
          "base_score": 0.414,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 31,
          "title": "",
          "score": 0.401,
          "base_score": 0.401,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 35,
          "title": "",
          "score": 0.4,
          "base_score": 0.4,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "visibility",
          "point",
          "points",
          "points visibility",
          "expanded"
        ],
        "semantic": [],
        "merged": [
          "visibility",
          "point",
          "points",
          "points visibility",
          "expanded"
        ]
      },
      "topic_id": 5,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22077668703101822,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285595+00:00"
      }
    },
    {
      "chapter_number": 33,
      "title": "Segment 33 (pages 319-337)",
      "start_page": 319,
      "end_page": 337,
      "summary": "defined the three basic rules (or steering behaviors) for flocking and explained how\nIn Game\nadded another steering behavior to make what I called the \"Four Rules of Flocking.\"\nresulting behavior of the boids can seem.\nON THE CD approach boids belonging to another flock, they flee, breaking apart into smaller\nsplit from their original flocks, individual boids eventually find fellows and form a\nflock is going, but the flock moves as one mass, avoids obstacles and enemies, and\n3.11 Flocking with Teeth: Predators and Prey \nI'll then introduce a new discriminator that gives our boids a reason to flee\nBoids will now\ncome in three flavors: hawks, sparrows, and flies.\ninto a boid from another flock), a given boid would pretty much fly around forever,\nenced a boid's motion was a minor function I added to the flocking algorithm (in\n(which teleported boids flying off one side of the world to the other side) could screw\nThis class gives us a simple way to make the world a bit more interesting and pro-\nFigure 3.11.1 shows how boids now come in three flavors, arbitrarily named hawks,\nFIGURE 3.11.1 Types of boids.\nEvery Boid Is a Bit Different\nThe original Simple Flocking demo initialized all boids with various parameters—range\nBoids belonging to other flocks were\nThe Predators and Prey flocking demo individualizes each boid a bit by allowing a\nA boid thus created (via a new construc-\nFirst, providing each boid with slightly\nThe tug and pull of two boids in the same flock,\nsome interesting group dynamics, as will a boid that can see an oncoming predator\nAdditionally, the new demo adds some finer control over what types of boids\ncompare types and determine if a given boid is a predator to be avoided or prey to be\n3.11 Flocking with Teeth: Predators and Prey \nFeeding the Flock\nIt follows that if we're going to have classes of boids that feed on one another, we're\nsparrows, of course, while sparrow boids will seek out flies.\nthem in one flock.\nEach time a hawk or a sparrow eats, a random test will determine\nFor example, if a hawk starts out with 10 hunger points and has eaten four sparrows,\nattempt to close with any sparrow boid it sees, while a sparrow boid will deliberately\nSince hawks feed on sparrows and sparrows feed on flies, flies are both at the low end\nno other type of boid has—they can reproduce.\ncongregate in a flock, they can reproduce, creating a new fly boid every few seconds.\nEach boid will, of course,\nnearest flock of sparrows, causing them to scatter in all directions to avoid being\nScattered flocks of sparrows and flies will seek the safety of others and form\nnew flocks, and the whole cycle starts over again.\ncal disaster—the sparrows eat all the flies or the hawks eat all the sparrows.\nflies die off, the sparrows also eventually die too from lack of food, and the hawks (left\nIf the sparrows all die because the hawks are just a bit\nIf sparrows and hawks are allowed to reproduce (not the demo default, but\n3.11 Flocking with Teeth: Predators and Prey \ncan reproduce in the demo, it's a simple matter to allow both sparrows and hawks to\n[ReynoldsOO], where there are nearly a hundred pointers to uses of flocking in gaming\n[WoodcockOl] also maintains a number of pointers to flocking articles and pages.\nOne reader of the original Game Programming Gems built a great litde flocking\nflocking so interesting.\naddition to discussing both flocking and boids, is Steven Levy's Artificial Life\n[GrubOl] Grub, Tom, \"Flocking Demo,\" www.riversoftavg.com/flocking.htm,\nsteering behavior at www.red3d.com/cwr/boids/ and has presented a wide variety\nGroup Behavior,\" Game Programming Gems, Charles River Media, 2000.\nA Generic Fuzzy State\nuzzy logic was ably presented in the original Game Programming Gems article\ntitled \"Fuzzy Logic for Video Games\" by Mason McCuskey [McCuskeyOO].\nmarry these two concepts into a generic Fuzzy State Machine (FuSM) C++ class that\nyou can use in your games, and to provide you with an additional overview of fuzzy\nlogic, as well as some ideas on how to use fuzzy logic in your games.\nFirst, let's briefly review the FAQ definition of fuzzy logic:\nThus, instead of the states of ON and OFF, or TRUE and FALSE, a fuzzy state\nwords, by using a FuSM (implementing fuzzy logic), a game developer can have mul-\nThis could also mean that states in a game do not have to be specific and\ndiscrete (often referred to in the fuzzy logic world as crisp), but can be, well, fuzzy (less\nbers from 0.0 to 1.0; however, that is not the only way we can represent a fuzzy value.\nWe can choose literally any set of numbers, and consider them fuzzy values.\nFIGURE 3.12.1 A) Fuzzy values for dislike attitudes toward player.\nB) Fuzzy values that\nconception often associated with fuzzy logic: there is no specific relationship between\nfuzzy values and probability.\nFuzzy logic is not some new way to represent probability,\nFuzzy logic values have no such requirement (note\nThis does not mean that fuzzy logic values can't\nWhy Use a FuSM In a Game?\nIn this author's opinion, the number-one reason to use FuSMs in a computer game is\nthat it is an easy way to implement fuzzy logic, which can broaden the depth of rep-\n3.12 A Generic Fuzzy State Machine in C++ \nAnother effect of adding FuSMs to computer games is to increase the replayabil-\nHow To Use FuSMs in a Game\nOne example of where a FuSM has been used in computer games is for the health\ncompletely healthy to partially healthy to almost dead to totally dead (fuzzy states).\nAnother example of using a FuSM in a computer game can be found in the control\ntoward the player or other NPCs. Applying fuzzy logic to states in a computer game is relatively straightforward, as\nNow let's consider putting fuzzy logic into a generic C++ class, a FuSM.\nThe FSMclass class object encapsulated the actual finite state machine\nprocess, maintained the current state of the FSM, supported the container for the var-\nious FSMstate class objects, and provided control for the state transition process.\nThe FSMstate class object encapsulated a specific state and maintained the arrays\nthe new output state.\nThe new output state was returned to the FSM user process by FSMclass::State -\nTransition () and was also made the new current state of the FSMclass object.\nthe generic FSM provided a crisp and discrete state transition in response to an input.\nfirst is to add support to the FSMclass class object for multiple current states.\nchange is to modify the FSMstate class to support degrees of being in a state.\nneed to modify the state transition process within both class objects to support a tran-\nThe reader is invited to review the Fuzzy/Finite State Machine project found on\nFSMclass, is now capable of supporting multiple current states (the new FuSMclass\nA pointer to any active fuzzy state (based on the current input\nAs in FSMclass before, FuSMclass also maintains an STL map object (the Fuzzy -\nState_Map m_map member) for containing pointers to all possible FuSMstate objects\nactive current states can be accessed by processes outside of FuSMclass.\nprogram can determine all the active fuzzy states.\nadaptation also maintains two additional attributes of the FuSMstate object: the value\nof membership in the set for this FuSMstate object (int m_iValueOf Membership), and\nNotice that the biggest difference between the finite state object (FSMstate) and\nour new fuzzy state object (FuSMstate) is that a state transition array is no longer\n3.12 A Generic Fuzzy State Machine in C++ \nThis is because in fuzzy logic, it is possible to be in one or more states at the\nsame time; while in finite logic, it is possible only to be in one state at a time.\nmultiple current states and to support various degrees of membership within a given\nstate.\nFor FuSMclass, this means modifying StateTransition() to process the Fuzzy-\nState_Map m_map member containing all possible states, giving each FuSMstate object\nindicating that the FuSMstate object is an active current state.\nFor the FuSMstate class object, the adaptation process involves replacing FSM-\nstate: :GetOutput () (from the FSM) with a new transition function.\nstate: :DoTransition() member function accepts the input value maintained by\nFuSMclass and considers the degree of membership this input value represents.\nmembership within the fuzzy state exists, the member function returns a TRUE and\nNow Fuzzy Up Your Games!\ning your games more fuzzy!\n[DybsandOO] Dybsand, Eric, \"A Generic Finite State Machine in C++,\" Game Pro-\n[McCuskeyOO] McCuskey, Mason, \"Fuzzy Logic for Video Games,\" Game Program-\nOne of the biggest problems in using fuzzy logic is that the number of \"if-\nthen\" statements grows exponentially as you increase the number of fuzzy sets you\nexplosion can make the use of fuzzy logic impractical.\nFor an introduction to fuzzy logic see \"Fuzzy Logic for Video Games\" by Mason\nprovide some definitions, as there is little agreement on fuzzy logic terminology.\nA fuzzy variable is a concept such as \"temperature,\" \"distance,\" or\n• Set. In traditional logic, sets are \"crisp\"; either you belong 100 percent to a set or\nFuzzy logic allows\nsets to be \"fuzzy\" so anyone over six feet tall may have 100-percent membership\n\"Combs Method.\" This results in a system with 10 variables and 5 sets per variable\ncreating rules that fit in with the Combs Method.\nThe health variables have three sets: Near death, Good, and Excellent.\nThe distance variable has three sets: Close, Medium, and Far. Finally, our output (aggressiveness) has three sets: Run away, Fight defensively,\nTraditional Fuzzy Logic Rules\nIf we were using a traditional fuzzy logic system, we'd start creating rules in a spread-\nTable 3.13.2 Some Traditional Fuzzy Logic Rules\nIn a game, we may need to take into account more variables such as the relative\nFortunately, the Combs Method only needs 15 rules to deal with the same five\nCombs Method of Fuzzy Logic Rules\nBuilding rules in the traditional system, we look at how the combination of input sets\nTo build rules using the Combs Method, we look at each indi-\nvidual set's relationship to the output and build the rules one variable at a time (Table\nnumber of sets as the output variable.\nfuzzy logic editor,\nwhich allows you to visually create a fuzzy logic system, integrate it into your game,\nUsing the same input values, the Combs Method rules are listed in Table 3.13.5.\nThe Combs Method is ORing the values together, which is the same as\nTraditional fuzzy logic ANDs values\nis no rule saying we can't) we would get the exact same result as the traditional fuzzy\nlogic method.\nThis is a result of the rules we selected for the Combs Method.\nthere is not an algorithm to convert traditional fuzzy logic rules to the Combs\nTable 3.13.5 Combs Method system output.\nFIGURE 3.13.5 Combs Method system output.\nMethod is based on the fact that the logical proposition (p and q) then r is equivalent",
      "keywords": [
        "Fuzzy Logic",
        "Fuzzy",
        "Generic Fuzzy State",
        "Fuzzy State Machine",
        "Combs Method",
        "Traditional Fuzzy Logic",
        "Fuzzy Logic Rules",
        "Fuzzy State",
        "State",
        "Combs Method system",
        "logic",
        "fuzzy logic system",
        "Game",
        "State Machine",
        "Finite State Machine"
      ],
      "concepts": [
        "flocking",
        "fuzzy",
        "fuzziness",
        "state",
        "logic",
        "logical",
        "object",
        "game",
        "gaming",
        "figures"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 25,
          "title": "",
          "score": 0.478,
          "base_score": 0.328,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 27,
          "title": "",
          "score": 0.45,
          "base_score": 0.3,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 29,
          "title": "",
          "score": 0.421,
          "base_score": 0.271,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 31,
          "title": "",
          "score": 0.408,
          "base_score": 0.258,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 7,
          "title": "",
          "score": 0.373,
          "base_score": 0.373,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "fuzzy",
          "fuzzy logic",
          "logic",
          "state",
          "boids"
        ],
        "semantic": [],
        "merged": [
          "fuzzy",
          "fuzzy logic",
          "logic",
          "state",
          "boids"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.16332673080524507,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285634+00:00"
      }
    },
    {
      "chapter_number": 34,
      "title": "Segment 34 (pages 338-346)",
      "start_page": 338,
      "end_page": 346,
      "summary": "Using a Neural Network in a\none of the most useful and widely applied neural networks, the multiplayer percep-\nTo provide a concrete illustration of the application of the MLP for this gem, it was\nhow an MLP can be taught, by example, to solve this problem.\nThe MLP is a type of neural network that became popular in the mid-1980s as a\napplied neural network architectures in industry, and has even been used in a number\nA neural network such as an MLP is really just a complex nonlinear function with\nprocess of teaching the network (or training it, as it is more commonly called) is sim-\nples and thus neural network training consists of nothing more than curve fitting-—\nadjusting the parameters in the network so that it fits roughly tJirough the samples.\nSince neural networks often represent quite complex equations, they are fre-\nformula for the output j/ of an MLP with one linear output, N inputs, Xj to x//, and M\nAlthough the MLP\n3.14 Using a Neural Network in a Game: A Concrete Example \nThe adjustable parameters of the network are the w's (weights) and b's (biases),\nneural networks is given in [LaMotheOO] and [Haykin94] and will not be repeated\ndie inclination of die AI tank's barrel that is required to hit die player's tank.\nand b's in Equation 3.14.1 are adjustable parameters that we can use to fit the MLP to\nSo, in order to train the MLP, we need a set of samples that consists of input-\noutput pairings that are examples of how the AI tank's barrel should be set to hit the\nClearly, from the problem we're trying to solve, we want the network's\noutput to be the inclination of die AI tank's barrel, but what should die inputs be?\nBefore the input-output samples that are required to train the network can be col-\nlected, it is necessary to decide what inputs the MLP is going to need.\ninputs must contain the information necessary for die MLP to calculate the correct\noutput; in diis case, die inclination of the tank's barrel that is required to hit the\nIn this case, much time can be spent training many different networks with different\nthink the network output should depend on a particular function of variables,\nadd that function into the set of network inputs.\n• Use variables that provide as different information about the game world as pos-\nrepeatedly adds single inputs to the network, at each stage adding the one that\nresult in a network that performs poorly and in unpredictable ways.\nit is possible to collect the samples that will be used during training.\nthe selected input variables (relative positions of the tanks and wind speed) and the\ninclination of the AI tank's barrel every time the player controlling the AI tank scores\ndone by setting the AI tank's barrel to random inclinations until, by chance, it scored\n3.14 Using a Neural Network in a Game: A Concrete Example \nwith as few as 107 training samples for a network with 7 inputs.\nOne important hazard in developing neural network solutions is that the last-\nchanges the behavior of the game world, cause the neural network to perform poorly.\nThis can be overcome by repeating the data collection and training processes to pro-\nduce a new set of parameters for the network.\nior of the game weren't too drastic, the difficult problem of input selection will not\ncontrol and the inputs it needs, and we've collected some training data to show it\nTraining the MLP\nerror with which the MLP reproduces each output sample given their associated\nMLP to the training samples, this article uses a rarely applied technique called the\n• Making it easy to experiment with a wide range of network structures, nonlinear-\n• Permitting the inclusion of discontinuous functions in the network.\nSince all of the techniques that can be used to train an MLP will indefinitely\nevaluated in the game, and training should stop either when the measured perfor-\nWhen evaluating the performance of the MLP in the game, great care must be\nhow the MLP will perform in the final product.\nIf the MLP's performance in the\n• The input samples contain insufficient information about their associated out-\nRepeat the input selection process to\n• The network is too simple to learn the relationship between the inputs and out-\nplify the relationship, or increase the number of hidden neurons in the network\n• The samples are not representative of the environment that the network encoun-\nThe behavior of the game world must not change after the training\nnetwork will encounter in-game in the right proportions.\nimportant to consider the computational cost associated with neural networks.\nUnfortunately, training an MLP is processor intensive, making the MLP poorly\nIn contrast, computing the output of a trained MLP\n3.14 Using a Neural Network in a Game: A Concrete Example \n1207 examples of successful shots, and the MLP was trained for around two-and-a-\nstopped because the MLP's performance was as good as was required, achieving a 98-\nThis gem described the steps taken to produce the neural network AI that is used in\nthe simple tank game that is included on the CD.\nS., \"Neural Network FAQ\" available online at www.ci.tuwien",
      "keywords": [
        "Neural Network",
        "MLP",
        "Imploding Combinatorial Explosion",
        "Network",
        "game",
        "Neural",
        "tank",
        "inputs",
        "tank barrel",
        "neural network training",
        "training",
        "samples",
        "MLP performance",
        "simple tank game",
        "Input Selection"
      ],
      "concepts": [
        "games",
        "input",
        "network",
        "tank",
        "training",
        "output",
        "die",
        "samples",
        "information",
        "gems"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 25,
          "title": "",
          "score": 0.524,
          "base_score": 0.374,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 31,
          "title": "",
          "score": 0.465,
          "base_score": 0.315,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 29,
          "title": "",
          "score": 0.45,
          "base_score": 0.3,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 27,
          "title": "",
          "score": 0.377,
          "base_score": 0.227,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 56,
          "title": "",
          "score": 0.339,
          "base_score": 0.339,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "network",
          "mlp",
          "neural",
          "training",
          "neural network"
        ],
        "semantic": [],
        "merged": [
          "network",
          "mlp",
          "neural",
          "training",
          "neural network"
        ]
      },
      "topic_id": 3,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15156350895592732,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285678+00:00"
      }
    },
    {
      "chapter_number": 35,
      "title": "Segment 35 (pages 347-359)",
      "start_page": 347,
      "end_page": 359,
      "summary": "methods discussed here use the same basic collapse/split algorithm, but implement it\nAn algorithm that uses more triangles than\nalgorithms for static (i.e., non-VIPM) meshes using modern vertex caches of around\nSingle operations are done that collapse a single vertex onto\nanother vertex along one of its triangle edges.\nnumber of triangles in it.\nare not binned but use the binned vertex are \"changed\" triangles, and changed so\nedge split, the previously binned vertex and triangles are \"new,\" although they are\ncollapses from a high-triangle mesh to a low-triangle mesh.\nbuses, graphics cards (\"the card\"), system/video/AGP memory, index, and vertex\nIt has a global list of static vertices, arranged in order from last binned to first\nEach time a collapse is done, the vertex being binned by the collapse is the\nThe triangles are also ordered from last binned to first binned.\nTriangles that are not binned but are changed during a collapse simply have the\nindex to the binned vertex changed to that of the kept vertex.\nSince the index list\nchanges as the level of detail changes, the triangle index buffer is stored as per-instance\nThe index buffer is comprised of indexed triangle lists (each triangle defined by\nthree separate indices), rather than indexed triangle strips.\nthat when performing collapses or splits, all the collapse data is in sequential memory\nTo perform a collapse, the number of vertices used is decremented since the\nbNumTris; again, the binned triangles are always the ones on the end of the list.\nThe changed triangles all need to be redirected to use the kept vertex instead of\nVanillaCollapseRecord *pVCRCur = the current collapse;\nIndex list\nIndex list\nFIGURE 4.1.1 An edge collapse with before and after index lists and the VanillaCollapseRecord.\nVanillaCollapseRecord *pVCRCur = the current collapse;\nmation and index buffer data is completely linear in memory and ordered by collapse,\nBecause triangle order is strictly determined by collapse order, there is no\nway to reorder triangles for better vertex caching.\nFinally, vanilla VIPM only works with indexed triangle lists, which can be a poor\nand a skip list is one of those data structures.\nVIPM method was the bit that noted that to bin a triangle, it does not have to fall off\nthe end of the index list, as in vanilla.\n(usually the kept vertex), and leaving it in the list of drawn triangles.\nThis means that the order of triangles is no longer determined by collapse order;\nskip strips paper pointed out is that triangles can now be ordered into strip order, and\nThe ability to reorder triangles increases vertex cache coherency.\nnumber of drawn triangles does not change with collapses and splits.\nAfter many collapses, there\nare many degenerate triangles in the list.\nAfter many collapses, the vertex cache efficiency also drops.\nA collapse that bins that vertex must change all the\naway the degenerate triangles, and start making a completely new skip strip from\nContinue collapses with this new skip strip until it too becomes inefficient,\nWhen creating each new skip strip level, all of the degenerate triangles are thrown\nThe triangles are also reordered to make lists that are again vertex-\nNew collapses don't need to change lots of degenerate triangle indices\neach time, each instance only needs to copy the skip strip level that it actually uses,\nThe different index lists can be stored globally since when switching to a new list,\na new copy is taken and then refined with collapses to exactly the number of triangles\nall-or-nothing thing, and the lower-resolution index lists are actually very small.\nFor a bit more efficiency, two versions of the index lists can be stored in global\nspace: fully collapsed (before switching to a lower-resolution list, that is) and fully\nbetween two index lists is still fairly efficient.\neach time the level of detail increases, the higher-resolution index list must be copied,\nand then all of its collapses need to be performed to draw the next frame.\ncollapsed versions stored as well means that a change in the level of detail of n col-\nThe actual collapse/split code and structures are the same as for standard skip\nstrips, except that there is a global array of structures holding the premade index lists,\nthe collapse lists for each one, and the number of collapses in each.\ncollapses or splits, the code checks to see if it needs to change levels, and if so, copies\nthe new level's index list and starts doing collapses/splits until it reaches the right level\nSkip strips also have an equivalent using triangle lists instead of triangle strips.\nrequire lists rather than strips, and some vertex cache routines can obtain slightly\nlist needs to be copied for each instance of the object.\nof this index list could be moved to global (i.e., static and shared between instances)\nOn a multilevel skip strip, many of the triangles are not affected, even when that\nlevel is fully collapsed.\nTherefore, there is no need to copy those triangles per instance;\nlists are used—the indexed strip case will be discussed later as a variant.\nthe triangles are split into four lists:\n• The triangles that are not affected by any collapses.\n• The triangles that are binned by collapses, but not modified by any before they\n• The triangles that are modified by collapses, but not binned.\n• The triangles that are first modified by one or more collapses and then binned.\nLists 2 and 4 are each sorted by bin order, just as for vanilla VIPM.\nlist is copied into instances when they use that level.\nthe only modification being that the number of triangles drawn will change as static\ntriangles are collapsed.\nThe other change is that there are two triangle counts, one for each list, and a collapse\nindex buffer that is tuned for vertex cache coherency (list 1).\nit could be, since the triangles in this list only make up part of the object.\nbe \"holes\" in the mesh where triangles have been moved to the other three lists, and\nthis decreases both the maximum and the actual vertex per-triangle numbers that are\nior (list 3), although collapses can interfere with this efficiency, and the mesh for list 3\nthe lists are ordered by collapse order, the granularity is even finer at the triangle level,\nAs with skip strips, using strips means that ordering by collapse\norder is too inefficient, and diis means that list 2 triangles now have to be binned by\nThe triangles from these three lists are merged and treated as a\nskip strips —reordered for optimal vertex cache efficiency, copied for each instance,\nfor each instance, and because the triangles are ordered by strip order and not collapse\norder, triangles cannot be binned entirely by simply dropping them off the end of the\nindex list.\nmodified triangles to actually be at the same physical position in the index buffer\nbefore and after the collapse.\nthe end of the index buffer along with the binned triangles, and the new versions\nTherefore, instead of an example collapse binning two triangles and editing three\nothers, it actually bins five triangles and adds three new ones.\nby collapses, in any (vertex cache-optimal) order.\nAt the end are triangles binned or\nNote that a triangle modified as the result of a collapse cannot then be involved\n(either binned or changed) in another collapse.\nwould mean that triangle would have to fall off the end of the index buffer.\nOnce a triangle has been modified by a collapse, the only way it can be involved\nin another collapse is if a new index buffer is started that has all the same triangles as\nIndex List \nFIGURE 4.1.2 A collapse showing the index list and the two windows.\nordering for collapses.\nto do a new collapse that involves a triangle that has already been modified by a pre-\nThis forces a new level to be made, and the index buffer needs to be\nIf only a few collapses are done before having to make a copy, the memory\nHowever, there is actually no need to strictly follow the order of collapses that\ncollapse that involves triangles that have already been modified.\nDoing this collapse\nthis collapse is ignored, and the best one that can be done without creating a new level\nthat much, and the collapse that will not force a new level is done.\nSince no runtime modification is made to the index or vertex lists, all the data can\nup is made to decide the index list to use, the start and end index to draw from that\nindex list, and how many vertices are used.\n// Number of triangles\nthe triangles at the beginning and end of each level's index lists.\nit makes strips hard to use—only triangle lists really handle fixed ordering well—and\nall of the triangles that use the binned vertex are removed, so they all go on the end of\nthe triangle list.\nneed to go together at the beginning of the index list, there are typically three to five of\nVertex cache coherency can be raised by having a larger middle index list section\nHardware that requires strips rather than lists can still use this method, although\none index per triangle, compared to a list's three.\nstrips are optimal) or triangle throughput (in which case, lists are optimal).",
      "keywords": [
        "triangles",
        "index list",
        "VIPM",
        "collapse",
        "list",
        "index",
        "Vertex",
        "VIPM Methods",
        "vertex cache",
        "Vanilla VIPM",
        "binned vertex",
        "binned",
        "strips",
        "index buffer",
        "level"
      ],
      "concepts": [
        "collapse",
        "collapsed",
        "triangles",
        "list",
        "index",
        "vertex",
        "strips",
        "level",
        "methods",
        "cache"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 38,
          "title": "",
          "score": 0.612,
          "base_score": 0.462,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 37,
          "title": "",
          "score": 0.534,
          "base_score": 0.384,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 36,
          "title": "",
          "score": 0.474,
          "base_score": 0.474,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 40,
          "title": "",
          "score": 0.417,
          "base_score": 0.417,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 32,
          "title": "",
          "score": 0.4,
          "base_score": 0.4,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "triangles",
          "collapse",
          "index",
          "binned",
          "collapses"
        ],
        "semantic": [],
        "merged": [
          "triangles",
          "collapse",
          "index",
          "binned",
          "collapses"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2676520964363759,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285730+00:00"
      }
    },
    {
      "chapter_number": 36,
      "title": "Segment 36 (pages 360-367)",
      "start_page": 360,
      "end_page": 367,
      "summary": "Interlocking Tiles\ncreate a simple terrain with the benefits of dynamically adapting detail levels and ani-\nThese small tiles were\ncreated out of little 32x32 pixel tiles.\nthe terrain into smaller, reusable tiles.\nthe tiles.\nThe terrain tiles are represented as index buffers that link together the ver-\nEach grid square represents a single tile in the terrain system.\nmay not appear as if the terrain tiles ever repeat, given that terrain is a pretty random\nConsider each terrain tile in the form of a vertex and index buffer.\nWhile each tile\nmay contain a unique set of vertex data, the index buffers used to draw the tiles can be\ncreate a finite set of index buffer \"tiles\" to use throughout the entire terrain.\ntile.\neach tile in an identical order so our index buffers can be used on any tile.\nat the sample tile shown in Figure 4.2.1.\nHere we have a 17x17 vertex tile showing\nUsing the proper index buffer, a given tile can be ren-\n4.2 Simplified Terrain Using Interlocking Tiles\nFIGURE 4.2.1 A sample terrain tile of 17x17 vertices.\nthe tile.\nSimilarly, index buffers using less vertices render tiles with reduced triangle\nFigure 4.2.2 illustrates this by showing a sample tile rendered at different\nFIGURE 4.2.2 Using index buffers to create two separate detail levels from the same set of\nIn order to create the landscape tiles, we need a set of source data from which to pull.\nCreating the tile vertices is simple.\nSince each tile vertex has a known 2D position\nFor each terrain tile, a\nvertex buffer for the tile.\nTile Templates\nThe index buffer can be thought of as a drawing template cast over the tile vertices.\nwe saw in Figure 4.2.2, the index buffer defines how we pull triangles out of the tile,\nFor an example 9x9 vertex tile, we can create a global set of index\nbuffers to draw all possible detail levels for any 9x9 set of vertices, skipping vertices in\nThe top-level index buffer uses all 81 vertices to\neach tile needs to use when being drawn.\ndetail levels for each terrain location.\nthe detail level is known, drawing is a simple matter of sending die tile's vertex buffer\nWhat we have now is a terrain that changes abruptly as tiles of different detail levels\ntwo tiles of different detail levels.\nThe key to this method is having tiles that interlock.\nThat is, creating tiles that\nboring tiles.\nTo do this, a different set of index buffers is required to merge tiles of dif-\n4.2 Simplified Terrain Using Interlocking Tiles\nFIGURE 4.2.3 The 16 basic tile bodies.\nFigure 4.2.3 shows the 16 possible body types for a tile of any given detail level.\ntiles at higher detail levels must use link pieces to fit together with lower-detail neigh-\nspaces where links are required to connect to a neighbor tile at a lower detail level.\nbody tiles.\nThese index buffers arrange triangles to step down from a tile using a\nple link tile used to connect two body tiles.\nFor the example 9x9 vertex tile, we would need three linking pieces for each side of\nlowest-detail level, the simple quad tile, needs no linking pieces, since all higher-detail\nFIGURE 4.2.4 An example link piece used to join two tiles of different detail levels.\nTable 4.2.1 All Index Buffers Required for Our Sample of Four Detail Levels\nGiven our example of a 9x9 vertex tile with four detail levels, we can calculate\ntile that contains a notched side for each neighbor that is at a lower detail level than\ndering API along with the tile's vertex buffer for drawing.\nfive index buffers per tile (one body, four linking), but in the best case, we still send\nonly one (the full body tile).\nFor larger tiles (33x33 vertices and up), this will greatly reduce rendering\nIn addition, the order of the vertices in the tile can be adjusted for better cache\ntile will be rendered with most often.\nframe of the terrain is exposed to show the various body tiles and linking tiles in use.\n4.2 Simplified Terrain Using Interlocking Tiles\nFIGURE 4.2.5 Sample output of the SimpleTerrain^rograzwz showing tiles and linking",
      "keywords": [
        "tile",
        "index buffers",
        "Terrain",
        "detail levels",
        "tile vertex buffer",
        "index",
        "detail",
        "buffers",
        "levels",
        "terrain tile",
        "Vertex",
        "Index Buffers Required",
        "vertices",
        "vertex tile",
        "Method"
      ],
      "concepts": [
        "tiles",
        "tiled",
        "terrain",
        "level",
        "rendering",
        "render",
        "method",
        "vertices",
        "vertex",
        "triangle"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 49,
          "title": "",
          "score": 0.487,
          "base_score": 0.487,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 35,
          "title": "",
          "score": 0.474,
          "base_score": 0.474,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 56,
          "title": "",
          "score": 0.431,
          "base_score": 0.431,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 11,
          "title": "",
          "score": 0.42,
          "base_score": 0.42,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 38,
          "title": "",
          "score": 0.393,
          "base_score": 0.393,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "tile",
          "tiles",
          "index",
          "index buffers",
          "terrain"
        ],
        "semantic": [],
        "merged": [
          "tile",
          "tiles",
          "index",
          "index buffers",
          "terrain"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24826691207722232,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:23.285774+00:00"
      }
    },
    {
      "chapter_number": 37,
      "title": "Segment 37 (pages 368-376)",
      "start_page": 368,
      "end_page": 376,
      "summary": "\\JLJfcile there are many data structures for storing static 3D objects, including\nalmost no CPU time updating an object in motion within the tree structure.\nwhen objects are inserted and removed from the tree with great frequency.\nbounding sphere does not necessarily fit very tightly around an object, especially if it\nsphere is presumed to encompass all child objects that are attached to the parent.\n4.3 Sphere Trees for Fast Visibility Culling, Ray Tracing, and Range Searching \nUsing Sphere Trees\nEvery object in the simulation, whether it is in motion or not, uses the class\nsphere, then that child is removed from the parent and inserted into the root node of\nthe tree.\nWhen a child node is detached from its parent, it is placed into the\nnode to be contained in multiple nodes of the tree.\nThis makes the sphere tree an ideal data structure for these kinds of queries.\nWhen performing visibility culling with a sphere tree, each node keeps track of the\nWhen an object in the\n4.3 Sphere Trees for Fast Visibility Culling, Ray Tracing, and Range Searching \nleaf node SpherePack inherits the properties of a Sphere class.\nBounding Box Trees\nhe axis-aligned bounding box (AABB) tree structure has proven to be very useful\n11 bytes per triangle.\nThis section covers quadtrees, k-d trees, BSP trees, bounding volume trees, and\naxis-aligned bounding boxes, data structures for sorting three-dimensional sets of\nwhich removes any upper bound on the size of the node structure.\nsame vertex, the octree recursion may never achieve one triangle per node and will\nBSP trees that adaptively use the planes of individual triangles for separation do not\n4.4 Compressed Axis-Aligned Bounding Box Trees\nBounding Volume Trees\nBounding volume trees approach the problem differently.\nbounding volume trees recursively divide a set of triangles into two subsets and find\nangles or include them in multiple nodes, and building a tree simply stops when a\nAABB Trees\nlow tree for a set of two connected triangles, L and R.\nAABB tree structure for this particular geometry.\nBuilding AABB Trees\nAn AABB tree is built to by successively dividing a set of triangles into two subsets\nAABB tree is:\nCompressing AABB Trees\ning box extents, requiring 6 X 4 = 24 bytes at each node.\nbefore building the tree.\nindices of the child nodes with 4-byte unsigned integers.\nanother 4-byte integer for a triangle index at each node, we can exploit the fact that\n215 (giving a node count of 216 - 1), unsigned 2-byte integers can be used for child\nSince most applications can divide triangle sets into chunks of 215, 56 bytes\nThere are two important properties of AABB trees that can be exploited to mini-\nFirst, child AABB nodes are fully contained by their parent.\nus to store child extent values as unsigned 8-bit integer offsets relative to their parent's\n4.4 Compressed Axis-Aligned Bounding Box Trees\nSecond, at most, six extent values of the child nodes are not identical to those\nof the parent node.\nIn order to use unsigned bytes as relative extent values for nodes, we must keep track\nof the floating-point extent values of the parent as the tree is built.\nextents relative to the parent AABB and then truncating to an integer value, we get a\nTo put this in perspective, if the extents of the parent node are one meter on\nmemory consumption down to 10 bytes per node, or 20 bytes per triangle.\nstore both the left and the right child information within one node structure.\nleft node/triangle\nright node/triangle\nFIGURE 4.4.4 The compressed AABB node structure consumes only 11 bytes per node.\nIn addition, only n nodes (including the root) are required to sort n triangles, so\nthe tree now needs only 11 bytes of storage per triangle.\nextents of the entire triangle set and is not part of the actual node array, which con-\nFIGURE 4.4.5 For a set of four triangles, the uncompressed tree requires seven nodes,",
      "keywords": [
        "tree",
        "node",
        "bounding volume trees",
        "AABB tree",
        "AABB",
        "Bounding Box Trees",
        "bounding sphere",
        "bounding",
        "Sphere",
        "Sphere Trees",
        "AABB tree structure",
        "BSP trees",
        "triangle",
        "objects",
        "parent"
      ],
      "concepts": [
        "node",
        "trees",
        "triangle",
        "extent",
        "objects",
        "bytes",
        "sphere",
        "bound",
        "culling",
        "value"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 38,
          "title": "",
          "score": 0.642,
          "base_score": 0.492,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 35,
          "title": "",
          "score": 0.534,
          "base_score": 0.384,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.388,
          "base_score": 0.388,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 23,
          "title": "",
          "score": 0.377,
          "base_score": 0.377,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 32,
          "title": "",
          "score": 0.371,
          "base_score": 0.371,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "trees",
          "node",
          "aabb",
          "tree",
          "sphere"
        ],
        "semantic": [],
        "merged": [
          "trees",
          "node",
          "aabb",
          "tree",
          "sphere"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23240381076038244,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285813+00:00"
      }
    },
    {
      "chapter_number": 38,
      "title": "Segment 38 (pages 377-385)",
      "start_page": 377,
      "end_page": 385,
      "summary": "propagating the expanded dimensions back up the tree to the root node.\nIn cases where the game data is static, quadtrees\nThis technique is a general-purpose optimization for quadtree access that\nless of what depth in the tree the target node resides in.\ntine was just a few lines of code that checked die bounding box of each child node and\ntially, most of the upper nodes toward the root node of the quadtree would eventually\nously cached quadtree node data would be flushed between calls.\nquadtree node without actually examining the quadtree nodes themselves?\neliminate most of the performance hit on the quadtree access routines.\nFirst, the quadtree has to be regular;\nFortunately, most quadtrees\nthe nodes at each level in the tree.\nThis means that either all of the quadtree node\npointers are placed in a linear array ordered by their spatial position, or if the quadtree\nway, given the x and y node coordinates on a specific level, the address of the quadtree\ndata can be obtained without having to traverse through other nodes.\nDetermining the Tree Level\nThe first step in directly finding the target quadtree node is determining at what level\nConsider that an object will reside in the root node of a quadtree if its volume\ncrosses the nodes midline for either axis.\neither it gets to the bottom level of the quadtree, or it finds a node where the object\nConsider just one axis of the area represented by the quadtree if the total length was\nnodes represented an area 1.0 by 1.0.\nThe midline of the root node would be at 128.0,\nthe midlines of the next level nodes would be at 64.0 and 192.0.\nbecause that indicates the lowest level of the quadtree in which it can be wholly con-\nour storage requirement is that the object be fully contained inside a quadtree node,\nthe quadtree level to store the object is actually one level higher than the level where\nthe node area size is the specific power of 2 that is crossed.\nFIGURE 4.5.1 A) Objects that cross the node's midlines cannot be stored in child nodes.\nObjects that don't cross the midlines are stored in child nodes.\n\"1\" bits in the result), then the range can be stored at the very lowest level in the\nquadtree.\nabove the bottom of the quadtree the range (xl} x2) can first be properly placed.\nnode and only fits at the top level.\nlevel minus position) gives us 1, or the first level (root level) in the quadtree.\noff the centerline and should fall all the way down to a leaf node (level 9).\n9-0 = 9* level in\nthe quadtree.\nleast four levels above the bottom nodes (level 9).\n9 - 6 = 3rd level in the quadtree.\nchoosing the highest level (in the quadtree) result.\npower of 2, in most situations the area represented by a quadtree is not going to be an\nthe quadtree's dimensions.\nFor the quadtree scale, 1.0 represents the size of the leaf\nnodes on each axis.\nquadtree will be in the range 0 to 2\"~1 for each axis.\ncount the bits, but a look-up table may work better for quadtrees with six or fewer\nlevels.\ndetermines the quadtree level using this method and a while loop.\nOnce the level in the quadtree has been determined, the only step remaining is to take\nthe scaled coordinates and extract the row and column positions of the target node.\nthe target node is on the bottom level, no scaling will be necessary.\nFor each level\nnumber of nodes on that level.\ngives the row and column positions to plug into the array lookup for nodes on that level\nof the quadtree.\nTraversing the Quadtree\nIf, after locating the search node, there still is a need to traverse the quadtree, all that\nis required is to save the tree level and array row and column positions.\nposition values right or left, a program can go up and down the tree levels, and by\nTuning the Quadtree\nquadtree access implementation.\nspanned position 128.0 would be placed in a root node.\nfor the quadtree.\nquadtree implementation, and analyze the results using real data, as the optimal set-\nListing 4.5.1 Simple implementation of quadtree search\n// Two C++ classes, one to represent the QuadTree and one to\nQuadNode* QuadTree: :GetNodeContaining(const rect &ObjBounds)\nListing 4.5.2 Code to determine the level of the target quadnode\nint Quadtree::GetNodeLevelContaining(const rect &ObjBounds)\nListing 4.5.3 Code to determine the level of the target quadnode\n// quadtree level\nreturn (nodes[y1«(NodeLevel-1 )+x1 ]);",
      "keywords": [
        "Quadtree",
        "Direct Access Quadtree",
        "level",
        "quadtree node",
        "node",
        "Access Quadtree Lookup",
        "Access Quadtree",
        "quadtree level",
        "quadtree node data",
        "Quadtree Lookup",
        "root node",
        "tree",
        "Tree Level",
        "target quadtree node",
        "object"
      ],
      "concepts": [
        "nodes",
        "level",
        "position",
        "positions",
        "trees",
        "data",
        "contained",
        "value",
        "bounding",
        "object"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 37,
          "title": "",
          "score": 0.642,
          "base_score": 0.492,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 35,
          "title": "",
          "score": 0.612,
          "base_score": 0.462,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "",
          "score": 0.424,
          "base_score": 0.424,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 36,
          "title": "",
          "score": 0.393,
          "base_score": 0.393,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 30,
          "title": "",
          "score": 0.381,
          "base_score": 0.381,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "quadtree",
          "node",
          "level",
          "nodes",
          "level quadtree"
        ],
        "semantic": [],
        "merged": [
          "quadtree",
          "node",
          "level",
          "nodes",
          "level quadtree"
        ]
      },
      "topic_id": 6,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24661799431152823,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285856+00:00"
      }
    },
    {
      "chapter_number": 39,
      "title": "Segment 39 (pages 386-393)",
      "start_page": 386,
      "end_page": 393,
      "summary": "Approximating Fish Tank\nwhen looking through the side of a fish tank.\ninside the tank to simulate the refraction effect.\nFish Tank Observations\nthe fish tanks by the lobby?\nshear in the left and right directions.\nto a 2D image when you're at the far left or far right of the tank.\nthe internal shape of the tank in a similar way.\nment is to concatenate a shear and scale matrix to simulate these observations.\ngem refers to fish tanks instead of shark tanks, the difference being the size of the tank\nIf you imagine a fish tank that is approximately 3 feet by 2 feet, a\nperson walking by that tank is the scale at which this gem is aimed.\nize that the person is spending most of his or her time directly in front of the tank rel-\n4.6 Approximating Fish Tank Refractions\nGiven a fish tank whose front face has dimensions width and height, the transforma-\ntion matrix that places the center of the front face of the tank at the origin in a certain\nformed into the space of the fish tank with a simple matrix multiply.\ntank.\nThe scale factor for the tank needs to be computed per frame, which can be visualized\nby bringing the far face of the tank toward the near face (the face through which the\nWhen the viewer is standing off to the side of the tank looking\nacross the face of the glass, the tank is scaled in quite a bit.\nGiven the viewer s position in tank space and the center of the glass, the angle to\nthe surface of the tank is computed while taking into account the ratio of the width\nuser clip planes are created based on the viewer's position and the edges of the tank glass.\nand height of the tank's glass.\n1. Transform the viewer's position into fish tank space.\nthe tank's glass at the origin.\n4. Divide the z-coordinate of the vector by the depth of the tank (distance\n6. Compute the dot product of this vector and the face normal of the glass in\ntank space (0, 0, -1).\nThe scale and shear factors can be placed into a single matrix:\n4.6 Approximating Fish Tank Refractions \nTo solve this problem, if the fish tank glass is rec-\nthe sheared geometry that could otherwise be seen from the outside of the tank.\ntank glass.\nSo far, this method describes how to make the geometry on the inside of the tank look\nare caused by light refracting as it passes from outside the tank through the surface of\nscrolling two caustic textures across all of the geometry in the tank using projective\nA simple way to get nice reflections on glass is to render the reflected geom-\netry of the glass into a renderable texture and then texture from that to give the illu-\nTo give the viewer the ability to see through the water at the top of the tank, we\nwater in the tank.\nObviously, this algorithm can be applied to each separate face of the fish tank.\ncombined with other real-time rendering techniques, it is possible to create a very\nRendering Print Resolution\nSince current graphics hardware cannot render the resolutions required for print, the\nbe a supported rendering resolution by the graphics hardware, setting the viewport\nRendering Print Resolution Screenshots\nfrustum planes define a projection matrix: near, far, left, right, top, and bottom.\neach subimage, new left, right, top, and bottom planes are computed that will define\na unique projection matrix for rendering that subimage.\n3. Render each subimage using its own frustum composed of the intermediate\nFirst, the frustum planes for the projection matrix are computed as six scalars.\nplanes, while the left, right, top, and bottom values are defined by the points at which\nvalues for the left, right, top, and bottom.\ninto each of the subimages, the entire scene is rendered normally.\nif (subrect == -1) \nGpgFrustum (left, right, bottom, top, Near, Far);\nGpgFrustum(left/3.0, right/3.0, top/3.0, top, Near, Far);\nGpgFrustum(left/3.0, right/3.0, bottom/3.0, top/3.0, Near, Far);\nGpgFrustum(left/3.0, right/3.0, bottom, bottom/3.0, Near, Far);\nmatrix[0] = (float)(2.0*zNear/(right-left));\n4.7 Rendering Print Resolution Screenshots \nmatrix[8] = (float) ((right+left)/(right-left)) ;\nused in the animation when each of the subimages is rendered.\nWe have presented a technique for rendering print-resolution screenshots using\nSince it is not possible to directly render the high-resolution",
      "keywords": [
        "Tank",
        "Fish Tank",
        "Approximating Fish Tank",
        "fish tank glass",
        "tank glass",
        "matrix",
        "Fish Tank Refractions",
        "glass",
        "top",
        "left",
        "bottom",
        "Fish",
        "Rendering Print Resolution",
        "float",
        "Fish Tank Observations"
      ],
      "concepts": [
        "matrix",
        "tank",
        "render",
        "rendering",
        "resolution",
        "resolutions",
        "value",
        "planes",
        "graphics",
        "effects"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "",
          "score": 0.447,
          "base_score": 0.297,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 45,
          "title": "",
          "score": 0.445,
          "base_score": 0.295,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 44,
          "title": "",
          "score": 0.434,
          "base_score": 0.284,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 49,
          "title": "",
          "score": 0.404,
          "base_score": 0.254,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 24,
          "title": "",
          "score": 0.386,
          "base_score": 0.236,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "tank",
          "fish",
          "fish tank",
          "glass",
          "left"
        ],
        "semantic": [],
        "merged": [
          "tank",
          "fish",
          "fish tank",
          "glass",
          "left"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.15896318198645756,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285897+00:00"
      }
    },
    {
      "chapter_number": 40,
      "title": "Segment 40 (pages 394-404)",
      "start_page": 394,
      "end_page": 404,
      "summary": "which we will call a decal, which coincides with an existing surface, and rendering it\nWe begin with a point P that lies on an existing surface and a unit normal direction N\nGiven the point P and the directions N and T, we have an oriented plane that is tan-\nWe will generate a triangle mesh for the decal object by clipping\nthe boundary planes, but far in front of or behind the point P.\ntive value E, since these triangles are facing away from the decal s normal direction N.\nRemaining triangles are clipped to the planes given by Equations 4.8.1 and 4.8.2 and\nWhen a triangle overlaps any of the planes and needs to be clipped, we interpo-\nThis has the effect of smoothly fading the decal texture in\n4.8 Applying Decals to Arbitrary Surfaces \nrelation to each triangle's orientation relative to the plane of the decal.\nTexture mapping coordinates are applied to the resulting triangle mesh by mea-\nsuring the distance from the planes passing through the point P and having normal\nLet Q be the position of a vertex in the decal's triangle mesh.\nEach triangle belonging to a surface that is potentially affected by the decal is treated\nas a convex polygon and is clipped to each of the six boundary planes one at a time.\nClipping a convex polygon having n vertices to a plane results in a new convex poly-\nSuppose that the vertex V, lies on the positive side of the clipping plane C, and\nFIGURE 4.8.2 Clipping a polygon against a plane.\npoint v3 lies on the plane C.\ntor of this class takes the decal center P, the normal direction N, and the tangent direc-\nclips all potentially affected surfaces to these planes and stores the resulting mesh in a\nVertex colors and texture mapping coordinates are then assigned\n4.8 Applying Decals to Arbitrary Surfaces\nFIGURE 4.8.3 A scorch mark decal applied to a curved surface.\nwith Skyboxes\nshankel@pobox.com\nRendering distant scenery in 3D can be accomplished with skyboxes.\nskyboxed scene.\nDistant scenery is rendered onto six textures,\nWhen the scene is rendered, the images projected on the walls of the skybox\nSkybox Resolution\nIdeally, one texel in die skybox object should map to one pixel on the screen.\nwhere skyboxRes is the resolution of one side of the skybox in texels, screenRes is the\n4.9 Rendering Distant Scenery with Skyboxes\nFIGURE 4.9.1 Skybox as seen from above: distant terrain is rendered on the sides of the\nSome 3D systems limit texture resolution to 256x256 texels.\nskybox textures may be stretched noticeably when rendered to the screen.\nskybox face to increase texture resolution (Figure 4.9.2).\nThe simplest technique for drawing a skybox is to render an ordinary textured cube,\nThe skybox\nTexture filtering may cause seams to appear along the edges of the skybox, where\nTexture\nat the edge of a texture.\ntexture filtering should be set to GL_CLAMP, which combines edge texels with the tex-\n4.9 Rendering Distant Scenery with Skyboxes\nCube environment mapping is an alternative to traditional skybox rendering.\nenvironment mapping combines all six sides of a skybox into a single texture.\nIn cube environment mapping, six textures are combined to form a cube, and\nthe center of the cube to a point on its surface (Figure 4.9.3).\nCube environment mapping can be used to render distant scenery, and to cast\nCube environment mapping limits skyboxes to one 2D texture per face, so subdi-\nment mapping systems support texture resolutions above 256x256.\nFIGURE 4.9.3 Texture coordinates for cube environment maps are specified as vectors\npointing to the surface of a cube centered on the origin.\nGenerating Skybox Textures\nSkyboxes provide an economical and effective way to render\ndemonstrates both 2D and cube environment map rendering.\nCube environment mapping is supported in OpenGL via the GL_ARB_texture_\nSkybox textures were generated with Terragen (Copyright © 1997—2000 Planet-",
      "keywords": [
        "texture",
        "skybox",
        "decal",
        "plane",
        "Rendering Distant Scenery",
        "Cube Environment Mapping",
        "surface",
        "cube",
        "Cube Environment",
        "Distant Scenery",
        "Applying Decals",
        "skybox textures",
        "decal triangle mesh",
        "Geometry Management",
        "clipping plane"
      ],
      "concepts": [
        "texture",
        "textured",
        "skyboxes",
        "skybox",
        "surfaces",
        "rendered",
        "render",
        "triangle",
        "clipping",
        "clip"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "",
          "score": 0.664,
          "base_score": 0.514,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 44,
          "title": "",
          "score": 0.628,
          "base_score": 0.478,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 48,
          "title": "",
          "score": 0.627,
          "base_score": 0.477,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 45,
          "title": "",
          "score": 0.613,
          "base_score": 0.463,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 49,
          "title": "",
          "score": 0.606,
          "base_score": 0.456,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "skybox",
          "cube",
          "decal",
          "cube environment",
          "environment"
        ],
        "semantic": [],
        "merged": [
          "skybox",
          "cube",
          "decal",
          "cube environment",
          "environment"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.22698182782333753,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285952+00:00"
      }
    },
    {
      "chapter_number": 41,
      "title": "Segment 41 (pages 405-415)",
      "start_page": 405,
      "end_page": 415,
      "summary": "Self-Shadowing Characters\nalex@vlachos.com, gosselin@ati.com,\nendering self-shadowing characters is an important visual cue missing from most\nself-shadowing of convex subsections of characters in real time.\ncharacter into convex subsections, the subsections are rendered into a texture with\nWhen the character is\nSegmenting Character Geometry\nThe first step in this algorithm is grouping the character geometry.\nOnce the character has been logically divided into convex subsegments, these groups\nrelatively small number of groups in a given character, this sorting is an insignificant\nThe character in Figure 4.10.2, for example, has only six\n4.10 Self-Shadowing Characters \nRendering the Character\nOnce the shadow map is created, the next step is to render the character into the\nThe first pass renders a fully lit character into the frame buffer.\nond pass renders each of the subsegments of the character with an alpha test of less\nbuffer that would be shadowing the character.\nThe final pass draws the character with its base color modulated by a small\nshows the results of this rendering over several frames of animation.\nFIGURE 4.10.2 Character rendered, with shadows from three different angles.\nWe presented a way to render animated characters with self-shadowing using a pro-\nBy segmenting the character into convex subsegments, we\nThird-Person Control and Animation\nitive ways to control a 3D character from a third-person perspective.\nThis gem will deal with the basic issues of controlling and animating a character\ncharacter around wherever he may go.\nAs the character moves from a stand to a run,\nthe camera smoothly accelerates toward the character trying to maintain a fixed dis-\nAs the character turns, the camera gently circles around trying to stay\nThe key to this control scheme is that the character will go whichever way we tell\ntroller, the character will move away from the camera.\nIf we press right, the character\nalways moving and that this camera-oriented control needs to be mapped onto the\nworld's coordinate system, where the character actually moves around.\ndirectly mapped into translations along the camera's forward vector.\nright/left controller movements get mapped into translations along the camera's right\nHowever, since the character basically moves on a flat plane, these camera vec-\nera and the character.\nFIGURE 4.11.1 Controller relationship to character with respect to the camera.\n4.11 Classic Super Mario 64 Third-Person Control and Animation \nArmed with the camera's forward and right vectors, we can now remap the input\ndirection the character should move, in world coordinates.\nOnce this final vector is normalized, it can be applied to the character so that he\nforward and right vector must be calculated, since the camera can move at any time.\nRotating the Character\nthe directions over time, the speed of the character can be determined.\nmodel for moving the character is to maintain both a direction and a speed separately.\nto orient the character using a zero vector.\nAs the input is sampled over time, the character's direction should converge on\nFor example, if the character is facing north and the player\nthe desired direction to the current direction, based on frame rate.\nnotice how the character initially rotates quickly and then slowly dampens toward the\nwhen controlling the character.\nFIGURE 4.11.3 Character rotation over time with exponential dampening.\nThis new dampening formula will now rotate the character 90 percent toward the\ndesired direction after one second, regardless of frame rate.\nWhen a character is told to move 180 degrees from the current direction, smooth\nto use a transition animation to make large changes in direction.\nTranslating the Character\nWith the character smoothly turning, we now need to actually move the character.\nThis is done by taking the character's current direction and translating him forward\nThe smooth rotation of the character basically points the hips in\nthe proper direction, and the current speed moves him forward.\nsecond) to the desired speed in order to make the control feel responsive.\n4.11 Classic Super Mario 64 Third-Person Control and Animation\nCharacters have\nFigure 4.11.4 shows the speed of a character under controller\nFIGURE 4.11.4 Character speed based on controller input with exponential dampening.\nAnimating the Character\nWhen the character's speed is zero, play the stand animation.\ncharacter's speed is above zero, play the running animation.\nspeed of the character.\nWhen moving, the character will spend most of the\n3. When the character is turning sharply at high speeds, die character should\nAnother turning enhancement is to have the character algorithmically\nrealism, since characters generally anticipate and look toward future positions.\n4. Transition animations (stand to run, walk to run) are tricky to implement.\n5- The transition from a stand to a walk or run can be virtually seamless by\nHowever, since a moving character can potentially stop at any\nstand can be dealt with by quickly interpolating die character to the stand\ntransition animations, such as a stand-to-run and a run-to-stand.\nplayer commands the character to start moving, the stand-to-run animation\nacter to stop, the character must somehow transition smoodily to the run-\nto-stop animation regardless of the current frame of the run loop.\nway to solve this is to have two different run-to-stand animations, each\nFIGURE 4.11.5 First frame for smooth transitions.\n4.11 Classic Super Mario 64 Third-Person Control and Animation\nthe run-to-stand animation.\nthe control and animation techniques.\nStand to Run\nRun to Stand",
      "keywords": [
        "character",
        "Classic Super Mario",
        "Super Mario",
        "run",
        "animation",
        "speed",
        "frame rate",
        "Character speed",
        "stand",
        "direction",
        "frame",
        "camera",
        "Mario",
        "Classic Super",
        "Character Geometry"
      ],
      "concepts": [
        "animation",
        "animated",
        "animations",
        "characters",
        "control",
        "controlling",
        "speed",
        "speeds",
        "smoothly",
        "dampens"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 48,
          "title": "",
          "score": 0.584,
          "base_score": 0.434,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "",
          "score": 0.584,
          "base_score": 0.434,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 42,
          "title": "",
          "score": 0.582,
          "base_score": 0.432,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 40,
          "title": "",
          "score": 0.546,
          "base_score": 0.396,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 47,
          "title": "",
          "score": 0.502,
          "base_score": 0.352,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "character",
          "stand",
          "run",
          "camera",
          "animation"
        ],
        "semantic": [],
        "merged": [
          "character",
          "stand",
          "run",
          "camera",
          "animation"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21650664578193216,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.285995+00:00"
      }
    },
    {
      "chapter_number": 42,
      "title": "Segment 42 (pages 416-423)",
      "start_page": 416,
      "end_page": 423,
      "summary": "Silhouette Edge Detection and\nThe basic concept of silhouette edge detection is to find\nthe important edges that depict the outline of a model.\ncartoon rendering gem describes several silhouette edge detection techniques: an\nedge-based detection method, a programmable vertex shader technique, and an\n5.1 Cartoon Rendering: Real-time Silhouette Edge Detection and Rendering\nImportant Edges\nSilhouette edge detection (SED) is the main component of the inker.\ndetection and rendering of silhouettes, there are other important edges of the model\nduction, silhouette edges are the edges that form the outline of a model, but can also\ntant to silhouette edge detection is that silhouettes are view dependent.\nthat the silhouettes have to be re-detected and rendered with each change in the\nSilhouettes from Camera View\nFIGURE 5.1.2 Shows the silhouettes detected from a camera facing the first step (left).\nhave one of the following differences: texture coordinates, materials, or normals.\nSilhouette Edge Detection Techniques\nWhy are there so many different silhouette edge techniques?\ntures that vary dramatically across hardware and APIs. Edge-based Inking\npolygons of the model to detect and render its important edges.\nthe model along with accurate silhouettes and crease edges are guaranteed with this\nOther inking techniques imply silhouette and crease edges through an esti-\nThe first step in the preprocess is to allocate and find a unique edge list for the model.\nThe three edges of each face of the model are examined individually and inserted into\nas a silhouette, crease angle, boundary, and/or an unimportant edge.\nTo detect silhouettes accurately, face normals have to be computed.\ncrease angle edges.\nFor nonprogressive meshes, the boundary edges can be processed\nRuntime consists of detecting and rendering the important edges of the model.\nrefers to the viewing vector, and Nj and N2 are the face normals of the triangles that\n5.1 Cartoon Rendering: Real-time Silhouette Edge Detection and Rendering \n• Compute V by subtracting the viewing vector position from one of the\nedge vertex positions.\n• Set boundary flag if edge has one neighboring face or two neighboring\n• Detect silhouette using (A/i • V) X (N2 • V) < 0 and set silhouette flag.\n3. Iterate over edge list and render edges whose edge flag is set.\nrate silhouette, crease, and boundary edge lists can optimize the rendering\nof the edges since each edge list can be rendered in a single API call.\nproducts between the face normal and the view vector for each of the edge's neigh-\nboring faces, highly accurate silhouettes are detected.\nVertex normals could be used as\n• Completely accurate silhouette edge detection.\n• Artists can choose threshold for crease angle edges.\n• Visibility of edges is solved via the z-buffer.\n• Must compute face normals for silhouette edge detection.\nListing 5.1.1 Edge-based silhouette edge detection\n// Detect silhouettes\nEdge *pEdge;\n// Subtract eyeposition from a vertex position on the edge\n// The edge is a silhouette edge\nSince we have shown that inking relies on the dot product of a normal with the view\nvector, we can pass the view vector and normals to the graphics hardware to find\nProgrammable Vertex Shader Inking Runtime\n4. For each vertex, create a view vector by subtracting the vertex position in\ntex normal and the view vector, N* V, shown in Listing 5.1.2.\nthe normal and view vector are in the same coordinate frame or the results\n5.1 Cartoon Rendering: Real-time Silhouette Edge Detection and Rendering \nAnother silhouette programmable vertex shading technique is a two-pass tech-\nand the model is rendering in the desired silhouette color.\nAll silhouette detection processing is placed on graphics card.\n• Does not detect crease or boundary edges without special variables.\n2. Use view space normal texture coordinates as a lookup into the cube map\n3. Use view space position texture coordinates as a lookup into the cube map\n• Requires specific thresholds for detecting crease angles, and specific alpha refer-",
      "keywords": [
        "Silhouette Edge Detection",
        "Silhouette Edge",
        "Edge Detection",
        "Edge",
        "Real-time Silhouette Edge",
        "Silhouette",
        "Cartoon Rendering",
        "vertex",
        "Rendering",
        "programmable vertex shader",
        "edge detection techniques",
        "vertex shader",
        "Detection",
        "Vector",
        "Texture"
      ],
      "concepts": [
        "edge",
        "silhouette",
        "texture",
        "rendering",
        "render",
        "facing",
        "face",
        "cartoon",
        "detection",
        "detected"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "",
          "score": 0.727,
          "base_score": 0.577,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 41,
          "title": "",
          "score": 0.582,
          "base_score": 0.432,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 40,
          "title": "",
          "score": 0.53,
          "base_score": 0.38,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 44,
          "title": "",
          "score": 0.497,
          "base_score": 0.347,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 49,
          "title": "",
          "score": 0.45,
          "base_score": 0.3,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "edge",
          "silhouette",
          "silhouette edge",
          "edge detection",
          "detection"
        ],
        "semantic": [],
        "merged": [
          "edge",
          "silhouette",
          "silhouette edge",
          "edge detection",
          "detection"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21134406417952492,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286038+00:00"
      }
    },
    {
      "chapter_number": 43,
      "title": "Segment 43 (pages 424-431)",
      "start_page": 424,
      "end_page": 431,
      "summary": "5.1 Cartoon Rendering: Real-time Silhouette Edge Detection and Rendering \nThe inking and painting techniques used to cartoon render a scene are just a couple of\n\"Cartoon Rendering and Advanced Texture Features of\nRendering Techniques of Real-Time 3D Animation.\" Non-Photorealistic Anima-\nCartoon Rendering Using\nTexture Mapping and\ntake advantage of modern real-time graphics capabilities, including texture mapping\nand programmable vertex shading.\nusing textures.\na highlight and shadow color, and use these colors to create a small texture map for\ncreation of the texture maps and texture coordinates for each material.\nties of the object along with the lighting, and calculates a texture map to be used for\nThe painter also calculates texture coordinates for the surface.\nIn the preprocess, each material is assigned a texture map that is created based\n5.2 Cartoon Rendering Using Texture Mapping and Programmable Vertex Shaders \nIn the runtime phase, this texture map is set as\nthe active texture, and the texture coordinates are generated based on the result of the\nangle between the vertex normal and the light vector.\nto-light vector needs to be computed per vertex; therefore, an expensive normalize per\nvertex is computed since the surface to light vector is different for each vertex.\ntherefore, the direction is the same and the surface-to-light vector doesn't require\nFinally, create a texture\nbetter suited to the fast path with most graphics hardware and graphics APIs. In the following process, C,- refers to the illuminated diffuse color, Cs refers to the\nthe ambient color for materials and lights, respectively.\nPreprocess Cartoon Shade:\n3. For each material, create and store a one-dimensional texture map with two\ntexture coordinate u, store C;at the u=l end of the texture and Cs at u=0.\nRuntime consists of setting up the texture pipeline with the preprocess texture, com-\nputing a dot product per vertex, and using this value to determine texture coordinates\nL refers to the light vector and n refers to the vertex normal in the\nRuntime Cartoon Shades\n1. Set up texture pipeline to make the texture computed in the preprocess\nthe active texture.\nSet the texture coordinate mode to clamp the texture\nthis step, so we set the texture combining function to replace.\nthe light direction vector, L • n.\n4. Enable texture mapping.\nListing 5.2.1 Function for computing Toon texture coordinates\n5.2 Cartoon Rendering Using Texture Mapping and Programmable Vertex Shaders \nrepresents the directional light vector.\nu=0 in the texture; when N; • L=.5, i=2, the transition point or hard boundary in the\ntexture occurs.\nFinally, when N; • L=l, n=3 and the texture coordinate \\i=\\is reached.\nThe preceding description details the typical cartoon shading style of two colors, one\nFor example, one can create a texture map with any number of colors to sim-\nGouraud shading by using several colors in the texture, which we call gradient shad-\nbrighten or darken the texture color for even more effects.\nMultitexturing allows us to apply other textures with the base\ncartoon shading texture.\ning, you can set up one texture to be the cartoon shading and the other texture to be\ninstructions on Intel CPUs. Given that we have programmable vertex shaders, how does this help us with car-\nwith the normal and light information, and perform the dot product calculation on\nFinally, we load the texture coordinates computed into the appropriate tex-\n5.2 Cartoon Rendering Using Texture Mapping and Programmable Vertex Shaders 449\n1. Set up texture pipeline to make the texture computed in the preprocess the\nactive texture.\nneed to be concerned about setting up the texture coordinate generation\nlight position to be used to compute texture coordinates.\nputing new texture coordinates, they do not need to be passed to the card.\nHowever, remember to make sure that the graphics unit expects texture\nthe light direction vector, Z,- • N.\nMake sure the normal and light vector are\nway to do this is to transform the light vector from light space to model\n5. Store the result of step 4 as the texture coordinate for the u texture coordinate.\nListing 5.2.2 DirectX 8.0 cartoon programmable vertex shader\n= light direction (in model space)\n; Lighting calculation - calculate texture coordinate\n; light vector dot vertex normal\nTwo methods have been presented for cartoon shading, as well as the core techniques\ntal approaches presented in this gem; namely, texture mapping and programmable\n[DietrichOO] Dietrich, Sim, \"Cartoon Rendering and Advanced Texture Features of",
      "keywords": [
        "Texture",
        "Programmable Vertex Shaders",
        "Vertex",
        "Cartoon Rendering",
        "texture coordinates",
        "Programmable Vertex",
        "Rendering",
        "Texture Mapping",
        "Vertex Shaders",
        "Cartoon",
        "Cartoon Shading",
        "light",
        "texture map",
        "vertex normal",
        "cartoon shading texture"
      ],
      "concepts": [
        "texture",
        "lighting",
        "rendering",
        "render",
        "vector",
        "cartoon",
        "coloring",
        "shading",
        "shade",
        "vertex"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 44,
          "title": "",
          "score": 0.813,
          "base_score": 0.663,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 49,
          "title": "",
          "score": 0.737,
          "base_score": 0.587,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 42,
          "title": "",
          "score": 0.727,
          "base_score": 0.577,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 40,
          "title": "",
          "score": 0.664,
          "base_score": 0.514,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 47,
          "title": "",
          "score": 0.629,
          "base_score": 0.479,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "texture",
          "cartoon",
          "light",
          "vertex",
          "light vector"
        ],
        "semantic": [],
        "merged": [
          "texture",
          "cartoon",
          "light",
          "vertex",
          "light vector"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2536712763547564,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286082+00:00"
      }
    },
    {
      "chapter_number": 44,
      "title": "Segment 44 (pages 432-439)",
      "start_page": 432,
      "end_page": 439,
      "summary": "5.2 Cartoon Rendering Using Texture Mapping and Programmable Vertex Shaders \n3D Textures for Dynamic Lightmapping\nThe first method of dynamic lighting we will examine is using a 3D texture for\n2D textures.\nIn traditional 2D texturing, two texture coordinates are present in each\nEach of the two texture coordinates (s, t)\ntextures expand upon 2D textures by adding a third texture coordinate (r) that refers\nof 2D textures (see Figure 5.3.1).\nThe texture coordinate r is used to select which\nFIGURE 5.3.1 A) 2D texture.\nB) 3D texture.\ntexture.\nA natural use for 3D textures is in dynamic lightmapping.\n3D texture.\nThe 3D lightmap itself can be specified in OpenGL using the EXT_texture3D\nThe 3D texture is sent to OpenGL using glTexIm-\nThe geometry in our example will be textured with a basemap (b) and will be\nmodulated with a moving light source (/) represented by the 3D lightmap texture.\n// 3D texture lightmap on stage 0\n// Basemap to be modulated by 3D texture\nGiven the light position (/) and radius (Ir), the texture coordinate at each vertex\nFirst, the texture coordinate for each vertex is\nNext, each texture\nthe texture matrix of minus the light position (— /).\nThe texture coordinate now\nThe texture matrix can be used to per-\nform this operation by scaling the texture matrix by the reciprocal of the light radius\nNote that while 3D textures are a natural method for performing dynamic per-\npixel point lights, 3D textures are not the most memory-efficient technique.\nper-pixel point lights using only 2D and ID textures.\nThe effect presented in the previous section using a 3D texture as a dynamic lightmap\nOpenGL, Dot3 bump mapping is exposed through the EXT_texture_env__dot3\nThis blend equation performs a dot product between the (r, g, b) vectors of any\n(r, g, b) values of a texture.\nThe light vector (L) in texture space can be encoded into\nThe texture map used for bump mapping will contain normals that will perturb\nAt each vertex, the light vector will be stored in the primary color component.\nFIGURE 5.3.4 Dot3 bump map texture generated from the beightfield using the Sobel\ntransformed into the space of the bump map texture on each polygon before it can\n3D light.\nIn order to rotate the light vector into the space of the texture (known as tangent\nGiven the Dot3 texture map (dotmap), the tangent space light vector (tl), the\nbasemap (b), and the 3D lightmap (/), we wish to perform the following texture\nglTexEnvi(GL_TEXTURE_ENV, GL_COMBINEJ1GB_EXT, GL_DOT3_RGB_EXT) ;\nglTexEnvi(GL_TEXTURE_ENV, GL_OPERANDO_RGB_EXT, GL_SRC_COLOR);\nglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);\nglTexEnvi(GL_TEXTURE_ENV, GL_OPERANDO_RGB_EXT, GL_SRC_COLOR);\nglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);\nglTexEnvi(GL_TEXTURE_ENV, GL_OPERANDO_RGB_EXT, GL_SRC_COLOR);\nglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR);",
      "keywords": [
        "Texture",
        "Programmable Vertex Shaders",
        "Carl Marshall",
        "Mark Harris",
        "Marc Blackstein",
        "Stylized Ren",
        "ENV",
        "EXT",
        "texture coordinate",
        "light",
        "bump map texture",
        "RGB",
        "map",
        "texture map",
        "light vector"
      ],
      "concepts": [
        "texture",
        "textured",
        "lighting",
        "vectors",
        "color",
        "dot",
        "dots",
        "mapping",
        "map",
        "maps"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "",
          "score": 0.813,
          "base_score": 0.663,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 49,
          "title": "",
          "score": 0.728,
          "base_score": 0.578,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 45,
          "title": "",
          "score": 0.713,
          "base_score": 0.563,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 40,
          "title": "",
          "score": 0.628,
          "base_score": 0.478,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 47,
          "title": "",
          "score": 0.622,
          "base_score": 0.472,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "texture",
          "3d",
          "light",
          "3d texture",
          "gltexenvi gl_texture_env"
        ],
        "semantic": [],
        "merged": [
          "texture",
          "3d",
          "light",
          "3d texture",
          "gltexenvi gl_texture_env"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.21238018471687217,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286123+00:00"
      }
    },
    {
      "chapter_number": 45,
      "title": "Segment 45 (pages 440-449)",
      "start_page": 440,
      "end_page": 449,
      "summary": "and V2 both have a length of 1, but when linearly interpolated, the resultant vector\nsame as the normalized texture coordinate used to look up into it.\ntexture coordinate that will be used to look up into the cubemap.\nFIGURE 5.3.6 The linear interpolation of two normalized vectors resulting in a vector\nthe map contains the normalized vector of the texture coordinate, the light vector will\nglTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_REPLACE);\nglTexEnvi(GL_TEXTURE_ENV, GL~SOURCEO_RGB_EXT, GL_TEXTURE);\nglTexEnvi(GL_TEXTURE_ENV, GL_OPERANDO_RGB_EXT, GL_SRC_COLOR);\nglActiveTextureARB(GL_TEXTURE1_ARB);\nglTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT,\nglTexEnvi(GL_TEXTURE_ENV, GL_SOURCEO_RGB_EXT,\nglTexEnvi(GL_TEXTURE_ENV, GL_OPERANDO_RGB_EXT, GL_SRC_COLOR);\nglTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_EXT, GL_TEXTURE);\nglTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SRC_COLOR) ;\n3D lightmap, we will use 2D texture to represent the light and project it onto each\nThe contents of the 2D texture will be a cross-section of the spotlight cone con-\nlight vector from the spotlight will be placed in the color component of the vertex.\nspotlight texture.\nThe \"look-at\" texture matrk\nThe texture coordinates for the spotlight texture will then simply be the world\nThe result of this texture look-up is modulated with the\nGenerating Procedural Clouds\nIn this gem, we'll set out to procedurally generate cloud textures that possess\nreside in graphics subsystem memory, we'll aim to generate the procedural clouds\n• Clouds are animated.\nAdditionally, the amount of cloud in the sky changes with\n• As the clouds change shape over time, small details change frequently, while\n• The level of cloud cover can also vary from a completely overcast sky to a clear\n• Clouds are lit much differently at sunrise and sunset, as the light of the sun tends\n• Clouds tend to float at a common altitude, forming a cloud layer.\nof clouds.\nRandom Number Generation\nAs with almost any procedural texture, a good place to start is with the generation of\nNoise is a term used to describe a primitive that is random in nature.\npseudo-random, allowing us to recreate the same result for a given input seed value.\nThe generation of random numbers (or pseudo-random numbers) is a subject of\nA random number generator of high quality generates a\nLuckily, for the purposes of this gem, the results of a very simple random number\ning the random number generator multiple times per pixel with different input \"seed\"\nThe pseudo-random number generator (PRNG) we'll start with is shown in List-\nGenerating Procedural Clouds Using 3D Hardware \nListing 5.4.1 A simple pseudo-random number generator\nof the function in a 512x512 texture map.\nUsing a 512x512 texture map gives us\nWe'll use this texture as a random\nnumber generator by copying part of this texture into a target texture, using a software-\ngenerated random number to offset the texture coordinates.\nnumber series texture to a quad in the target texture.\nFIGURE 5.4.1 A) The random number lookup table texture.\nnoise texture.\nFIGURE 5.4.2 A) Sampling the random number lookup table texture to create an array of\nIt's worth noting here than in some cases when using noise to create procedural\nWe'll refer to this as an octave of noise, since we will later combine multi-\nAnimating an Octave of Noise\nIf we want to animate an octave of noise, we can look at time as a third dimension\nthat we can use to index into our random number generator.\nment this using the graphics hardware is to periodically save off our noise texture,\nThe rate at which we update the texture determines the frequency in this third\near interpolation results in some artifacts, as the noise becomes more \"focused\" at the\n5.4 Generating Procedural Clouds Using 3D Hardware \nInterpolating between noise updates to animate an octave of noise.\nA commonly used technique in procedural texture generation is to use a fractal sum,\ndering techniques, such as fractal terrain, many types of procedural textures, and so\nimplement the octaves of noise as a series of texture maps whose sizes are a series of\nListing 5.4.2 Noise octave composition\nupdates, and building the composited turbulent noise texture.\nFIGURE 5.4.4 Composition of several octaves of animated noise.",
      "keywords": [
        "texture",
        "noise",
        "Clouds",
        "Random Number",
        "ENV",
        "EXT",
        "noise texture",
        "number",
        "Random",
        "light vector",
        "octave",
        "random number generator",
        "graphics hardware",
        "Generating Procedural Clouds",
        "Graphics"
      ],
      "concepts": [
        "texture",
        "clouds",
        "noise",
        "map",
        "mapping",
        "maps",
        "resultant",
        "resulting",
        "interpolated",
        "interpolation"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 44,
          "title": "",
          "score": 0.713,
          "base_score": 0.563,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 47,
          "title": "",
          "score": 0.625,
          "base_score": 0.475,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 49,
          "title": "",
          "score": 0.614,
          "base_score": 0.464,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 40,
          "title": "",
          "score": 0.613,
          "base_score": 0.463,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "",
          "score": 0.557,
          "base_score": 0.407,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "texture",
          "noise",
          "random",
          "random number",
          "clouds"
        ],
        "semantic": [],
        "merged": [
          "texture",
          "noise",
          "random",
          "random number",
          "clouds"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.17333787730478473,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286165+00:00"
      }
    },
    {
      "chapter_number": 46,
      "title": "Segment 46 (pages 450-457)",
      "start_page": 450,
      "end_page": 457,
      "summary": "5.4 Generating Procedural Clouds Using 3D Hardware \nNow that we have a texture map of animated, turbulent-looking noise, we need to do\nSubtracting a fixed value from the texture\nclamps the texture at 0 where the noise was below that fixed value, isolating some\nclouds.\nFIGURE 5.4.5 Subtracting a fixed value to get isolated clouds.\nAnother way would be to have all the layers of texture that we have talked about so\nture lookup, where one texture's color value affects the location from which a texel is\nOne example of a texture- dependent lookup is the\nencode an exponential function in a texture map and simply look up the result.\nHaving prepared the cloud texture in Figure 5.4.5, we can map it to the sky geometry.\nmapping the texture easy.\nFIGURE 5.4.6 Terrain geometry and the skyplane used for the cloud texture.\n• Noise-driven wind direction, cloud cover.\n• The clouds can cast shadows on the ground simply by using the end result texture\nYour terrain will need to have another set of texture\ncoordinates, or will have to use texture projection in order to do this.\n• Modify lighting and/or lens flare intensity.\nSince we know how the texture is\nGenerating Procedural Clouds Using 3D Hardware \nshould decrease the intensity of the directional light of your \"sun\" in the scene,\nAllowing the graphics hardware to do much of the grunt work in this technique\nually lock and modify the texture at every frame.\n• Render-to-texture support.\nHowever, support for rendering to texture surfaces is far\nCurrent hardware stores texture and render target values as\n\"monochrome,\" generating a texture in shades of gray, we are limited to 8 bits per\n• Limited hardware instruction set and capabilities.\nof the graphics hardware limits us in terms of what we are able to do.\nAs well, we make much use of render-to-texture,\n• Texture resolution.\n• Texture update rate.\nNot every texture need be updated per frame.\nFigure 5.4.7 displays the final result of the procedural cloud example program.\nFIGURE 5.4.7 Final result of procedural cloud example program.\n5.4 Generating Procedural Clouds Using 3D Hardware \ntexture generation, using clouds as an example, and how to get graphics hardware\nto do much of the per-pixel work needed in generating dynamic procedural textures.\n[Pallister99] Pallister, Kim, \"Rendering to Texture Surfaces Using DirectX 7\", avail-\nhis gem introduces a novel way in which to generate texture information from\npixels already rendered to the frame buffer.\nMany games attempt to read back pixels generated in the frame\na technique that works without CPU assistance, and does not require reading\nMany modern games add lens flare to the scene to increase realism.\nusually applied as the last item in the scene, using a 2D texture map rendered as a bill-\nThen we read back the frame buffer\nWe can do this in two ways: we can read back the color buffer and look\nfor values that match our sun color, or we can read back the Z-buffer and look for Z\ndraw our lens flare by blending it onto the final scene using an alpha value to set its\n5.5 Texture Masking for Faster Lens Flare \nThe preceding approach is generally taken when rendering lens flare in games.\ngraphics chip will drain the buffer as it draws polygons into the frame buffer.\ngood parallel system, the game can be doing useful work on the CPU, such as physics,\nAI, and so forth, while the graphics chip (GPU) is draining the staging buffers.\nFIGURE 5.5.1 Parallelism of the GPU I CPU in an ideal game engine.\ngame wants to do is to read back the contents of the scene to determine the sun vis-\nto read the completed scene from the frame buffer, we must wait for the rendering to\nproblem is to insert our physics/AI code after the scene render, but before the lens\nIn this way, the CPU will be busy while the GPU is rendering the\nIn this case, if our CPU work is more than the GPU work, then we do not have a\nfor the CPU to finish its work, when it could be doing more rendering (Figure 5.5.2).\nLock / Read Frame Buffer\nIf our CPU work is less than the GPU work, we will again stall when we try to\nread back the lens flare data.\npreparing the next frame of the game on the CPU while the last one completes on the\nReading back data from a current generation graphics card is a slow\nThe result is that for a 32-bit frame buffer, we can\nTherefore, reading an area of 256 * 256 from the graphics card will take\nFIGURE 5.5.3 Pipeline stall caused by flush before end of frame, after CPU work.",
      "keywords": [
        "scene",
        "lens flare",
        "texture",
        "CPU",
        "Clouds",
        "flare",
        "graphics",
        "Generating Procedural Clouds",
        "Draw Scene",
        "Submit Scene",
        "Hardware",
        "frame buffer",
        "CPU Preparing Scene",
        "sun",
        "lens"
      ],
      "concepts": [
        "texture",
        "scene",
        "clouds",
        "hardware",
        "value",
        "cpu",
        "result",
        "game",
        "work",
        "limitations"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 49,
          "title": "",
          "score": 0.644,
          "base_score": 0.494,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 47,
          "title": "",
          "score": 0.604,
          "base_score": 0.454,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 44,
          "title": "",
          "score": 0.597,
          "base_score": 0.447,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 40,
          "title": "",
          "score": 0.585,
          "base_score": 0.435,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 45,
          "title": "",
          "score": 0.555,
          "base_score": 0.405,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "texture",
          "lens",
          "flare",
          "scene",
          "clouds"
        ],
        "semantic": [],
        "merged": [
          "texture",
          "lens",
          "flare",
          "scene",
          "clouds"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19841783877956032,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286206+00:00"
      }
    },
    {
      "chapter_number": 47,
      "title": "Segment 47 (pages 458-468)",
      "start_page": 458,
      "end_page": 468,
      "summary": "form of a texel in a texture map, and this texel needs to contain either a luminance\nWe know that we can render to a texture map in\nGPU to one on the frame buffer, and can be used to accumulate color information.\nAdd to that the realization that objects in our scene are rendered in a color of our\nCreate a texture map of 16x16 texels.\nCreate a 1x1 texture map.\nRender the portion of the scene containing the sun into the sun map.\nWe render one of two colors to the sun map.\nIf the sun is rendered first, Z-BufFering\nsun map now contains 256 values, some of which are white, some of which are black.\nIn 32-bit color, this means that the frame buffer contains OxFFFFFFFF or\nRender 256 pixels to the 1x1 intensity map.\nSet texture coordinates so that each sun map texel is referenced\na time from the sun map, so we set texture sampling to point sampling mode.\nOne further step is that we blend each sun map texel with a constant value of\nthe modulated sun map values will either be 0x01010101 if the source sun map texel\nis white, or 0 if the source sun map texel is black.\nin the sun map because these are generally easy to achieve during rendering, and can\nmap, the more visible sun pixels there are in the sun map, and hence the scene itself.\nWe have \"masked\" out the texture results of a previous rendering and added them\nthe rendering of the sun map must be quick.\ncriticism of the technique is that the sun is typically a circular object and the sun map we\nlike from the source sun map, including a circular sampling pattern.\nto make the sun map larger in order for it to cover the required number of samples.\nIf we wish, we can only sample a selection of the sun map texels.\nsimply sample the required number of texels in the sun map, and change the modu-\nShadows\nnative shadow support, including priority buffers and shadow depth buffers.\ndepth buffer shadows, and.\npriority buffer shadows.\nShadow depth buffers [Williams78] work by using the Z-buffer or a texture that\nrepresents per-pixel depth from the light.\nShadow\ndepth buffers work like so:\nFor each Light\nClear Depth Buffer Texture to Oxff\nFor each Object in Light's Viewing Frustum\nPriority Buffers\nDepth Buffers\nRender To Texture\nshadow map\nshadow map\nPer-Object Shadow\nM = Size of shadow map\nM = Size of shadow map\nCompute Per-Pixel Depth from Light from 0x0 to Oxff\nRender Object into Texture, using Depth as the color\nFor each light\nSelect Depth Buffer as a Texture\nProject vertices to the Depth Buffer Texture\nFor each pixel of Object\n5.6 Practical Priority Buffer Shadows \nPixel is in Shadow\nPriority buffers work by first assigning each \"Object\" a unique ID from 0x0 to\nAn object is defined as something that can't shadow itself.\nwith perfect shadowing through this technique are convex objects and individual tri-\nPriority buffer shadows work like so:\nFor each Light\nSet Priority Buffer Texture as the Render Target\nClear Priority Buffer Texture to Oxff\nFor each Object in Light's Viewing Frustum\nRender Object into Texture, using ID as the color\nFor each light\nSelect Priority Buffer as a Texture\nProject vertices to the Priority Buffer Texture\nFor each pixel of Object\nPixel is in Shadow\nComparing Priority Buffers to Depth Buffers\nPriority buffers and depth buffers are very similar techniques—we could even use the\nDepth buffers have the advantage that each pixel is treated individually by having\nits own depth value measured from the light.\nOne downside of depth buffer shadows is that the depth from the light is typi-\nalpha channel to represent depth from the light as in our previous example, only 8\nscenes to support both proper inter-object shadows as well as intra-object self-\nshadowing (Figure 5.6.1).\nFIGURE 5.6.1 Depth from light.\nPriority buffers overcome this difficulty by assigning each object its own ID,\ntions of the object can't shadow each other.\nFIGURE 5.6.2 Priority buffer from light's view point.\nent object IDs shadow each other.\nbuffer and priority buffer texture are at different resolutions and different orienta-\nThis causes a point sample of the priority buffer to fall somewhere within one\n5.6 Practical Priority Buffer Shadows\npriority buffer.\nIf we have texels with object ID 100 and 200, and\nThen, perform the shadow test\nfour times, and only allow a shadow when all four samples agree that the pixel should\nbe in shadow.\nAn improvement to this technique is to \"pre-jitter\" the priority buffer.\nating the priority buffer as we did earlier, by putting the object ID in the alpha chan-\nnel of the priority buffer, we perform another render-to-texture pass into a texture the\ntaking the four texels that neighbor the original sample location in the priority buffer,\nThis way, during the shadow testing phase, a single texture fetch of the \"pre-\njittered priority buffer\" gives all four neighboring samples.\nshadow (Figure 5.6.4).\nFIGURE 5.6.5 Pre-jittered priority buffer from\nPerhaps the best use of priority buffer shadows is to use them for inter-object shadows\nthey use the same object ID, and they must be shadowed with the self-shadow test.\nOne approach that combines priority buffers for inter-object shadows and depth\nbuffers for self-shadowing is to encode the 8-bit object ID into the red channel of a\ntexture in a vertical ramp, and an 8-bit depth in the green channel in a horizontal\nThe idea here is that the 8-bit depth buffer is only used for self-shadowing\ngets around a major problem with standard depth buffer shadows: limited precision\n5.6 Practical Priority Buffer Shadows \nwhether a pixel is in shadow, thus allowing this technique to work on any hardware\nAnother hybrid approach is to use stencil shadow volumes only for self-shadowing.\nthe object's bounding box, instead of extending them to the limit of the light's range.\nthe self-shadowing test for objects outside the viewing frustum.\nYet another way to achieve self-shadowing with priority buffers is to perform ray\nPriority buffers are a great way to get inter-object shadows that bypasses the issue of",
      "keywords": [
        "priority buffer shadows",
        "Priority Buffer",
        "Priority Buffer Texture",
        "shadow depth buffers",
        "sun map",
        "buffer",
        "Depth Buffer Texture",
        "buffer shadows",
        "depth buffers",
        "shadow",
        "Texture",
        "Practical Priority Buffer",
        "Buffer Texture",
        "map",
        "depth"
      ],
      "concepts": [
        "shadows",
        "objects",
        "texture",
        "depth",
        "light",
        "sample",
        "sampling",
        "buffer",
        "priority",
        "color"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 49,
          "title": "",
          "score": 0.671,
          "base_score": 0.521,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "",
          "score": 0.629,
          "base_score": 0.479,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 45,
          "title": "",
          "score": 0.625,
          "base_score": 0.475,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 44,
          "title": "",
          "score": 0.622,
          "base_score": 0.472,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 46,
          "title": "",
          "score": 0.604,
          "base_score": 0.454,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "priority",
          "priority buffer",
          "buffer",
          "depth",
          "shadow"
        ],
        "semantic": [],
        "merged": [
          "priority",
          "priority buffer",
          "buffer",
          "depth",
          "shadow"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.23375664408276556,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286250+00:00"
      }
    },
    {
      "chapter_number": 48,
      "title": "Segment 48 (pages 469-476)",
      "start_page": 469,
      "end_page": 476,
      "summary": "fact, the academic version of impostoring started when rendering things such as\nInstead of rendering a high-triangle object every frame, the high-triangle object is\nEvery frame this texture is mapped onto a much lower-triangle object which is drawn\nThe main target for impostors is scenes with lots of small static objects in them—\nEach of these objects will use an impostor, and most will be redrawn at a\nAn impostor is a single texture, whereas rendering the object normally\nDrawing the object each frame requires that it be lit\n• Rendering the impostor texture on the screen each frame.\nthe impostor.\n• Rendering the impostor's mesh at low speeds to the texture.\nthe impostor.\nRendering the Impostor:\nan alpha-blended object into an impostor, and then rendering the impostor to the\nA pixel P is rendered to an impostor texture (which is cleared to black) to pro-\nThe render to the impostor produces the result:\nThe render to the impostor produces this result:\nto the impostor, and will influence the result when die impostor is rendered to the\nNon-alpha-blended (i.e., opaque) rendering to the impostor must ensure that\nOne problem with impostoring is that alpha-blend effects rendered into an\nFortunately, these sorts of effects are rarely used on objects\nThe most obvious way to render the impostor is to simply render a quad representing\nthe impostored object.\nThis gives a perfect result as long as the neither the object or\nQuads are no good if an impostored object is going to be\nclose to other objects.\nThey may be quite good for flying objects that don't usually get\nInstead of a quad, the object-space\nbounding box of the object is drawn, with the impostor texture projected on it.\nFIGURE 5.7.1 Side view and rendered view of a billboard impostor showing Z-buffer\nBecause the bounding box is a real 3D object, its Z-buffer properties can be con-\nused, but I recommend the front, because many objects fill their bounding boxes, so\nBounding Object\nThere are plenty of objects for which a bounding box is not a good enough approxi-\nUsing an impostor object that is closer to the real shape of the object, although\nerwise, the impostor image may be bigger onscreen than the impostor object being\nobject must usually be convex to prevent self-sorting problems, because the impostor\nOne of the problems with the impostor object is that it must be both convex and\nthis inevitably means that the parallax as the object rotates (or the camera moves) is\nnot going to be correct, because the impostor object is bound to be larger than the\nUsing a higher-tri impostor object can help reduce this in the case\nnot noticeably improve matters—the impostor object must remain convex, and no\non the real object (and thus the impostor texture image) each impostor objects vertex\nviewer through the impostor object vertex to the original object.\nbecause of the low density of vertices in the impostor object, producing large warps\nobject out to these vertices.\nThis factor is only done once for each impostor object\nvertex, and hand-tweaking around 8 to 10 vertices per object does not take long.\nobjects, find the nearest real-object vertex to each bounding object vertex.\nis mapped to the impostor object.\nOn each frame, for each impostor, the decision needs to be made whether to update it\nthis sum is over a global factor (which may be static, object-specific in some way, or\ndynamic to try to maintain a certain frame rate), the impostor is updated.\nAnimation changes the appearance of the object, and at some point the error is going\nimpostor was rendered with, and the animation frame that would have been used if\nthe object were not impostored.\nthe expense of rendering an object, and it is a good idea to try to avoid a complete ani-\nimpostoring for anything but slight animations on distant objects.\nIf the lighting changes significantly on the object, it will need to be updated.\nimpostor update.\nThis will change when the object rotates, and also when the\nAs well as the direction from the object to the camera, the distance between the two is\nAlthough it does not change the actual appearance of the object, as\nthe camera moves directly toward the object, the impostor texture gradually enlarges.\nbilinear filtering, and not a real polygonal object, and so needs updating.\nA common one for FPS games is that objects near the center of the view are usually\nthese objects can be \"more wrong\" before the player notices the error.\nupdates to the impostor textures, rather than doing them as they are needed.\nWhen updating an impostor, the current state of the object is rendered to the texture.\nIf an object is currently being updated every sixth frame, when updating the impos-\nhard to predict, and it is probably a waste of time trying to impostor players.\nPrediction of moving objects can also\nHowever, both camera movement and object movement can\nchange abruptly, and when they do, the best thing is to flag the impostor for an update\nImpostoring is useful when trying to draw scenes with lots of fairly static objects in",
      "keywords": [
        "impostor object",
        "object",
        "impostor",
        "impostor object vertex",
        "impostor texture",
        "texture",
        "rendering",
        "Adding Clutter",
        "frame",
        "camera",
        "object vertex",
        "alpha",
        "bounding",
        "Mucky Foot Productions",
        "vertex"
      ],
      "concepts": [
        "object",
        "impostors",
        "rendering",
        "render",
        "texture",
        "triangle",
        "change",
        "changed",
        "pixel",
        "alpha"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 40,
          "title": "",
          "score": 0.627,
          "base_score": 0.477,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 49,
          "title": "",
          "score": 0.627,
          "base_score": 0.477,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "",
          "score": 0.62,
          "base_score": 0.47,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 41,
          "title": "",
          "score": 0.584,
          "base_score": 0.434,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 47,
          "title": "",
          "score": 0.524,
          "base_score": 0.374,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "impostor",
          "object",
          "impostor object",
          "objects",
          "impostor texture"
        ],
        "semantic": [],
        "merged": [
          "impostor",
          "object",
          "impostor object",
          "objects",
          "impostor texture"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19405727644269702,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286293+00:00"
      }
    },
    {
      "chapter_number": 49,
      "title": "Segment 49 (pages 477-489)",
      "start_page": 477,
      "end_page": 489,
      "summary": "Texture Animation\nmost advanced chips sample four textures per pass and offer powerful texture\nAmong these are dependent texture reads,\nwhere the color value sampled from one texture is used to perturb the coordinates of\nder to a color buffer and use that buffer as a source texture in later rendering make it\npossible to generate interesting textures and texture animations entirely on the graph-\ndural texture effects run very fast and are practical for real-time 3D-accelerated scenes.\nTechniques for procedural texture generation have been with us from the early\nProcedural texture\nThe first is four-sample texture sampling from adjacent texels of an\nimage, and the second is 2D dependent green-blue texture addressing.\ntexture coordinates.\ncoordinates for neighbor texel sampling in each of the four texture stages that feed the\nalso further manipulate the samples with the dependent texture addressing opera-\nMany procedural texture algorithms rely on sampling a texel's neighbors and filtering\nbor sampling for all the texels of a source texture by rendering it into a color buffer of\ntexture is selected into all texturing units, and a vertex program generates four sets of\nindependent texture coordinates, each offset by the distance to one of the texels\nBy rendering a single quad with texture coordinates from 0.0 to 1.0, which\nexactly covers the render target, and setting each texture coordinate offset to zero,\neach texel of the destination would sample from its single source texel four times.\nwould end up with an exact copy of the source texture.\nBy offsetting each texture\ncoordinate by a vector to a neighboring texel, each pixel of the destination samples\ndraws upon four texels, so we could potentially sample 16 neighbors per pass.\nweighting of texels within each 2x2 bilinear sample is determined by the precise tex-\ntexels nearest neighbors by placing four bilinear samples exactly between pairs of\nlocations from the source texture used to render it.\n5.8 Operations for Hardware-Accelerated Procedural Texture Animation\nFIGURE 5.8.1 Texel sampling for the code of Listing 5.8.1, showing the sample pattern\nThe vertex program's texture\ncircle marks where a sample of texture coordinate offiet (0.0, 0.0) would fall, illustrating\nCode and vertex program for sampling each texel's\nRenderFullCoverageQuadO renders a single quad with input texture coordinates\nare offset four ways into the four output oT[0-3] texture coordinates so that as each\npixel is rendered, it draws upon neighboring texels for its result.\nfloat s1 = 1.0f / texture_resolution_x; // one texel width\nfloat t1 = 1.0f / texture_resolution_y; // one texel height\n; v1 = vertex texture coordinate\n; Write S,T,R,Q coordinates to all four texture stages, offsetting\nbuffer with the same resolution as the source texture, a texture coordinate offset of\nexactly where texture samples are placed for procedural texture algorithms to work as\nThe four resulting texture samples can be combined in the programmable pixel\nBy using the resulting image as a new source texture and\nOperations for Hardware-Accelerated Procedural Texture Animation\nTexture 1\nTexture 2\n\"embers\" at the bottom are rendered to the texture each frame before blurring and scrolling upward.\nbright source pixels or \"embers\" in the bottom of the texture for each frame, the result\nUsing just two 128x128 32-bit textures,\nBecause we cannot simultaneously render to a texture and use it as\na source, we must use two textures and ping-pong back and forth between them.\nheight-field-based water in successive render-to-texture operations.\nuse textures to represent the water height, velocity, and force.\ntices on the CPU, we sample neighboring texels on the graphics processor.\nTwo textures represent the height of the water as\ngrayscale color values (height maps), with one texture for the heights at the current\nanimation using this technique, and despite the use of six 256x256 32-bit textures\nSix textures are used in generating subsequent time steps, although only\nthe output height texture is shown here.\n5.8 Operations for Hardware-Accelerated Procedural Texture Animation\nFIGURE 5.8.5 Six state textures used for height-based water animation.\nFigure 5.8.5 shows the progression of textures used in generat-\nwith neighbor offsets slightly greater than one texel width or height.\nnearest-neighbor sampling to create an RGB normal map from the grayscale map.\nThe normal map can be created in a single render-to-texture pass on the\nTwo passes and a dependent texture read opera-\nUse texel offsets A from Listing 1.\ngrayscale height texture.\nselected into all four texture stages, and offsets A from\nalong that axis (value of 127 stored in the texture).\n// (blue = up out of texture)\nget colors from all 4 texture stages\n// Select source grayscale texture into all 4 texture stages\n// Sample all 4 texture stages\n5.8 Operations for Hardware-Accelerated Procedural Texture Animation \nDependent Texture Addressing\nThere are other more sophisticated and powerful texture operations at\nDependent texture address operations enable us to fetch texture samples\nproducts of iterated texture coordinates and texture colors.\none of the more simple dependent texture operations: the dependent green-blue\nrendered, the hardware fetches the source texture's color at that pixel.\ntexture.\ntrates this with a 3x3 source texture.\ngreen and blue values, then any resolution of Texture 2 greater than 256 is pointless,\nTexture 2 provides\nan arbitrary lookup table for the Texture 1 input, and this can be used with render-to-\ntexture operations to run some very sophisticated programs entirely within in the\n\"rules\" texture, because Texture 2 determines how an input color maps to a result.\nWith render-to-texture operations, we can use one or several texture maps to\nTexture 1 \nTexture 2 \nFIGURE 5.8.6 Dependent green-blue texture addressing.\nThe Texture 1 source is sampled\nEach texel of Texture 1 determines the coordinate at which to\nsample from Texture 2, the \"rules\" texture.\nThe resulting color from Texture 2 is output as\nsecond operation maps the results of the procedural texture to any RGBA values for\nlying green-blue textures driving the calculations.\nrepresent by a texture map of white or black texels, respectively.\n5.8 Operations for Hardware-Accelerated Procedural Texture Animation\nThe game requires that we sample eight neighbors and the center cell, and apply\nEach neighbor texel of the source is multiplied by 1/8 green and added to the\nwe use bilinear sampling and the B offsets of Listing 5.8.1 to sample two neighbors at\nB) is the green component of the condition texture that is each 'cell's number of\nD) is an 8x2 pixel texture that encodes the rules of the game.\nreads from an 8x2 pixel rules texture that determines the color (white or black) of the\nThis rules texture is black at all texels except those at\ngeneration source texture, the green-blue condition rendered from it, the rules tex-\nthe source or intermediate into an arbitrary color ramp to create a separate texture for\nAs graphics processors draw more texture samples per rendering pass, the 8-bit color\nhardware-accelerated procedural texture effects.\npoint values in textures and pixel calculations could enable fluid flow simulations and\nThe future of real-time procedural texturing and animation is filled with promise.",
      "keywords": [
        "Texture",
        "Procedural texture animation",
        "procedural texture",
        "source texture",
        "Texture Animation",
        "texel",
        "Hardware-Accelerated Procedural Texture",
        "dependent texture",
        "texture coordinates",
        "texture addressing",
        "texture coordinate offset",
        "texture samples",
        "offset",
        "Operations",
        "source"
      ],
      "concepts": [
        "texture",
        "sample",
        "colors",
        "operations",
        "operates",
        "operation",
        "animation",
        "animations",
        "animated",
        "neighbor"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "",
          "score": 0.737,
          "base_score": 0.587,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 44,
          "title": "",
          "score": 0.728,
          "base_score": 0.578,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 47,
          "title": "",
          "score": 0.671,
          "base_score": 0.521,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 46,
          "title": "",
          "score": 0.644,
          "base_score": 0.494,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 48,
          "title": "",
          "score": 0.627,
          "base_score": 0.477,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "texture",
          "texel",
          "procedural",
          "procedural texture",
          "operations"
        ],
        "semantic": [],
        "merged": [
          "texture",
          "texel",
          "procedural",
          "procedural texture",
          "operations"
        ]
      },
      "topic_id": 0,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2629744204563615,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286338+00:00"
      }
    },
    {
      "chapter_number": 50,
      "title": "Segment 50 (pages 490-497)",
      "start_page": 490,
      "end_page": 497,
      "summary": "Game Audio Design Patterns\nIn this gem, we will use them as an inspiration for an audio\nThis discussion assumes that we are audio interface designers and\nWe want to supply an audio interface to our\nsome design patterns and how we can relate them to audio interface design.\nSound Identifiers\ntifier for each particular sound.\nWe can start and stop a sound by passing its identifier.\nHow the audio system actually does the work to start and stop the sound is com-\nAlso hidden is the way in which sounds are loaded and accessed.\nsimilar calls to load and unload a particular sound.\nvoid UnloadSound( int nSoundld );\n6.1 Game Audio Design Patterns \nPerhaps more useful is yet another identifier system for collections of sounds.\nNow we can load and unload many sounds at a time.\nIt may be useful to know if a sound is currently loaded,\nIf we try to start a sound that is not loaded, the response could be to play no\nsound or play an error sound.\nWhen writing an audio API for game programmers to use, the goal is to hide any\nsame interface to control these sounds makes the audio subsystem easier to use.\nSimilar complexity may be hidden in a call that stops all sounds currently playing.\nNow the internal audio code can interpret the states and parameters available in\nsounds.\ntrolling an individual sound object or compositions of sound objects.\nControl of ambient sounds can also be a situation that exhibits composite behavior.\nmany animal sounds.\n\"Provide a surrogate or placeholder for another object to control access to it.\"\nHandles provide just such a placeholder for another object to control access through.\nWhen we start a particular instance of a sound, we may want to continue to control\naccess the sound instance.\n6.1 Game Audio Design Patterns \ninstance of a sound, we can help clients link other responsibilities with sound\nWe can add user data access functions to our handled sound interface.\nWe can also provide a callback field that clients can set per instance of a sound.\ncallback could be defined to be triggered when a sound loops or has played for a cer-\nWe can put some or all calls to our audio API in a command queue that is processed\nsound is being called more than once per frame, or whether a sound has been started\nWhen we want to pause all sounds, we could return a handle to a state that can be\nused to restart those sounds later.\nIf we can pass a type number to a sound that we are starting, we could later reference\nthat sound and any others that have been given the same type.\nall the sounds for a particular character with the same type number, then we can later\nturn off those sounds with one call.\nWe can also update all sounds of a particular type,\nThe last design pattern I want to mention is the Big Ball of Mud. The paper with this\nGame Audio Design Patterns \ners, and Sweeping It Under the Rug. So, how does the Big Ball of Mud pattern relate to audio and game program-\nOur first goal might be to keep our audio system's internal code from being a\nBig Ball of Mud. Our second goal might be to keep the rest of the game code from\nviding useful features in our audio API.\nTherefore, even if Mud prevails, our audio API can provide\nsound status.\nWe can provide a logging system that records audio system activity.\nOne detail level might just record all audio API calls and parameters passed.\nthe game is to disable the audio system completely.\nabled, all calls to audio API functions simply do no work.\nUsing design patterns as an inspiration, we have outlined useful features for a game\naudio API.",
      "keywords": [
        "Procedural Texture Animation",
        "Texture Animation",
        "Game Audio Design",
        "Audio",
        "Audio Design Patterns",
        "Hardware-Accelerated Procedural Texture",
        "audio API",
        "void",
        "Design Patterns",
        "audio system",
        "Game Audio",
        "Game",
        "Sound",
        "Big Ball",
        "Audio Design"
      ],
      "concepts": [
        "void",
        "sound",
        "game",
        "programming",
        "program",
        "function",
        "functionality",
        "audio",
        "code",
        "handles"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 52,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 53,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 55,
          "title": "",
          "score": 0.616,
          "base_score": 0.466,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 3,
          "title": "",
          "score": 0.524,
          "base_score": 0.524,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 54,
          "title": "",
          "score": 0.514,
          "base_score": 0.364,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "audio",
          "sound",
          "sounds",
          "design",
          "audio api"
        ],
        "semantic": [],
        "merged": [
          "audio",
          "sound",
          "sounds",
          "design",
          "audio api"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.19895849146257996,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286378+00:00"
      }
    },
    {
      "chapter_number": 51,
      "title": "Segment 51 (pages 498-505)",
      "start_page": 498,
      "end_page": 505,
      "summary": "Sample-based Synthesizer\nactive sample and the next sample to be played, resulting in a sharp pop or click sound\nFIGURE 6.2.1 The amplitude difference between samples can create a distracting click.\nTo reuse an active voice for playback of another sample, you might try slowly lower-\ning the volume of the current sample and immediately starting the playback of the\nnew sample.\nthe old sample, and would start the new sample prompdy.\nthe old sample, and then start the new sample on the same voice.\ndelaying all voice starts, no matter if reusing voices or not.\nchange in the amplitude of the output signal.\nalso be audible if one were to switch off the old sample even without starting a second\nsample.\nThe idea now is not only to stop any change or oscillation of the old sample, but\nA single sample being stopped\nFIGURE 6.2.2 Holding the last amplitude from a sample prevents an undesiredpop\n6.2 A Technique to Instantaneously Reuse Voices In a Sample-based Synthesizer \nbit, since all logic concerned with fetching new samples or handling the pitch for the\nold voice can be dropped as soon as the new sample is started.\nFIGURE 6.2.3 Starting the second sample at the final amplitude of the first.\npotentially high DC offset to the output signal, which, due to the limited maximum\namplitude of the output sample, may cause the output quality to drop significantly\nhas to fade out the halted old sample (Figure 6.2.4).\nAll this would still require separate logic to handle the halted old sample for each\nIn fact, one could handle all DC offsets introduced by voices being reused\nFIGURE 6.2.4 Fading the initial sample to zero.\nThe logic is as follows: each time a voice is reused, the last value mixed into the\nsum by the old sample on this particular voice will be added to a global DC offset\nThis value in turn will be added to the output signal once all voices are\nunwanted, one lowers the DC offset sum on a per-sample basis over a certain time.\nFIGURE 6.2.5 Fading the initial sample to zero while playing the second sample.\nOne would have to reuse extreme numbers of voices at high amplitudes to\na moment's notice with no delay and with no audible artifacts in the output signal.\nsamples.\nJust one voice has to be set aside to contain the DC offset values to be added\nin the form of a sample data stream generated by the CPU following the algorithm\nSample rate conversion\nTo filter an audio signal is to emphasize or deemphasize certain frequency com-\nFor instance, applying a low-pass filter tends to make the wave sound muf-\nfled, and applying a high-pass filter tends to make the wave sound thin.\nmultiplied with the incoming samples, and then added together.\nficient is multiplied with the current sample, the second with the previous sample,\nAfter each sample is computed, of course, the contents of the previous Output[]\nThe sample code uses a vari-\nexpensive—mostly because each output sample is the sum of one input sample multi-\nplied by ALL of the impulse samples.\nquency domain (where each sample represents a frequency like on a spectroscope,\nThis can be useful if you're already storing samples in the frequency\nA digital delay is probably the easiest DSP effect to generate.\nThe algorithm is simple: for each sample, push a copy\nof the sample onto a queue or circular buffer.\noutput samples are fed back into the delay buffer, producing a multiple echo effect\nSince the gain of each sample is reduced\nto each sample.\nalgorithm, a copy of the input sample is not only pushed onto the tail of the delay\nInterpolation is the art of determining values for nonexistent samples, based on the\nvalues for known samples.\nOne of the most effective ways to compress audio is to reduce its sample rate,\nSample-rate conversion (and pitch shifting, which is by and large the same thing)\nsource sample rate is a multiple of two.\n• Linear interpolation, similar to sample averaging except that the average is\ncase where the resample ratio is not a power of 2, simple sample averaging is the best\nwhere the ratio between the source and target sample rates is between .75 and 1.5.\nCubic sampling can get you higher ratios without sounding terrible, but no simple",
      "keywords": [
        "sample",
        "Voices",
        "output",
        "output signal",
        "delay",
        "delay output samples",
        "sound",
        "amplitude",
        "DSP",
        "filter",
        "output sample",
        "Sample rate",
        "signal",
        "time",
        "effect"
      ],
      "concepts": [
        "sample",
        "sampling",
        "filtering",
        "filter",
        "sound",
        "effect",
        "delays",
        "output",
        "voices",
        "march"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 54,
          "title": "",
          "score": 0.574,
          "base_score": 0.424,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 52,
          "title": "",
          "score": 0.553,
          "base_score": 0.403,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 50,
          "title": "",
          "score": 0.509,
          "base_score": 0.359,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 53,
          "title": "",
          "score": 0.509,
          "base_score": 0.359,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "",
          "score": 0.476,
          "base_score": 0.326,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "sample",
          "output",
          "samples",
          "old sample",
          "old"
        ],
        "semantic": [],
        "merged": [
          "sample",
          "output",
          "samples",
          "old sample",
          "old"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.14683257623405907,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286418+00:00"
      }
    },
    {
      "chapter_number": 52,
      "title": "Segment 52 (pages 506-515)",
      "start_page": 506,
      "end_page": 515,
      "summary": "Games (and other applications) have a need for an audio processing pipeline.\ngoal is to allow a set of DSP functions with corresponding parameters to be specified\nOther sounds may pass through a different set of DSP functions and/or\n• Each sound can pass through A^DSP functions.\n• Any parameter for any DSP function may be changed at any time.\n• Makes it easier to write DSP functions.\nIf we store all DSP function and para-\nNext is the requirement to support N DSP functions per sound.\nIf we wanted to pass a sound through only a single DSP function,\nA speed-changing DSP function, in the con-\ntext of our pipeline, is any function that outputs a different number of samples than\nThe classic example of a DSP function which slows down music is\nof memory; for example, if a DSP function returns \"I have no work to do,\" no mem-\nAn audio\nThere are many types of DSP functions.\nas much ancillary work as possible, so that each DSP function implements an algo-\nto supply us with as many samples of audio as we request, within reason), the output\nit waits until it needs that many samples, and then triggers the audio processing.\nTherefore, the audio processing pipeline must output 16,384 samples.\nfar, we know only that the last function in the chain must output 16,384 samples.\nHow many samples does this function need for input?\nwants 24,576 samples of input to produce 16,384 of output.\nsamples of input to obtain from the stream, we continue traversing the chain of DSP\nfrom the input stream, and pass them to the first function in the chain.\nWhat if a DSP function produces fewer sam-\nThe next DSP function in the chain must be given the\neither run out of input samples, or fill the output buffer.\nDSP functions should be implemented in a manner such that they don't frivolously\nstantial processing (for example, if the DSP function would have to actually process\nthe audio to know exactly how many samples it would need).\nWhat if a DSP function \"eats\" fewer samples than requested?\nThe pipeline must provide a buffer between each pair of DSP func-\nThe buffer between function #2 and function #3 holds underflow\nWhat if a DSP function produces too many output samples?\nThis raises a point: DSP functions are not commutative.\nThe processing engine must call the input stream manager to request raw data for\nThe processing engine can call each DSP function with several messages.\nwe've discussed a query to determine how many input samples are needed to produce\na DSP function, to let it allocate instance data, and lastcall allows it to free that data.\nTo implement a DSP function to plug into diis architecture, the programmer\nples of DSP-specific parameters would be room size for a reverb, ratio for a speed\ntained by the DSP function itself.\nThe processing engine uses three buffers: a source, a destination, and an accumu-\nDuring processing, the buffers swap roles, so the engine uses buf [0],\nThe reason is that the destination (output) of DSP function #1\nbecomes the source (input) of DSP function #2.\nSimilarly, if the last DSP function in the chain outputs less than the amount\nvoid dsp_ProcessAudio(dsp_AUDIO *audio)\nflow buffers in the DSP chain itself.\nstream_GetData() is the call to the input stream manager (external to DSP.C).\nimportant to understand that this function must put the samples in the destination\nstatic void QueryDSPIn(dsp_AUDIO *audio)\ndsp_PARAMS params;\ndsp = &(audio->dsp[audio->numdsps - x - 1]);\n(*dsp->callback) (&params) ;\nunderlen = bfbuf_GETDATALEN(dsp->underbuf ) ;\ndsp->inreq = (underlen < params.\ndsp->outreq = params.\nNotice how the function begins by knowing how many samples remain (audio ->\nThe loop itself traverses all the DSP filters used by the sound in reverse order.\nEach DSP stores how many input samples it needs, and the expected output (the\nstatic void DoDSP(dsp_AUDIO *audio)\ndsp_PARAMS params;\nparams.cmd = dsp_OUTPUT;\ndsp = &(audio->dsp[x]);\nbfbuf_MoveAll(srcbuf, dsp->underbuf);\nbfbuf_SetDataLen(dstbuf, dsp->outreq);\nparams.dspspecific = dsp->dspspecific;\n= dsp->privdata;\n(*dsp->callback)(&params);\nbfbuf_MoveAll(dsp->underbuf, srcbuf);\nEach DSP func-\ntion is given the previous function's output (destination) for its own input (source).\nThis also makes it easy to handle the case when a DSP reports that it has done no\nThe underflow for DSP function #1 is different from the\nunderflow for DSP function #2, and must be kept separate.\nThis makes DSP pro-\nAfter the call, if the function did no work, we set the destination buffer to empty,\nOtherwise, something was done by the function, so we check to see if the DSP\nDSP functions could have changed.\nThis code forms the core of an audio processing\ndsp_New-\nSound () must be called when a new sound is added to the system, and dsp_Delete-\nWhatever code calls dsp_ProcessAudio() must check this bit, and then call\nDSP functions (such as echo) may retain their\nThis way, the DSP engine\nknows that when a stream reaches the end, and the DSP function chain produces no\nrelated limitation is that the dsp_AUDIO struct and its dsp_DSP array are allocated\nstructures, parameters, and so forth, outside the DSP engine.\nFirst, the code doesn't handle the case of when a DSP\nwe've gone to great lengths to make sure that DSP functions are small, lightweight,\nThe other missing feature is that there is no way to add or remove DSP functions\nThis can be worked around as long as all DSP functions have\nof the DSP functions that you'll possibly want to use on it at any point during its life-\nIt would be a bad kludge, but you could actually add new DSP functions to the\nThe essence of this gem demonstrates how to build a basic DSP pipeline that supports\npassing a sound channel through a chain of DSP filters, each of which can do any-\nprocess, we need a query call to ask the DSP \"if we want N samples of output, how",
      "keywords": [
        "DSP",
        "DSP function",
        "Audio",
        "function",
        "audio processing pipeline",
        "audio processing",
        "buffer",
        "samples",
        "Processing",
        "sound",
        "Audio Programming dsp",
        "DSP function produces",
        "input",
        "output",
        "processing pipeline"
      ],
      "concepts": [
        "audio",
        "functions",
        "function",
        "functional",
        "buffer",
        "buffering",
        "sound",
        "processing",
        "process",
        "data"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 50,
          "title": "",
          "score": 0.659,
          "base_score": 0.509,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 53,
          "title": "",
          "score": 0.62,
          "base_score": 0.47,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 54,
          "title": "",
          "score": 0.604,
          "base_score": 0.454,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 55,
          "title": "",
          "score": 0.579,
          "base_score": 0.429,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 51,
          "title": "",
          "score": 0.553,
          "base_score": 0.403,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "dsp",
          "dsp function",
          "dsp functions",
          "function",
          "samples"
        ],
        "semantic": [],
        "merged": [
          "dsp",
          "dsp function",
          "dsp functions",
          "function",
          "samples"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.24696927389239556,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286460+00:00"
      }
    },
    {
      "chapter_number": 53,
      "title": "Segment 53 (pages 516-524)",
      "start_page": 516,
      "end_page": 524,
      "summary": "A Basic Music Sequencer\ncomparison of music streaming and music sequencing.\n• Music data plays the same way each time.\n• Music data can be dynamically altered at runtime to create unique game and\n• Voices for music may compete with voices needed for other game audio.\nEvent Blocks\nMusic can be described as events or commands occurring over time.\ncan build our music command language with \"event blocks\" composed of three ele-\nments: time, event type, and event details.\nevents and call it a delta-time.\nThe event type will be identified with a number, and\nthe event details will be zero or more parameters diat are defined by the event type\nBy using a sequence of event blocks we can describe any combination of events\nDelta Time / Event Type / Event Parameters\nFIGURE 6.5.1 Event block.\n6.5 A Basic Music Sequencer for Games \nchoosing how to store the delta time, choosing the event types to support, and choos-\ning the parameters supplied for each event type.\nIn making a music sequencer for games, we aren't as\nrelate directly to making our music sequencer for games.\nMIDI Event Types\nThe MIDI specification defines several events called the channel voice messages.\nThe channel voice messages are the core musical control events defined by MIDI.\nEvent Type\nEvent Parameters\nTwo of die most commonly used Controller IDs are 7 for Volume and 10 for Pan. There are also meta-events defined in die MIDI file format 1.0 specification.\nThe End of Track meta-event defines the end of a series of event blocks, and the\nSet Tempo meta-event defines how fast to step through die delta time values of event\nThe Time Signature and Key Signature meta-events do not change the way\nmusic data.\nMIDI Channels and Tracks\nevent block also contains a channel number from 1 to 16 (0 to 15).\nTable 6.5.2 Selected MIDI Meta-Event Types\nMeta-Event Type \nMeta-Event Parameters\nSequence/Track Name \n6.5 A Basic Music Sequencer for Games \nThe basic music sequencer that we will present processes any number of tracks\nComputer Music Sequencer Implementation\nFor the purposes of this gem we will choose to implement event types that\nare very similar to MIDI event types.\nYou can create your own additional event types\nSequences, Tracks, Events, Instruments, and\nEach track is a series of event blocks that we\nOn event in a track will start a voice of the current instrument.\nNote Off event will turn this voice off.\nMany types of events in a track will modify the\nstate of the track's voices.\nSequencer Event Types\nAs a first step in creating our basic music sequencer we will come up with a list of\nevent types that we want to support.\nEvent Type Ideas\nEvent Types \nThese work like the traditional MIDI events\nEvent Types\nThese work like the traditional MIDI events\nTarget an event value rather than setting it\nThese event types are quite similar to certain MIDI messages.\nsion from MIDI files for these events easy.\nThese event types interpolate from current value to destination value over a given\nThese event types switch us to different sections of music data.\nA Basic Music Sequencer for Games \nThese event types generate callbacks to functions that have been registered with the\nmusic sequencer.\nThe abbreviated data structures that we could use for our music sequencer are listed\nListing 6.5.1 Music sequencer data structures\nTrack_t \nsequences, tracks, and voices.\nWe also see that sequences, tracks, and voices each have\nA Track_t\nsequence that owns the track.\nsequences, tracks, or voices.\nEvent Data Structures\nTo implement the event type commands, we can have the event type command num-\nbyte length of the event type and parameters.\ntion pointers give us a quick way to get to the code associated with each event type.\nListing 6.5.2 Event type data structures\n// Example Note Off Event Block\n// the pEvent is pointing at our event block\n6.5 A Basic Music Sequencer for Games \n// the pEvent is pointing at our event block\nEVENT_TYPE_NOTEOFF ,\nEVENT_TYPE_NOTEON,\nEVENT_TYPE_COUNT\nstatic EventTypes_t aET[EVENT_TYPE_COUNT] = {\nHere we show that we can give each event type a number that can be used to call\nfunction pointer to call for the given event type and the length of the command ID",
      "keywords": [
        "Music",
        "Basic Music Sequencer",
        "Event",
        "Music Sequencer",
        "event type",
        "MIDI",
        "MIDI Event Types",
        "data",
        "Track",
        "Basic Music",
        "Music data",
        "type",
        "MIDI Event",
        "computer music",
        "string data"
      ],
      "concepts": [
        "event",
        "music",
        "musical",
        "midi",
        "data",
        "track",
        "values",
        "sequencer",
        "sequence",
        "notes"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 54,
          "title": "",
          "score": 0.892,
          "base_score": 0.742,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 50,
          "title": "",
          "score": 0.651,
          "base_score": 0.501,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 52,
          "title": "",
          "score": 0.62,
          "base_score": 0.47,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "",
          "score": 0.573,
          "base_score": 0.423,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 51,
          "title": "",
          "score": 0.509,
          "base_score": 0.359,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "event",
          "music",
          "event type",
          "midi",
          "music sequencer"
        ],
        "semantic": [],
        "merged": [
          "event",
          "music",
          "event type",
          "midi",
          "music sequencer"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18351651028661703,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286500+00:00"
      }
    },
    {
      "chapter_number": 54,
      "title": "Segment 54 (pages 525-535)",
      "start_page": 525,
      "end_page": 535,
      "summary": "happen when we are changing data structures for the music sequencer.\nIn order to play our music data at different rates, we need to work out how to step\nthrough our music data based on three parameters: the music tempo, the update\ninterval, and the resolution of our music time format.\n6.5 A Basic Music Sequencer for Games \n• Music tempo is described in beats per minute (BPM).\n• Music time resolution is described in parts per quarter note (PPQ).\nWe are looking for the amount of music time to increment for each audio call-\nWe recalculate the parts-per-update value any time that a sequence's tempo\nSince these time parameters are in the sequence structure, we can only change\nAn important issue for our music sequencer implementation is how music event para-\nThis is where music sequencer code\nOne important part of connecting our audio synthesis to our music sequencer is\ntypes of control we will have available and music will have to be written with these\nThe example code on the CD-ROM shows how to play music using our custom\nmusic sequencer language.\nThis includes how to step through the music data of each\ntrack of each sequence, and how to code the event types for a particular synth inter-\nWe covered the details of a basic music sequencer.\nbeen presented, as well as our custom music language.\nAn Interactive Music\nThis means that a player has control over the game in some\nway, and the game asks the player to use his or her control to interact in some\nputer games with the immersiveness of music.\nHow do we control music?\nwe create musical interaction?\n\"What kind of musical meanings can we generate?\nBuilding on the concepts and code from the basic music sequencer, we now will\nto modify parameters on the sequence level and track level.\nMaking interactive music can be viewed as controlling a puppet.\nway the music plays, we may even pull the emotional strings of our game player.\nlist of associations and meanings that music can convey.\nMusical Associations\nMusic is its own form of entertainment.\nories associate music with past situations, friends, and places.\nstyle of music with a particular geographical location.\nof some music widi love, hate, contentment, or anger (Table 6.6.1).\nTable 6.6.1 Music Associations\nMusical Meaning\nIf we want our music to be interactive, we should know the different meanings that\nwe wish to convey with the music.\nattach to the control of music are categorized in Table 6.6.2.\nTable 6.6.2 Musical Meanings\nConfidence in the music.\nStrength in the music.\nSharpness and agility in the music.\nHeaviness or lightness in the music.\nMusic that is familiar to certain player states in the game.\nPleasing attitude in the music.\nHarsh attitude in the music.\nSweetness in the music.\nViolence in the music.\nMusic that is familiar to certain nonplayer character states in the game.\nEven, predictable music.\nIrregular, ominous music.\nMusic that is familiar to a common location in the game.\n6.6 An Interactive Music Sequencer for Games \nEven, predictable music.\nIrregular, ominous music.\nTriumphant music.\nWhimpering or taunting music.\nMusic that is familiar to a common situation in the game.\nIn addition, a transition might mean a new track section, musical\nTransitions may be triggered by a combination of game logic and music language\nof the interactive control of music.\nThe simplest way to use music interactively is to simply switch music.\none composition that is considered traveling music, and one composition that is con-\nsidered battle music, then when we stop traveling in the game to have a battle, the\nmusic switches at the same time.\nThis type of musical interactivity is very common\nWe could even use a basic music sequencer to simply stop one tune\nIf we want our transitions between tunes to be more musical or sub-\ntle, then we need more sophisticated functionality from our music sequencer.\nTo use music interactively is not the same as making interactive music.\nmean that we actually change the character of a music composition through various\nTable 6.6.3 Music Transition Types\nthe music to make it seem more dangerous?\nthe mix of the music to emphasize our new instrument timbres and bring up the per-\nNow we are talking about interactive music.\nularity available for music parameters.\nThese volume control types are listed in Table\n6.6 An Interactive Music Sequencer for Games \nMusic\nThe music volume controls all musical sequences.\nEach track of a sequence has a volume.\nIt is useful when creating music to be able\nwant a volume control so that the instrument can be programmed to have similar\nIt is useful when creating music to have this\nThe abbreviated data structures for our music sequencer with new target controls\nListing 6.6.1 Sequencer data structures with target control\nThere are four important factors in the discussion of interactive music: game design,\ngame programming, music design, and music programming.\nMusic programming is\n• Game design will influence music design.\n• Music design will influence music programming.\n• Game programming will influence music programming.\nTo point out these influences, I will describe some interactive music design examples.\nwant to hear his energy in the music.\nMusic design: Transition the melody and percussion track instruments to add DSP\nProgramming design: Two sequence states are created, and the game can choose\nSummary: The music responds to the player's attributes.\nThis way, the music tells\nwant to hint at that approaching danger, using the music to do so.\nMusic design: Fade down the main melody track and fade up die danger melody track.\nSummary: The music responds to the player's location.\nThis way, the music tells the\nat night, we'll want energy music during the day, and tense and scary music at\nMusic design: To keep it simple, we will describe three tracks of the music: melody,\nStop at each column in the table and you can see a different stage of the music.\nWe can consider each column a keyframe for our music control parameters.\nProgramming design: We generate our control value based on the game time.\ncontrol value is used to interpolate between instrument states and track states.\nSummary: The music responds to the game state.\nThis way, die music tells the\nBuilding on die code presented in the basic music sequencer gem, die example code\nshows how to play music that can be interactively modified to new target states.\nThe reasons for developing your own interactive music sequencer code are the same as\ninteractive music.\ninteractive music sequencer and make sure interactive music is part of your game's",
      "keywords": [
        "music",
        "music sequencer",
        "Interactive Music",
        "Interactive Music Sequencer",
        "game",
        "Basic Music Sequencer",
        "Control",
        "Audio",
        "music design",
        "time",
        "music sequencer code",
        "track",
        "sequencer",
        "Interactive",
        "code"
      ],
      "concepts": [
        "music",
        "musical",
        "control",
        "controlling",
        "instrument",
        "instruments",
        "time",
        "timing",
        "sequences",
        "sequencer"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 53,
          "title": "",
          "score": 0.892,
          "base_score": 0.742,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 52,
          "title": "",
          "score": 0.604,
          "base_score": 0.454,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "",
          "score": 0.578,
          "base_score": 0.428,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 51,
          "title": "",
          "score": 0.574,
          "base_score": 0.424,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 50,
          "title": "",
          "score": 0.514,
          "base_score": 0.364,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "music",
          "sequencer",
          "music sequencer",
          "interactive",
          "interactive music"
        ],
        "semantic": [],
        "merged": [
          "music",
          "sequencer",
          "music sequencer",
          "interactive",
          "interactive music"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.17571655531359984,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286540+00:00"
      }
    },
    {
      "chapter_number": 55,
      "title": "Segment 55 (pages 536-543)",
      "start_page": 536,
      "end_page": 543,
      "summary": "his gem describes a platform-independent, low-level sound API suitable for\nspecific APIs. A DirectSound reference implementation is provided on the CD.\n• Software mixing and processing\n• Wave caching\nCore Classes\nWraps a wave audio source.\nIterator class for indirectly accessing a CWave.\nfunction is to fill a user-supplied buffer with bytes from the wave\nThe base class is fully functional, but it can be extended if\nCWavePtr to convert a 16-bit PCM input source into floating-\nplatform-specific memory functions.\nplatforms contain both areas of memory that are directly CPU-\nA CWavePtr-derived class might automatically move\nThe base class mixer does not allocate any memory\nfor channels, since derived class mixers may want to use their\nown channel implementations.\nThe base channel class is tightly coupled with CMixer, so it's\nimplemented as an inner class.\nmanaging a CWavePtr, which is the input to that channel.\nchannel class extracts data from the CWavePtr on demand, keeps\nThe channel class can also be extended to meet varying\nCMixer-channel also contains a virtual tick() function,\nplatform-specific channel implementations to perform hardware\nbuffer\nThe sample source on the CD contains implementation classes for various\nDirectSound-based classes, showing how hardware acceleration, software mixing, and\nDSP-style processing can be worked into the base classes.\ntion designed to make your life easier as a game developer.\n• Demos of many of the techniques described in the book\n• Links to useful and interesting game development sites\nBloom Filter algorithm, 133\ncollision detection, 228-238\ncombinatorial search algorithms, 354\nrandom number generator algorithm, 130\nclouds, procedural texture generation, 463-473\ngame programming vs.\nAudio design patterns\nbridge audio design pattern, 514-515\ncommand audio design pattern, 517\ncomposite audio design pattern, 515-516\ndecorator audio design pattern, 517\nfacade audio design pattern, 515\nmomento audio design pattern, 518\nobserver audio design pattern, 518\nproxy audio design pattern, 516\nAudio processing pipelines, interactive, 529-538\nAudio programming\naudio design patterns, 514-520\nDigital Signal Processing (DSP) techniques,\ninteractive processing pipeline for digital audio,\nAxis-aligned bounding box (AABB) tree structures\nBehavioral classes, 53\nactive behaviors and brain classes, 267\nevent-driven behaviors for AI optimization, 251-252\nbrain classes, 267-269\nBridge audio design pattern, 514-515\nBuffers\npriority buffers described, 483\ndeprecated functions and, 63\ndrop-in debug memory manager, 66-73\nexporting classes from DLLs, 28-32\noptimization techniques, 5-15\nproperty class for generic member access, 46-50\ntexture mapping and, 444-451\nChild classes, data 43-44\nClasses\nSee also Specific classes\nClass member functions, exporting from DLLs, 30-31\nprocedural cloud generation, 463-473\nscalability of procedural generation techniques,\nCollision detection\ndistance to collision point, 184-185\nSee also Collisions\nCollisions\nSee also Collision detection\nCombs Method for managing exponential growth,\nCommand audio design pattern, 517\nCommand queues, audio design and, 517\nComposite audio design pattern, 515-516\ncharacter rotation and input, 427—428\nthird-person control of animated characters,\nCreational dependencies, 302-304\nCubic interpolation, DSP techniques, 528\nDecorator audio design pattern, 517\ncreational dependencies, 302-304\ncubic interpolation, DSP techniques, 528\nfiltering technique, 525-526\ninteractive audio processing pipeline, 529-538\nlinear interpolation, DSP techniques, 528\nDigital Signal Processing (DSP) techniques, 525-528\nDrop-in debug memory manager\nAPI functions, 36\nclass member functions, exporting, 30-31\nexporting C++ classes from, 28-32\nvirtual class member functions, exporting, 31-32\nDynamic type information (DTI) class\nsilhouette edge detection and rendering, 436—443\ndeath of entities, AI management strategies, 269-270\nEntity class and subclass, 54-55\nentity managers and cooperation among AI agents,\nExponential growth, Combs Method to manage,\nExported classes, 50, 56-57\nFacade audio design pattern, 515\ngame entity factory, 51-61\ntexture filtering, 418, 479\nFloating-point numbers\nclamping values to a specific range, 173—174\nSee Floating-point numbers\nFlyweight classes, 53\nFunction pointers, used within C++ classes, 59—60\nFunctions\ndeprecated functions, 62-65\nCombs Method rules for, 344-348\naxis-aligned bounding box (AABB) trees and,\nGetProcAddress function, 34\nhardware accelerated procedural texture animation\nsilhouette edge detection and rendering, 436-443\nHandles, used in proxy audio design, 516\nHashing functions, 129, 134\nBehavior class hierarchy, 54-55\nof C++ classes, method for describing, 51-61",
      "keywords": [
        "audio design pattern",
        "Audio design",
        "design pattern",
        "audio",
        "Low-Level Sound API",
        "design",
        "API",
        "Sound API",
        "pattern",
        "Classes",
        "functions",
        "processing",
        "API functions",
        "channel",
        "command audio design"
      ],
      "concepts": [
        "functionality",
        "function",
        "functions",
        "classes",
        "audio",
        "describes",
        "describing",
        "defined",
        "technique",
        "patterns"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 50,
          "title": "",
          "score": 0.616,
          "base_score": 0.466,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 52,
          "title": "",
          "score": 0.579,
          "base_score": 0.429,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 53,
          "title": "",
          "score": 0.482,
          "base_score": 0.332,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 51,
          "title": "",
          "score": 0.45,
          "base_score": 0.3,
          "topic_boost": 0.15,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 54,
          "title": "",
          "score": 0.417,
          "base_score": 0.267,
          "topic_boost": 0.15,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "audio",
          "audio design",
          "design",
          "design pattern",
          "pattern"
        ],
        "semantic": [],
        "merged": [
          "audio",
          "audio design",
          "design",
          "design pattern",
          "pattern"
        ]
      },
      "topic_id": 2,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.18053218733310827,
        "topic_boost": 0.15,
        "timestamp": "2025-12-17T23:07:23.286579+00:00"
      }
    },
    {
      "chapter_number": 56,
      "title": "Segment 56 (pages 544-551)",
      "start_page": 544,
      "end_page": 551,
      "summary": "game-specific updates, 494\nIncrement functions, optimization and, 7\nas tile templates, 378-379, 380\nInfluence maps\nAI optimizations, 256\ncell data types, 289-290\nIsA function and dynamic type information (DTI)\nclass, 40-41\nInline functions, 11-12\nSee Inline functions\nconverting player's input for third-person control\nweb-cams for multiplayer games, 153\nIsA function, dynamic type information (DTI) class\nand inheritance, 40—41\ntexture masking demo, 479—480\nAI optimization, 254\nDot3 Bump mapping, 456—459\nper-pixel techniques, 452—462\nfor Windows-based games, 80-84\nLinear quantization and floating-point numbers, 178\nLOS search systems, 279-286\nterrain reasoning for 3D games, 307-316\nmemory manager logging, 68-70\ninline functions, 16-19\nMaps\ninterlocking landscape tiles and height maps,\nlightmapping, 3D textures, 452—459\nplayer visibility maps, 281-282\nshadow maps, 422\nMemory\ndrop-in debug memory manager, 66-73\ninline functions and, 18\nmanaging for optimization, 9\nmemory tracking, 29, 66-73\nMFC's memory manager, 72\nStandard Template Library and, 12—14\nSee also Memory allocation\nMemory allocation\nstack management, 262\nMixing functions and randomness, 129\nfile management using resources files, 102-104\ngame profiling, 74-79\nmemory-tracking module, 66-73\nforward motion and animation, 428—429\nobjects, 216-217\nMovies, input recording to create game movies, 107\nMultiplayer games\nMultitasking in games, 82-83\nevent data structures, 546-547\nsequencer data structures, 545-546\nsequencing methods, 539-540\ntiming calculations, 548-549\nNearest-point calculation, closed-form equations for,\nturbulent noise creation, 467—468\npainting for cartoon rendering, 444—451\nObjects\noptimization and return by value, 7\nOptimization\nArtificial Intelligence strategies, 251—257\nfor C++ games, 5-15\nLOS templates for player visibility systems, 281-283\nmemory management techniques for, 9\nof points-of-visibility pathfinding, 324—329\nvirtual functions and, 9—11\ncomputing Toon texture coordinates, 438—440,\nParameter types, inline functions and, 18\nhierarchical on-demand pathfinding, 254—255\nprecomputing propagated influence values, 294—295\ntile-based pathfinding, 325\nSee also Points-of-visibility pathfinding\nfloating-point numbers and, 167-181\nsearching systems for tile-based games, 279\nSee also Optimization\nPlayer visibility systems, 279-286\nmaps, 281-286\nplayer visibility maps, 281-282\nfunction pointers used within C++ classes, 59-60\nPoints-of-visibility pathfinding\noptimization of, 324-329\ntile-based pathfinding, 325\ngenuine randomness and, 127—128\nprotecting game predictability, 107-108\nAI optimization and, 255\nof data files, 113-114\ninfluence maps, 293—297\nProcedural textures\nbuilt-in game profiling module, 74-79\nProjective shadowing techniques, 421—424\nsimple pseudo-random number generator code, 465\nRand() function, alternatives to, 109\nmixing functions and, 129\nReal-time strategy (RTS) games\nLine-of-Sight searching systems for, 279-286\nReplays, input recording to replay interesting games,\ndefined and described, 100\nused for file management, 100-104\nSee Real-time strategy games (RTS)\noptimization, 14\nCOM interface searches, alternatives to, 46—50\nquadtree search implementation code, 400\ntile-based game search systems, 279-286\ndefined and described, 91-92\nShadow maps, 421-424\nhybrid approaches for, 486—487\nshadow maps, 421-424\nprogrammable vertex shader inking, 440—442\nSilhouette points and zones, pathfinding, 325-329\nSine functions, lookup tables for, 174—175\nSkip strips VIPM method described, 368-370\ntextures for, 419\nSee under Influence maps\nSee Optimization\nbounding spheres, 384—385\nstack management and micro-threads, 262\noptimization and, 12-14\nStatus functions in audio design, 519\nStrategy games\nLine-of-Sight searching systems for, 279-286\nsequencing method for music, 539-540\ntactical values, converting to waypoint properties,\nTemplate Method pattern, 55\nTemplates, optimization and, 14\ninfluence maps and, 293—297\ninterlocking tiles method, 377- 383\nreasoning for 3D games, 307-316\nskyboxes for rendering distant scenery, 416—420\nresources required for algorithm, 314—315\nfloating-point numbers, 115\nParser class, 116\nTexture filtering, 479\nTextures\ngreen-blue texture addressing, 497—498, 505-506\nself-shadowing with projective textures, 421—424\n3D textures for light mapping, 452-459\nSee also Procedural textures\nbone weighting (influence values), 146—148\nmesh data and, 145-146\nTile-based games, Line-of-Sight searching systems for,\nsearching systems for tile-based games, 279\ntile-based pathfinding, 325\nrendering method for, 382\nTracks, audio, defined, 543\nmaximum height calculations, 211—212\ntime, position and velocity as function of, 206-207\noptimizations and, 213-214\naudio design, 519\nType information code of tweaker interface, 125\ndefined and described, 38\ndynamic type information (DTI) class, 38-43\ndynamic types in audio design, 518\nArtificial Intelligence (AI) data updates, 255-256\ntactical values, converting to waypoint properties,\ninfluence maps to track, 289-290\nmixed-mode method described, 365-368\nskip strips method described, 368-370\nsliding window method described, 372-375\nVirtual class member functions, exporting from DLLs,\nheight-field water as procedural texture, 501-503\nuses of waypoint-based reasoning, 315\ncapture window initialization, 153—158\nmemory allocation for, 155-156\nin multi-player games, 153\nWorld, defined for tile-based games, 280",
      "keywords": [
        "functions",
        "Standard Template Library",
        "maps",
        "systems",
        "memory",
        "optimization",
        "games",
        "type information",
        "Template Library",
        "audio design",
        "audio",
        "defined",
        "texture",
        "pathfinding",
        "Inline functions"
      ],
      "concepts": [
        "function",
        "texture",
        "game",
        "maps",
        "mapping",
        "optimizations",
        "optimal",
        "optimally",
        "classes",
        "defined"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 31,
          "title": "",
          "score": 0.521,
          "base_score": 0.521,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 18,
          "title": "",
          "score": 0.458,
          "base_score": 0.458,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 36,
          "title": "",
          "score": 0.431,
          "base_score": 0.431,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 9,
          "title": "",
          "score": 0.41,
          "base_score": 0.41,
          "topic_boost": 0.0,
          "method": "sbert"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 49,
          "title": "",
          "score": 0.397,
          "base_score": 0.397,
          "topic_boost": 0.0,
          "method": "sbert"
        }
      ],
      "enriched_keywords": {
        "tfidf": [
          "maps",
          "systems",
          "optimization",
          "games",
          "tile based"
        ],
        "semantic": [],
        "merged": [
          "maps",
          "systems",
          "optimization",
          "games",
          "tile based"
        ]
      },
      "topic_id": null,
      "chapter_provenance": {
        "methods_used": [
          "sbert",
          "tfidf",
          "bertopic"
        ],
        "sbert_score": 0.2873837418131496,
        "topic_boost": 0.0,
        "timestamp": "2025-12-17T23:07:23.286968+00:00"
      }
    }
  ],
  "total_chapters": 56,
  "enrichment_provenance": {
    "taxonomy_id": "none",
    "taxonomy_version": "none",
    "taxonomy_path": "none",
    "taxonomy_checksum": "sha256:none",
    "source_metadata_file": "Game Programming Gems 2_metadata.json",
    "enrichment_date": "2025-12-17T23:07:23.297595+00:00",
    "enrichment_method": "msep",
    "model_version": "ai-agents-msep-v1",
    "processing_time_ms": 4312.46208399898,
    "total_similar_chapters": 269
  }
}