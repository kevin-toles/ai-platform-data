{
  "metadata": {
    "title": "Game Programming Gems 1",
    "author": "Unknown Author",
    "publisher": "Unknown Publisher",
    "edition": "1st Edition",
    "isbn": "",
    "total_pages": 603,
    "conversion_date": "2025-11-27T15:07:37.456897",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "Game Programming Gems 1.pdf"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-10)",
      "start_page": 1,
      "end_page": 10,
      "detection_method": "topic_boundary",
      "content": "1.0\n\nThe Magic of Data-Driven\nDesign\n\nSteve Rabin\n\nGames are made up of ewo things: dagic and data. This is a powerful distinction. Sep-\narate, they are useless, but together, they make your game come alive. The logic\ndefines the core rules and algorithms of the game engine, while the dara provides che\ndetails of content and behavior. The magic happens when logic and data are decow-\npled from cach other and allowed to blossom independently.\n\nObviously, game data should be loaded from files, not embedded inside the code\nbase. The genius eomes from knowing how far vo run with this concept. This arricle\ngives seven ideas that will revolutionize the way you make your games, of at least con-\nfirm your suspicions.\n\nIdea #4: The Basics\n\nGreate a system that can parse text files on demand (not just at startup), This is essen-\ntial to putting data-driven design to work. Every game needs a clean way to read in\ngeneral-purpose data. The game should eventually be read in binary files, but the abil-\nity to read in cext files during development is cracial. Texe files are dead simple for\nediting and making changes. Withour altering a single line of code, your whole team,\nincluding testers and game designers, can cry out new things and experiment with dif-\nferent variations, Thus, something thar is crivial to implement can quickly become an\nindispensable tool.\n\nIdea #2: The Bare Minimum\n\nDon't hard-code constanes. Put constanis in text files so chat they can be easily\nchanged without recompiling code. For example, basic functionality such as camera\nbehavier should be exposed completely. [f this is done properly, the game designer,\nthe producer, and che kid down the street will all be able to alter che behavior of the\ncamera with nothing more than Notepad. Game designers and producers are often at\nthe mercy of programmers, By exposing algorithm constants, non-programmers can\n\n3\n\n4 Section 1 Programming Techniques\n\ntune and play with the values to get the exact behavior they desire—without bother-\ning a single programmer.\n\nIdea #3: Hard-Code Nothing\n\nAssume that anything can change, and probably will. Lf che game calls for a splic\nsereen, don't hard-code it! Wrine your game to support any number of viewport, cach\nwith its own camera logic. In isn’t even any more work if ir’s designed right. Through\nthe magic of text files, you could define whether the game is single-screen, split-\nscreen, or quad-screen. The files would also define all the starting camera values, such\na5 position, direction, field of view, and ult. The best part is chat your game designers\nhave direct access co all elemencs within the tent files.\n\nWhen core design decisions are flexible, the game is allowed to evolve co its full\npotential. In fact, che process of abstracting a game co ins core helps renvendously in\nthe design. Instead of designing to a single purpose, you can design each component\nto its general functionality. In effect, designing flexibly forces you no recognize what\nyou should really be building instead of che limited behavior outlined in the design\ndescurrene.\n\nFar example, if the game calls for only four types af WRapoits, you could progeua\na perfeeely good system that encompasses all of chem. However, if you abseract away\nthe functionality of cach weapon, using dara oo define its behavior, you'll allow for che\npossibilicy of countless weapons chat have very distince personalities. All it takes is a\nfew changes in a text file in onder to experiment with new ideas and game-play\ndynamics, This minelset allows the game to evolve and ultimately become a much\n\nbenter gare.\n\nDid You Believe Me When | Said \"Nothing\"?\n\nThe truth is that games need to be cuned, and great games evolve dramatically from\nthe orginal vision. Your game should be able to deal with changing rules, characters,\nraces, weapons, levels, control schemes, and objects. Without this flexibility, change is\ncostly, and every change involves a programmer—which is simply a waste of\nresources. If change is difficult, it promotes far fewer improvements to the original\ndesign. The game will simply not live up to its full potential,\n\nIdea #4: Script Your Control Flow\n\nA scripe is simply a way to define behavior outside of the code. Scripts are great for\ndefining sequential steps that need co occur in a game of game evens thar need to be\nuigp¢ened. For example, an in-game cur-scene should be scripted. Simple cause-and-\neffect logic should also be scripted, such as the completion conditions of a quest or\nenvironment triggers. These are all great examples of the dara—driven philosophy ar\nwork.\n\n1.0 The Magic of Data-Driven Design 5\n\nWhen designing a scripting language, branching instructions require some\nthought. ‘There are two ways to branch. The first is to keep variables inside the seripit-\ning language and compare them using mathematical operarors such as equals ( =) or\nless than ( < ). The second is ro directly call evaluation functions that compare vari-\nables that exist solely inside the code, such as IsLifefeloere reentage(so). You could\nalways use a mix of these techniques, but keeping your scripts simple wall pay off, A\ngame designer will have a much casier time dealing with evaluation functions chan\ndeclaring variables, updating chem, and then comparing them. It alsa will be easier to\ndebu\n\nTian Scripts require a scripting lanpuage, This means that you need to\ncreate an entirely new syntax for defining your behavior. A scripting language also\ninvolves creating a script parser and possibly a compiler to convert the script to a\nbinary file for faster execution. The other choice is to use an existing language such as\nJava, but thar requires a large amount of peripheral support as well. In onder nor ro\nsink too much time into this, it pays off to design a simple system. Overall, the ren-\ndency is to make the scripting language coo powerful, The next idea explains some\npitfalls of a complicated scripting language.\n\nIdea #5: When Good Scripts Go Bad\n\nUsing scripts to data-drive behavior is a natural consequence of the data-driven\nmethodology. However, you need to practice good common sense. ‘The key is remem-\nbering the core philosophy: Separate logic and data. Complicated logic gocs in the\ncode; dara stays outside.\n\nThe problem arises when the desire to data-drive the game goes too far. Ar some\npoinc, you'll be tempred to put complicated logic inside scripts. When a Script starts\nholding state information and needs to branch, it becomes a fmite state machine,\nWhen the number of states increases, the innocent scriprwriter (some poor game\ndesigner) has the job of programming. If the scripting becomes sufficiently complex,\nthe job reverts co the programmer wha must program in a fictional language that’s\nseverely limiting. Scripts are supposed ta make people's jobs easier, nor more difficult.\n\nWhy is it so important to keep complicated logic inside the code? Irs simply a\nmarter of functionaliry ane debugging. Since scripts are not directly in the code, they\nneed to duplicate many of the concepts that exist in programming languages. The\nnatural tendency is to expose more and more functionaliry until it rivals a real lan-\nguage. The more complicated scriprs became, the more debugging information is\nneeded to figure our why the scripts are filing. This additional informacion results in\nmore and more effort devoted to monitoring every aspect of the SCLIpL as it runs.\n\nAs you probably guessed, non-trivial logic in scripts can get very involved.\nMonths of work can be wasted writing seripr parsers, compilers, and debuggers. It's as\nthough programmers didn’t realize they had a pertecdy good compiler already in front\nof them.\n\n6 f Section 1 Programming Techniques\n\nThe Fuzzy Line\n\nThere is no doubr thar the line berween code and scripts is furry. Generally, irs a bad\nidea to put artificial intelligence (AT) behavior in scripts, whereas it’s generally a good\nidea wo have a scripted trigger system for making the world interactive. The rule\nshould be: If the logic is tao complicated, it belongs in the code. Scripting languages\nneed to be kept simple, so they don't consume your game (and all of your program-\nMing resources).\n\nHowever, some games are designed to ler players write their own AL Most com-\nmonly, these games are first-person shooters thar allow the creation of bots. When this\nis the goal, it’s inevitable thar the scripting language will resemble a real programming\nlanguage. An example of chis situation is Quake C. Since bot creation was a require~\nment of the design, resources and energy had to be put into maki ng the scripting lan-\nguage as useful as C. A scripting language of this magnitude is a huge commitment\nand shouldnt be raken lightly.\n\nAbove all, remember that you dont want your game designers or scriptwriters\nprogramming the game. Sometimes programmers are trying wo shirk responsibility\nwhen they create scripting languages. Irs all too easy to lure game designers into pro-\ngramming the game, Ideally, programmers should be boiling down che problem and\nexposing the essential controls in order to manipulate the logic. That's why program-\nmers get paid the big bucks!\n\nIdea #6: Avoiding Duplicate Data Syndrome\n\nIts standard programming practice to never duplicate code, If you need the same\nbehavior (for example, a common function) in nwo different spots, it needs to exist in\nonly one place. This idea can be applied to dara by using references to global chunks\nof dara. Furthermore, by caking a reference to a chunk of data and modifying some of\nits values, you end up with a concept very close ta inheritance.\n\nInheritance is a great idea that should be applied to your dasa. Imagine thar your\ngame has goblins thar live inside dungeons. In any particular dungeon, your data\ndefines where each goblin stands, along with its propertics. ‘The right way to encapsu-\nlave this data is to have a global definition of a goblin. Each dungeon's data simply has\na reference to thar global definition for every instance of a goblin. In order to make\neach goblin unique, the reference can be accompanied by a list of properties co over-\nride. This technique allows every goblin to be different while eliminating duplicate\ndara.\n\nThis idea can be taken to multiple levels by allowing cach chunk of data ro have a\nreference, Using this technique, you can have a global definition of a goblin along\nwith another global definition of a fast goblin thar inherits from the basic goblin,\n‘Then inside each dungeon definition, regular goblins or fast goblins can be instanced\ncrivially. Figure 1.0.1 shows this inheritance concept using referencing and overriding\nof values.\n\n1.0 The Magic of Data-Driven Design Tt\n\nFast Goblin Goblin Instance\n\nRisferense = Fast Gobi\nPasion = (3. 0.0)\nFuca = (1, 0, 0\n\nFIGURE 1.0.1. Data inheritance.\n\nIdea #7: Make the Tool That Makes the Data\n\nWith any large game, text files eventually become unruly and hard to work with. The\nreal solution is to make a cool chat writes the text files. Call this cool a game edivor, a\nlevel editor, or a script editor, but you'll speed up the game development process by\nbuilding the right tools. Having a tool doesn't change dhe data-driven methodology; it\nmerely makes it more robust and efficient. The time you save always makes the extra\ntool development ame worth it,\n\nConclusion\nnr\nIt's easy to buy into the data-driven methodology, bur it's harder to visualize the dra-\nmatic resules, When everything is daca driven, amazing possibilities unfold.\n\nAn example of this rule is the ame Total Annihilation. The designer, Chris Tay-\nlor, pushed data-driven design to the limit. Total Annihilation was an RTS thar fea-\ntured two distinct races, the Arm and the Core. Although the entire game was\ncentered on these two factions, they were never hard-coded into the game. Theoreti-\ncally, data could have been added to the Fame to support theee races, even after the\ngame shipped. Alchough this possibility was never exploited, ‘Total Annihilation tool\nfull advantage of iss flexibilicy. Since all unics were complerely defined by dara, new\nunits were released on a weekly basis aver the games Web site. In fact, many people\ncreated their own units with functionality thar shocked even the game's developers,\n\nThe data-driven design helped Toral Annihilation maintain a committed follaw-\ning in a crowded genre, Since Toral Annihilacion, other games, such as The Sims, have\nemployed the same idea by providing new data content over their Web sites. Without\ndevelopers’ serious commitment co the data-driven philosophy, this unprecedented\nexpandability wouldn't be possible.\n\n1.1\n\nObject-Oriented Programming\nand Design Techniques\n\nJames Boer\n\nIris easy to understand the popularity of C++ among game programming professian-\nals, While not straying coo far from the highly portable and efficient oot of C, it also\noffers the design benefits of an object-oriented language. Inherent in this power,\nthough, is the requirement thar C++ code be properly designed and implemented.\nAlthough the object-oriented programming (OOP) paradigm was created to enhance\nprogram design, portability, and maintainability, the brutal fact of the marter is chat\npoorly designed C++ programs can he worse than poorly written © programs.\n\nMany books and articles give good advice on general object-oriented design prac-\ntices; very few teach those practices with game programmers specifically in mind.\nGame programmers are a slightly different breed than the typical application pro-\ngrammer. Because their work is always expected to be cutting edge, pushing both\nhuman and hardware constraincs wo che limit, game developers tend to be much more\nwilling to bend or even break traditional programming design rules. Unforcunately,\nthis tendency often has the megative side effect of creating unmaintainable code due to\na poor understanding or implementation of basic OOF principles.\n\nAs games grow more and more complex, companies are looking to reuse more\nand more code to mitigate ever-increasing development coms. Engine licensing is\nbecoming more prominent as companies focus om content and game play and will\nundoubtedly grow into a major and separate support industry in the near future. This\nsort of development work requires much more stabiliry and long-term planning than\nwas previously known in the game development world. No longer is it acceptable to\ncompletely scrap your previous code with each new game.\n\nThis article obviously can't even begin to cover all thar a game programmer needs\nto know. Instead, ir identifies key areas in which a game programmer, and a company,\ncan take steps co improve the quality and consistency of production code, which will\nin turn lead co both more robust and more reusable libraries and game engines. We\nalso point you woward resources that much more thoroughly cover the copics dis-\ncussed.\n\n1.1 Object-Oriented Programming and Design Techniques 5\n\nCoding Style\n\n——————\nProgramming style can often degrade into a religious argument. I'm not going to\nenter the debacle of where curly braces should be placed, bur ir is imporant for a\ncompany to adopt a style, and for everyone in that company to use it.\n\nA company, not co mention an individual, should strive for consistency in class,\nfunction, and variable naming conventions as well. Many companies have ailopted a\nsimplified Hungarian notation scheme. The Hungarian notation was invented by Dr.\nCharles Simonyi, chief software archirect of Microsoft, years ago in order to help stan-\ndardize variable naming conventions. Some argue thar sich a naming convention is\nunnecesary in a type-safe language such as C++ and creates more work when chang-\ning data types (since it requires changing the variable prefix), but others appreciate the\nease and speed with which data types are visually identified.\n\nThe basic premise of Hungarian notation is to preface the variable name with an\nidentifier describing the rype of data che variable represents. For instance, an integer\nvariable named SomeVariable would instead be named iSomeVariable. In addition to\nvariable types, pointers can be represented. A pointer to some class Foo might be\ncalled pFoodbj. Prefixes can also be combined to provide more information than a\nsingle prefix can provide, For instance, a pointer co an integer would be represented\nby the prefix pi, ora pointer to a pointer would be represented as pp.\n\nOther types of scope information are often used in front of the rype prefix, Mem-\nber variables are labeled with a_, so an integer member variable mishe be labeled\na_iSomevar. Global variables (tsk, you shouldnt even really be using these) are repre-\nsented as g_, and some variations represent static variables as 5_, although this isn't\nseen as often. Although the formal Hungarian notarion can be somewhat complex,\nmany companies have adopted a simplified version of it. Table 1.1.1 presents an\nexample of a common variation on formal Hungarian notation. You can find other\ndescriptions in books such as [PerzoldG), or you can find Simonyi’s original paper on\nthe World Wide Web in various locations,\n\nThe most commonly used notational cypes are listed in the table. Objects are gen-\ncrally not given any prefix, with che exception of a few common classes such as those\nrepresenting 30 vectors and points. Your company might adopt eenventions for repi-\nresenting other commonly used utility classes as well, Note char most of the descrip-\ntive tags are quite logical and would mot require you to look them up ina table.\n\nThe exact syntax you adopr is not as impertant as the relarive consistency af\neveryone who conforms to it. If all company code looks similar, ir will be easier for\nprogrammers to work on code that they might not have written.\n\nOne word of caution: Don't over-engineer a coding specification. A page or rwe\nshould really be all that’s required eo describe che company style. IF programmers have\nto look up how a variable should be named, they'll be far less likely to use che stan-\ndard. [ hesitate to recommend stricdy adhering to SIMONV'Ss Original system. It's far\ntoo complex for day-to-day operations, and since readabiliry is now more important\n\nSection 1 Programming Techniques\n\nee ee ee\n\nTable 1.1.41 An Example of Hungarian Notation\n\nge es |\nJ Inteper\n\nFE Float\n\nD Double (float)\n\nL Long (integer)\n\ntC (Character\n\nE Boolean\n\nDw Double word\n\n8) Word\n\nby or byte Byte\n\nv\n\n; Costyle (null-cerminated) string\nCommon Extensions Description\n\nStr C++ string object\n\nH Handle (user-defined type)\nV Vector (useralclinad class)\nrh Point (user-delined class)\nReb RGB oiplee (user-defined struct of type)\nModifier Description\n\nF Paincer to\n\nR Reference to\n\na Unsigned\n\n4 oF ary Array of\n\nScope Description\n\ntm_ Member varnable\n\n£ (sbobal variable\n\n& Stacie variable\n\n=\n\nthan type safery, there's no reason to create hard-to-read ende when a simplified ver-\nsion will work just as well.\n\n(Class names should also be designed for ease of maintenance and readability. A\nconvention that has gained some popularity among Windows programmens is the use\nof class prefices ro indicate general design intent. Classes beginning with the lemer C\nare designated as Conerete clases, or classes with a specific use and implementation.\nClasses beginning with the letter are Jnterfiece chares, or classes intended to be used as\ndesign templates. These classes are not used direcily by applications; instead, chey\nallow other classes to be derived from them.\n\n1.1 Object-Oriented Programming and Design Techniques 41\n\nIn addition to or instead of these class prefixes, it can also be helpful to prefix\nclasses by functionality. For instance, alll classes dealing with a user interface (UI) sys-\ntem can be prefaced with OY. This is especially helpful in programming environments\nand tools thar sort classes in a project alphabetically.\n\nClass Design\n\n(C++ classes offer an unlimited amount of design flexibility, which can be both a good\nand a bad thing, There are no naming requirements, other than for your constructor\nand your destructor. However, you might want to self-impose a standandized class\nnaming convention. Here is a simple example:\n\nclass Sample\n\n{\n\npublic:\nSanpla() { Glaar();\n—Sanplai) { Destroy(}; }\n\nvoid Clear);\n\nbool Greate();\n\nvoid Update[):\n\nyold Destray():\n}i\n\nThe first thing you'll notice about this class is the trivial constructor, Implement-\ning classes this way isa good idea for 4 number of reasons. To start with, the C44 con-\nstructor has no return value. Therefore, it's simply nota pood idea ro do anything that\nmighe fail. So instead, we simply call Clear(), a fumetion diac clears out all the inter-\nnal member variables, The benefit of clearing variables in a separate fanction is that it\nallows you to clear the class variables at any time. You'll see why this is especially\nimportant later.\n\nAt times, you won't want to “activate” a class che moment it is created. This often\nhappens for wrapper classes that are themselves members of another class. Lastly,\nthere is an efficiency issue, Divercing the object's actual creation point from che con-\nstructor allows you to dynamically create an object once burt repeatedly call the cre-\nate() and Destrey() members to reuse che same object's memory. Dynamically\nallocating memory is expensive, so when possible, ir’s best to avoid doing so. As men-\ntioned, the Create() and bestroy() members do che work of actually creating and\ndestroying whatever ic is the object represents. The Creste(} function has a simple\nbool value for indicating success or failure. This value is both intuitive and easy to\nimplemenc. Another popular choice of return type is standardized exror code rypes\n(usually signed integers). Bools are casy ro use buc require additional errorquerying\nmechanisms if return codes are not provided. Exception handling, alchough theoreti-\ncally superior tte simple return vilues, cemds to be both expensive in Muno-time perfor-\n\n12 Section 1 Programming Techniques\n\nmance and easy for programmers to overlook. In addition, exception handling is nat\nself-documenting, as error codes or return values are in header files,\n\nThere is also an importance caveat for the Deatroy() function. Since we want bath\nthe convenience of automatic cleanup and the Nexibility of “destroy and recreate on\ndemand,” we need to make sure that the Destrey() function can be called multiple\ntimes safely or withour the Create(} function having been called, Be sure to call the\nSlear() funetion at the end of your destroy function in order te reser all the object\nvariables back to their initial states.\n\nGame programming often means programming a real-time system instead of the\nmore commen event-based programming model found in most commercial applica-\ntions. We might want co recognize chis difference in our class designs. The last por-\ntion of the class is the Update() function. This is the “step” function, or the function\nthat gets called once every frame. [t's a big help to agree on a common name for this\nfunction. Depending on che class, you might or might nec want to implement the\nVadate() function with a bool repurn value to allew for checking of nun-cime errors in\nthe step function,\n\nClass Hierarchy Design\n\nKnowing how to make the most of class reuse through inheritance is a key factor in\nobject-oriented programming. Although a complete discussion of relationships\nbetween objects and how to implement them is beyond the scope of this article, there\nis a single design rule chat is of such importance thar it bears brief mention.\n\nThere are two primary methods of extending classes co work with each other:\ninheritance and layering. Jsheritance, of course, is deriving one class from another\nLayering is when one object is contained as a member of another object. Layering is\nalso known by such terms as composition. containment, and enabeadding.\n\nThe simple rule is this; fan object has an i-a relationship to another object, use\npublic inheritance. [fa Aws-a relationship describes the abjects best, then use layering.\nWhat exactly do the terms ir and Aar-a mean? Pretty much exactly what they sound\nlike. If we use them in a sentence, the meaning becomes clearer:\n\nClass Corvette fit type of class Car.\nClass Corvette Ata type class Radio.\n\nWhen deciding how to relate classes to cach other, it’s often helpful to actually\nspeak the two relationships out loud. More often than noe, the correct answer simply\nsounds correct.\n\nDesign Patterns\n\nWhen creating a solution to a common programming problem, most developers\nunconsciously refer to a similar problem chat they have solved previously and then",
      "page_number": 1,
      "chapter_number": 1,
      "summary": "The logic\ndefines the core rules and algorithms of the game engine, while the dara provides che\ndetails of content and behavior Key topics include classes, games, and design.",
      "keywords": [
        "game",
        "Design",
        "Steve Rabin Games",
        "Programming",
        "Design Steve Rabin",
        "game designers",
        "code",
        "data",
        "Programming Techniques",
        "Idea",
        "che",
        "game programming",
        "thar",
        "Scripts",
        "data-driven design"
      ],
      "concepts": [
        "classes",
        "games",
        "design",
        "designated",
        "programming",
        "program",
        "code",
        "coding",
        "variables",
        "variable"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 2,
          "title": "Segment 2 (pages 19-41)",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        },
        {
          "book": "Data-Oriented Design",
          "chapter": 1,
          "title": "Data-Oriented Design",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 1,
          "title": "Segment 1 (pages 1-18)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 42,
          "title": "Segment 42 (pages 849-853)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 55,
          "title": "Segment 55 (pages 530-540)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 11-18)",
      "start_page": 11,
      "end_page": 18,
      "detection_method": "topic_boundary",
      "content": "1.1 Object-Oriented Programming and Design Techniques 13\n\nextrapolate the new solution from che old. Design patterns are about formalizing\nthese general software solutions co give a. common frame of reference when discussing\neveryday engineering tasks, A number of design patterns are described more thor.\noughly in other books, but here we discuss parterns mast commonly used by and rel-\nevant to game developers.\n\nThe Singleten Pattern\n\nThe singleton pattern is used when a single global object must be accessed across a\nwide number of classes and/or modules. Simply creating a mon-local static object\nworks, but there are many problems inherent with that practice, noc the least of which\nis determining when the object will actually be created, compared with other objects\nwith the same global scope requirements. The singleton pattern solves this problem\nby foreing access chreugh a class, which stores a static object internally. Here's whar a\nbasic implementation might look like:\n\nClass Singleton\n\npublic:\nSingletoni& Instances}\n{\n\nStatic Singleton Obj;\nreturn Obj;\n\nprivate:\nSingletont()};\n\na\n\nThis simple cede solves the problem quite elegantly. However, if you want to\nderive new classes from this one, you'll be hard pressed ta come up with as elegance an\nemtension. By changing the design and requiring more specific intervention during\nobject creation and deletion, though, we can expand on the basic singleton concept\nand allow extensibility to our original class:\n\nclass SingletonBase\n{\n\npublic:\nSingletondage/ |\n{ cout << “Singletonfase created!\" << end): }\nVirtual =5ingletongasea i )\nq Gout << \"Singletondase destroyed!\" << endl; }\nWittual vold Ageass()\n{ Gout << \"SinglotonBase accessed!\" << endl: 3\nStatic SingletonBase* Getobj()\n{ heturn @pohy-- }\nStatic vold SetObj(SingletonBasa* pObj)\n{ mpObj = pooj; }\nprotected:\nStatic Singletonfase* m poh];\nhi\n\n14\n\nSection 1 Programming Techniques\n\nSingletonBase* SingletonBase::m_ pony:\n\ninline SingletonSase\" Base()}\n\n{\naseert(Singletonbase: :Gebobj i);\nreturn SingletonBase: :Getob)();\n\n}\n\nff Create @ derived Singletan-type class\nclass SingletonDerived : public SingletoaBage\n\n{\npublic:\nSingletonberived( )\n{ cout << \"SingletonDerived created!” << endl; }\nvirtual -SingletenOerived()\n{cout << \"SingletonDerived destroyed\" << endl; }\nvirtual woid Access(}\n{ cout << \"SingletonDerived accessed!\" << endl; }\nprotected:\n};\ninline Singletonfarived\" Derived()\ni\nassert(Singletonberived: :aetdh] dhl;\nreturn (Singletonberived* )SingletonDerived: :GetObj ();\n}\n\nfy Using the coda...\n\ni} The complex singleton raquires more work to use, but is\nff gore Ttlaxible. It also allows mora control over object\nif creation, which is sometimes desirable.\nSingletonDerived: :Sat0bj(naw Singletonterived) ;\n\nI! Notice that the functionality has been overridden by the new\nii class, even though accessing it throewgh the original method.\nBase()-=Access();\n\nDearived(}-*Access( }j\n\nif This variation on a singleton unfortunately requires beth\nff explicit creation and deletion.\ndelete SingletonDerived: :Getobj();\n\nThis modified form of the singleton class is not quite as simple in the construc-\ntion and destruction phases, but the plobal access, which is the primary point of the\nsingleton, remains as accessible as ever. Furthermore, with the addition of inline\naccessor functions, the code becomes quite easy to read from the user's perspective.\n\nSingleton patterns are often used in situations in which you traditionally might\nthink of using a global object or pointer to reference a single instance of a class, An\nexample might be a manager-cype class, where only a single instance (thus, the mame\nof the partern) is required. Classes thar manage an application's sound, a wser inter-\nface, graphics, of even the game or applicarion inself are all likely candidates to\nbecome singleton-type classes.\n\n1.1 Object-Oriented Programming and Design Techniques 15\n\nSo, why go vo all chis bother instead of simply creating a global object or pointer?\nThere are a few great reasons. First, if you were planning on creating global objects,\naccessing an object through 2 single function is easier than having to extern a global\nobject in all your files. In addition, you gain the benefit of controlling exacely when\nyour object is initialized. Second, if you're using a pointer instead of an object, you\ngain C++ control over every access of the object, meaning that you gain benefits of\naccess control, in turn meting that you can do things such as monivor every time the\nclass is accessed. Finally, if you create your singleton with dertved clases in mind\nusing the techniques described, you can extend your base class while maintaining\ncompatibility with the existing base class. Let's examine how this mighe work,\n\nIn order to make che most of this sort of extensibility, you can imapine a scenario\nsuch as the following: Library A utilizes a singleton class, as described previously.\nLibrary B must use Library Ain order to function, so it is dependent on those classes\nand includes their header files. Application C makes use of both Libraries A and B but\nrequires changes to be made to Library A for some game-specific items. Instead of\nhaving to create a new version of the library (and lose any improvements made to the\noriginal library by, say, a concurrent project), Application C can simply derive a new\nclass (Class D) from Library A. If, as part of our singleton convention, we require char\nthe application is responsible for allocating the object, we can subscinute derived Class\nD for Class A. By creating a mew accessor function with a new name thar remurns a\npointer to Class D instead of Class A, we can access all of D's new functions. How-\never, Class B will continue to use the old accessor function thar returns a pointer to A\nand so will expect the old functions to function similarly co the way they did before.\nNore that virtual functions behavior can be overridden, but you must ensure chat the\nnew functionality is compatible with the old to preserve backward compatibility.\n\nIn this way, the singleton pattern allows you co create a primitive library version-\ning scheme. You can sec how a simple technique can evolve inte a powerful mecha-\nnism for code organization and reuse. You can find in chis book another variation of\nthe singleton pattern in the article “An Automatic Singleton Utility.” by Seo Bilas.\nIn this article he describes an elegant method of using wemplares and public inheri-\n\ntaNce to automate the creation of singleton classes.\n\nFagade Pattern\n\nThe singleton segues nicely into the next partern we'll investigate: the japsde parters.\nThis pattern is generally used as what is often referred to as a manager claw. This is a\nclass that provides a single interface to a large collection of relared classes, usually\nsame sort of subsystem. These classes are often designed as singletons because it usu-\nally makes sense vo have only onc manager object per cype of subsystem, For example,\nyou need only a single object to manage access to pour audio or graphical user inter-\nface subsystems.\n\nA facade or manager is necessary in order to keep interdependencies berween\nclasses, otherwise known as coup/ing, to a minimum. One can imagine in a theoretical\n\nSection 1 Programming Techniques\n\nSubsyetern|\n\nFIGURE 1.7.17 An cram ple of bad coupling.\n\nworst-case scenario thar every elass in a project “knows” abour and requires explicit\naccess to every other class, as illustrated in Figure 1.1.1. The maximum number of\ninterdependencies berween classes can be described as (n-1?, where nis che number of\nClasses IN a project.\n\nThe problem with this sort of interdependency comes when an entire subsystem\nneeds to be heavily modified or even replaced. Object-oriented programming protects\nagainst implementation changes within single classes, but a new paradigm is needed\nfor protection against more sweeping changes. The facade pattem solves the same sort\nof problem thar object-oriented programming protects against, bur on a much larger\nscale.\n\nThe general rule of thumb when implementing facade classes is this: Whenever\npossible, avoid exposing internal subsystem Classes to outside systems. This is not\nalways possible to do entirely, but with some clever coding and function wrapping,\nyou can reduce the exposure of these classes a great deal, as illustrated in Figure 1.1.2.\nEvery class you hide means that there is bess work to be done the next time that sub-\nsystem has to be reimplemented.\n\nState Pattern\n\nAlmost every game programmer has had to deal with the problem of keeping track of\nconstantly shifting game states in real time. States usually stare out as simple enumer-\nations, and behavior is implemented based on switching between states in a switch\n\n. case sermcture. Problems cin develop, however, when the number of states starts\ngrowing larger and functionality must be shared in a greater number of these states. A\ncur-and-paste nightmare can quickly ensue, wherein the programmer tries to find all\nthe stares that share code and make sure that any changes to one state occur in all of\nthem.\n\n1.1 Object-Oriented Programming and Design Techniques 17\n\nSebsysiem]\n\nFIGURE 1.1.2. Using fagade classes to reduce interdependencies.\n\nA more elegant object-oriented solution is to simply use objects to represent logi-\ncal stares. The advantages of using objects are that states are better encapsulated, states\ncan logically share code in their base classes, and new stares can easily be derived from\nexisting ones using inheritance, These advantages reduce the typical problem of hav-\ning 00 cut and paste code between discrete states, as shown in Figure 1.1.3.\n\nAlthough the pattern does mot specify how state ransitions are to be made, it can\noften make sense to leave the transitions of classes to a central manager. In this man-\nner, inter-abject dependencies can be avoided, leaving only the manager te worry\nabout having to know all the different stare objects. Better yet, the stares can simply\nbe enumerated and created through the use of a factory object, which is explained in\nthe next section,\n\nThe state pattern does not necessarily have to be used only to represene discrete\nfame states, Tt can also be used in Al systems or even co represent different types of\ngame modes within a single game. By representing each game mode as a different\nobject, for example, you gain the flexibility of allowing new behavior to be added after\n\nooo ——— OnEnteri}\n| StateManager BaseState Update()\nDynamicallyswotches\nbrtweenstate\n\n1\n1\nobjectuinreal-time\n1\n1\n1\n\nStatel | State® | |} Stared\n\nFIGURE 1.1.3. Using che state parmem.\n\nSection 1 Programming Techniques\n\nthe initial release through the use of dynamic link libraries (DLLs) or other means of\nadding an object to existing code dynamically.\n\nFactory Pattern\n\nThe factory pattern deals with organization in the creation of objects. A form of the\npattern is defined as a method for allowing abstract interface classes to specify when ro\ncreate concrete, derived implementation classes. This method is fren required in\napplication frameworks and other similar clase hierarchies, However, came program-\nmers Often deal with a specific subser of the factory parrern—namely, the use of fac-\ntory objects with enumerated object creation lecated in a cencral class, usually via a\nsingle-member function.\n\nIn Englich, this means thar a single object is responsible for creating a wide vari-\nety of other objects, usually relarecl by a common base class, This class often tales the\nform of a class with a single method that accepts some sort of class ID and returns an\nallocated object. The advantages of clustering object allocation inte a single location\nare especially noteworthy for eame developers:\n\n* Dynamic memory allocation ig expensive, so you want to carefully monitor allo-\ncations. Allocating all objects in a central area makes it easier to monitor these\nallocations.\n\n* Olten, common initialization or creation methods must be called for all objects\nwithin a class hierarchy. If all object allocation is put into central area, ir\nbecomes easy to perform any common operations (such as inserting chem into a\nresource Managerjon all objects,\n\n* A factory allows extensibility by allowing new objects to be derived from the\nexisting factory. By passing in a new class ID (which can easily be obtained from\ndata instead of code), you can provide run-time extensibility of new classes with-\nout changing the existing base code.\n\nThe final point stresses extensibility as a henefic of using the factory pattern. For\nthis reason, creating simple functions ot static dasses should be avoided, since you\ncannot derive mew classes from chem:\n\nBaseclass* ClassFactory::CreateObject (int in)\n{\n\nBasellass* pllass = 0:\nswitch( id)\n{\n\nCase i:\npClass = n@w Classi;\nbreak;\n\nCHSe 2:\npClass = new Class;\nbreak;\n\nCage 2:\nPClase = new Class3;\nbreak;\n\n14 Object-Oriented Programming and Design Techniques 19\n\ndefaults\nassert(!\"Errort Invalid class ID passed to factory |\");\n\n/f perhaps perfors some comian initialization is heeded\npPClass->Init():\n\nréturn pilass:\n]\n\nYou can see thar chere is technically nothing sophisticated about a factory creation\nmethod. However, centralizing these object allocarions provides a powerful organiza-\ntion and extensibiliry mechanism.\n\nFactory patterns are used whenever large numbers of different objects within an\nobject hierarchy must be dynamically created at run time. This can include Al\nobjects, resources such as textures or sounds, or ever. more abstract objects such as\n\ngame states (as in the previous discussion).\n\nSummary\nee\n\nDeveloping good object-oriented techniques is not an end in iwelf. It should pervade\nevery aipect of your code, which will save you ime and trouble in the long run. Well-\nwritten object code is more flexible, more maintainable, and more extensible than\nprecedural code. Game programmers have not adopted a complex new languape and\nceding paradigm for their personal entertainment; there is a method to their madness.\n\n‘There are several references listed at the end of this article. Do yourself a favor\nand immediately pick them up if you don't yet own them. They are indispensable\ntools in learning the finer points of both object-oriented programming and C++ lan-\nFllage Usage in peneral.\n\nReferences\n——\n\n[(Gamma‘)4] Gamma, et. al., Dene Patterns, Addison-Wesley Longman, Inc, 1994.\n\n[Mcyers98] Meyers, Soom, Affective C+, second edition, Addison-Wesley Longman,\nInc., 1998.\n\n[Meyers96] Meyers, Scot, More Bifectine Ces, Addison-Wesley Longman, Inc.,\n1595,\n\n[Perzold96] Perzold, Charles, Programming Windows 95, Microsoft Press, Inc., 1996.\n\n1.2\n\nFast Math Using Template\nMetaprogramming\n\nPete Isensee\n\nWhen programmers think of C++ templates, they usually chink of things like the\nSTL, generic containers, and type-safe macros. Most programmers are unaware chat\ntemplates can act as virtual compilers, creating tremendously optimized code in rerms\nof both speed and size. This unforeseen quality of templates was first noticed ly\nErwin Unruh in 1994. He presented the C++ Standards committee with a template\nprogram that didn’t compile but instead coerced che compiler into generating a list of\nprime numbers in its error messages [Veldhuizen)9].\n\nThis discovery led a number of language experts to focus on che use of templates\nas precompilers, Todd Veldhuizen and David Vandevoorde ereathy expanded on this\ncapability, showing char virtually any algorithm could be templatized, provided the\ninput parameters to the algorithm were known at compile time [Veldhuizen 5).\nGiven a good compiler, intermediate code can be completely optimized away, result-\ning in extraordinary efficiency.\n\nThe best way to see this in action is to consider a simple example.\n\nFibonacci Numbers\n\nThe Fibonacci sequence looks like this: 0, 1, 1,2, 3, 5, 8, 13, .... The general equation\nfor the sequence is Fib(n) = Fib(a-1) + Fib(n-2). A typical function to recursively gen-\nerate Fibonacci numbers is as fellows:\n\nunsigned RecursiveFibl unsigned nm }\n\niff a= 1}\nreturn ni\nréturn RecursiveFib( n-1 } + fecursiveFib( n=-2 )3\n\n}\n\nBelieve it or not, this simple function runs in exponential time. Ir's highly ineffi-\ncient and should never be used in production code. The function is simply a step-\nping-off point for generating a templatized version:",
      "page_number": 11,
      "chapter_number": 2,
      "summary": "This chapter covers segment 2 (pages 11-18). Key topics include object, classes, and singleton. The Singleten Pattern\n\nThe singleton pattern is used when a single global object must be accessed across a\nwide number of classes and/or modules.",
      "keywords": [
        "object",
        "classes",
        "singleton",
        "Pattern",
        "Object-Oriented Programming",
        "singleton pattern",
        "Programming",
        "Design Techniques",
        "Programming Techniques",
        "Techniques",
        "code",
        "access",
        "singleton class",
        "single",
        "states"
      ],
      "concepts": [
        "object",
        "classes",
        "singleton",
        "state",
        "accessed",
        "access",
        "creating",
        "create",
        "code",
        "coding"
      ],
      "similar_chapters": [
        {
          "book": "A Philosophy of Software Design",
          "chapter": 9,
          "title": "Segment 9 (pages 68-76)",
          "relevance_score": 0.61,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 12,
          "title": "Segment 12 (pages 225-246)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Effective-Python",
          "chapter": 24,
          "title": "Segment 24 (pages 241-248)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "AntiPatterns",
          "chapter": 4,
          "title": "Segment 4 (pages 30-37)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "A Philosophy of Software Design",
          "chapter": 10,
          "title": "Segment 10 (pages 77-87)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 19-28)",
      "start_page": 19,
      "end_page": 28,
      "detection_method": "topic_boundary",
      "content": "12 Fast Math Using Template Metaproegramming ai\n\ntemplates unsigned N > struct Fib\n\n{\nGnhiun\n{\nif Recursive definition\nWal = Fibs W-1 >;;Val + Fibs W-2 =::Wal\n};\n\nff Specialization for base cases\n\niy (termination conditions)\n\ntemplate <> struct Fibs 0 > { enum { Val =\ntemplate <> struct Fibt i» { enum { Val =\n\n=o\n— i\n\nfi Make tha template appear like a funotion\n#define FibT( m ) Fibt nm =2:Val\n\nAn example “call” co the template via the define:\n\nStet rGoue «x FAT, 4 py fy Fibt 4 *isVal\n\nSome important things co nore about the cemplatized version are as follows:\n\n* ‘The template function is not really a function ar all—ir's an enumerated integer\ncalled Val, recursively determined at compile time. The notation Val = Fib<N-\n1>2:Val + Fib«N-2>::Val is uncommon bur valid C++ synraw.\n\n* Fib is defined as a struct to simplify the notation. Seruct dara is public by default,\nwhich is exacthy what we want. Similar nocartion is used for all the following code\nlistings.\n\n* ‘The template parameter WW is used to specify che function input. This is an uncorm-\nmon but perfectly acceptable use of template parameters. For example, std::bit-\nseten> uses the numeric value Wi as its template parameter to define the number of\nbits represented. This numeric parameter must be known at compile time. Call-\ning FibT(i) when i is a non-const variable will generase a compiler crror.\n\n* To terminate the recursion, you must handle the base case properly. For Fibonacci\nnumbers, the base case is when N is zero or onc. With templares, che way to han-\ndle base cases is with templare specializacion. The notation tenplate<> indicates\na specialization. When W is zero or one, Val = W.\n\nWow comider how a compiler might evaluate FabT (4p:\n= Fibté=: i Val\n\nFibctie::Val 4 File: Val\n\nFibtze: Vel + Fibei>::Val + Fib<issival + Fib<0>::Val\na\n1\n\nFibti>; iVal Fifbete: Wal + 1+ 14-0\n1* 0 + 7+ + 0\n4\n\n'\n\na2 i Section 17 Programming Techniques\n\nSince all inputs are known at compile time, a compiler can reduce FibT(N) ta a\nconstant. In other words, the compiler can produce exactly the same code ax though\nyou had written:\n\nStd: scout << 37 Jf Fibs}\n\nThis is an amazing rool to have in your C++ tool kit, It’s not every day you can go\nfrom eponential rr time to constant run tine, With template metaprogramming, the\nprice you pay is additional compile time instead of additional execution time. For\ngames, execution time is usually more critical than compile time, so this technique is\nvery appealing.\n\nFactorial\n\nHere's another example of turing a standard function into a cemplatized version.\nFirst, the standard (C++ version for reference:\n\nunsigned RecureiveaFact( unsigned n }\n\nreturn {(f == 1) 7 0: {n * RecursiveFact(n - 1))):\n}\n\nAnd the template metaprogram version:\nfl Templatized tactorial(n)\ntemplate= unsigned NW > struct Fact\n{\n\nhi\n\nanum { Val = N* Fact= N - i >::¥al };\n\nff Specialization for base case\nTemplate <= struct Fact< 1 >\n{\n\nenum { Val = 4 }:\nIi\n// Make the template appear like a function\nHdefing FactT( nm ) Faet<= f =:: Val\n\nAAs in the Fibonacci example, the compiler can reduce a “call” such as FaetT(4) to\nthe constant 24. We've gone from linear run time to constant ran time. That's a pow-\nerful argument for using metaprogramming, There are two drawbacks: a compile-\ntime pesialey, which is typically insignificant, and a code readability penalty, which\ncan usually be hidden by a well-defined macro such as FactT(n).\n\nLet's step back for a momenct. Template metaprogramming is compelling and\nundeniably efficient, but not many games require a Fibonacci sequence or factorial\nnumber generation. Even if they did, it’s not likely chat the code will know the\n\n12 Fast Math Using Template Motaprogramming 23\n\nrequired input parameters at compile time. Is this just a meat C++ party trick, or is this\nsomething that's actually useful?\n\nTrigonometry\n\nTime for a more complicated example. Let's take on the sine function. Many games\nuse sine tables or a similar method for fast ong calculations. What if we could make\nthe compiler read something like x = sie(].234) and generate a single move insmruc-\ntion? Template metaprogramming to the rescue!\n\nGenerating standard trig functions involves using a series expansion. For sines,\nthe expansion looks lilee this:\n\nsime(x) =x — (x9 / 3) + (SI — (xe he GEO...\n\nwhere xis in radians, 0< =x < 2m. To compute the cerms efficiently, we can rewrite\nthe expansion:\n\nsine(x} =x * rerm{O)\nwhere rr(z) is computed recursively as:\nterm(a) = 1 —x° f (2e4 2) / (2+ 3) * cerm(ael)\nYou can write this expansion without templares as follows:\nGouble Sine double fAad }\nconst int iWaxTerms = 10;\n\nroturn Thad * SineSeries( tAad, 0, iMaxTerms );3\n\ndouble SineSeries( double ffad, int i, int iMaxTerns }\n\n{\nif{ i = iMaxTeras }\nraturn 1.0;\nreturn 1.0 — ({ fad * fead / (2.0 \"i +2.0) / (2.0 * £ + 3.0)\n* GingSeries( fad, i + 41, iMaxTeras } };\nI\n\nIncreasing iWaxTerms improves accuracy at the expense of run-time speed. It's nor\ndifficult to convert this to a templatized version. The solution is presented in Listing\n1.2.1, The solution uses two template objects: Sine<A> computes A * term(G) and\nSerios<A, I» compures ferm(l) recursively out ta the number of terms specified by\nWaxTerms. With the template metaprogramming version:\n\ndouble x = SineT( 1.234 }:\n\nthe compiler can theoretically generate the same code as though we had written:\n\ndouble x = 0.4395 1820837463368:\n\n24 Section 1 Programming Techniques\n\nThe actual value of stm('J.234) is 0.94381820937463370..., so the template ver-\nsion, which evaluates 10 terms, is accurate to approximately 15 decimal places! With-\nout much effort, we have a solucion in which we can get sines for free (ie., constant\ntime) by using the compiler as the workhorse. We don't have to compute a table ar\nrun time or embed a table in our executable, because the compiler can pemerate the\ntable entries we need (and oaly the ones we need) ar compile time,\n\nCompilers in the Real World\n\n‘There's potentially a big problem with template metaprogramming. Many compilers\navailable today (circa 2000) can't reduce the recursion and mathematics involved with\ncomplex templare-based algorithms. In the sine example, evaluating the series expan-\nsion to 10 terms requires the eampiler to reduce approximately 20 floating-point\nmultiplications, 50 integer multiplications, 20 FP divides, 10 EP subtractions, and 10\nrecursive calls down to one of nwo move instructions, Cova a compiler do tha? OF\ncourse. Shen a compiler do that? Probably, given ample resources (RAM and time}.\nWella compiler do char? It depends.\n\nT tested the preceding examples using Microsoft Visual C++ 6.0. VC6 did a splen-\ndid job with the Fab and factorial templates, producing single move instructions for\neach. It had more difficulty on the sine template, generating code thar is inferior even\nto the C run-time sin() function! By default, WC6 was able to unrall che recursion to\nonly cighe levels, and it hardly optimized the arithmetic ar all. Using the ViC6-specific\nFpragmas inline_depth(255) and inline _recursion(on) allowed ViC6 om unroll the\nrecursion complerely and optimize away all the math, so fortunarely, good results are\nstill possible.\n\nThe moral of the story is char all optimizations are guilty uncil proven innocent.\nExamine the code produced by the compiler, and evaluate che performance before\nand after templares are introduced as an optimization. You might need ta weak some\ncompiler flags to ger the results you want. In the future, expece compiler writers to\nfocus more heavily on template optimization and templace metaprogramming itself\nIn the meantime, program softly and carry a big profiler.\n\nTrigonometry Revisited\n\nGiven that C++ compiler technology is sill immacure when it comes to dealing with\npemiplares, is there anything we can do to improve our chances of the compiler doing\nthe right ching? Listing 1-2.2 shows another amempt at the sine funetion, The recur-\nsion has been removed and the series expansion is inline out to 10 terms. We're down\nto 12 multiplications, 21 divides, and 10 subtractions. We've also eliminated the tem-\nplate specializacion since it’s no longer needed.\n\n1.2 Fast Math Using Template Motaprogramming 25\nne ee we ee\n\nThe resulting function is a bit easier to handle, from both a readabiliry standpoint\nas well as a compiler ssandpoint. Indeed, ViOG has an easier ime with this version.\nThe special #pragnas are no longer required for the compiler to generate a constant.\n\nAt this point can we clearly see the benefits and drawbacks of the rechnique. Tem-\nplate metaprogramming can generate massive speed improvements—sometimes, but\nnot always.\n\nTemplates and Standard C++\n\nNot many compilers are completely compliant with the C++ standard, especially\nwhen it comes to templaces. Templates are so flexible and powerful, compiler wrirers\nhave a tough job getting them right. In no place is this more apparent than Visual\nC++, which was slow to adopt templates in the first place and slower still to conform\nto the standard. For example, V6 does mor support partial specialization, making the\nspecialized versions for many of the templase functions more complicated and less\ngeneric than they need to be.\n\nMuch more important, however, is the support or non-supporr of flaating-point\ntemplate parameters. The sine template functions in Listing 1.2.1 and Listing 1.2.2\nuse a floating-point template parameter for the incoming radian value. However,\naccording to the (l++ standard, “a non-type template-parameter shall not be declared\nto have floating point ... type.” In other words, on a conforming compiler,\n\ntemplates double A » struct Sine // compiler errer\n\ngives an error message. The solution is to use a reference parameter instead:\n\ntemplates dowble& R > struct Sine |/ Ox\n\nInterestingly and unfortunately, Visual Ce+ 6.0 support: floating-point types as\ntemplare parameters but does mar support references as parameters, It has things com-\nplecely backward! To use the sine template code on conforming compilers, change\ndouble A to doubled R.\n\nMatrices\n\n——_—————— EE EE\nWhere template metaprogramming really comes into its own is the handling of\nmatrix operations. Three-dimensional games heavily use matrices, Templatizing key\nfunctions can generate noticeable speed improvements. In che following section, we\nuse templates to improve initializing, transposing, and multiplying matrices.\n\nSection 1 Programming Techniques\n\nIdentity Matrices\n\nThe idensity matrex contains elements whose values are zero, with the exception of the\ndiagonal, which contains ones. We begin with a typical implementation. Norte the\nembedded for loops:\n\nmatrixaasé matrixss: :identity()\n\nfor (unsigned ¢ = 0; c <= 9] err}\nfor (unsigned r= 0; r= 3; ree)\ncoli cif r] = (cr)? 1.0 = O00;\nreturn *thia;\n\nThe template metaprogram version is shown in Listing 1.2.3. The parameters for\nthe template version include the manrix utx, the size of the matrix N (a square matrix\nis assumed), the current row Rand column C. Ar every iteration, we evaluate the next\nelement of the matrix.\n\nThe key thing to notice is the method by which we loop over the columns and\nrows. Ar each step in the algorithm, we know 1, which simply goes from 0 to m\nsquared. Given I, we can compute the current row by taking 1 modulus w. For exam-\nple, ifm is 3, the row sequence would be: 0, 1, 2, 0, 1, 2.0, 1, 2. 0. The current col-\numn is I divided by N mod Ww. LEN is 3, the colurnn sequence would be 0, 0,0, 1,1, 1,\n2, 2, 2, 0. The template specialization terminates the algorithm when 1 reaches N\nsquared. Now we can replace the original version with:\n\nmatrix33& matrixdd: sidentity )\n{\n\nIdentitylttxT( matrixds, “this, 3 )-\nraturn \"this;\n\nThe compiler can expand che new version to:\n\nmatrixdg& matrixdd: :identity()\n\n1\neol[ © ][ 0 J = 1.0;\neol[ O ][ 1] = 0.0;\ni\neol] 2 J[ 1] = 0.0;\neolf 2 ][ 2 ) = 1.0;\nreturn “this;\n\n}\n\nIn other words, the compiler can compdetedy somrodl the foop. OF course, we could\nhave unrolled che loop ourselves, but the template version is a general solution, It will\nwork for square marrices of any size (provided you include the specialization). For\nexample, the code for 44 matrices would look like:\n\nmatrinéad matrix44: identity!)\n\n1.2 Fast Math Using Template Metaprogramming 2?\n\nIdentityltxT( matrizd4d, “this, 4 4):\nreturn \"this;\n\nMatrix initialization\n\nWe can create templarized initialization code by using che same technique we used in\ngenerating the idencity marrix. In fact, the only line that needs to change in Listing\n1.2.3 is the line thar determines each marrix clement value:\n\nmel GL A] = € C =A) Tf 1.0! 0.0: fF identity matrix\nwhich is replaced by:\n\nfix], © IL R ) = 0.0; Fi zero matrix\nor more generally by:\n\nmtx[ C IL R ] = static _cast< F =( Init }; s/ init matrix\n\nwhere F is the cype of value stored in each element and Init is 2 numeric template\nparameter thar defaults to zero. The general solution allows you co easily initialize\nmatrix elements to any constant value.\n\nMatrix Transposition\nTransposing a matrix flips the matrix using the diagonal as che axis:\nRatrixag& matrixda: :transpose()\nTor (unsignéd c = 0; c =< 3: cee}\nTor (unsigned r =o +1; fF = 3s r++\netd: :swap{ col[ c j[ r ], col{ r if ¢ 1);\n\nraturn \"this:\n}\n\nThis algorithm cries our for optimization because it dees so little actual work. For\na3™ 3 matrix, there are only three swaps, For a4 x4 matrix, there are only six. List-\ning 1.2.4 shows the templare implementation, We can now replace the original with:\n\nmatrixntah matrixgds transpose }\nTransutxT( matrixgs, *thig, 2 33\n\nreturn this;\n\ni\nwhich the compiler will expand to:\n\nHatrixass matrixda: transpose |\n\nSection 1 Programming Techniques\n\netd::awap( colja)][i], coljijp[o) t;\netd rawap( coljd][2], colj2)(0) };\natdriswap( col[ij[2], colj2jfil };\nreturn *this;\n\nI\n\nThe embedded for loops are optimized away, leaving only the swaps themselves.\nSwap itself is an inline function, so we're down to only nine move instructions. Doesnt\nget much beter than char.\n\nMatriz Multiplication\n\nFor our final look at metaprogramming, we tomplatize metric multiplication. A cypi-\neal non-templatized implementation looks like his:\n\nmatrimddé metrixdd::operater *= (const matrixch’ mj\n\n{\nnatrixaa tj\nfor (unsigned r= 0; rot 3; ree]\ni\nfor (unsigned ¢ = 0; 6 =< 3; e*)\ntle][r] = 0.0;\nfor (unsigned k = 0; & = 3: ke4)\nt{elir] += col[(k)(r] * ae) [ke];\n}\n}\nthis = t;\nreturn \"this;\nI\n\nThe comesponding template metaprogram version is shown in Listing 1.2.5.\nMatrix multiplication has an inner loop chat becomes the additional template para-\nmeter K. Unlike the identiry OF transposition algorithms, which expand to A squared\niterations, multiplication expands to N cubed iterations (mote thar the specializations\ntake “W cubed” as a parameter). Now we can replace the original version with:\n\nmatrixzagh matrixgad:seperater *= (const matrixzaé m)\n{\n\nnatrixas t;\nZeroMixT( matrixds, t, 3 5\nWultMtxT( matrixds, t, \"this, m, 3 }:\nTehis = t;\nreturn \"this;\n}\n\nWe initialize the resulting matrix to be empty (zeroed) so that the += operator in\nthe MulttxIep] template will work properly. The compiler can expand the new mul-\ntiplication operator to something like this:\n\n1.2 Fast Math Using Tamplate Metaprogramming 29\n\nmatrix33h matrix: ioperater *= (const matrixs3a nh\nmatrix3d3 t;\n\nI) ZerovteT\nt(O) [0] = 0.0;\nhier ee\n\nt[2][2] = 0.0:\n\nff MultutxT\n\nCLO][O] *= col[oj (0) \" mPa] fo);\ntLO]PO] *= col[i}{o] * m[ol]i):\neee\n\ntLS)[3] = ecol[2](9] * afd] [2];\ntl3}[3] = eol(3](o] * mpo][a];\n\n\"this = t:\n\nreturn *thigs;\n\n}\n\nThe multiplication template is a general solution for any square matrix. The code\nfor any arbitrary Vx NV matrix would be:\n\nmatrixWN& matrixWN::operator *= (const matrixNN& m)\n\n{\nMatrixnh t;\nZerautxT( natrixWN, t, W jj\nMULEMEXT( matrixhW, t, “this, m, Nj;\n*this = t;\nreturn \"this:\n\n}\n\nActual Matrix Performance\n\nHow efficient are the templatized matrix operations? The general-purpose answer ix\nthar your mileage will vary depending on the quality of che compiler and the compiler\noptions you chensc.\n\nT tested the matrix operations using WC6 with full optimizations, opdmizing for\nspeed, using the inline option “any suitable\" and the #pragmas inlina depth(2ss)\nand inline_recursion(on). | benchmarked cach operation 100 million times, with\nthe results shown in Table 1.2.1. All times are in milliseconds, The Unrolled column\nindicates whether or not the compiler was able to unrell che recursion.\n\n‘To see relative performance, I graphed these results to show how much faster the\ntemplanzed versions operated compared with the non-cemplatized versions (see Fig-\nure 1.2.1).\n\nWith the exception of multiplying 4% 4 macrices, the templatized versions were\nall considerably faster. Nor surprisingly, the matrix wansposition operations showed\nthe best improvernents. In the eases of the simpler algorithms, the compiler was able\nto completely unroll the template recursion. However, for multiplying 4 x 4 matrices\n\n30 Section 1) Programming Techniques\n\nTable 1.2.1 Matrix Operation Test Results\na ____—_—_—————————\n\nNon-Templatized Templatized\n\nOperation {in Millisecands) fin Millisecornds) Unrolled =\nmarix33-:2er0 33,092 29,330 Completely\nmatrina4szena 36/063 50,297 Completely\nmatrix33-:identity 45,827 79,526 Completely\nmatrind4-identicy 46,845 29S Completely\nmatrix 3 Jctranspose 55,338 79055 Completely\nmatricii:ctranspose O0,638 30245 Partially\nmatrix33-op *= 62,94 50.352 Partially\nmatrixddscp \"= 326,390 FoLI01 Partially\n\nms Lo cain\nSnr peopared ta oon-besglale yew\n\nFIGURE 1.2.1. Relative performance of templite functions.\n\n(4° operations), the compiler only partially unrolled che recursion, and the overhead\nof the recursive function calls far outweighed any inlining improvements, so the\nresulting function was much slower than the original. These results simply show the\nimportance of profiling your “optimizations.”\n\nSummary\n\nTemplates can be a highly elective way of generating algorithms directly in the in-\nstruction stream. [he abilicy to reduce and unroall code in a generic way can be a very",
      "page_number": 19,
      "chapter_number": 3,
      "summary": "This chapter covers segment 3 (pages 19-28). Key topics include template, matrix, and compile. Similar nocartion is used for all the following code\nlistings.",
      "keywords": [
        "Template",
        "compiler",
        "Val",
        "template metaprogramming",
        "matrix",
        "time",
        "compile time",
        "sine template",
        "Fib",
        "template parameter",
        "sine",
        "Fast Math",
        "version",
        "template metaprogram version",
        "sine template functions"
      ],
      "concepts": [
        "template",
        "matrix",
        "compile",
        "compiler",
        "function",
        "functions",
        "sine",
        "time",
        "col",
        "operations"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 25,
          "title": "Segment 25 (pages 784-814)",
          "relevance_score": 0.73,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 15,
          "title": "Segment 15 (pages 456-487)",
          "relevance_score": 0.71,
          "method": "sentence_transformers"
        },
        {
          "book": "More Effective C++",
          "chapter": 32,
          "title": "Segment 32 (pages 320-329)",
          "relevance_score": 0.7,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 30,
          "title": "Segment 30 (pages 950-980)",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 21,
          "title": "Segment 21 (pages 651-684)",
          "relevance_score": 0.68,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 29-38)",
      "start_page": 29,
      "end_page": 38,
      "detection_method": "topic_boundary",
      "content": "1.2 Fast Math Using Template Metaprogramming |\n\npowerful programming technique. The notation for template metaprogramming is\nunusual at first, but it's not much more difficule chan examining standard recursive\ncalls. Macros can be used to hide the notation from the calling code.\n\nThe metaprogramming technique can be extended ta a wide variety of functions,\nincluding square-root caleulations, gitatest common divisors, matrix inversians—\nevent sorting. Any algorithm for which at least some of the input parameters are\nknown at compile time can benefit from templare mctaprogramming.\n\nCurrent compilers are still limited in dealing with templates, especially recursive\ntemplates. Compiler template error messages can range from cryptic to undecipher-\nable, As with any optimization, there is often a time and space cradeoff. In many cases,\ntemplate metaprogramming can generate the best of both worlds: very small and fast\ncode. In other cases, unrolled code can be much larger than the original version,\nreducing or even eliminating the speed advantage. Nevertheless, expect to see tem-\nplate metaprogramming play a significant role in Cr+ libraries and games of the\nfurture.\n\nListing 1.2.1\nrr\n\nff Series expansion for sin{ A).\ni) For conforming compilers, change double A to double& B\ntemplate= dowble A > struct Sine\ni\nenum { MaxTaras = 10 4; // increase for ACCUraCy\netatic inline double sin{}\n\nf\n\nI\nhi\n\nreturn Ao\" Series< A, 0, MaxTeras =:ivaly;\n\nTemplate double A, int I, int WaxTerne >\nStruct Series\n{\nenum\n{\nff Gontinue £8 true until we've evaluated M terns\nContinua = I+ 1 f= MaxTerns,\nNxtI = { I #1) * Continue,\natMaxternis = MaxTerms * Continue\n\n}\n\nff Recursive definition called once per tere\nStitio inline double yval()\n\n{\nreturn i -A* RS (2.0 * T+ 2.0) J\n{2.0 * 1+ 9,0) * Series< A * Continue, HxttI,\nAxtMaxterms =o valy);\nI\n\nhi\n\nff Specialization to terminate the loop\n\naz Section 1 Programming Techniques\n\nTemplate <= struct Series 0.60, Oo, oO >\ni\n\nStatic inline double yval() { return 1.0; }\nti\n\nii Make the template appear like a function\nfiatineg SineT{ ro) Sines f =::sin{)\n\nListing 1.2.2\n\n_—_ n> gg\ni] Series expansion for sin( fj.\n/) Far conforming compilers, change double A to doubles aA\nteaplate < double R > struct Sine\n\n{\n\nff All values Known at compile time,\n\nff A decent conpiler should be able to reduce\n\nff te a single constant.\n\nStatic inline double sin(}\n\n{\n\ndouble Asqr = R ® A;\nreturn A\" [ 1.0 - Asqgr / 2.0 ff 4.0\n\n* { 1,0 - Aegr f 4.0 7 6.0\n* {| 1.0 - Regr / 6.0 ff 7.0\n* [| 1.0 - Regr / 6.0 / 8.0\n*{ 1.0 - Regr f 10.0 7 11.0\n*{ 1.0 - Regr f 12.0 f 13.0\n*\"{ 1.0 - Regr f 14.0 7 15.0\n\"{ 1.0-- Regr f 16.0 7 17.0\n\"(1.0 -- Ragr / 18.0 / 19.0\n*{ 1.0 - Regr /f 30.0 / 21.0\nboat omy Ke) feee eet Te See a fel 0\n\n}\n\na\n\nff Make the template appear like a fumetion\nFdefine SineT( r ) Sinme< pr »::8in(}\n\nListing 1.2.3\n\niY Templatized identity matrix; Wis matrix size\nTemplate= class tx, unsigned N > struct IdMtx\n{\n\nstatic inline void eval WtxA mtx i\n\n{\n\n}\ni\n\nif 4551gn8 each element of the matriz\n\nteaplate= class Wtu, unsigned W, unsigned ¢, unsigned A,\nunsigned I >\n\nstruct IdudtxImpl\n\n{\n\nidWtxImpl< Wtx, WH, 6, 0, O >:ieval( mix J;\n\n12 Fast Math Using Template Metaprogramming ao\nee\n\nénuz\nif\nNutl = I # 1, ff Counter\nNinth = NwtI % N, ‘i Aow (inner loep)\nNietG = NxtI / N & WH ii Coluan (outer leap)\nie\nstatic inline void eval Mtx& mtx )\n{\n\netx CIP R)=( Gf) ? 1.0: 0.0;\niGMtxInpl< tx, M, Net, MxtR, Nxt >:teval( atx ey\n}\n};\n\ni) Specialize for 9x3 and 434 matrix\ntenplate<> struct IdutxImpl< matrixaa, 3, 0, 0, 3*3 >\n\n{\nStatic inline void evalj matrixns3& ) {}\nMe\ntéenplates> struct IdMtxInpl< matrix44, 4, Oo, 0, a\"4 >\n{\n\nStatic inline vold eval matrix44& } i}\nhs\n\nf/ Make the template appear like a function\nHeating IdentitylttxT( MexType, Mtx, N) \\\nTdutse< MixType, M =:roval( Wtx }\n\nListing 1.2.4\n\nSEE\nff Templatized transpose; W is matrix size\ntemplate Glass Ute, unsigned N > struct Transltx\n\nf\nStatic inline woid eval{ Mtxh mtx }\n{\nTraneitxInpl< Mtx, M4, 0, 1, 0 *::eval( mtx 13\ni\ni\n\ntemplates class Mix, unsigned N, unsigned ¢, UAisigned A,\nunsigned I >\nStruct TranslttxImel\n\n{\nenum\n{\nNxtI = I + 1,\nNzt® = Natl / NM & 4H,\nNath = ( Netl & No) + MxtG + 1\n\nbi\nStatic inline void eval{ Mtx& atx }\n{\niff R=}\nStdssawap( mtx[ C I[ A], mtxf RIL & ] 4;\nTransMtxImpl< Mtx, N, MxtC, Nxth, Nxtl >::eval( mex };\n}\n\na4 Section 1 Programming Techniques\n\nhi\n\nif Specialize for 3x3 and 4x4 matrix\ntemplate<> struct TransMtxInpl< matrixd, 3, 0, 1, 3*3 =\n{\n\nBtatic inline void avall matrins3& } {}\nhi\ntemplate<> struct TransMtxInpl< matrixdd, 4, 0, 1, 4°4 >\n{\n\n};\nif Wake the tenplate appear like a function\n\nfdefine TransltxT( MexType, Mex, No) \\\nTransWtx< MtxType, M >::eval( Ntx j\n\nstatic inline vaid eval( matrixd4& } {}\n\nListing 1.2.5\n\nif] Templatized multiplication; N is matrix size\ntemplate: class Mtx, uneigned N > struct Multittx\n\n{\nStatic inline void eval( Mtxk r, const Mtxh a, const Mtxi b )\n{\n\nMultiitxImpl< Utz, WH, 6, 0, 0, O >::eval{ r, a, b );\n}\nhi\n\ntemplate< class tx, unsigned W, unsigned G, unsigned fi,\nunsigned K, unsigned — =\nstruct Multitxiagl\n\n|\nenum\n{\nHxtI = I+ 4, ff Gounter\nNxtkK = Nett & NH, ff Internal loop\nHxtG = Nxti | WS H, ff Galenn\nMeth = Neti | hy ASN SS Ae\nti\nstatic inline woid eval( Wtwk r, const Mtxk a, const Mtx& b }\nFL GIL A) + al KIL A] * BT CoE K OO;\nMuLtetxInpl< Mex ,N,Nxtc, Meth ,Wetk,Nxtl 2::eval{ rya,b );\nt\nhi\n\nif Specialize for 3x3 and 4x4 matrix\ntenplate<> struct MultWtxImpl< matrixd3, 3, 0, 0, 0, 3*3*S >\n{\n\nATaTic inline void aval[ mMatrixci’, comet matrivs4,\n\nconst matrix33& ) {}\n\nIi\ntemplate<* struct MultWtxIapl< natrixdd, 4, 0, 0, 0, 4*4*4 >\n{\n\nStatic inline void aval( matrixé44h, canst matricdds,\n\n1.2 Fast Math Using Template Metaprogramming 35\n\nconst matrixdéé } {}\nbi\n\nff Make the template appaar like a function\nWdefine MultitxT( MtxType, r, a, b, NW} |\nMuliutx< MtxTypa, N >:teval( r, a, b }\n\nReferences\nnt\n[Veldhuizen99] Veldhuizen, Todd, “Techniques for Scientific Ce+.\" Available\nwew.exuemeindiana.cdu/-tveldhui/paperstechniques!, August 1999.\n[Veldhuizen98] Veldhuizen, Todd, et al., “Blices-+ Numerical Class Library.” Available\nwww. conumerics. ong) lite! Aueuse 1998,\n(Veldhuizen96) Weldhuizen, Tedd, and Kumaraswamy Ponnambalam, “Linear Alge-\nbra with C++ Template Metaprograms,” Dr Dobbs Journal, August 1596,\n[Veldhuizen95) Veldhuizen, Todd, “Using C++ Template Metaprograms,” C++ Report,\nMay 1995.\n[Pescio97] Pescio, Carlo, “Binary Constants Using Template Metaprogramiming,”\nCiC++ Uber: Journal, February 1997.\n[Karmesin99] Karmesin, Steve, et al., “PETE, Portable Extension Template Engine,”\nAvailable www.acl.lanl ov! petes, February 1499.\n\n1.3\n\nAn Automatic Singleton Utility\n\nScott Bilas\n\nThis article presents an easy and safe method to provide access to a C++ class single-\nton while retaining control over when ic is instantiated and destroyed.\n\nDefinition\n\nA singleton is an object that has only one instance in a system atany time. Some com-\nmon examples of singletons in games are managers for rexture maps, files, or che user\ninterface. Each is a subsystem thar’ generally assumed to be available once the game\nhas started and will stay in existence uncl the game shu down.\n\nSome of these subsystems can be implemented using global functions and static\nvariables. An example would be a memory manager's nalloc() and free() functions.\nThese types of subsystems are noc singletons in char they don't have their functional-\nity encapsulated into a class and can't be represented using a single instance of that\nclass, There's no reason a memory manager such as this couldnt be converted into a\nclass and used as a singleton, but this practice isn't common.\n\nAn example of a singleton is a fectere map manager. It could be called Texturesigr\nand have methods such as GetTexture() and UseTexture(). Its purpese would be to\nfind texture maps in the file store, convert them to system graphies objects, make\nthem available to the rasterizer(s), and own chem until they are no longer needed, at\nwhich point it deletes them. Only one instance of Textureligr will be needed in the\nsystem, 50 this class would naturally be used as a singleton.\n\nAdvantages\n\nWhiar's che poinc of singletons? First, chey provide conceptual clarity because labels are\nvery important. Calling a class a singleton and following a naming convention (such\nas -Mgr, -Api, Global-, etc.) relates importance details abour how we intend that class to\nbe used.\n\nSingletons also provide notational convenience. Every object in a C++ system\nmust be owned by something. The ownership pattem of these objects depends on the\n\n13 An Automatic Singleton Utility a7\n\ngame, but ir often resembles a multilevel hierarchy, in which each higher level owns a\nset of child objects, each of which in curn can awn child objects. Each object pub-\nlishes a set of functions to access its children. For example, co get at the Texturemgr\ninstance, you might need co call a sequence of functions such as Getapp( ) ->Getser-\nvices ()->GetGui()->GetTexturemgr(), where cach function revurne a pointer to che\nrequested child ehject. This system is inconvenient and not exactly efficient, consid-\nering the multiple dereferences. Singletons can solve this problem because they are\ntreated as global objects.\n\nThe Problem\n\n——— eee\nWell, then why not just use global objects? They are certainly convenient; the Tax-\ntureligr object could be accessed through a g_Texturelge object reference chat has\nbeen declared with external linkage at global scope (or within 2 namespace) or per-\nhaps through a function that returns a reference to that object instead. However, the\nconstruction and destruction order of global objects is implementation dependent\nand generally impossible to predict in a portable manner.\n\nThere are workarounds to all these problems, bur what we really want is a way to\nhave the convenience advantage of treating a singleton like a global object, withour\nthe inconvenience of losing control over when and where it Bets constructed and\ndestroyed.\n\nTraditional Solution\n\nThe textbook solution to managing a singleton usually looks something like this:\nTextureugré GetTextureligr( void }\nf{\n\nstatic T $_Singleton:\nreturn ( 3_Singleton }:\n\nThere are many variations that use cemplates and macros for notational conve-\nrience, bue the effect is still the same, This solution allows a singleton to only be\ninstantiated on demand—the first time this funetion is called. Ir’s convenient co use,\nbut ic leaves its destruction up to the compiler and requires thar i¢ be done only at\napplication shutdown time. We need more control than tha, Order of destruction is\nvery imporcant in a game in that some subsystems must be shut down and destroyed\nbefore others. Furthermore, what if we want to shut dewn only part of the game while\nit's still running? Doing so is impossible wich this solution.\n\nao E Section 1 Programming Techniques\n\nA Better Way\n\nAll we're really after ts che ability te crack a singleton, and for chat whar we need is a\n\npointer to it. Whar if we were to do something like this:\n\nClaas Texturawgr\n\n{\nStatic TextureMgr™ mg_Singleton;\npublic:\nTextureligr( void ) { ms_Singleton = this; /*...\"/ J\n-Téxtureligr{ void ) { ms_Singleten = 0; f*.. 8h)\nfe con\nTextureligré GetGingleton( void ) { return { ‘ms Singleton }; 4\nhi\n\nAdd a few assertions for safety purposes, and this solurion would work! We can\nnow construct and destroy a Texturewgr wherever we like, and accessing the singleran\nis as simple as calling Texturelgr::GatSingleton(). However, this solution is still a\nlittle inconvenient, given that the same code (to track the singleton pointer) needs to\nbe added to every singleton class.\n\nAn Even Better Way\n\nA more generic solution is to use cemplates to automatically define the singlecon\npointer and do the work of setting it, querying it, and clearing it, It can also check\n(through assert()) to make sure thar we arent accidentally instantiating more chan\none. Best of all, we can get all chis functionalicy for free just by deriving from this sim-\nple little class:\n\nfinclude <cassert>\n\ntenplate <typename T> class Singleton\n\n{\n\nStatic T* ns_Singleton;\npublic:\n\nSingleton( void }\n\nif\n\naseert( ima Singletan };\nint offset = (imt)(T*)1 = (int)(Singleton <T=*)(1T*\")1;\nms Singleton = (T*){{int}this + offset);\n\nbi\n=fingleton( wold |\n{ assert{ ms_Singleton }; as_Singleton = 0; }\nstatic Th GerSingleton! void }\n{ s8eert( me_Singleton }; return [ *na_Singletan j: }\netatic T* GetSingletonFtr( woid )\n\n1.3 An Automatic Singlaton Utility a9\n\n{ return { m&_Singleton }; }\ni\n\ntenplate <typenane T= T* Singleton “T+: ims_Singleton = oO:\n\n‘To convert any class into a singleton, you only need to do these three easy steps:\n\nPublicly derive your class wyGlass from Singleton <MyClass>,\n\nMake sure that you're constructing an instance of MyClass somewhere in che sy\ntem before using ic. How you instantiate it doesn’t matter. You can let che cam-\npiler worry about it by making it a global or local static, or you can worry about\nit yourself via new and delete through an owner class. Regardless of how and\nwhen you construct the instance, it will get tracked and could be used as a single-\nton through a common interface by che rest of the system.\n\n. Call MyClass: :GetSingleton() to use the object fram anywhere in che system. If\n\nyou'te lazy like me, you cam #define g MyClass te be MyClass: :GetSingleton(}\nand treat it exactly like a global object for notational convenience.\n\nHere is a sample usage of the class:\n\nclase Textureligr : public Singleton <TextureMgr>\n\nhs\nTextura* GetTexture( const char* name };\ntiger\n\nhi\n\nfdetine g_Vexturevgr Textureligr; sGatSingLetent }\n\nvoid SonmeFunction( woid }\n\n{\nTexture* stone = Textureigr: GetSingleton().GetTexture( \"stonei\" 3;\nTexture* woods = 9 Textureligr.GetTexturel \"woods\" );\nTipess\n\n}\n\nThe Singleton class's only purpose in life is to automatically register and unregis-\n\nterany instance of its derived (uyClass) type as it is constructed and destroyed. We're\nderiving MyClass from Singleton <wyCless> purely to inherit this convenient func-\ntionality. This doesnt affect the size of the class in any way; it only adds some auto-\nmatic function calls.\n\nSo how does this work? All che important work is done in che Singleton con-\n\nstructar, where it figures out the relative address of the derived instance and stores the\nresult in the singleton poinrer (ns_singieton). Nove that the derived class could be\nderiving from more than just the Singleton, in which case “this” from MyClass might\nbe different from the Singleton “this.” The solution is to take a nonexistent object sit-\nHing at address 0x1 in memory, cast it to both rypes, and see the difference. This dit:\n\na0 Section 1 Programming Techniques\n\nference will effectively be che distance berween Singleton <MyClass> and its derived\ntype MyClass, which it can use co calculate che singleton pointer.\n\nReferences\n\nMevers, Scot, Wore 2fectiee C++, Addison-Wesley Publishing Go.. 19945.",
      "page_number": 29,
      "chapter_number": 4,
      "summary": "This chapter covers segment 4 (pages 29-38). Key topics include template, singleton, and object. The notation for template metaprogramming is\nunusual at first, but it's not much more difficule chan examining standard recursive\ncalls.",
      "keywords": [
        "Singleton",
        "static inline void",
        "Static inline",
        "Template",
        "Template Metaprogramming",
        "inline void",
        "inline void eval",
        "Static",
        "inline",
        "struct",
        "Automatic Singleton Utility",
        "Static inline double",
        "void",
        "unsigned",
        "mtx"
      ],
      "concepts": [
        "template",
        "singleton",
        "object",
        "static",
        "functions",
        "function",
        "functional",
        "matrix",
        "calls",
        "unsigned"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.67,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 30,
          "title": "Segment 30 (pages 950-980)",
          "relevance_score": 0.67,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 57,
          "title": "Segment 57 (pages 1824-1855)",
          "relevance_score": 0.67,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 1,
          "title": "Segment 1 (pages 1-35)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 15,
          "title": "Segment 15 (pages 456-487)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 39-47)",
      "start_page": 39,
      "end_page": 47,
      "detection_method": "topic_boundary",
      "content": "Using the STL in Game\nProgramming\n\nJames Boer\n\nIn 1997, Cre was officially standardized, ending a nine-year process thar not only\ndefined the official language specifications but also gave C++ programmers a massive\nnew set of tools in the form of the standard C++ library. A large portion of this library\nisthe Standard Template Library of STL. The STL is a collection of container foollec-\ntions of dara) classes, ranging from vectors to balanced binary trees, In addition to the\nbasic containers, the STL provides a massive assortment of algorithms thar can oper-\nate on those basic containers.\n\n‘common concern is whether using STL will slow dewn your code. The truth of\nthe matter is that the STL was designed with speed as a foremost priority. For\ninstance, vectors do ne bounds cheeking, and iterators are never validated before\nattempting to access a container. The net result is thar, for example, STL vectors can\nproduce code with performance equivalent to that of a simple dynamically allocated\naray. Other containers fare just as well when put under the performance microscope.\nThe STL was designed for high-efficiency (4+ applications, Don't lose sleep about\n\nusing them extensively in your code.\n\nSTL Types and Terminology\n\nThe STL is a large and somewhat complex portion of the Standard C++ library. Using\nthe STL effectively requires the understanding of the basic components and how they\nwork together\n\nContainers\n\nSTL containers represent the classic data abstractions and organization schemes such\nas vectors, lists, quewes, and maps. However, we should make a few distinctions\nbetween certain types of containers and how they are implemented.\n\nThe $TL containers’ vector, list, and deque (pronounced “deck”) are implicte dara\ntypes that both describe an abstract data type and imply a specific method of imple-\n\n|\n\na2 Section Programming Techniques\n\nmentation. A wecter is, of course, a dynamically resizable array. The Ji is imple-\nmented as a double-linked lise, A aegue, or double-ended queue, is implemented in a\nmanner that allows amortized constant time insertion or deletion of elements ar either\nend of a randomly accessible array-type structure, Deques are also known as sequence\ncontdiners because they store ordered secs of data, meaning that the order in which you\ninsert the data affects the order in which chey are stored.\n\nContainers such as stack, queue, and priority_queue are slightly higher-level\nabstractions. They describe a conmainer’s behavior but allow for different cypes of\nunderlying implementations. For example, a queue mighe be implemented using a\nvector, list, or deque inrernally. These are known as container adapters. Container\nadapters, because they rely on sequence coneainers as their underlying data, also fall\ninto that caregory as well.\n\nOther containers, such as a map, set, multimap, or multiser, are all implemented\ninternally as red-black trees (balanced binary trees) bur offer different container\nbehaviors. These are also known as astoctativr containers because the dara inserted inta\nthem is ordered based on a certain sorting criteria,\n\nHterators\n\nSterators can be thought of as pointers to elemencs in the containers, and indeed the\nSTL even uses pointer notation for traversal and aceess to container data. For\ninstance, the ++ operater moves the iterator to the mexe clement in a container, much\nthe way a pointer to an clement in an array can be incremented. In addition, like\npointers, the actual data can be accessed by dereferencing che iterator using the *\noperator.\n\nAlgorithms\n\nUnlike what you might expect, alporttbmr designed to operate on STL classes do not\ncome in the form of member functions of che container classes. Instead, they exist in\nthe form of stand-alone functions that operare on iterators, Why did the designers of\nSTL choose this seemingly ani-OOP design paradigm?\n\nBy separating the data from the algorithms, the designers dramatically reduced\nthe number of combinations of specialized algorithms. Since each container has simi-\nlar types of iterators, cach algorithm had to be written only once instead of once for\neach container, The downside is chat there are sometimes less than obvious side effects\nar suboptimal solutions. In most cases, however, specialized member functions are all\nyeu heed to perform most basic operarions on your containers,\n\nSTL Concepts\n\nA few basic concepts are important to working with the STL. First, it is importane to\nunderstand the methods used to determine ranges when working with a container,\nTeo methods common to all containers begin() and and(), rerurn the full range of\n\n1.4 Using the STL in Game Programming 43\n\nthe container. As you can sec in Figure 1.4.1, negin() rewrns the first element in che\ncontainer, but end() returns the position depond ote dave nalie element.\n\nThiete are several advancages ro Organizing the ranges in this manner. First, spe-\nclal-case coding for empry lists is eliminated. Second, iterating through containers has\na simple ending criteria: continue as long ax end() is not reached, The disadvantages\nof chis sysrem are that it is somewhat less intuitive, and reverse iteration requires spe-\ncial members and iterators.\n\nIt obviously becomes important to remember not to dereference an inerator that\nis pointing at end(). Such behavior is undefined.\n\nWhen you use functions specifying a range, functions in STL usually take as\nparameters two iterarors, one specifying the beginning element and one specifying the\nend element. To pair effectively with beging) and end(}, these functions assume an\ninclusion of the first clement specified and exclusion of the last clement specified.\nMathematically, che following notation usually designates this sort of range-\n\nrange [begin...end)\n\nThere is another aspect of the STL design of which you should be aware, STL\ncontainers pass Information by value, not by reference. This means that when dealing\nwith small dara types, ir is acceptable co allow the container to make a copy of the\ndata. With larger dara structures or classes, it becomes advantageous vo pass in point-\ners to these objects or structs, Ocherwise, every insertion or access results in a copy\nconstructor being called.\n\nWectors\n\nOTL vectors are essentially resizable arrays. Nove that although the formal C++ stan-\ndard does not specify what underlying dara saructures are to be used far containers,\nthe performance and interface requiremencs leave litle ambiguity as to how they will\nbe implemented in practice, Thus, all versions of STL will likely be very similar, with\n\nonly minor variations in implementarion details,\n\nContainer\nfeel ukest tied [Feed es pees\nbegin() end)\nbegin() points to chad) points lo position\nfirst sf Setertes beyond last element\n\nFIGURE 1.4.1. ondé) points after che lasr valid clement.\n\nSection 1 Programming Techniques\n\nVectors behave alrost identically to standard C arrays, with one major excepuion:\nthey are dynamically resizable. However, it is important to understand the nature of\nthis resizing.\n\nVectors are implemented as arrays that periodically need to reallocate memory\nand transfer dara to a new array. This means two things for developers. First, a vector\ncan allocare more memory than ir currently needs, due to the requirement chat it\nmight be expected to grow at any time. Second, adding an element to che end of a\nvector is described as comstanr sme—it is important to remember that this means\namortized comtant time. In other words, same grow functions can require a substantial\namount of resources as they allocate new memory, copy the existing array inte this\nnew block, and delete the old memory, but they do not require chese exera resources\nevery time, Depending on implementation, a vector can allocace twice its current alla-\neated memory when it mins out of buffer space.\n\nfe is also evitical chat you understand when a vector reallocates memory, since\ndoing so invalidates any iterators currently pointing to elements in the vector. Let's\nexamine the functions to help more precisely manage a vector’s internal memory, alter\nviewing the eode-\n\nFinglude <vector>\nHinglude <iostrean>\n\nusing nanespace std:\n\nif Typedeft tha container and iterator names for better\nii readability\n\ntypeadet vectersint> Int¥ector:;\n\ntypede? IntVector::iterator IntVectIter:\n\nvoid maint}\n\n{\nif €reate a vector object of integers\nIntVector co;\nif Reserve room for 10 integere\nc.reserved 10);\n\nif Fill the vector with 3 different elements\nc.push_back(3);\n\nc.push back(S9):\n\nc push back (42);\n\n({ How loop and print owt all the element values\nfor(InmtVactItor itor = c.begin(}; iter |= e-end({)j +-itor)\ncout << “alament valua = \" << (*iter) << ondl:\n\nff Since the elements have been crested, we can access or\nae replace them jpust like A formal array.\n\ne(0] = 12;\n\nef] = 3ce\n\n1.4 Using the STL in Game Programming 45\n\nc[2] = 944;\nTor(int 2 = 0; d = e.eivedys i++)\ncout =< “elenent value = \" << ci] << endl;\n\n}\n\nThis example shows most of the basic principles you need to know to stare using\nSTL containers. Notice at the cop of the listing the inclusion of the appropriate\nheader files for this program. In addition, note the usage of namespace std. Like all\nportions of the C++ library, che STL is part of the eta namespace and so roquires you\nto declare such in your program.\n\nNexr, we sce typedets for the type of container and iterator we want te use in the\nprogram. This is a very common practice: it nor only makes the code easier to read,\nbut it becomes easier to change the underlying dara structure, if desired, (We'll see\nhow easy that is next.)\n\nThe next section of code creares the vector container object v and proceeds to call\na vector-only function char reserves 10 integers’ worth of memory. The code proceeds\nto push_back() 3 integers onto the back of the vector. Since we have preallocared well\nover this amount of memory, no additional memory allocation is required.\n\nThere are a few routines chat you mighe find helpful when you want to closely\nmonitor and control the allocation of your vector's memory. As shown, you can\nreserve a bulfer in the vector by calling reserve() and passing a size parameter. This\nvalue can he retrieved by calling capacity(). If capacity()=-reserve() and another\nclement is inserted into the array, a memory allocation will rake place and all current\nirerarors will be invalidated. In order co determine the maximum amount of memory\nthat can be allocated for a single vector, use the sax_size() function,\n\nThe push_front(}, push_back(), pop_froet(), and pop_back() functions are\ncommon to all basic ordered containers (vector, list, and deque). These functions\nobviously add and remove elements ftom the frome and back of the container. Due co\nthe implementation of a vector, you want to aveid push front() or pop_front() on\nthese types of containers, if possible, due to the Oy'n! performance, but they are avail-\nable far use if you absolutely need them.\n\nThe final portion of sample code demonstrates one of che most commonly used\ncomponents of STL usage: the iteration loop. We use a for loop with an iterator\ndetermining the current position. The initial position is set eo begin(), and the itera\ntor increments with the prefix ++ operator until the iterator equals ena(}, ar which\npaint the exit condition of the loop is satisfied. Every container with an accesible\niterator can be looped through in this manner.\n\nSince the iterator is the only item keeping track of che current position in the vec-\n(Of, WE must use It to extract any information we want. We can see that in keeping\nwith the notion of a pointer, we simply dereference the iterator to access the data.\n\nAfter the standard iteration loop, we see an example of a vector in use like a nypi-\neal array. It is important to note that array subscripting cannot be used to insert ele-\nments into a liste—only to access existing elements.\n\n46 Section 1 Programming Techniques\n\nLists\n\nThe STL dir is perhaps the most widely used of the basic STL structures. Ir is imple-\nmented as a doubly linked list, so any insertion and deletion of elements is done in\ntrac constant time. The tradeoff for this capabiliry is the loss of random access that\nthe vector and deque allow,\n\nOne beaury of using STL containers is the consistent naming conventions and\nmethods used throughout the library. Once you learn che basics of manipulating one\ntype of container, you csentially know how to use them all.\n\nUsing a list is even simpler than using a vector. The push front(} and\nputh_back() functions work exactly as you would expect. Iterating through the list\nalso works exactly as we saw in the vector example. In this code, we see many of the\nsame techniques used tn che vector class:\n\nWinclude <list>\nfinclode <iostream\n\nusing namespace std:\n\nclass Foo\n{\npublic:\nFoo(int 1) { m_iData = i: }\nvoid SetDatafint i) { miata = i: }\nint GetData/) { return m_idata; }\nprivate:\nint m_iData;\nti\n\nif TypedeT tha containér and iterator names for better\nfi readability\n\ntypadet list<Foa*= Foalist;\n\ntypedet Foolist::iterator FooListitor:\n\nvoid main)\n\n{\nff Create a list container of integers\nFoolast ¢;\n\n{/ Fall the last with 3 different elements\nCc. push_back(new Foo{i}):\nc.push_back(new Foo(2));\nc.puech_back(new Foo(a) ji\n\nff Tterator through the list\nTfor(FooListItor itor = c.begin(); Lter '= c.end(}:}\n\n1f((*itor)-*Gerbatal) == 2)\nff} dengnstrates proper method of remoying an\nff elenent trom the @iddle of the list.\n\ndolete (*itor);\n\n1.4 Using the STL in Game Programming ay\n\nitor = c.arase( itor):\n\n}\n\nelse\n++itor:\n\nt\n\nff Make Sure to delete all the objects, since the list\nif gestructor will mot do this automatically for you\nTor(Faolistiter itor? = c.begin(}; dter2 |= c.endi);\n++itorZ])\ndelete [*itor2);\n}\n\nWe see in this example the same basic type of container manipulation, bur we\nhave added the wrinkle of using user-defined objects instead of built-in dara cypes,\n‘This is 2 much more common usage scenario, so we cxamine how it differs in practice\nfrom inserting data by value.\n\nSTL containers do not operate on the data you pass into chem. Rather, they make\ncopies of che data they receive and distribute, In order to negate the cost of copying\nlarge data structures in memory, you'll want to pass pointers to larger, dynamically\nallocated objects, Nacurally, our objects are ridiculously small for example purposes,\nbur they could conceivably be large enough oo seriously affect performance if we\ncopied a large number of them.\n\nThere are a few things to remember when working with pointers to dynamically\nallocated structs or objecss. First, and perhaps most obviously, is that you are respon-\nsible for freeing any allocated memory when you are finished with the objects. Since\nthe container has no idea what eype of data might be used, there is no way for the con-\ntainer to automatically deallocate memory for you.\n\nSecond, and perhaps less obvious, is that many operations appear to fail beeause\nthey are operating direcdy on the object or struct pointers instead of on the objects or\nstructs themselves. Take the list's sort {) function, for example. It operaces by using\nthe < operator co determine value and sort accordingly. Even ifa proper operator is\ndesigned for class Foa, the list still sorts on the actual value of che pointer, mor by the\nvalue of the data in the object.\n\nIt therefore becomes necessary to design your own compare operator that derefer-\nences the pointers before comparing them, See the sample code in the article\n“Resource and Memory Management,” by James Boer, to sec how this comparison\ncan easily be done.\n\nThe third “gotcha” is appropriate to all pointer manipulation routines but alsa\nbears mentioning in che context of STL. When copying containers, remember that\nonly the pointers are being copied, noc the objects. If you create duplicate pointers, it\ncould become extremely difficult to know which ebjects to delete. There are only ovo\nsolutions to this problem: Use smart pointers with your objects or avoid STI. routines\nand algorithms that copy elemencs from container to container.\n\n&\n\nDeques\n\nSection 1 Programming Techniques\n\nYou should ako be wary of removing an element from a list while iterating\nthrough che list. Since removing an element co which you are currencly pointing\ninvalidates the itcrater, you must be sure to make proper use of the erase() function's\nreturn value, which retrieves the next valid position in the container, By assigning this\nreturn value wo the old inerator, we essentially skip ahead of the invalidated position.\nHowever, this leaves us with another problem. Since we've already incremented the\niterator to the next position, we run into rouble when the for loop tries co increment\nitagain at the end of the loop. To solve this problem, we remove the increment oper-\nator from che body of the tor loop and place it conditionally inside che loop itself,\nincrementing only when an clement is nor erasecl\n\nIt is often preferable to use algorithms to crase elements from a container instead\nof inerating through them manually. Algorithms such as renove_it() perform the\nsame operation safely and efficiently. Unfortunately, a complete listing and deserip-\ntion of the provided algorithms (and how to create your own) could fill up an entire\nbook, so recommend the resources listed at the end of this article for further srudy.\n\nDegues, or double-ended queues, are designed for situations in which inserting and\nremoving elements from either end of the container must be performed, bur inserting\nand removing elements from the middle of the container is not required (or doesn't\nhave to occur often). Like vecrors, deques can perform insertions and removals at the\nfront and back of the container in amortized constant time, and inserting or deleting\nelements from the middle is somewhat slaw. Deques also allow random access, but\nbecause of the slightly more complex nature of the internal data of a deque, which is\narranged in a linked series of memory blocks, random access is not quite as efficient as\nwith vectors, Unlike vectors, though, there is no mechanism in place for determining\nexactly when additional memory allocations will take place.\n\n#Wincluds <deque>\nFinclids <lostrean>\n\nusing manespace std;\n\nif Typedef the container and iterator names for better\nJ] readability\n\nTypadat deqgue<int> IntDeque;\n\ntypedat [ntBeque: i reverse iterator IntdequeAl ter;\n\nvoid main(}\n\n{\nji Graate a daque container of intagers\nInttaque ¢;\n\nif Fill the deque with 3 different slements\nc.push_ frent(ai;\nc.push front(2);\n\n1.4 Using the STL in Game Programming 49\n\n©, push front {i};\ne.push back(3);\ne.push back(2);\nd.push back(i);\n\nif Cycle BACKWARD through the list - special iteraters and\n\nIf notation is necessary to do this.\n\nfor(intDequeAltor riter = c.rbagin(}; ritor [= ¢.rend{);\n++ritar)]\nGout = \"Walue = \" =< {*riter) << endl:\n\nff Prenove the first and last elements\npop Trest();\nc.pop back i);\n\ni! Atteséing elements directly - if needed renenber to\nif check to seo the dequa is net enpty. AGGESsing non-\nff existent elements will lead to undefined behaviar;\nif probably an access violation\n\nif(ic.amety(})\n{\n\ncout << \"Front = \" << ¢.front{) << endl:\ncout << “Back = \" << ¢.back{} << endl;\nI\n}\n\nWe see in the preceding listing the familiar code of STL usage, but with a few\nmew cwises this time. First, lee’s introduce the reverse iterator. You mipht notice that all\nour iterations up to this point have been in the positive direction. Although bidirec-\ntional iterators de exist, it often is much simpler to create a dedicated reverse iterator\nand utilize it a5 you use the standard iterator.\n\nThe reason we need a reverse ineraror i¢ that because of che bounding conditions\nof a container (illustrated in Figure 1.4.1), we cant simply iterate backward and\nexpect to be able to check for the same exit conditions (iter != bagin(}). This\nwould leave the first element in a container out of che iteration loop. Instead, we uti-\nlize a reverse inerator combined with the rbegin() and rend() functions. These func-\nHons work exaetly like their forward-looking cousins, but rbegin{) actually accesses\nthe last element, whereas rend() points to a position im frant of the firse valid entry.\nThis exactly mirrors the forward versions of chese functions. Because the reverse iter-\nator travels backward when the increment operator is applied, you can use the exact\nsame syntax for looping through all elements in a conrainer.\n\nIn this example, we also incoduce che opposites of push_front() and push back({),\npop_tront() and pop_back(}. These functions simply remove an clement from the\nfront or back of a container, respectively, Note thar the value of the clement is not\nretumed. You must we two more functions we introduce in this example to access the\nfront or back elements: tront() and back(). These fictions retum the value of\nthe front or back element in the container. In the example, we check co ensure that\nthe coneainer is not empry using the enpty{) function before trying to aecess these",
      "page_number": 39,
      "chapter_number": 5,
      "summary": "The STL is a collection of container foollec-\ntions of dara) classes, ranging from vectors to balanced binary trees, In addition to the\nbasic containers, the STL provides a massive assortment of algorithms thar can oper-\nate on those basic containers Key topics include container, iterating, and iteration. Covers iterator.",
      "keywords": [
        "STL",
        "STL containers",
        "container",
        "vector",
        "back",
        "STL containers pass",
        "iterator",
        "elements",
        "memory",
        "che",
        "list",
        "data",
        "STL containers represent",
        "functions",
        "element"
      ],
      "concepts": [
        "container",
        "iterating",
        "iteration",
        "iterations",
        "iterate",
        "elements",
        "element",
        "vectors",
        "functions",
        "function"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 13,
          "title": "Segment 13 (pages 247-268)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Concurrency in Action",
          "chapter": 36,
          "title": "Segment 36 (pages 355-362)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "More Effective C++",
          "chapter": 29,
          "title": "Segment 29 (pages 293-301)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 20,
          "title": "Segment 20 (pages 616-650)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        },
        {
          "book": "More Effective C++",
          "chapter": 3,
          "title": "Segment 3 (pages 17-24)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 48-55)",
      "start_page": 48,
      "end_page": 55,
      "detection_method": "topic_boundary",
      "content": "5o : Section 1 Programming Techniques\n\nelements. Accessing clemenes in an empty list resules in “undefined behavior,” which\nyou can expect to probably result in some sort of access violation; pap _front() and\npop_back()simply are “no-ops\" when performed on an empty container.\n\nSTL tmapr are perhaps the most complex (relatively speaking) of the basic containers to\nuse and perhaps the mose versarile, Here we examine maps instead of the other trce-\nbased structures: sets, multisets, and multimaps. Learning the fandamentals of maps\nallows you to easily use che other container types, so we leave char research up to you,\n\nThe map is essentially a walue-pairing container. Two arbitrary types of dara are\npaired as a key/value structure and inserted into the container. Looking up che value\nvia the key then can occur in O¢1og n) time. Although tot quite as efficiene as a hash\ntable, the difference is often negligible and has the advantage of sorting the data dur-\ntng insertion. This process allows iteration of completely sorted data, which is a ben-\neficial consequence of the method of storage (a balanced binary tree, otherwise known\nas a red-black tree)\n\nepragma warning (disable: 47B6)\nFinglude map>\n\n#include <iostream>\n\n#inglude <string>\n\n#include <algorithm>\n\nUsing namespace std;\n\nff This Tunetion abject allows us to compare map containers\ntemplate <clase F, class §>\nclass value equals\n\nprivate:\n& second:\npublic:\nValue_@quals(const $4 s) : second]s)\n{}\nbool opérator(} (pairsconst F, S> ales)\n{ return elem.second == second; }\n\nff Typédef tha container and iterater names for betrar\nif readability\n\ntypedef mapeint, string» isllap;\n\ntypede? isMap::value type iaValType;\n\ntypedet isMap: iterator isWapltor;\n\nvoid main)\n{\n\nisiiap cj\n\n1.4 Using the STL in Game Programming Es\n\nI! Insert key / value pairs\nc.insert(isvalType(ido, “One Hundred\") ):\nC.ingert(isvaltype(a, \"Three\" ));\nc.ingert(isValType(150, “One Hundred Fifty\");\nc.ingert(isValType(99, \"Winery Nine\")):\n\n{/ display all the keys and values\n\nTor(isMaplter iter = c.begin(}; iter != ¢.end(); +41tor}\nout << \"Key = \"<< (*iter). first << \", Value = *\n“¢ (\"itor).secomd << endl;\n\nff You can also atcess the map like an ageociative array\nSout << “Key 3 displays value * << c[S].costr() << endl;\n\nff Or insert like this as well\ne123] = “One Hundred Twenty Three’:\n\nif Find and remove a specific element based on tha key\nfelaaltor pos = c.find(i23);\nif(pos f= ¢.end())\nif erasing an lament invalidates any iterators\ni} pointing to it. Calling pos++ now would result in\nJi undgtined behavior,\nc-praseaipos) |\n\nff Find and remove an element based on the value\nPos = find_iffe.bepin(), c.endi), value equals\n“int, string=(\"Ninety Ning\"}};3\nif(pos != c.end(}}\n©.orase (pos);\n\nff Tf you must remove elentents while iterating through\nff the list...\nfor{isMapitor itr = c.begin(); itr = c.and(}; }\n\ni\nif(itr- second == \"Three™)\nG.arase(itres):\nelse\n+eitr;\n}\n\n}\n\nWere introduced to a new intermediare dara type in this example, the nalie_rype,\nwhich represents the key/data pair representing every element im the container. For\nconvenience, we ve typedef ed this type along with che other usual types,\n\nInserting combined key/data values uses the insert() function like any other\ncontainer, with the only difference being that you must insert type nap::value type.\nThe map sorts every entry as it is inserted, so at any given time the container is always\nsorted by keys. We can see this as we iterate through the map and display all the keys\nand their associated values.\n\nAccessing keys and data through iterators means an additional scruccure ta mavi-\ngate through. Dereferencing the iteracor revurns the value_type structure, which has\n\nSection 1 Programming Techniques\n\nowo data members: first and second. Accessing first gives you the key value; accessing\nsccond gives you the dara value.\n\nIn addition to access through iterators, maps also provide ranclom access via their\nkey values, The map acts like an associative (or sparse) array. Elements can be accessed\nor inserted using the index() operator, Caution must be used when using this opera-\ntor, however. IF you attempt to access an element with an index that does not yet exist,\nthe element is created with a default constructor and ts inserted into the map. This\nmight not be the intended behavior and so is something co watch out for.\n\nMoving. on, we see 2 simple method of finding an element based on the key using\nthe find() function. Since che keys are sorted, this function performs in O(log 1)\ntime.\n\nIf we want to find am clement based on the value, we must do a bit more work. At\nbest, this work will be performed in linear time, since the data is sorted on the key\nrather than the value, The solution to this problem gives us our first look at generic\nSTL algorithms. We use the tind_if() algorithm for this particular problem. The\nfunction requires three parameters: an iterator telling where to begin, am ieraror\ntelling when to stop, and a function telling when the algorithm should return a true\nvalue. The iterators are self-explanatory, but the function abject, or functor, requires\nseme further elaboration.\n\nIn STL, classes with overloaded function operators (did you even know you could\ndo char?) are used in place of functions. This replacement enables both encapsulated\nand type-safe solutions to generic programming problems. The function object pro-\nvided in this example simply compares the second value in a walue_pair and returns\nthe result, Initializing the objece with the result we want to search against provides a\nclean and completely encapsulared solution. Note thar for most solutions, $TL pro-\nvides ready-to-use funesion objects chat you can simply plug into your code. Sec a\ncomprehensive STL book for a listing of different algorithms and function objects\navailable to use.\n\nThe previous paragraph describes the preferred method of searching for values in\na container, but if you must iterate chrough and remove elements manually ina map,\nwe also show you the proper way to do that. Removing elements while iterating\nthrough a map poses a special problem because for speed reasons, the designers of\nSTL neglected to have the erase() function return the value of the next valid posi-\ntion, as other containers do. Unfortunately, because of this failure, we cannot use the\nsimple method of removing elements, as shown in our second code snippet. Instead,\nwe have co resort to a bic of wickery to make sure we don't invalidate our iterator,\n\nIn this example, instead of incrementing the iterator inside the for loop, we do it\ninside the body in a conditional manner, Notice thar when an element must Le\nerased, we post-increment the iterator when passing it 2% the parameter to erase().\nbur ifan element doesn't need to be erased, we perform the standard pre-increment\noperator instead. Because of the order in which the operations occur, this method\nallows safe ineration without having 00 feSOrT tO UsIneE Temporary iterators. Unfortu:\n\n1.4 Using the STL in Game Programming Bs\n\nnately, the necessity of this sort of coding creates far more possibility of bugey code\nthan if the designers had just sacrificed a bit of speed in the erase() function, With\nany luck, the standards commitcee will consider revising this function in che furure to\navoid these types of kludgy workarounds.\n\nThis might be a good time to answer a question you might want vo ask, namely,\n“Why do you always use the pre-increment operator in your iteration loop?”\n\nThe answer is efficiency, The post-increment operator must retum a copy of its\nold value, so ir might require the use af a temporary object. The owo solutions work\nthe same way, but unless chere’s a specific reason to use the post-increment (or post-\ndecrement) operator, as in the previous example, you should prefer che pre-increment\nand pre-decrement operators.\n\nStacks, Queues, and Priority Queues\n\nWe lump together stacks, queues, and priority queues because using them is simple\nenough that they require line additional explanation. These containers are really\nexamples of conteiner adapters because they are implemented as restricted interfaces\non top of existing containers.\n\nStacks.\n\nThe STL stack class provides thie primary members—pusht{ }, pop, }, and top¢}—for\nadding and removing elements from the container, These member functions respec-\ntively push an element on the stack, pop ir off the stack, or retrieve the top element.\nTo check the current stare of the stack, size() and empty{} are provided,\n\nThe stack is implemented as a deque by default, but it allows you to change the\nimplementation in the constructor.\n\nff Implenents a stack with deque aa the underlying\nif container type.\natack<int> cr\n\nff? Tnplements a stack with a vector as the underlying\ni! container type.\nStacksint, veetortint> > cr\n\nNote that using a vector might noc be as poor a choice as ir seems, because\npush{), pep(}.and top() actually map to push_back{), pop_back(), and back). Any\ncontainer that supports these functions can be used as the underlying implementation\nfor the stack class, Notice that in the second line of code in the preceding example, we\nmake sure to put a space between the cwo greater-than operators, Otherwise, they\nwould be incorrectly parsed as a single stream operator, >>.\n\nIt is important to alsa lenow that the stack class, like many STL containers,\nprefers speed to safery. Thus, the class assumes that when you call pop() or top(), a\nvalid element actually exists. It is therefore importanc ro always remember to use\n\nfa | Section 1 Programming Techniques\n\nsize() of empty() to verify thar a stack is not empry before performing these opera-\nTOs on it. Queuss and priority queues work in the same manmer, so che <ame warn-\nings apply to these containers as well.\n\nGusues\n\nThe quewe class works much like the stack class except that elements are pushed onto\nthe back and popped off che fone. The following members are defined for the queuc\nclass for element manipulation: push(}, pop{), front{}, back(). backi) refers to the\nlocation in which elements are inserted, and freat() refers to the location from which\nelemenss are removed.\n\nLike the stack class, the queue also defines size(} and empty) to manage the\nsize. As with the stack class, you can specify a container other than the default deque\nto be used as the underlying implementation. Unlike stack, a vector used with a deque\nmakes a poor choice duc to the bad performance when inserting elements at the front\nofa vector. However, a list might make sense in some situations.\n\nPriority Queue\n\nThe prierity quewe works identically to a queue but differs in ome important respect:\nall inserted elements are immediatehy sorted in descending order based on a compari-\nson using the < (less-rhan) operator. Because of the sorting functionality, an addirional\n\nir parameter ts offered in the constructor, allowing you te override the defaule <\noperator with your own function. This ability could come in especially handy if you\nare inserting pointers to objects instead of passing in che objects by value. Avoiding\nsorting the queue based on the value of che pointers requires writing a functor class\nthat calls the < operator after first dereferencing the pointers. There is an example of\nthis functor in the article “Resource and Memory Management,” with code sample\nprovided.\n\nSummary\n\n———\nThe STL is a powerful new tool available for C++ programmers. By understanding\nboth ics strengths and irs limitarions, you can make the most of the features now avail-\nable without compromising the speed or integrity of your code.\n\nEnure books have been written explaining how to use the STL. It is therefore\nobviously impossible to think thar chis article could de justice to the broad function-\nality that exists in this library. Ifyou want to fully utilize che power of STL, there is no\nsubstitute fora goed reference book. Several excellent tutorials and references are\nlisted in the following References sectian.\n\n1.4 Using the STL in Game Programming 55\n\nReferences\n\n[Nicolai9] Josuctis, Nicolai M., The C++ Standard Librag-A Tatorial and Reference,\nAddison Wesley Longman, Inc, 1999.\n\n[Srroustrup97) Stroustrup, Bjarne, Te C++ Programming Language, third edition,\nAddison Wesley Longman, Inc, 1997,\n\n[Breymann93) Breymann, Ulrich, Designing Components with she Ca STL, Addison\nWesley Longman, Inc., 1°98,\n\nA Generic Function-Binding\nInterface\n\nScott Bilas\n\nSeripting engines and nenwork Messaging have an Important requirement in com-\nmon: They must be able to interface with the game's functionalicy in a type-safe, effi-\ncient, and convenient way. This article provides a method for exporting functions and\nthen binding to them dynamically ar run time. It does so withour sacrificing run time\nspeed of convenience.\n\nRequirements\n\nThe basic requirement for our scripting engine is that we can call a function and pos-\nsibly pass it parameters. For this task, we need to know the function's name, its loca-\ntien in memory, and che paramerers it takes. The types for these parameters must be\ntypes that we support direcoly in the scripting engine as part of che language. Let's\nSune we support bool, float, int, string, and void.\n\nThe basic requiremenc for our network remote procedure calls (RPCs) is chat we\nean call a function on a remote machine and possibly pass it parameters. Given that\nour machines will probably be running the code ar different memory addresses, we\ncant pass function pointers over the network and must instead convert them into a\ntoken that both sides recopnize, For this token, we use a serial ID that can be con-\nverted back and forth to an actual function poincer very quickly. In addition, we need\nto know how to recognize strings and memory pointers in the parameters so thar the\ndata they point to can be packed at the end of the RPC: chunk for handoff to the ner-\nwork transport.\n\nFor convenience, we should be able to simply call an RPC-capable function wirh-\nout having to do any explicit parameter packing from the caller's code. If the call is\nmeant for another machine, the called function should automatically Sem 11s para-\nmeters and serial ID to the network transport, then recum immediately, If meaner for\nlocal execution, it would just directly execute the code. The dispatcher on the remore\nmachine would look up functions based on the serial 1D and then call them directly\nafter resolving to a function pointer:\n\n15 A Generic Funection-Binding Interface 57\n\neS ese\n\nPlatform Concerns\n———$—$—————\nThis is a good place to paint out char the sample code provided with this article is very\nspecific toa particular platform: Visual C++ 6.0 run ning on an x86 version of Win32.\nIn particular:\n\n1. There's a little bit of assembly code in here thar is obviously x86 specific.\n\n2. The name mangling and unmangling and how calling conventions work is spe=\ncific to Visual C++ 6.0.\n\n3. 1 use the specific way that Win32 image (DLL/EXE) expons work.\n\nfit the very least, the conceprs if nor the implementation are still portable co other\nplatforms. All che x86 assembly code can be converted to any other instruction ser,\nalthough you need knowledge of the calling conventions of that platform for ix wm\nwork, Dynamic link libraries (DLLs) are hardly unique to Win32; all this article\nneeds is a table thar maps exported function names to memory addresses, Finally, you\nshould be able to figure out how other compilers (especially open source compilers\nsuch as GCC) mangle and unmangle names.\n\nAttempt #1\n\nLer's get back to the cask ar hand. We are trying to find a way to export game func-\ntionaliry in a gemeric way so thar it can be called from seripes or passed over the net-\nwork as RPCs. Here is a really simple solution:\n\nvoid Fool void }:\n\nvoid Bari void }:\ni ecarir\n\nenum @Funotion\nFUNCTION_FoO,\nFUNCTION BAR,\n\nPipettes\nhe\n\nftruot Function\ntypedat void (*Prec}{ vodd J;\nconst char* @_Mame;\nProc © Proc;\nFunction m_Funetian;\n\nhs\n\nFumetion g Funetions[]) =\n\nq\n\n{ \"Foo\", Foo, FUNCTION_FOD, +,\n{ “Bar\", Bar, FUNGTION_BAR, +},",
      "page_number": 48,
      "chapter_number": 6,
      "summary": "for{isMapitor itr = c.begin(); itr = c.and(}; }\n\ni\nif(itr- second == \"Three™)\nG.arase(itres):\nelse\n+eitr;\n}\n\n}\n\nWere introduced to a new intermediare dara type in this example, the nalie_rype,\nwhich represents the key/data pair representing every element im the container Key topics include function, functions, and functionality. Covers function.",
      "keywords": [
        "function",
        "STL",
        "container",
        "key",
        "stack",
        "stack class",
        "element",
        "che",
        "STL stack class",
        "elements",
        "map",
        "Programming",
        "code",
        "Programming Techniques elements",
        "Programming Techniques"
      ],
      "concepts": [
        "function",
        "functions",
        "functionality",
        "value",
        "iteration",
        "iterating",
        "iterate",
        "map",
        "work",
        "elements"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 65,
          "title": "Segment 65 (pages 2081-2112)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 66,
          "title": "Segment 66 (pages 2113-2146)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 15,
          "title": "Segment 15 (pages 285-307)",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 15,
          "title": "Data Structures, Algorithms, and Code Simplification",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 20,
          "title": "Segment 20 (pages 616-650)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 56-64)",
      "start_page": 56,
      "end_page": 64,
      "detection_method": "topic_boundary",
      "content": "56. Section 1 Programming Techniques\n\nUF erates\nhi\n\nThe eFunetion enumeration provides a serialized list of unique IDs for all avail-\nable functions, The Function structure maps a text name onto a function poincer and\nunique ID. Finally, the g_Functions array is the set of all published functions in the\nsystem. Our example function exports are, of course, Foo and Bar.\n\nOur imaginary scripting engine can search through the g_Funcetions array when\nits compiling a script to resolve function calls by name and then call che procedure\ndirectly ance it is found. Flopefully, this lookup would be done through an index for\nspeed. Our imaginary network-messaging system could convert function calls into\ntheir eFunction IDs and use chose [Ds to resolve the RPC on the other machine. It's\neasy and simple.\n\nThis solution would work fairly well but suffers from a critical drawhack: all\nfunctions must be the same—they must all take ne parameters and return veid. We\ncould change che Function: :Froc rype so thar the functions could ar lease return a\nvalue and take some parameters. However, this is not an acceptable solution, because\nits highly unlikely that all published functions will have identical signatures. Besides\nthat, its a very inconvenient limitation, considering the large and varied function sets\nrequired of modern games.\n\n(One way co work around this problem is to cast parameters back and forth from\ntheir real types to the common types required by Function::Proc. We could, for\nexample, have cach function pass two or three unsigned integers and pack our real\nparametets into them. This is a common and efficient technique useel by application\nprogramming interfaces (APIs) for callbacks such as window procedures. However, it's\nunsafe and can't be supported very well by a general-purpose scripting language. Ir\nwould also be impossible co figure out which of the generic parameters are pointers, a\nflaw that makes passing the parameters over the network for RPCs very difficulc.\nHacks are on the horizon. Let's wry something else.\n\nAttempt #2\ncic el i a kg ered ee yy\n\nA.common partial fix to the problems of Attempt #1 is wo provide a package class char\nsiores the parameters in an internal buffer and provides add and excrect methods to\nserialize data in and our of the object:\n\nStruct Parameters\n\nste: ivector «unsigned char> m_Data;\n\nbool ExtractSool (¢ woid }:\naint ExtractInt ( wold 9;\nfinat ExtractFloat ({ wold }:\n\nconst char* ExtractString! wold }:\n\n1.4 A Generic Function-Binding Interface\n\nig\n\nvoid AddBool { bool };\n\nWold AddInt { amt 4};\n\nWold AddFloat { flaat J;\n\nveld AdGString( const char® j:\nhi\n\nvoid Foo( Parameters& params }\nint param = parass-ExtractInt (1:\n\nfloat param? = parans-ExtractFloat/);\nff Use parami, parang...\n\n}\nveid Bar( Paraneters& params 13\nAga\n\nnun GFunetion\n\nFUNGTION_ FOO,\nFuNGT TOM_BAR,\nhi\n\nstruct Function\ntypedef void (*Proc){ Paremetars& };\n\nStditetring m_Nane;\n\nProce m_Proc;\n\naFunction m_Function;\nHi\n\nFunction g_Funetions|] =\n\n{ \"Foo\", Foo, FUNCTION_FOO, },\n{ \"Bar\", Bar, FUNCTION_BAR, 4,\nfe eee\nhi\n\nNow we can pass generic parameters to any function—a big improvement! This\nmethod, however, has its own set of drawbacks, some of which ir shares with the first\nathem pr.\n\nFirst, this solution is inherently nontype-safe and dangerous because of its\nadd/extract functions, The C++ compiler cannot check the types at compile time\nbecause it doesn't know whar's supposed to go into a Parameters object; by its very\ndefinition, it can hold anything. The best we can do is provide some basic run-time\nchecking by storing a type each time an Add method is called and then checking those\ntypes from the called function cach time an Extract method is called. This isn't very\nefficient and can be error-prone. Furthermore, any time the function paramerers\nchange, every call to that function must be searched for and updated to match. The\ncompiler can't detect changes like this, and the manual search-and-replace function is\n\n60 Section 1 Programming Techniques\n\nanother error-prone process, Missing ome changed call by accident could introduce\nlarent and difficult-to-find bugs.\n\nCalling functions in this way is also tedious and inefficient. The add/exnract\nprocess adds a lot of memory copying and verification overhead. In also has serious\nengineering time overhead. A simple function can no longer be added vo an export\nlist; it must now change its function signature and have a prologue chat converts a\nParameters object into local variables. Likewise, callers must consorwen the Parana -\nters object co begin with, although this requirement can be made a little easier\nthrough some clever cemplate work. Still, there must be a better way.\n\nHalf of the Solution\n\nLet's ssart at the end and work back to the beginning for the solution, What we're\nreally looking for here is a function specification table that gives us everything we\nneed to know about how to call a particular finction in a completely generic way. We\nneed to be able co set up the stack with a chunk of memory (ie., push che parame-\nters), jump directly co the function for the call, and then retrieve the return value co\npass back to che original caller. Por this task, we need to know the function's name,\nlocation in memory, renurn type, parameter types, and calling convention:\n\nif funetion specification\nstruct Function\n{\n{J simple variable spec\nenun eVarType\n\nVAR_WOID, VAR_BOOL, VAH_INT, VAA_FLOAT, VAR_STRING,\nhi\n\niJ possible calling conventions\nenum eCallType\n\nCALL CDECL, CALL_FASTCALL, GALL_STOGALL, GALL_THISGALL,\n}3\n\ntypedef std:ivector ~eVarType* Paranvec;\n\nStd: tetring m_Hane;\n\nvoid\" m_Prac;\n\nungzigned int m Serialip;\n\neVarType m_Returntype;\n\nParaavec n_FParantypes;\n\neCallType n_CallType;\ni\n\nTYpedeat ald: i vector <Function= Functionvedc;\n\n/} the global cet of specifications for exported functions\nFunctionVec g Functions;\n\n14 A Generic Function-Binding Interface 61\n\nAssume for the moment that we have a way to fill g Funetions with specifications\n\nfor all our exported functions (I'll explain how to do thar a little later). Now, how can\nwe use this information to actually call functions? First we must know how our plar-\nform's various calling conventions work,\n\nCalling Conventions\ner\nYou can check your compiler’s documentation co see how its calling conventions\nwork, On Visual C++ for x86 Win32, all function calls have certain things in com-\nmon:\n\nThe stack grows downward, and all parameters are pushed from right to left. In\neffect, parameters go from left to right on the stack for increasing memory\naddresses.\n\n- The stack pointer (esp) always points to the lowest memory address of the stack,\n\nwhich unfortunarely has the name of “top.” It must be dword (4-byte) aligned, so\neach parameter pushed must be likewise aligned to adword. The push instruction\ndecrements esp first, chen stores the data. The Pop instruction loads data first,\nthen increments esp.\n\n- Parameters passed by value are pushed on the stack in their entirety. Doulsles (8-\n\nbyte) and user-defined types are just copied onto the stack. The memory\naddresses contained by references and pointers are directly pushed onto the stack.\n\n- Simple non-Aloat reruen values such as integers and pointers are stored in the eax\n\nregister. Etght-byte suructures are recurned in edx and eax as a pair. Floats and\ndoubles are returned through the FPU in sto. Retum values for user-defined\ntypes have their addresses pushed onto the stack last, but they will also be\nreturmed in eax,\n\nHere are the treo calling conventions that we'll be slipporting:\n\n_edecl. The caller cleans wp the stack, meaning chat it is responsible for pop-\nping its own arguments off the stack after the call completes. This convention is\nrequired for variable argument functions because the called function doesn't nec-\nessarily have the information it needs to pop the correct number of arguments.\nThis is the default calling convention for static and giobal functions in € and\nC+4.\n\n—Sstdeall. The called function cleans up the stack. This is the standard conven-\ntion used for Win32 API calls, probably because ir is more efficient in terms of\nclient code size.\n\nSupport for the other three calling conventions (_tasteall and the neo this-\n\nall variants) is beyond the scope of this article, but it could be worth looking into\nand supporting, depencling on the application.\n\n62 Section 1 Programming Techniques\n\nNow we have enough information to do generic function calls with these ovo\nconventions. We also need a function to retrieve a floating-point value from the FFUs\nSTO register (as is convention) co be stored in a generic return value. Here are some\n\nfunctions that do the dirty work:\nDWORD (all edeci{ const void‘ args, size_t sz, OWRD func }\n1\nCAD re: ff here's our raturn value...\n__ am\n{\nmov ECx, Sz fi gat size of buffer\nmov 854, args ff get buffer\nSub bsp, #ox ff allocate stack space\nmov edi, ¢sp ff start of destination stack frame\nshr ocx, 2 if make it dwords\nrep powsd ff copy parars to real stack\ncall [fine] ff call thea function\nmv ro, ax if save tha return value\nadd 84f, 42 ff restore the stack pointer\n}\nreturn ({ re }:\n}\nWORD Call stdeall( const wold* arge, aize_t sz, O@OAD func }\n{\nCwoAo re; ff fere's our return value...\n50\n{\nmov CK, Sz ff get size af buffer\nmov O51, args ff get buffer\nsub) 6OSp, ocx {f allocate stack space\nmov oi, asp {f start of destination stack frame\nshir Ge“, 2 if Bake it dwords\nrap oo mowsd if copy it\ncall [func] ff call tha function\nmov Tc, gam ff save tha return value\n}\nreturn { re ji\n}\n_Gecispeac { maked ) DWORD GetSTo( woaid 4\n{\nCADAD Ti ff temp var\n__#5m\n{\ntstp dword ptr [fT] Ii} pop STo inte f\nmoy eax, dward ptr [f] // copy inte pax\nrat Ii done\n}\n}\n\nNow, given a function's address and some parameters stored in a memory buffer,\nwe can calla function in an almost completehy generic way.\n\n1.5 A Genoric Funection-Binding Interface ; 63\n\nCalling the Function\n\nBefore making the actual call, our client subsystem (scripting engine, network RPCs,\nete) needs to doa little preliminary work. First it looks wp the instance of the Func-\ntion structure within g Funetions that corresponds to che function it will be calling.\nFor the scripting engine, we want to verify that the function's specification matches\nup with what we're expecting: Check and convert any parameters if necessary, or give\nan error if its a mismarch. This procedure could be expensive and should be done\nduring the seript compilation phase, and not in real time.\n\nLooking up the Function instance for network RPCs isa little more complicated.\nA good way to set chis up is ta intercept the call fom within the function thar is des-\ntined to be called over the network. Look in g Functions for the Function instance\nwith the highest o_Proc value thar is less than the current instruction pointer (eip) to\nfigure owt which funcrian is currently being called. Here is an example:\n\n—Heelspec { naked } DWOAD Getler void }\n\n{\n__ S50\n{\nHOV €4x, daord ptr [esp]\nreat\n}\n}\n\nff sample APG able ftunetion\nvoid MetFaa( bool sand, int i}\n{\nff FindFunction() should look in g Functions for highest “a_Proc'\nff [ese than *ip\" and return it\nState Const Function* sFunction = FindFunction( GetEIF() TF\nif ({ send }\n{\nff AouteFunction(} should pack up the Parameters and send the\nff PeQuest aver the network.\nRouteFunction{ sFunction, (BYTE*)asend + 4 1;\nreturn:\n\n}\n\nff... normal @xecution of Methoo\nprintt( “i = Sain\", 2 pz\n}\n\nThe next step is to construct the parameter buffer ro pass to che function. Fora\nScripting engine based on a virtual machine, this is easy; all our parameters are already\non a dword-aligned virtual stack, We can simply take the address of the start of the\nparameters and pass it along. For network RPCs, it will be a litcle more difficult. We\ncant pass pointers generically over the network, but we can make a special case for\nsirings, s0 analyze the m_ParasTypes for VAR_STAING types and append the contents af\nthe string to the end of the buffer thar gets sent to the network transport. On the\n\n6a _ Section 1 Programming Techniques\n\nreceiving end, resolve the pointers to point to the appended data, and then use the\nstart of the chunk as the beginning of the parameter buffer.\n\nNow thar we have the Function instance and our parameter buffer, we call either\nCall_edeol() or Call_stdcall(), depending on n_CallType, passing in the parameter\nbuffer and m_ Proc. Then we can either use the recurn value or call GetsTo() co ger ic if\nm_ReturnType is a float or double. Thar’ all there is co calling a function generically!\n\nCompleting the Solution\n\nUntil now we've been assuming that the g_Functions array has already been set up.\nLet's go back and fill in this hole now, There are several ways co fill out the g_Func-\ntions array. Perhaps the easiest to implement bur least safe to use is co apply macros\nof a function to set it up:\n\nfloat Foo{ int, const char* |;\nint Bar( void j);\n\nvoid SatupFunctionexporta( void |\n\n{\n\n{\nFunction function;\nfunction .m_Name = \"Foo\"}\nfunction.m Prac = Fes\nfunction.g Serdalio 9 = g Functione.siza();\nfunction. AeturnType = Function. avarType: :WAR_FLOAT;\nfunction. Paramtypes . push_back{ Fumction.eVarType::VAR_INT };\nfunction.n_ParasTypes . push _back( Function, eVarType:-VAR_STAIMG };\nfunction. mGallType = Function. eGallType::GALL COeci;\n@ Functions.push_back( function );\n\nI\n\n{\nFunction tunction;\nfunetion. m Mane = \"Bar\";\nfunction mi_Proc = Bar;\nfunction.m SarisilIp = g Functions.size();\nfunetion.© Returnlype = Fumetion.eVarType: :VAA_INT;\nfunction.m_Calltype = Function.eCallType: iCALL_CDEGL;\ng Functions.push back function };\n\n}\n\ni\n\nThis example is illustrative but not exactly optimal. It could be improved with\nsome helper functions and macros to make it easier to add new functions to the table.\nHowever, it will always be unsafe and inconvenient. Adding a new function te the table\n\n1.4 A Generic Function-Binding Interface 65\n\nmeans that someone has co write some code that specifies its rypes, name, and calling\nconvention. (Changing a function (adding 2 parameter, for example) without updating\nthe table could ineraduce some nasty and hard-to-debug problems. It isa locof work to\nkeep the function specifications in sync with the actual function prototypes.\n\nWe need 2 way to build this table automatically and safely climinate these prob-\nlems. Fortunately, the C++ compiler already has all the information we need. While\nparsing the function's protorype, the compiler builds an internal representarion of the\nfunction—its return type, parameters, calling convention, and so on—cxactly whar is\nrequired to eenstruct a function specification! Unfortunately, we dont have access to\nthis information from within the code, and besides, all char information gets thrown\naway when the linker constructs the final EXE, We could probably find a way DO use\nthe PDB (debug symbols database) co query for whar we need, but we can't ship\ndebug symbols with the game. Besides, we wouldn't have an easy way to tell which\nfunctions are for export and which aren't.\n\nCombining the export table functionalicy of a Win32 image file with the C++\nlanguages name-mangling faciliey gives us the informacion we require. IF we tag a\nfunction for export using dhe __daclspec( dllexport } keywords, thar function's\nname and address will appear in the EXE (or DLL) export table, In addition, because\nthis is a (C++ application, those names will be mangled to support type safety and\noverloaded name resolution, Mangled names are encoded with all the information we\nrequire, so all we need is to decode che names into a form we can understand and then\nuse that to build the Function encry co add to g Functions.\n\nThe name-mangling format is completely implementation specific and undocu-\nmented, and it even changes from release to release of Visual Ces, sa attempting to\nreverse-chginesr it is probably not a goed idea, In's also Linnecessary; Microsoft\nexported a name-unmangling function called UnDecorateSymbolNane() fram borh\nImageHIp.dil and DbgHelp.dil that does exactly this. So if we were co cake our Foot}\nFunction from the last sample and DLL-expart it, the Entry 7FooRavAMHPADEZ would\nappear in the EXE's exporr table. If we unmangle the name, here's whar we get back:\nfloat _edecl Foo(int,char const =). Now this is something we can easily parse\nand convert to a Function entry for addition to our 9 Funetions table.\n\nSo now our procedure for building g Functions is:\n\n1. Tterare over all entries in the EXE's export table, and retrieve cach function's\naddress and mangled name.\n2, Unmangle each name to get a function protetype in text form.\n3. Parse che function protorype en retrieve name, type, and calling comvencion infor-\nMa thor.\n4. Store the results in a new entry within g Functions. Repeat for cach export.\nIterating over the exports to get the function addresses and mangled names\nrequires knowledge of the binary format of Win32 Portable Executable (PE) forrat\nfiles. A specification for this format is available from the Microsoft Developer Net-\n\n66 Section 1 Programming Techniques\n\n—— EEE\n\nwork Library (hop://msdn.microsoft.com). Search for the ~.edara” section within the\nlibrary entry for the Microsoft Portable Executable and Common Object File Formar\n\nSpecification to find the structure of a Win32 export table.\n\n‘There's one final lictle detail. The entries in the export table point wa jump table,\nwhich in tum points to the actual functions. This detail isn’t important if all you're\ninterested in is binding to functions and calling them generically. However, if you\nneed to be able to do a reverse lookup and convert eip from within the called function\nto find its Function instance (required for RPCs, as described eatlier), you need vo get\nthe actual address of the function for comparison, noc the address of che enery in che\njump table. This is easy enough: Dereference the address given by the DLL export\nentry to find the jump table entry. The first byte will be ox&9 (jmp), followed by a 4-\nbyte offset to the actual entry point of your function. ‘Take the address given by the\nDLL export entry, add 5 for the full jmp instruction, add che 4-byee offset, and this\nwill be the address of the entry point of pour funcuion. This address can then be used\nfor reverse lookup to find the Function instance from within g_Funetions.\n\nConclusion\n\nWe now have everything we need co call functions in a completely generic way. In\norder to publish a function in the system and allow other subsystems such as script-\ning and necwork RECs co bind to it, we simply tag it with declspec( dllexport }\n(this verbose tag is best wrapped in a macro to reduce clutter). At run time, the\nfunction-binding publisher iterates over the Win32 export table and extracts name,\ntype, and calling convention information from cach entry, Other subsystems can\nlool up functions by memory address, name, or serial ID and call them generically\nusing Call_edeel() or Call_stdeall(}.\n\nThis seems like quire a bit more work wo implement than mecessary, and for\nsmaller projects with small export sets, it probably is. Larger projects, on the other\nhand, will probably be changing constantly. The good news is that, once the basic\nwork is done, adding new functions co the system is as simple as tagging them for\nexport, and chey'll immediately be available. This process more than pays for itself\nand is a powerful ability to give any engineer on your team. When combined with a\ngeneral-purpose scripting engine, the process can be turned into a useful debugging\ntool as well as serving the content-specific needs for which it was originally wricten.\n\nIn the interests of space and simplicity, we have left out many of this article's fea-\ntures. The generic function-binding concept can be taken much further in a variety of\nways. It ean easily be enhanced to include support for pointers and references, variable\narguinent functions, and passing more than just strings over a network. User-defined\ntypes could be supported for RPC packaging through a serialization interface char can\nbe detected and called directly when post-processing RPC parameter buffers for out-\nbound network buffers. In addition, support for calling class member functions is a\nvery useful tool and can be easily added. Finally, one fearure thac might of might not",
      "page_number": 56,
      "chapter_number": 7,
      "summary": "Section 1 Programming Techniques\n\nUF erates\nhi\n\nThe eFunetion enumeration provides a serialized list of unique IDs for all avail-\nable functions, The Function structure maps a text name onto a function poincer and\nunique ID Key topics include functions, function, and parameters.",
      "keywords": [
        "Function",
        "functions",
        "function calls",
        "call",
        "parameters",
        "stack",
        "generic function calls",
        "che Function",
        "Function instance",
        "call functions",
        "function specification",
        "Programming Techniques",
        "calling conventions",
        "Bar",
        "Foo"
      ],
      "concepts": [
        "functions",
        "function",
        "parameters",
        "calls",
        "void",
        "work",
        "network",
        "exports",
        "types",
        "stack"
      ],
      "similar_chapters": [
        {
          "book": "Python Distilled",
          "chapter": 14,
          "title": "Segment 14 (pages 116-123)",
          "relevance_score": 0.68,
          "method": "sentence_transformers"
        },
        {
          "book": "Effective-Python",
          "chapter": 11,
          "title": "Segment 11 (pages 99-114)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        },
        {
          "book": "Python Essential Reference 4th",
          "chapter": 7,
          "title": "Program Structure and Control Flow",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "AI Agents and Applications",
          "chapter": 42,
          "title": "Segment 42 (pages 363-371)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 26,
          "title": "Segment 26 (pages 815-849)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 65-77)",
      "start_page": 65,
      "end_page": 77,
      "detection_method": "topic_boundary",
      "content": "1.5 A Generic Function-Binding Interface 67\n\nbe necessary isa coal char will post-process an EXE, stripping off the exports table and\nconverting it into a native data formar for direct import into g Functions. This tool\ncould be necessary either for SECUMIY teatans (to prevent cheating. perhaps) ar to\nmake it unnecessary to ship ObgHalp.dll with the game.\n\nReferences\nee\n\nMicrosoft Developer Network Library, http:!/msdn.microsoft.com.\n\n1.6\n\nA Generic Handle-Based\nResource Manager\n\nScott Bilas\n\nAll computer applications are databases. They spend most of their time juggling data\nresources—creating, desroying, caching. modifying, querying, saving, and restoring\nobjects of various types. Games typically contain multiple rypes of databases, each of\nwhich is generally hard-coded for each different case, wo keep things speedy, Some\nexamples of game databases are file systems, texcure managers, font managers, and\nfame actor managers. On top of those, there is a wide variety of domain-specific dara-\nbases thar completely depend on the game's genre and content.\n\nAvresource database that's built into all C++ games is the basic object memory man-\nager. A programmes calls new to construct a new abject and passes ins pointer around\nso thar other objects can pass it messages. When the object is no longer needed, some-\nbody deletes it, and its resources ane retumed mo the system. This method works very\nwell in general, bur it breaks down when we have to worry about shared resources.\nThis is where we need a more specialized databace,\n\nLet's use a fone abject for our example. Ar minimum, the font consists of a bit-\nmap and a set of specifications, such as che XY (or £64 locations of its character cells,\nso the graphics system can render it to the screen. Such an object is fairly heavy duty\nin terms of memory usage and creation time. Different systems in the game, such as\nthe development console and a text control within the GUI, want to use fone objects,\nbur we can't have each system creating its own local copy of the font objece, Obvi-\nously, that would be slow and consume a lot of memory. To solve this problem, we\nneed to come up with a way to share font objects. Qur solution is called che Fontigr\nand features methods thar get pointers to fonts, loading them on the fly and caching\nthem until they are no longer needed. The FontMgr is made available from a global\nlocation (possibly as a singleton; see the article “An Automatic Singlecon Utilicy”) and\nis responsible for all che fone objects in the system,\n\nWhat we're really talking about here is a specialized database. The Fontwgr is\nresponsible for juggling font resources and, now that it’s considered an API. suddenly\ntakes on additional responsibilities as the central clearinghouse for fonts. Whar if\nsomeone tells the Fontégr to delete a font to free Up resources, but some systems in\n\n1.6 A Generic Handle-Based Resource Manager 69\n\nthe game still have pointers to it? How do we guarantee safery of the system without\nsacrificing performance? Will we he copy-pasting this code again (with slight tweaks)\nwhen it comes time to build che MousePointertigr? This article presents a simple, safe,\ngeneric, and efficient way to manage controlled resource objects.\n\nThe Method\n\na\nThe job of a resource manager is to create resources on demand, hand them our ro\nanyone who asks, and then eventually delete them. Handing out those resources as\nsimple pointers is certainly easy and convenient, bur it’s not a very safe way to do ic.\nPointers can “dangle”; one part of the system can tell the resource manager to delete a\nresource, which then immediately invalidates all ocher outstanding pointers. There's\nno good way to prevent the dangling pointer problem from happening, and the only\nway we would find our that someone was attempting to dereference a deleted abject is\nwhen the game crashes. The problem is that, with pointers, there's no way to Imew\nhow many references are outstanding, given thae cients can copy the pointers as\nmany times as they like without telling the manager abeut it.\n\nAnother problem is that the underlying data organization cant change with\npointers. Any reallocation of butters immediately invalidates all outstanding pointers.\nThis becomes especially important when you are saving the game to disk. Pointers\ncant be saved ro disk, hecause the next time the game ts loaded, system memory will\nprobably be configured differently or you could even be on a completely different\nmachine. The pointers must be converted into a form that can be restored, which will\nprobably be an offset or a unique identifier of some sor, Working around this prob-\nlem ist't exactly crivial and can require a lot of work to support in client code.\n\nSo it's plainly not a good idea for a safe and flexible resource manager to be hared-\ning out pointers. Rather than using pointers or attempting to write some kind of\nsuper-intelligenc, overly complicated “smart pointer,” we can add one layer of abstrac-\ntion and use handles instead, putting the burden on the manager class. Handles are an\nancient programming concept that APIs have been using with great success for\ndecades. An example of a handle is the HANDLE type returned by the GreateFile: ) call\nin Win32ss file system. A file handle, representing an open file system object, is cre-\nated through the GreateFile;) call, passed to other functions such as AeadFile(} and\nSetFilePointer{) for manipulation, and then finally closed off with CloseHandle().\nAttempting to call those functions with an invalid or dosed handle does not cause a\nerash; instead, ir returns an ester code, This method is efficient, safe, and easy to\nunderstand.\n\nHandles almost always fir into a single CPU register for efficient storage in col-\nIcctions and passing as parameters to functions, They can be easily checked for valid-\niry and provide a level of indirection chat allows the underlying data organization to\nchange withour invalidating any outstanding handles. This has significance advantages\nover passing around pointers, Handles can also be easily saved to disk, because the\n\nTo Section 1 Programming Techniques\n\ndara stmuctures they refer co can be reconstructed in the same order on a game restore.\nThis facility allews che handles ta be stored directly, with no conversions Necessary,\nbecause they are already natively in unique identifier form.\n\nThe Handle Class\n\nA fast and safe way to represent handles is to use an unsigned integer composed of pwo\nbitfield components (this class appears in Listing 1.6.1). The first component\n(=_EIndex) is 2 unique identifier for fase dereferencing inte the handle manager's data-\nbase, The handle manager can use this number however it likes, bu perhaps the most\nefficient use is as a simple index into an std::vactor. The second component\n(= Magic) is a “magic number” that can be used to validate the handle. Upon derefer-\nencing, the handle manager can check to make sure that the magic number compo-\nnent of the handle matches up with its corresponding entry in the database.\n\nThe Handle class is very simple and really doesnt do much except manage the\nmagic number. Upen calling Init(), the handle is given the next magic number,\nwhich automatically increments and wraps around, if necessary. Nowe chat che magic\nnumber is not intended to be a GUID. Its purpose is 00 serve asa very simple and fast\nvalidity check, and it relies on the high improbability of a condition arising where ane\nobject happens to have the same index and magic number (via wrapping) as anocher.\nThe magic number of zero is reserved for the “null handle\" where che handle’s data is\nzero, The default Handle constructor secs itself to null, a stare that returns true on an\nIsWull() query. This is convenicot to use for am erpor condition; a function that cre-\nates an object and retums a handle to it can simply return a null handle co indicate\nthat an error occurred.\n\nIn most ways, the Handle class acts as a read-only unsigned inceger. It's not\nintended to be modified after being created, although it can safely be assigned back to\nnull to reset it. Morice that Handle is a parameterized class, raking a TAG rype co fully\ndefine it. The template parameter Tag doesn't do anything except differentiate among\ntypes of handles; an object of type TAG is never used anywhere in the system. The\nmotivation here is oype safety. With Handle mot parameterized, a handle meant for\none type of resource could be passed to a function expecting a handle to a different\ntype of resource, withour a complaint from the compiler. So to keep things safe, we\ncreate a new handle type, taking any unique symbol and using it for the parameter.\nThe TAS type can really be anything so long as ic is unique across Handle types, but it’s\nconvenient co define an empty struct and use thar in the typedef for a handle, like this\ntexture handle example:\n\nstruct tagTexture {\ntypedef Handle <tagTexture> HTexture;\n\nNow we need a handle manager thar is responsible for acquiring, dereferencing,\nand releasing objeces (via handles) for a higher-level owner.\n\n1.6 A Generic Handle-Based Resource Manager Fi |\npei $$\n\nThe HandleMogr Class\n\nThe Handlelige class is a parameterized type composed of three main elements: a data\nstore, a Magic number store, and a free list (this class appears in Listing 1.6.2). The\ndata store is simply a vector (or any other randomly accessible collection) of objects of\ntype OATA. The DATA type, the first nype paramerer for Handleugr, should be a very’\nsimple class thar contains context information about the resource that it controls. For\nexample, in a Handlevigr thar manages files, che DATA type would probably have only\nthe file handle and the name of the file:\n\nstruct FileEntry\n{\n\nStd:cstring m_Filetane;\n\nHANDLE f_FileHandle; // OS file handle\nIi\n\nstruct tagFile { 4};\ntypedef Haridle <tagFile> HFile;\ntypedef HandleMgr <Filefntry, HFile> FileHandleugr;:\n\nThis simple handle manager maintains a set of context objects that correspond ta\nall the open files char it knows abour. The FileHandlewgr class will probably nor be\nused directly by clients bue will instead be owned by another class (call it Fitengr)\nthar handles the abstraction and knows about the problem domain (thar is, what DATA\nis supposed to represent). This class might look something like this:\n\nclass FileMgr\nFileHandleMgr m_Mgr;\n\npublic;\nHFile OpenFile ( const char* mane );\nbool ResdFile { HFile file, woid* gut, Bize t bytes ):\nbool CloseFile( HFile fila };\n\nie face\nhi\n\nUpon calling any of these methods, Filewgr aske its m_lgr to dereference the han-\ndle to get at the actual Filemntry object. After verifying that the dereference suc-\nceeded (ic will Gil on an invalid handle}, it chen perlorms the operarion.\n\nFor our Hendletige class, cach handle references cxactly one elemenc within the\nobject store, plus irs corresponding clement in the magic number store. Dereferencing\nthe handles to ger at the actual FileEntry object is as simple as using the m_Index\ncomponent of the handle as an index into the object store (a very fast operation).\n\nWhen dereferencing the handle, the code also checks the m_ Magic component\nagainst the same index in the magic number store to make sure the handle is valid. As\nhandles are freed and reacquired, corresponding entries in the magic number store are\n\n72 : Section 1 Programming Techniques:\n\nupdated with the new handle magic numbers. This process nearly guarancees chat\n“dangling” handles on released objects won't refer to unexpected objects when the\nslors are Filled by a later handle acquisition bur instead simply fail to work and return\nan error code. Obviously, the magic number store always has the same number of ele-\nmenes at the object store.\n\nAs objects are released, the handle manager adds the indices of the slots they\noccupy to the free list. This saves ic the trouble of needing to search through the\nobject store to find an open soc, which results in a tasty O(n} complexity for new han-\ndle acquisition. It’s imporrant co note that the DATA type is not your rypical C++ class.\nIt shouldn't have constructors and destructors that do anything important, such as\nacquire and release local resources. Objects contained within che object store are con-\nstructed, destroyed, and copied as the vector class sees fir. Nowe chat the std::string\nused in the sample FileEntry is “simple” enough for our meeds; it’s reference-counted,\nwhich minimizes the impact of its constructors and destructors and makes it nearly\nfree for vector to copy.\n\n‘When asked to acquire an object from the store, we'll likely cnd up reusing an\nobject that has already been constructed but is no longer in use, as indicated by its\nentry in the free list. This object needs its members reinitialized before it can be used,\nbecause it won't have had the constructor call co set ix up. When an object is freed\nfrom the store, it is noe destroyed; instead, it has irs index added co the free list and as\nsuch needs its resourees manually freed. These minor limitations arise fram che fact\nthar were embedding our OATA type directly in vector, rather than using poincers and\ncreating and destroying the objects with new and delete for each handle acquisition\nand release. The major advantage here is speed, in char the objects dont have to be\ncompletely brought up and shut down cach ume. To make things more convenient,\nthe initialize/shutdown code can be moved into member functions for casy callback\nby the HandleMgr owner.\n\nThe amount of handle validation necessary could depend on the application and\ncould even be chosen through an additional templare parameter for HandleNgr. For\nexample, the rest for an invalid handle might be found unnecessary and could be\nremoved (although the debug assertion should always remain), For a more robust sys-\ntem in which error handling is important, the cade could, upon detecting an invalid\nhandle, set an error condition and chen abort the function call.\n\nSample Usage\n\nListing 1.6.3 provides a sample texture manager class. ‘This class allows clients po ask\nthe manager for textures by name and constructs them on demand. Ic automatically\nunloads the textures on deletion and provides a ser of query functions to use the tex-\ntures. The textures are indexed by name for speedy lookup to make sure thar the same\ntexture is not addedd to the store rece. Ir would he a simple exercise to add reference\n\n1.6 A Generic Handle-Based Resource Manager 73\n\ncounting 60 ehis example co make ir safer, replacing DeleteTexture() with Release-\nTextured).\n\nFor another (larger) sample of file handle usage, see the sample code for my GDC\n\n2000) talk, fer Sell! Loading? Derigning an Efficient File System, available aniline at\nwenw.anoeo-scormby peel.\n\nNotes\n\nee\n\nThe Handietigr class is very simple and is meanc ro illustrate some bade concepts, but\nican be expanded in a number of ways, either with the existing Handleligr or separare\nclasses:\n\nCreate a Handletigr that works better with larger DATA objects, holding them indi-\nrectly through pointers. Ir should also allow hiding of the data strucrure to\nclients.\n\nAdd automatic reference counting as standard functionality, rather than leaving it\nthe responsibilicy af the owner of che Handlemgr.\n\nAdd support for constant-time iteration over the potentially sparse object stare by\nembedding a linked list within ies elemens. Use $TL-style iteraror naming and\noperation for consistency.\n\nMany databases, such as a font manager or texture manager, likely require indexes\nto acoess objects by name co retrieve handles. Build this requirement in as a stan-\ndard feature of as a separate (derivative) class.\n\nThe Handlotgr system is especially effective when combined with che singleton\npattera (see the article “An Automatic Singleton Utility” elsewhere in this book).\nMany of a game's databases are naturally singletons.\n\nTake the singleton patcern a litle further and make the Tag type of Handle actu-\nally be the type that it corresponds to within the Mandlewgr. Then the Handle\ncould have an operator -> that dereferences itself inte a TAG by direcsly accessing\nthe singleton that manages it,\n\nSave-game functionaliry should be fairly casy wo add, but it is necessarily specific\nto your games architecture. The handles can be saved our directly; just make sure\nthat the Handiewgr stores the indexes for its objects along with the object dara,\nand on restore, all handles will remain valid.\n\nListing 1.6.1\nae\n\nfincluda =cassert>\n\ntemplate <typenane TAG\nclass Handle\n\nuniar\n\n{\n\nTé\n\nSection 1 Programming Techniques\n\nenum\n\n}/ i288 to use for bit fields\nWAX BITS INDEX = 16,\nWAX BITS MAGIC = 16,\n\ni} sizes to compare against for asserting dereferences\nWAX INDEX = ( 1 << MAX BITS INDEX) - 1,\nWAX MAGIC = (| 1 << MAX BITS WAGIC) - 1,\n\nhi\nstrinct\n{ -\nunsigned m_Index : MAX_BITS_INDES; // index inte resource\narray\nunsigned m_Wagic ; MAX_BITS_MAGIG; // magic number to check\nhi\nunsigned int m_Handle;\nhi\npublic:\n\nif Lifetine.\n\nHandlo( void ) : m_Handle; o) { }\n\nyoid Enit( unsigned int index j;\n\nif Query.\n\nunsigned int Getindex ( void ) const { return (| mIndex 4}; 4}\nunsigned int GatWagic ({ void ] const { return ( -m Magic 4}; }\nunsigned int GetHandle{ void ) const { return {| m_Handle }; }\nbood [sNull 8 { void ) const { return ( Im Handle }; }\n\noperator unsigned int { void } const { return { mHandle }; }\n\nhi\n\ntenplate <typenanme TAG>\nvoid Handle <TAGe 3: Imit( unsigned int index }\n\n{\n\nassert( IsNull{) }; ff don't allow reassignment\nassert( index <= MAX INDEX }; Ji verify range\n\nStatic unsignad int &_AutolWagic = 0;\nif ({ ++5_AUTOMagic > WAX_MAGIC }\n\n1\n\ns AutoNagic = 1; ff 0 is used for “null handle\"\n\nI\n\nm_Index = index:\nmM Magic = 8 AutoWagic:\n\n}\n\ntemplate <typenane TAG=\n\n1.6 A Generic Handice-Based Resource Manager Té\n\ninline bool operator i= ( Handle <TAG 1, Handle <TAG> r )\n{ Féeturn { 1.GetHandle() != r.GetHandle() jp; }\n\ntemplate <typename TAG\ninline bool operator == [ Handle <TAG= 1, Handle <TAg> r j\n{ return ( l.Gethandle() == r.GetHandleal) ); 3\n\nListing 1.6.2\nge\n\nfincliaé@ <vector>\n#inclidé <cassart>\n\ntemplate <typaname DATA, typaname HANDLE>\nclass Handleugr\n\n{\nprivate:\ni} private types\ntypede?t stdi:vwecter <DATA> UserVvec:\ntypedet stdiivector <unsigned int» Magiovec;\ntypedef std::vector <unsigned int™ Freeved;\ni? private data\nWserVec mo _Userbata; ff data we're going to get io\nMagicVec m_WagicNunbers; // corresponding agic numbers\nFreevec _FreeSlots: ff keeps track of free slots in tha db\npublic:\n\nff Litetime.\n\nHandleWgor( vaid ) { 4}\n-HandleaWgr([ void } { 4}\n\ni/ Handle methods.\n\nff aequisi tion\nDATA* Acquire! HANDLER handle }+\nWold Release( HANDLE handle };\n\nif Gereferencing\nDATA Dereference( HANDLE handle }:\nconst OATA\" Dereference HAWDLE handle } const:\n\n{i other query\nunsigned int GetWeedHandleGeunt( void | const\n{ return ( m_Magichumbers.size{) - m_FreeSlots.size() ); }\nbool HastsedHandles| void ) const\n{ return ( |1GetUsedHandleGount() ); 3\nhi\n\ntemplate “typename DATA, typename HANDLE=\nDATA\" Handleligr <DATA, HANDLE> :: Acquire, HANOLES handle ]\n\nIi if free list 45 empty, aod a new one otherwise vee first one four\n\n76\n\n}\n\nSection 1 Programming Techniques\n\nunsigned int index;\nif { m_FreeSlots.empty() 5\n\n{\nindéx - m_Magichumjers.size()+\nhandle. Initt index j;\nn_Userbata.push_back( DATA) };\nn_Wagichunbers.push_back{ handle.GetWagic,) };\n}\nelge\n{\nindex = m_Freeslots.back( );\nhandle. Inmit( index };\nm_Freeslots, pop back();\nm_Magichiabers[ index ] = handle.GetMagic(}:\n}\n\nreturn { n_Userbata.begin() + index J;\n\nTenplate <typename DATA, typename HASOLE>\nvoid Haridletgr <DATA, HANDLE» :: Release HANDLE handle }\n\n{\n\n}\n\nI) which ono?\nungkigned int index = handle GetIndgex();\n\n! i gake sure it's valid\nassert( index < m Userbata.size|) };\nassert( @_Magichumbars| index | == handla.GetMagial) );\n\nff ok remove Gt - tag as unused and add to free list\nm_Magiclumbers[ indax ] = 0;\nm_FreeSlots.push back( index };\n\ntenplate <typaname DATA, typenene HANDLE>\ninline DATA* HandleMgr <DATA, HANOLE>\n:: Dereference( HANDLE handle }\n\n{\n\n}\n\nif { handle.Tshull() ) return ¢ oO 413\n\nif check handle validity - 3 this check can be removed for apeed\nif it you can assume all handle references are always valid.\nunsigned int index = handle.GetIndex();\nif { ¢ index >= n_Userfata.sizel) }\n\n|| ¢ m_Magichenbers[ index ] I= handle.GetWagic() } }\n\n{\nff fa good! invalid handle == client programming error\nagsert( O 33\nreturn ( O 9;\n\n}\n\nreturn { m_UserData.begin() + index M3\n\ntemplate <typiname: DATA, Typenem HANDLE>\n\n1.6 A Generic Handle-Based Resource Manager TT\n\noe\n\ninline const DATA* Handleligr <DATA, HANDLE>\n=> Derefterence, HANDLE handle } const\n{\n\nff this lazy cast is ok - non-const version does not modify anything\ntypedeat Handlemgr <DATA, HANDLE» ThisType;\nreturn [ COMET_¢ast <Thislype*> { this ):>Dereferencel haadle } V3\n\nListing 1.6.3\neo eet a\n\n#include <vector>\n#include <nap>\n#Hinclude <cassert>\n\nff so. [ platform-specific surface handle type hare |\ntypedef LPDIRECTORAWSURFACET Ostandle;\n\nSTFUCT taglenture { 4:\ntypadat Handle <tagTexture> HTexture;\n\nGlass Textureldge\n{\n\nff Texturo object data and db.\nstruct Texture\n\n{\ntypecat sid: ivecter <Oshandle> Handlevec;\n\nStdisstring © Mam: fy) tor receastruction\nHnsignead int m_Width; ff mip 0 width\nunsigned int m_Héight; ff mip 1 width\nHandlaVec m_Handles; If handles te mip surfaces\nOsHandle GetOsHandle( unsigned int mip }) sonst\n{\nassert({ mip =< m_Handles.sizal) };\nreturn { &_Handlas[ mip ] 3};\nI\n\nbool Load { const stdi:string& mame j;\nvoid Unload{ void };\nhi\n\ntypedet Hanilelgr <Texture, Hlaxture= HTexturemMgr;\nff Index by mame ante db.\n\nif case-ingensitive string conparison predicate\nstruct istring_Less\n{\nbool operator () ( const stdrratring& 1, const std::string& r }\nconst\n{ return ( i:stricmp( Lie _str(}, r.c_str{} } <0}; }\n\nSection 1 Programming Techniques\n\nhe\n\ntypade? Stdscmap <sto:sstring, Hlexture, istring_less » Manelndax;\ntypedef std:cpair <NameIndex::iterater, bool> NaneIndexInser thc;\n\nif Private data.\n\nHléxtureligr n_Textures;\nHaneIndex n_Nameaindex;\n\npublic:\nif Lifeting.\n\nTextureligr{ wold ) { #* ... TF }\n-Textureligr{ woid ji\n\nif Texture management.\n\nHTexture GetTexture | const char* name };\nvoid DeleteTexturel HTexture tex };\n\nii Texture query.\n\nconst std:istrings GetName( HTexture Wtex ) const\n{ return { m_Texturos.Bereferance( htex }->m_Nane };  }\nint GetWidth{ HTéexture Atex } const\n{ return { @Textures.Dereference( htex j->m@ Width }; 3\nint GatHeight{ HTexture htex } const\n{ return | mTextures-Dereference! htex }->m Height |; }\nDsHandle GetTexture( Texture htex, unsigned int mip = @ ) const\n{ return | @Textures-Dereterencal Ntex }->GetOsHandle( mip ) }:\n\njoo eee\nfan\n\nTextureuigr i: =Textureiigr( woid }\ni\nff release ell our remaining textures before we go\nNamIndex: iiterater i, began = m NameIndex.begin(}, and =\nm Nanelndex.end( ps\nTor {| a = begin ; i != end = ++i )\n{\n\nI\n\nB_Textures.Deraterence( i-*secend )->Unload(};\n}\n\nHiaxture Textureligr => GetTaxture( const char* name )\n{\nff insert {find\nNameIndexIngerthe co =\nm_Nanaindex. insert, stdiinake_pair{ mane, HTexture() ) 1;\nif { re.sacond }\nq\nff this is a new ingartion\nTéxture® tex = n_Textures.Acguire( fe.tirst->second };\n\n1.6 A Generic Handle-Based Resource Manager Ta\n\nif { Itex->Load( re.first->first ) }\n\nDeleteTexture{ re.tirst->second };\nro.first->second = HTexture();\n\n}\n}\nreturn | ce.tirst->4econd 4;\n}\nvoid TexturaMgr ©: DeleteTexture( HTexture htex }\n{\nTexture* tax = m_Textureas.Dereference( htex );\nif ( tem 120 }\n{\nif delete from indax\nm_Manelndex.erase( om NaeeIndex.tind| tex->n_Name } }\"\nif delete fro db\ntex-=Unload ( );\nn_Textures Release, htex 4;\n}\n}\nbool Texturelgr::Toxture :: Loasd( const Sta: strings name }\n{\nn_Wame = name;\nff... | load texture fram file system, return false on failure |\nreturn { true /* or false on error *s }3\n}\n\nvoid TextureMigr::Textura =: Unload( void }\n\nm Mane.erase|};\nff... [ free up mip surfaces ]\nm_Handles clear);\n\nReferences\nnso sicems\n\n[Bilas00] Bilas, Score, GDC 2000 Talk, Jes Still Losdling? Designing an Efficienr File\nSytem, available online at wrww.aa.nec/-seottb/edc/.\nMeyers, Scott, More Efftertie Cr+, Addison-Wesley Longman, Inc, , 195.",
      "page_number": 65,
      "chapter_number": 8,
      "summary": "This chapter covers segment 8 (pages 65-77). Key topics include handle, handling, and data. 1.6\n\nA Generic Handle-Based\nResource Manager\n\nScott Bilas\n\nAll computer applications are databases.",
      "keywords": [
        "handle",
        "data",
        "Resource Manager",
        "handle manager",
        "handle manager data",
        "magic number",
        "index",
        "Generic Function-Binding Interface",
        "Manager",
        "Handle-Based Resource Manager",
        "Generic Handle-Based Resource",
        "Magic",
        "unsigned int",
        "Magic number store",
        "object"
      ],
      "concepts": [
        "handle",
        "handling",
        "data",
        "objects",
        "returns",
        "classes",
        "index",
        "indexes",
        "manager",
        "manage"
      ],
      "similar_chapters": [
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 4,
          "title": "Segment 4 (pages 25-32)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 8,
          "title": "Segment 8 (pages 57-67)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "Designing Data-Intensive Applications",
          "chapter": 59,
          "title": "Segment 59 (pages 583-590)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 15,
          "title": "Segment 15 (pages 289-307)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "More Effective C++",
          "chapter": 8,
          "title": "Segment 8 (pages 61-75)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 9,
      "title": "Segment 9 (pages 78-85)",
      "start_page": 78,
      "end_page": 85,
      "detection_method": "topic_boundary",
      "content": "1.7\n\nResource and Memory\nManagement\n\nJames Boer\n\nComputer and video games, more than any other type of software, often require han-\ndling vast amounts of media resources such as graphics, sound effects, music, video,\nmodels, animation, and other types of memory-hogging data. Dealing with this large\namount of data while maintaining a relatively reasonable memory footprint is not a\ncrivial task. In this article we examine the workings of a simple resource manager and\ndiscuss how it might be both used and extended in real-world applications.\n\nFirst, lets clearly define our problem and how we expect to solve it. Within a\ngiven time in which it is not acceptable to display a loading sereen or break the action,\nwe expect to use more data in our game than we can hold in memory at one time. It\nis also assumed thar we have a medium from which we can dynamically load our data\nwhile the game is playing, On console systems, this would most likely be a CD or\nDVD type of device, whereas on the PC ir is probably the hard drive.\n\n‘Our solution entails creating resource objects that are able to automatically load,\ndiscard, and reload their data based on usage patterns. We will also create a manager\nte coordinate the available resources and control access wo the resource objects. This\nwill be accomplished through the use of handles, which are essentially just unique\nidentification numbers.\n\nThe Resource Class\nrrr\n\nTo begin with, let's examine the base resource class:\nClass §49e8esourca\nable:\nann PriorityTypa\n: AES_LOW_PRIORITY - oO,\nAES MED PRIORITY,\n\nAES HIGH PRIORITY\n};\n\n1.7 Resource and Memory Management a1\n\nBasehesource() { Clear(}; }\nvirtual -Basehesource(}) { Destroy{}; }\n\ni! Claars the elass data\nvirtual woid Claar();\n\nfi Greate and destroy functions. Note that the Create)\n\ni} Tunetion of the derived class does not have to exactly\n‘/ match the base class. No assumptions are fade regarding\ni? Parameters.\n\nvirtual baal Createg) { roturn false; }\n\nvirtual vodd Destrayt) {}\n\nff Dispote and racreate aust be able te diseard and then\n\nff completely racraate the data contained in the class with\nif 0 additional paranetars\n\nVirtual bool Aacreate(} = O;\n\nVirtual void Dispose() = Oo;\n\n/f GatSize() must raturn the size of the data inside the\nif clase, and [sDisposed(} lets the manager know if tha\nif data exists.\n\nvirtual size_t GetSize() - 0;\n\nvirtual bool Tsfieposed() = 0;\n\nff These functions set the paranetara by which the sorting\nff operator determines in what ordar resources ara\nif discarded\ninline void SetPriority(PriorityType priority}\n{ @_Priority = priority; }\ninling PriorityType GetPriority) }\n{ return mPriority; }\n\ninline void SetReferancecount (WinNT nGount)\n{ #lnhefCount = ntaunt; }\ninline UINT Getheferencetount( }\n{ Feturn minfefGount; }\ninline bool Tslerked( }\n{ feturn (m_nitetCount > 0) Ff true : false; 3\n\ninling void SetLastAceess(time t LastAccass)\n{ @_LastAccess = LastAccess: }\n\ninling time_t GatLastaccess()\n{ return m_LastAceess: }\n\nfi The less-than operator defines how resources get\nff sorted tor discarding.\nvirtual bool operatar <= (Basehesouree& containar):\n\nprotected:\nPriocityTypea  m_Priority;\nWINT _nRetGount;\ntine_t m_Lastéccess;\n\nSection 1 Programming Techniques\n\nThe Basefesource class acts as a template from which other resource container\nclasses must be derived. Several member functions must be overridden by any base\nelass and are critical co how the system works.\n\nle ts expected thar che initial Greate() function will load some amount of\nresource data from disk or even from another location in memory, Ir is critical for the\nclass to retain the necessary data in order to repeat this operation as many times as\nnecessary in the Recreate() function. This may mean, for example, storing the path\nand file information of a bitmap to he loaded. The application must overnde the Dis -\nposa() and Recreate() functions in order co allow the resource manager to swap the\nresource in and out of memory as it sees fit. Keep in mind that only che most signifi-\ncant portion of the resource (c.¢., the bitmap data, the sound buffer, and the like} ,\nnot athe class dara, must be swapped our.\n\nGetsize() and IsDisposed() are two more functions thar must be overridden\nproperty for the system ta work, GetSizel) is fairly intuitive. The function should\nreturn the size of the data that can currently be swapped out. If the dara has already\nbeen swapped our, the function should return a size of zero. Technically, you could\ncalculate the actual size of the abject by including all che other data members, bur in\nall practicality, this method is really not worth the effort. IsDispased(} must return\ntre if the dara has heen discarded and false if ir has rot, The class makes ne LIT p=\ntons about how you can determine this stare. It is up to the derived class eo provide\nany necessary data members to keep crack of this state, if needed. Often simply check-\ning to see if'a pointer is null works instead of adding a data member.\n\nA oumber of other data access funceions provide access no the data members\nn_Priority, a_nRefCount, and m_LastAccess. The first, =_Priority, is an enumera-\ntion defining the general priority of a resource (high, medium, low). High-priority\nitems tend to stay in memory longer, and low-priority items should be swapped our\nfirst, The function m_nftefCount indicates the number of times the resource has heen\nlocked. We examine chis function a bit later. The n_LastAccess function is the time at\nwhich the resource was last accessed.\n\n‘The less-than operator ( < ) ts what determines the priority of sorting resources\n\nfor discarding. The default function looks like this:\n\nbool Baschesource::operatar < (Sasehesourcea container)\n\nif(GetPriority() <= container .GetPriority{})\nraturn true:\n\nelse if(GetPrigrity() > sontainer.GetPriority())\nreturn false:\n\nelse\n\nif(m_LastAccess =< container.GetLastAccess/))\nreturn true:\n\nGlse if(m_LastAccess » container. GetLastéccess( }}\nreturn Talse;\n\nBlse\n\n{\n\n1.7 Resource and Memory Management\n\nif Resource 83\n\nif (GetSize() < conteiner.GetSize[})\nreturn trugy\nelse\nreturn false;\n}\n\nreturn talee;\n\n}\n\nYou can see from this function thar rescuirees are sorted firse by priority, then by\naccess time, and last, by size, Although a rarher primitive algorithm, it works surpris-\ningly well for many situations. If you require a different or more sophisticated algo-\nrithm, you can cither modify the base code or supply a new sorting operator in the\nderived class.\n\nThe Resource Manager Class\n\nThe other half of the managed resource problem is supplying a manager thar can\norganize all the stored resources, provide access on demand, and handle the dynamic\ndisposal and reallocation of resources to stay within a memory budget. Let's examine\nthe ResWanager class to see how ic works:\n\nclase AesWanager\n\ni\n\npublic:\nReslanager ( } { Glear(j; }\nvirtual —-ResWanager{} { Oestroy(); 4\n\nvoid CGlear[};\n\nbool Create (WINT nlaxSirey ;\nWOid Destroy):\n\ni! Aesourcea map iteration\n\nse joss oo\n\nff Access functions for cycling through each item. Giving\nff direct aceess te the map or iterater causes a stack\nif pointer fault if you access the map across a dll\nii Boundary, but it's satg threugh the wrappers.\ninling void Gotabegin( }\n{ m_CurrentResaurce = m_Aesourceilap begin): }\ninling BaseResource* GetCurrenthesourcel }\n{ return (*n_Currenthesource).secand;  }\ninline bool GotoNext(]\n{ s_CurrentRhesource++; return [sValid(); }\ninline bool IsValid)\n{ return (m_Currenthasource I= f_Resourcellap.end())\n¥ true : false; }\n\nSection 1 Programming Techniques\n\nUD newness pele SSS ey eee eee nenne ene\n\ni! General resource access\n\nf/ Allows the resource manager to pre-reservea an amount of\n// menory 60 an ingarted regaurce does not axceed the\n\nff maxinum allowed manory\n\nbool Reservellemory(size_t nile):\n\nff Tf you pass in the address of a resource handle, the\nff Resource Manager will provide a unique handle for you.\nbool InsertResource(/RHANDLE* rhiiniquelD,\n\nHasehesouree™ phesource) ;\n\nbool InsertResource(RHANOLE rhuniqueDd,\n\nBasaiesource* plesource) ;\n\nif AaMives anh abject completely from the manager.\nbool RemoveResource(Basehosource® pResource);\nbool AemoveResource (RHANOLE rhUniquelD);\n\nfi Destroys an object and deallocates it's memory\nbool DestroyAesource (BaseResqurce* pResource);\nbool Destroyiesource (AHANDLE rhlniquelb) ;\n\nfi Using Gethesource tells the manager that you are about\nff to gocess the object. It the reseuree has been\n\nfi disposed, it will be recraated before it has been\n\ni? returned.\n\nBasehesource® Gethasource (RHANDLE mhliquelol;\n\nff Locking thé resource ensures that the resqurce does mor\nff get managed by the Resource Manager. You can use this\nff to ensure that & Surface does not get swapped out, for\nff instance. The fesouree containa a reference count\n\nif to ensure that numerous locks can be safely made.\nBaseAesource\" Lock(RHMWOLE rhUniquelD):\n\nif Unlocking the object lets the resource manager know\n\nff That you fa longer need exclusive access. When all\n\nfi locks have been released (the reference count is 0), the\ni! gb]86t is considered safe for management again and can\ni! Da Swapped out at the manager’s discretion, The object\nff can be referenced either by handle or by the object's\n\ni} pointer,\n\nint Unleek{RHANOLE rhUniquelb) ;\n\nint Unlock (BaseResqurce\" phesource);\n\nff Retrieve the stored handle based on a podnter to the\n{i resource. Note that\n\nff Pesoureée. Note that it's aséuaed that thare are no\n{f duplicate pointers, as it will return the first match\nff found.\n\nAKANDLE FindhesourceHandle(fesehesource\" pAesourca):\n\n1.7 Resource and Memary Management 85\n\npretected:\n\nff Internal funetiong\n\ninline void AddMemory(UINT nilgam}\n\n{ S_NGurrentlsedilenory += nMgm;\ninline vold Resovellenory(UINT nMem)\ni @_nGurrentligeddenory -= nMem; +\nWINNT GatMexthesHandle[ }\n\n{i raturo —-irhiNestRestandle; }\n\nff This suet be called shen you wish the manager to check\nJif for discardable resources, Resources will only be\n\ni} swapped out if the maximum allowable limit has been\n\nff reached, and it will discard then from lowest\n\nJf to highest priority, determined by tha resource class's\nff < opetater. Function will fail if requested aenmory\n\nJ/ cannot be freed.\n\nbool CheckFordverallocation():\n\nprotected:\nAHANOLE m_rhhexthoesbandle:\nWIT m_nCurrentWisecvenory:\nWIT m_nilaxinueMemory ;\nfesWapT ter m_Currenthasource:\nAesiap m_Aesourcevap;\n\nhi\n\nThe heart of the resource manager ts che data member m_ResourceMap. This is an\nSTL map, which means that every unique resource handle (which is simply an\nunsigned int) is paired with a pointer ro a resource object.\n\nHandles can either be pre-assigned (perhaps hard-coded or read from script files)\nor dynamically assigned by che resource manager itself. Keep in mind that the current\nimplementation is very primitive, It simply starts at dhe maximum value for handles\nues start relatively low, This method gives you several billion handle values before you\nrun out of room. If you plan to use that many resources, you'll want to implement a\nmore sophisticated handle distribution scheme.\n\nOnce the resource manager object has called the create() function and passed in\nthe target memory limit, the manager is ready to use. Simply call the Insertae-\nsource() function vo insert resources into the manager. Ifyou pats in the address of a\nhandle instead of passing it by value, the function fills in the value for you, In the\ncumple program. we created a factory class that automatically allocanes, creates, and\nthen inserts the resource object into the manager.\n\nIt is important to understand one ching about the resource manager. When you\nspecify the memory target, the InsertResource() function allows che memory target\nto be briefly exceeded by the amount of the current resource. The manager then\nSW2ps OE resources until the currently used memory is lower chan che threshold spec:\nified. Although this method may be acceptable if your resources are allocating out of\ni common memory pool or you are working in an environment with true viral\n\nBE Section 1 Programming Techniques\n\nmemory, it could create problems if you are working with fixed amounts of special-\ned memory, such as audio or texture memory.\n\nRequesting the manager to reserve an amount of memory for the resourec you are\nabout to load can solve the problem. This function, called Reservewenory(}, takes a\nstandard sf2¢_fype parameter. The function remurns true if it can free up che requested\namount of memory. After this function successfully returns, you can chen call\nInsarthecourea(). Most likely, the ReserveMenory() function would be called in che\nresource clases Greate() function alter loading some sort of resource header informa-\ntion, which would probably inform how much memory needs to be allocated to hold\nthe entire resource. Once the memory is reserved by the resource manager, the Gre-\nate() function can finish the daca loading and insert the resource into the manager.\nIn order te optimize this process, you might want co pre-load chis information and\nstore it in a globally accessible cable.\n\nHow Handles Work\nee\nThis system uses handles in order to prevent clients from directly manipulating\nobjects, which allows the manager the freedom to swap our resourees as it sees fit. In\norder te gain access to a resource, the client must call a member function and pass in\nthe handle in order to get back a pointer to the resource. Here's how it looks:\n\nSoneResdurce* pes = (Senchesource* jresngr.Gethesource (hiestHandle);\nif (i pRes)\nreturn Error;\n\nff the resource can now be safely used before any other calls are\n‘J made to the manager\n\nIt is important to remember that the resource pointer must be considered valid\nonly until another call to the resource manager is made. Accessing another resource\ncould cause the resource manager to swap out the resource you were previously access-\ning. You will most likely want to put asserts in your resource class's code to ensure that\ntheir member functions are not called if the resource has been disposed.\n\nIf for any reason you do want to get and hold onte a pointer to a resource, there\nisa mechaniom in place to do so: the Lock() function, Locking a resource increments\nthe reference count on the object, which prevents the resource manager from dispos-\ning of the object uncil the resource has been unlocked with, of course, che function\nValock(). [cis important to remember to eventually unlock objects you've locked, or\nthe resource manager assumes that it is noc allowed to dispose of the resource when\nthe program closes, and memory leaks could ensue. Since the resource manager hus\nevery resource indexed, it properly disposes of all resources automatically when its\ndestructor is called.\n\n1.7 Resource and Memory Management ay\n\nPossible Extensions and Modifications\n\nThe use of a resource manager is extremely beneficial in managing large amounts of\nresources effectively. Although there is a slight increase in difficulry when accessing\nresources, this difficuley is offset by the simplicity of automatic memory management.\n\nTf your application's entire cata set is already indexed in che resource manager, a\npre-caching system could be implemented by using esting functionality. Ta load a\nresource that has been determined a candidate for pre-caching, you should access che\nreiguiree using the GetResource() function and raise the priority level. This method\nforces any swapped data in those resources ro be reloaded and made ready for direct\naccess ad well as discourages further swapping because of the heightened priority. For\na resource that is no longer needed, simply lower che priority level in the resource, and\nit ts automatically discarded when more memory is needed for other data.\n\nIn addition to these enhancemences, clients might want to build in more compre-\nhensive reporting functions. A feedback loop could be created to repert on resources\nthat are being discarded more than average, and the priority could be adjusted te min-\nimize these sorts of problems. By effectively secting priority levels, perhaps even\ndynamically, clients can dramatically improve the performance of the manager.\n\nOther techniques you might want to ery are featured in a related article in this\nbook, “A tseneric Handle-Based Resource Manager,\" by Scott Bilas. Rather than\nusing the manager as a virtual memory system, this mesqurce manager instead Focuses\non techniques such as using templates and more intelligent, type-safe handles.\n\nConclusion\n\nAs the amount of data concent chat modern games must manipulate grows, the tech-\nniques for dealing with such vast quantities af data must also evolve. Creating an\neffective and efficient resource manager can help streamline the development process\nby allowing programmers co worry less about memory constraints and memory leaks,\nat the same time providing a powerful tool for monitoring resource usage.",
      "page_number": 78,
      "chapter_number": 9,
      "summary": "We will also create a manager\nte coordinate the available resources and control access wo the resource objects Key topics include resource, functions, and function. Covers function.",
      "keywords": [
        "resource manager",
        "Resource",
        "manager",
        "Memory",
        "che resource manager",
        "James Boer Computer",
        "function",
        "data",
        "Resource Manager Class",
        "Resource Class",
        "PRIORITY",
        "resource manager object",
        "Management James Boer",
        "bool",
        "che resource"
      ],
      "concepts": [
        "resource",
        "functions",
        "function",
        "functionality",
        "memory",
        "returned",
        "management",
        "access",
        "accessed",
        "virtual"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 15,
          "title": "Segment 15 (pages 289-307)",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 39,
          "title": "Segment 39 (pages 359-367)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 1,
          "title": "Segment 1 (pages 1-20)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 4,
          "title": "Segment 4 (pages 25-32)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 16,
          "title": "Segment 16 (pages 308-325)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 10,
      "title": "Segment 10 (pages 86-98)",
      "start_page": 86,
      "end_page": 98,
      "detection_method": "topic_boundary",
      "content": "1.8\n\nFast Data Load Trick\n\nJohn Olsen\n\nOne of the constant challenges with game programming is to make things fast.\nWhenever you leave someone staring ata screen waiting, you break the flow of infor-\nmation and risk losing that player. One critical clement is che cime it takes to load\ndara files into memory. With larger and larger game levels, you end up with longer\nand longer load times, Here is a trick char can be used to reduce your load times.\n\nPreprocess Your Data\n\nOne of the most important things you can do to your level dara is to preprocess as much\nas you possibly can. This can be done either with a stand-alone utility program, such as\na separate level editor used to edit your in-game dara, or within the game itself during\ndevelopment by enabling custom data-packing code for development builds. P've used\nboth methods, even on different portions of the same game, with good results.\n\nFor the ultimate in fast dara load times, you need to prepfocess your data into che\nfinal format it will tale within the game. With a bit of planning, you can lay our your\nC++ classes of © structures in a way thar makes chem good candidates for high-speed\nloading. Any data to be saved must be a non-static member variable, and no poinrers\nshould be saved. in the dara file.\n\nIfyou need pointers in your data, be sure to never use them before seating them\nup properly after loading, since the data saved out in the pointer member is almast\ncertain to contain bad dara when it is reloaded. Another possible option is te replace\npointers with a handle or index number of some sort. See the article “A Generic Han-\ndle-Based Resource Manager,” by Scott Bilas, for details.\n\nSince C++ uses virtual function tables, you should make sure to nor use any vir-\ntual fnctions ir your class, or i¢ will end up calling into seemingly random memory\nlocations when you overwrite your table with stale dara, If you want to play ic really\nsafe, you can experiment with making all your accessor functions static, guarantecing\n\nthey wont show up in your dara.\n\n1.8 Fast Data Load Trick ao\n\nSave Your Data\n\nOnce your dara is all filled into structures, either in-game or in a stand-alone prepro-\ncesing tool, you can write that data out to disk. For C++, you can use your this\npointer and sizeot() for the class. Far C, just use the structure pointer and sizeof {)\nfor the structure. Be sure mor te use sizeo? (this) or you will get the size of the pointer\nrather than the size of the structure. This size is the size of the non-static member data\nfor your class, along with any padding built into the class by che compiler.\n\nIdeally, you have nested all your necessary dara into one parent block holding all\nthe others, so you can load everything in one large read. You have to break things up\ninte multiple saves and loads if you are using anything bur ene continuous section of\n\nThe following example code shows how this might be done in C+4, with the\ngame data class having member Functions to perform che loading and saving, Please\nforgive the odd mixture of C++ classes with C file handling. If you're enough of a\npurisc to be bothered by it, [im sure it’s easy for you to change to your preferred\nmethod:\n\nFinclude <stdio.h>\nclass Gamobata\n{\n\npublic:\n\nbool Save(char *filetame) +\n\nbool Load(char *fileNam=):\n\nbool BuTTeredload(enar *fileiame) ;\n\n// Add accessors to get to your game data.\nprivate:\n\n!/ Only open one file at @ tina.\n\nstatic FILE *fileDescriptor:\n\n// Game data goes hare.\n\nint dataliO00); // Aaplace this with your data format.\nIs\n\nbool GamaData::Savalchar *fileNane]\n\nfileDascriptor = fopan(filetiang, “wb\"};\n\nif(filebescrigtoar)\n\n{\nfwrite( this, sizeof (Gamefata), 1, fileDescripter):\nTelose(fileDeseriptor) ;\nfi Report success eriting the file.\nreturn TAUE:\n\nI\n\nglee\nfi Regort an error eriting the file.\nreturn FALSE;\n\nI\n\na Section 1 Programming Techniques\n\nLoad Your Data the Simple Way\n\nSaving the data as described previously makes it really easy to get the data back into\nyour application later when you load the desired level. Just read che data back int the\ngame, into the same structure or class you wrote it from:\n\nbio] GantData: :Load(char *filehanec)\n\n{\nff Open the Tile for reading.\nfilefescriptor = fopen(fileNana, \"rb*):\nif(fileDescriptor)\n\nfread(this, sizeof(Gamelata), 1, filebesoriptar);\nfelose(fileDescriptor);\n\nif Heport suctess reading the file.\n\nreturn TRUE:\n\nalse\nff Aeport an error reading the file,\nreturn FALSE:\n\n}\n}\n\nLoad Your Data More Safely\n\nThere is at least one really important thing co watch eur for on certain console gaming\nhardware. Some systems always read our to the end ef the current sector on a disk. For\nexample, the Sony PlayStation loads data from CD-ROM in multiples of 2,048 bytes,\nThis means that if you read dara directly into your struccure, you stomp on whatever is\nin memory after that structure if it isn't some multiple of 2,048 bytes in length.\n\nTo avoid this memory stomp, you need to have a temporary buffer large enough\nto hold the dara file padded out to a 2K boundary. Should you be reading several files,\ndont allocate and free a buffer cach time. Instead, get the largest buffer size, allocate\nthe buffer once, and reuse it for all reads. Free ie after all the reads are completed.\nOnly the simpler single-read method is shown here.\n\nIf you are using a system with very tight memory, you might have already mapped\nout your entire memory usage and avoided dynamic memory all tegether. In that\ncase, you need te find 2 buffer somewhere in memory that is mot in use at the time\nyou need to read data files, Use thar as your temporary buffer instead of using the\ndynamic memory allocation shown below:\n\nff Ghack your hardware to sea what site of blocks it reads.\n‘f/f Put that value inte this define.\nfdetine AEAD GRANULARITY Doda\n\nbool Gasebata: ButferedLoad(char *fileName)\n{\n\n1.8 Fast Data Load Trick a1\n\nf/f Make sure there 23 room in the reed buffer.\n\nfi This could be made saaller to natch the\n\nff known read size by making it a multiple of the\n\ni} HEAD GRANULARITY, but this way is a bit faster.\n\nchar “tempButfer = new char[sizeot(GameaData) + READ GRANULARITY];\nif(ltampsutter)\n\n{\n\nii Gould not allocate the buffer.\nJ? Return an eeror code.\nreturn FALSE:\n\nI\n\nfileDescriptor = fopen(fileName, \"rb\"};\n\nif (filebeseriptar)\n\n{\nTread tempiutfor, sizaot(Ganebata), 1, fileDescriptor):\nfelose( filebescripter):\nmamepy (this, tenpBuffar, sizeof (Ganebata) jj\ndelete tenphutfer;\nff HEpOrt Success reading the file.\nreturn TRUE;\n\n}\n\nalse\n\n{\ndelete tenpbutfer;\nff Aepert an error reading the file,\nreturn FALSE:\n\n}\n\n}\n\nNow you are well on your way to highly optimized level loads. By preprocessing\nyour dara, you save the CPU time used to convert data into a usable formar, and you\ncompress the amount of data te be read. The best optimizations are chose win/win sit-\nmations im which che resule is both smaller and fever\n\n1.9\n\nFrame-Based Memory\nAllocation\n\nSteven Ranck\n\nThis article presents a simple and extremely fast memory allocation system that pre-\nvents memory from heeoming fragmented between game levels. It can be used for a\nwide range of game modules during level-loading time. In addition, the system is\nextremely fast at both allocating and de-allocating memory and can be used on any\ntype of plarform, from console to PC to areade,\n\nThe Ghallenges of Conventional\nMemory Allocation\n\nOne problem with standard memory allecation systems chat include malloc() and\nnew is thar memory can become fragmented and result in deteriorated game perfor-\nmance and the possibility of insufficiently large memory blocks available. When an\napplication requests a block of memory, sophisticated operating systems, such as\nUNIX and Microsoft Windows, employ advanced memory management systems that\ncan logically rearrange physical chunks of memory vo create the requested contizuous\nmemory block, But this rearrangement comes at the cost of CPU cycles that the game\ncould ordinarily have used. With game consoles, where the operating system is little\nmore than a tiny set of slimmed-dewn library functions, there is no such sophisticared\nmemory manager.\n\nIntroduction to Frame-Based Memory\n\nAsolution to these challenges of conventional memory allocation is framre-hased meni\nary. Frame-based memory eliminates memory fragmencation and is very fast. How-\never, it is not useful as a general-purpose memory allocation system like nallec() and\nnew. Framte-based memory is best suited for game and level initialization modules.\nAs shown in Figure 1.9.1, frame-based memory works like a stack. Ar initializa-\ntion time, the game allocares a single memory block from the operating system, which\n\n1.4 Frame-Based Memory Allocation aa\n\nBiol\n\naa Lozer Heep\nFetes Pooeter\n\n§— Bere ow emery)\n\nFIGURE 1.9.1. Frame-based MMcMory Tepresentarian.\n\nwill be used and managed by the frame memory system. This memory block is allo-\ncated only once throughout the lifetime of the game and is released back to the oper-\nating system just before the game terminares. In Figure 1.9.1, che entire block\ndenoted by Memory Block is used by the frame memory system. From the memory\nblock's pointer, we compute the Base and Cap memory pointers, optionally aligning\nthem toa memory boundary thar firs the specific system the application was designed\nto run on. The Base pointer points to the lowest aligned memory address in our\nMemory Block, and the Cap pointer points to the next higher-aligned memory\naddress just outside the top of our Memory Block (as seen by the placement of the\narrow in Figure 1.9.1). The Memory Block, the Base pointer, and the Cap pointer\nremain constant throughout the life of che game. Finally, che Lower Heap Frame and\nUpper Heap Frame pointers are set equal co the Base and Cap pointers, respectively.\nWell see later how these two pointers change as allocations and de-allocations are\nmade during the course of the game. The following code initializes the frame memory\nsysteani:\n\ntypedef unsigned char w8;\ntypedef unsigned int wint;\n\nfdetine ALIGMUP( nAddress, mBytes } ( ({(uint}mAdoress)] + \\\n(nbytes)-1) & (=({nBytes}-1)) }\n\nstatic int _niyteAlignmeant; // Menory alignment in bytes\n\nstatic uf “_pMemoryHlock} ff Walue returned by malloc()\nStatic ud *_apBaseAndCap[2]; // [O)=8ase pointer, [1]=-Cap pointer\nStatic wa *_apFrane[2]; ff [O]=Lowar Trame pointer, [1)=Upper\n\nff frame pointer\n\nSection 1 Programming Techniques\n\nif Must be called exactly once at game initialization time,\n\nif nRyteAlignment must be a power-of-2,\n\nif Returns 0 if successful, or 1 if an error securred.\n\nant InitFramaMemrysystem( int nSizelnbytes, int n8yteAlignment } {\nif Make sure nSizeinbytes 15 a multiple of nbyteAlignnent:\nnsizelngytes © ALTGNUP( nSizelnbytas, nbytedlignment };\n\nif First allocate our Memory Bleck:\n_plamoryalock = (u8 *jmalloc( nSizealnBytes +\nnbytedlignnent };\n\nif( _pMenorySlack == 0 } {\nff et engugh mamory. Retura error flag:\nreturn 1;\n\n}\nhy tetlignmant = nbyteAlignment;\n\n{/ Set up Base pointer:\niplasetndCap[ Oo) = (wh *)ALTGNUP/ pitenoryelock,\nnByteAlignment 33\n\nff! Set op Gap pointer:\n_aphaseandGap[1] = (ua *)ALIGNUP( _pliemoryBlock +\nnSizeinbytes, nbyteAlignnent 4;\n\nff Finally, initialize the Lower and Upper tram pointers:\n_apFrane(] = _apiasesndtap(o];\n_apFrame[1] = _aphaseAndCap] 1);\n\nff Successtull\nreturn 0;\n\n}\nTo shut down the frame memory system:\n\nvoid ShutdoemFrameMemorysysten( void ) {\nfrea{ _pilenoryBleck };\n\nExactly once during game initialization, a call is made to InitfraneMemorysys-\ntem(}, passing in the total number of bytes co be managed by the frame memory sys-\ntem and the byte alignment. All allocations made through the fame memory systern\nmaintain the byte alignment. Note that the ALIGNUP() macro requires hac the nBytes\nparameter be a power of 2\n\nAt this point, che frame memory system is ready to use. It maintains two individ-\ntal heaps: the Lower Heap allocates upward, and the Upper Heap allocates down-\nward, as shown in Figure 1.9.1. It is completely up to the game how it wants co utilize\neach heap. For example, the Upper Heap could be used to store 3D geometry data\nand the Lower Heap used for sound dara. In this example, independent allocations\nmade by the geometry and sound modules would not fragment memory, because the\nowo beans ane physically separated.\n\n1.9 Frame-Based Memory Allocation 85\n\nAllocating and Releasing Memory\n\nFrame memory allocation works like a stack. A call is made co che system, requesting a\nchunk of memory from one of the two heaps. If the lower heap is specified, dhe Lower\nHeap Frame pointer is bumped up by the amount allocated, and its value por vo the\nmedification is retusned. The Lower Heap Frame pointer always points to the next\navailable byte of memory: If, on the other hand, the upper heap is specified, the Upper\nHeap Frame pointer is bumped alow by the amount allocated, and the new value is\nreturned. This is because the Upper Heap Frame pointer always points co the last allo-\ncated byte af memory. If the two frame peinters cross cach other, there isn't enough\nmemory to satisty the request. The following function performs the allocation:\n\ni! Aeturns a pointer ta the base of tha menory block,\n\n/f ar returns 0 af there was insufficient nenory.\n\nff H@apNum 1s thé heap number: O-lower, 1=upper.\n\nwold “AllocrraneMemary( int nBytes, int nkeaphun } g\nui \"piliem;\n\nff First, align the requested size:\nniytes = ALIGNUP( naytes, _nByteAliqnment 5\n\nff Check for available manary:\n\naf( _apFrane[O)+nBytes > apFramefi] } {\nHt Insufficient mamary:\nreturn Oo;\n\n}\n‘f Now perform the manory allocation:\n\nif( nHeaplum } {\nMf Allecating from upper heap, down:\n\nApFrame|1) -= niytes;\nPuen = apFranefi]:\n\n} else {\nff Allagating tron lewer heap, up:\n\npllam = _aprrame[ do);\n_apFramne[O] +° n@ytes;\n\nreturn (void *)pWen;\n\n}\n\nThis function performs frame-based memory allocation very quickly, Since frame\nmemory is allocated like a stack, ic must be de-allocated the same way. This is where\nframes are introduced. A frame is a handle that che game retrieves from the memary\nsystem and is used to free memory. Memory can be freed only by using a frame. A\nframe acts as a bookmark within the pages of memory allocared by the system. When\n\nSection 1 Programming Techniques\n\na frame is freed, all memory allocated since the frame was obtained is freed. Figure\n1.9.2 demonstrates the use of a frame.\n\nIn Figure 1.9.2, (b) and (c) show two individual memory allocations being made\nvia the AllocFrametermory() function. In (dj, the game obtains a frame from the\nmemary system, The frame is simply a handle that the game will later wse to free\nmemory In (e) and (f), the game allocates another two blocks of memory. In (g), the\n\nFrame\nOEGGE\n\n(a) Ince (h) Firm Ce) Secu (d) From\nBaap 2 meory memory ebomed hy\nOper aisciticn sade abomizon toe ge\n\nmenary\nalison pode\n\nFIGURE 1.9.2. Memory allocation and release.\n\n19 Frame-Based Memory Allocation a7\n\ngame wants to release all memory allocated since the frame was obtained, The follow-\ning function obrains a frame for either the upper or lower heaps:\n\ntypadet struct {\nWB \"pFrane;\nint nHgapNun;\n} Frane_t;\n\nff Returns & Frame handle which can be used to\nff later release nengry allocated henceforth.\n‘f nHeaphum 23 the heap number: O=lower, t=upper.\nFrame_t GetFrame( int nHeaplun ) {\n\nFrame t Frame;\n\nFrame.pFrane = _apFrane[nteapNum);\nFrame. nitapNum = nteapltues\n\nretura Frane;\n\n‘To the memory system, a frame is a copy of the specified heap number and ies\ncurrent frame pointer. But to che game, it's simply a handle, Frama_t. To release\nmemory, we implement the following function:\n\nvoid ReleaseFrame( Frame_t Frame } 4\n_apFrane[ Frame .nheaplun] = Frame.pFrame:\n\nThe game calls AeleaseFrane() to release all memory allocated since the time\nthat Frame was obtained by GetFrame(}. There is no limit to che number of simulta-\nneous frames the game can allocate, provided thar the frames are released in che order\nopposite of that in which they were obtained. However, the memory system doesn't\nrequire that frames be released. For example, if Frame 1, Frame 2, and Frame 3 are\nobtained, ic is valid to release Frame 3 and then Frame 1, provided thar Frame 2 is\nnever released.\n\nHaving two independent heaps has several advantages. Consider our previous\ncxample of the upper heap being used to store 31D) geometry, and the lower heap being\nused ta store sound dar. Suppose thar allocations between the cwo heaps were made\nas follows: 3D block allocated, sound block allocated, another 3D block allocared,\nanother sound block allocated. When the 3D memory is freed (boch blocks), unused\nmemory holes are not created and fragmentation is prevented. The largest chunk of\navailable memory is always equal eo the toral size of the free heap. Likewise, the langest\nchunk of available memory in the lower heap is always identical to che largest chunk\nof available memory in the upper heap.\n\n58 Section 1 Programming Techniques\n\na\n\nExample\n\nConsider the following application example:\nFdefing HEAPHUM i fs Arbitrary. We'll use the upper heap [1}.\n\nextern int GatOojectSizal conet char *pszObjectName };\nextern int LoadFromDisk( eenst char \"psrObjecthane,\nvoid “ploadAddress }:\n\nStatic void “_p0bjecti; J! Where our Coptar object will be laaded.\nStatic void “_p0iject2; // Where our RobbarGar objact will be loaded.\n/7 Loads the CapCar and RobberGar objects from disk inte\nJ) _HEAPHLM.\nIf Aeterns 0 if successful, or 1 af not successful.\nint LoadGerdbjects( veid j {\n\nFrama t Frame:\n\ni} Get a frame handle:\nFrame = GetFrame{ HEAPHUM );\n\nif Attenpt ta load the CopGar object:\n\nPie jecti = LoadiyObject! “CopCar\" 1:\n\nif({ pOsjecti == 0 } {\nff Object couldn't be loaded. Release memory:\nReleaseFrane( Frame jj\nreturn 1;\n\n}\n\nji Attempt to load the AobberGar object:\n_plbject2 = LoadWyObject( “Robbertar™ 1;\nif( pObject? == o } {\nJf Giject couldn't be loaded. Release memory:\nReleaseFrane( Frame }:\nreturn 1;\n\n}\n\nfi Objects loaded ok. Kaap the menory around:\nreturn 0;\n\n}\n\nff Allocates memory fron HEAPNUM and loads tha specified object\nif trem disk inte the allocated memory. Returns a pointer to tha\nff object if successful, of 0 if not successful.\nwoid *Load¥yObject( conet char *psz0njectName } {\n\nint n0ojectSiza;:\n\nWold “pObject:\n\nnObjectsize = GdetlbjectSize! psrdbjecthame };\nif( nOdjectSiza == 0 ) {\n\nif Trouble getting object size;\n\nreturn 0;\n\n1.9 Frame-Based Memory Allocation oo\n\npObject = AllocFramoMenory | nobjectSize, HEAPNWUM };\nif{ pObjact == 0 ) 4\n\nff Insufficient memory:\n\nréturn oO:\n}\n\nif( LoacFromDisk( pazOojecthame, pObject pid\n/f Trawble loading object from disk:\nreturn oO;\n\nff Object loaded successfully:\nreturn pObject;\n}\n\nIn the preceding example, the function LoadGarQbjects() gets a frame but\nreleases it only if there was a problem while loading the objects. If both objects loaded\nwithout issue, the frame is not released and the function recums with the memory\nintact. [rs possible char a higher-level function obrained its own frame encapsulating\nall object-loading functions in addition to Load¢arOsjects(). When it comes Time to\nfree all object memory, the higher-level function simply calls ReleasaFrame() with\nthe frame it had obtained.\n\nConclusion\n\nSS\nSince frame-based memory works like a stack, it is imperative that frames are released\nin the order opposite of that in which they were obtained: otherwise, memory cor-\nruption can occur. Detecting violations of this condition is simple. Consider this\nreplacement function for releasing a frame:\n\nvold Aaleaseframe| Frane_t Frame } {\nff Ghack validity if releasing in Lower heap [O}:\nABEert( Frame.nHeepium==1 | |\n(uint)Frame.pFrane<=(uint) apFrame[o] I;\n\nff Check validity if releasing in upper heap (1):\nassert( Framé.obeaptun==0 ||\n(uint) Frame. pFrame>=(uint)_apFrame[1] 4;\n\nii Release frase:\n_SpFrane[ Frame .nteaplum] = Frana .pFraime:\n\n}\n\n‘This code detects arempts to release frames in che incorrect order in debug builds\nof the game. Further assertions could be added to detect additional validity problems\nwith the parameters.\n\nOne final point worth noting is chat for pame platforms with multiple indepen-\ndent types of memory (main, sound, rexure, geometry, and so forth), a frame-based\nmemory system could easily be implemented for each memory type and then linked\n\nSection 1 Pregramming Techniques\n\ntogether to provide a master frame, Recall the preceding example. Suppose thar Load -\nFromBisk() loaded geometry, textures, and sound for the specified model. The geom-\netry is to be placed in system memory, the textures into texture memory, and sound\ninto sound memory. In this case, there would be three independent frame memory\nsystems linked nopether by a master frame:\n\ntypedet struct {\n\nFrame t SyamenFrame; i! System memory Fram\nFreane_t TéexmenF rane; J} Texture mesory Frame\nFrene t SoundnenFrame; i! Sound semory Fram\n\n} HasterFrame t+;",
      "page_number": 86,
      "chapter_number": 10,
      "summary": "This chapter covers segment 10 (pages 86-98). Key topics include memory, frame, and load. Preprocess Your Data\n\nOne of the most important things you can do to your level dara is to preprocess as much\nas you possibly can.",
      "keywords": [
        "memory",
        "Trick John Olsen",
        "frame",
        "frame memory system",
        "frame memory",
        "Heap Frame pointer",
        "memory allocation",
        "Heap Frame",
        "Upper Heap Frame",
        "John Olsen",
        "Lower Heap Frame",
        "Load Trick John",
        "Data Load Trick",
        "Frame-Based Memory Allocation",
        "Upper Heap"
      ],
      "concepts": [
        "memory",
        "frame",
        "load",
        "returned",
        "pointers",
        "game",
        "gaming",
        "allocate",
        "allocation",
        "allocating"
      ],
      "similar_chapters": [
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 21,
          "title": "Segment 21 (pages 193-203)",
          "relevance_score": 0.7,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 16,
          "title": "Segment 16 (pages 308-325)",
          "relevance_score": 0.68,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 6,
          "title": "Segment 6 (pages 48-56)",
          "relevance_score": 0.67,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 38,
          "title": "Segment 38 (pages 764-785)",
          "relevance_score": 0.67,
          "method": "sentence_transformers"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 33,
          "title": "Segment 33 (pages 662-682)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 11,
      "title": "Segment 11 (pages 99-106)",
      "start_page": 99,
      "end_page": 106,
      "detection_method": "topic_boundary",
      "content": "1.10\n\nSimple, Fast Bit Arrays\n\nAndrew Kirmse\n\nWe love bitwise operations because they are fast and they pack data efficiently, but we\nhate them because they are error-prone and depend on the machine's ward size. What\nwe really wane is an abstraction of bitwise operations char gives us all the benefies but\nhides che unpleasanc details,\n\nOverview\n\n————\nThe three (C++ classes in this article implement arrays of bits. The base class, BitArray,\nisa simple one-dimensional array of bits. Its subelass pitarray2D is a cwo-dimensional\narray of bits, and the Teogdtarray subclass is an array of integer elements whose values\ncan range from © to 3. Each of the classes can be manipulated through English-\nlanguage methods or, alternatively, chrough familiar operators, The classes feature clear\nsyntax, portabilicy, range checking, correct use of const, and high performance.\n\nThe C++ Standard Templare Library (STL) includes a one-dimensional armay of\nbits in the header bit set. Although feature-rich, many implementations ane cryptic at\nbest and difficult co extend or modify (for a sample implementation, sec [SGI98]).\nSome STL implementations alsa depend on parts of the C++ standard such as mem-\nber templates and namespaces that are missing from some compilers. The implemen-\ntations in this article are straightforward and easy to integrate with existing code.\nThey also provide additional features thar are useful for game development.\n\nArray of Bits\nee\n\nThe base class Bitarray acts just like a normal C++ array af bools, although you are of\ncourse free to interpret the bits as integers with values of O and 1. The bits are stored\nin a buffer of longs in an endian-independent manner. Syntactically, you can crear a\nBitArray as similar to a regular C++ array, with the added benefic of dynamic array\nbounds and additional operators. For example, you can do the following:\n\nBitArray bits(num_bits), other bits (nun bits);\nbits ..Clear():\n\n101\n\n102 Section 1 Programming Techniques\n\nbits[10] = true:\nif ({bits & other _bits).AlMBitsFalse()) {}\n\nThe class implements the standard birwise operators 4, |, -, 4=, |=, “=, and -. It\ndoes not implement shift operations.\n\nIn the interest of high performance, a BitArray is not initialized with any particu-\nlar value when it is created, The Clear() method sets all bits co Glse. As a further opti-\nmization, small BitArrays chart can fic inside a machine word do moe allocate any\nadditional memory. This males che class useful for even small sets of flags. This syntax:\n\nflags[FLAG INDEX] = true:\n\nis Clearer than che tradicional:\n\nflags |= 1 << FLAG_INDEX:\n\nBitArray and the other classes call assert when an array index is out of bounds.\nIn real-time games, this is generally preferable co throwing an exception, as the STL\ndoes, due to the overhead associated with exceptions.\n\nThe array subscripr operaror in BitArray is implemented with a useful C++ pat-\ntem known a¢ a precy elas. (See [Meyers95] for more information about proxy\nClasses.) The proxy class 8itProxy represents a single bit in the Bitarray. In the\nexpression:\n\nalidj = true;\n\nwe assign to the BitProxy of JO) using operatore, while in the expression:\n\nbool val = afio];\n\nwe merely read che value of a bit via the bool operator, The 8itProxy class allows us\nte delay evaluation of rhe expression a//0! until we know che context in which ic is\nused (reading or writing). This is a very handy erick char is also used in che ocher bit\narray classes.\n\nWore that the BitProxy object must be returned by value, so it might incur the\ncost of instantiating and deleting a temporary object. In normal circumstances, where\nthe bit value is immediately read or assigned co, che compiler is able to optimize away\nthis temporary object.\n\nOther Arrays\n\nBitarray20 is a two-dimensional analog of BitArray. For the most part, it behaves\njust like any other two-dimensional array:\n\nBitarray20 bats(10, 20};\nbits[S)(4] = true;\n\n1.10 Simple, Fast Bit Arrays 103\n\nNote that the array subscript operator for Bitarray2D returns an ArrayProxy, which\nisa proxy class representing a single row of the array. ArrayProxy itself has a subseript\noperator thar returns a proxy fora particular bir in the aray. These mechanics are nec-\nessary to allow the familiar C++ double-subscripting syntax.\n\nBitarray2D intentionally does mot creat iss subscripted clements as one-\ndimensional 8itarrays:\n\nbits2d[S)] = bit array; ff illegal!\nbits2d[5].FlipAllSits.); ff illegal)\n\nAlthough it’s certainly possible to allow such operations, ir would complicate the\nArrayProxy class considerably, and these uses are comparatively rare.\n\nBitArrayed is implemented asa single BitArray chat concains as many bits as the\ntwo-dimensional array. Because itarray2D does not have the same public interface\nas BitArray, it inherics from BitArray via private. Like BitArray, all of i functions\nare short and inlined.\n\n‘The final class, TwoBitarray, provides an array of rwo-bir values, (Arrays with\nmore bits per clement are easy extensions vo this class.) The implementazion is an\nalmost trivial use of a Sitarray with owice as many elements as the Tee@itarray.\n\nthough extremely simple, this class is a convenient way to pack stare information\ninto a minimum of space,\n\nApplication\n\nEven such tradicional low-level C conseructs as bit arrays can benefit fom implemen-\ntation in C++. The C++ code is easier ro read and understand for a performance cost\nthar is almost always negligible. For games, this means less time spent developing and\ndebugging code thar is necessary for many applications,\n\nIf you use these classes in major dara senactures in a game (e.z,, state bits attached\nto each cell in a cwo-dimensional array of tiles}, ic might be useful to add operators a\nread and write the array to a stream. IF you do, be careful no Pay attention to endian-\nness When dealing with che array’s contents, if portability is important.\n\nThe sample code includes a vest program thar illuscrares usage of these bit array\n\nReferences\nee\n[SGI98) StGI, “STL header bit set.” available online ar wwwsel.coml Technology!\nSTLibinser, 19798,\n[Mevers95] Meyers, Scom, Jone Effective Cr+, Addison-Wesley Longman, Inc., 1995,\n\n1.11\n\nA Network Protocol for Online\nGames\n\nAndrew Kirmse\n\nMost encryption schemes assume that a trusted sender and a trusted recipienc want to\ncommunicate over an unerusted channel It seems absurd to suggest char che sender\ncould deliberately try to fool the recipient, yet this is exactly the problem facing\ndesigners of online games. Some players cannot be trusted, and worse, chey have com-\nplete access to the encryption algorithm and all communicarions via the client exe-\ncurable. Under such circumstances we cannot hope to provide completely secure\ncommunications, bur we can make the attacker's job more trouble chan i's worth.\nThis article presents some practical techniques for building an application-level com-\nmunications protocol for online games.\n\nDefinitions\n\n104\n\nProtocol design is most interesting in client/server pames, where one of more untrusted\nliens communicare with a trosted central server. (Cheating is cermainly also a problem\nin peer-to-peer games, but because no enuity is crusted in such games, the situation is\nhopeless.) The consequences of cheating in a clieno/server game is high because the\nserver, 26 the only trusted entity, maintains che game state and verifies all cient com-\nmands. When the game state is persistent, a single successtul cheat can destabilize a\ngame invelving thousands of players.\n\nWe consider protocol security features in a client/server system. The client and\nserver communicate by sending packets over a necwork channel, which might be reli-\nable (typically TCP) or unreliable (UDP). Although clients can also communicate\ndirectly with each other, perhaps for chat or voice, we assume that any data that need\nto be secured are sent only between a clienc and che server.\n\nEach packet contains two pars: the Aeader, containing administrative informa-\ntion, and the payload, containing the actual dara we want to communicate. The goal\nof the neework protocol is to deliver the sender's original payload ta the recipient. Any\nmodifications to the sender's sequence of payloads should be detected. We deal only\n\n1.11 A Network Protece! for Online Games 105\n\nwith delivery of the payload, leaving the details of packer ordering and reliabiliry co\nlower levels in the protocol stack,\n\nPacket Tampering\n\nMost protocol hackers are casual: they change bytes in a packet and sce what hap-\npens, The first line of defense against such atracks is a simple checksum. A checksum\nis a short number produced by combining every byte of the packet. The sender com-\nputes the checksum of the packet and sends both the packet and the checksum to the\nrecipicnoe. ‘The recipient takes the packer and recomputes its checksum: if the com-\nputed checksum doesn't match the checksum fom the sender, the packet is corrupt\nand should be rejected. It's important to include the entire packet, including the\nheader, in the checksum computation, so that the recipient can devect changes to the\nheader as well as che payload.\n\nA perfect checksum computation would produce a different value if any byte of\nthe packet were changed to any other value. A perfect checksum would be too long to\nbe useful, of course, bue hash functions have the same design poal and make excellent\nchecksums. Particularly useful are one-way hash functions, which scramble their\ninput to the extent that reconstructing any part of the input from the hash value is\nimpossible for practical purposes. The MID5 algorithm is well tested, publiely avail-\nable, and fast enough for use in games. A public domain implementation is available\nonline [Plumb],\n\n‘There are two weaknesses in this simple checksum mechanism. First, because the\nclient cxecutable contains the checksum computation code, am actacker can reverse\nengineer the checksum algorithm, and then compute valid checksums for any mes-\nsage. Second, an attacker can capture valid packets and resend them larer, an attack\n\nknown as packer replay,\n\nPacket Replay\n\nIna packet relay attack, a malicious user captures a packer from the client (prpically\nusing a packer sniffer), and chen sends it multiple times. A common tactic is to use\npacket replay co perform commands faster chan the game allows, even if there are tim-\ning checks in the cliene. For example. a client might use a timer to send a certain com-\nmand to the server at most ance per second, no marter how’ frequently the player\nissues the command. Using packer replay. a single user might issue the same com-\nmand hundreds of times per second.\n\nA system designer might my to stop this particular atrack by putting a similar\nonce-per-second timer check on the server as well. In the face of widely variable net-\nwork latency, however, this defense is impractical, Although it detects most packet\nreplay attacks, varying network delays can make packets bunch together by the time\n\nSection 1 Pregramming Techniques\n\nthey reach the server, causing legal command sequences to be rejecoed. We certainly\ndo not want our security scheme to mark law-abiding players as cheaters.\n\nTo guard apainst packer replay, cach packet should conrain some stare informa-\ntion, 0 that even packers With identical payloads have difterenc bir Paltrerms, Sarre:\nthing as simple as a number that increments with each sent packer would do, although\nthat scheme is too easy for an attacker to figure out. A better answer is to use a state\nmachine to produce successive identifying numbers for successive packers. A fast and\nreasonably complicated method is a linear congruential random number generator of\nthe type cypically found in system libraries. Such generators operate as follows:\n\nState = (State + a) * 6\n\nwhere @ and 4 are carefully chosen integers. (For a discussion of this generator, sec\n[Rnuch98].)\n\nThe sender and recipient cach keep a linear congrucntial random number gener-\nator for cheir connections. When sending a packet, the sender produces a random\nnumber and adds it ta the packer, simultaneously stepping its random number gener-\nator. ‘The receiver checks the random number in the incoming packet against its gen-\nerator, if che numbers dont match, the packer has been tampered with. If the\nnumbers do match, the receiver steps its random number generator to prepare for the\nnext packer.\n\nThere are two complications with this scheme. The first is how the sender and\nreceiver initially synchronize their state machines, They could each start their state\nmachines with the same fixed seed, bur then the initial stream of packets would\nalways have the same bit patterns and thus would be vulnerable to analysis. Instead,\nthe server can initialize its stare machine with randomly generated seed values and\nsend these to the client in its first message.\n\nThe second complication is how to keep the state machines synchronized during\ncommunication, On a reliable connection, packets are never lost, so synchronization\nis guaranteed. When packets are dropped or reordered, however, the sicuation\nbecomes more complicated. Ifa message is lost, the sender's state machine will have\nadvanced one more step than che receiver's; subsequent packers will be rejected, even\nthough they are legitimate. A simple solution is co rely on a true sequence number\nsent with each packer (most games include this number with messages anyway, to\nprovide a reliable connection over an unreliable cansport). Given a sequence number,\nthe receiver can determine how many times to step its state machine ro catch up to the\ncurrent packet. [f the application allows out-of-order delivery, the old state of the stare\nmachine will have to be stored for use when an out-of-order packer arrives later.\n\n‘The rand function provided with most run-time libraries is inappropriate for use\na a Hate machine because of its low precision (many implementations have only 15\nbits) and its obvious choice as a source of random numbers. A fact, high-quality ran-\ndom number implementation is given in [Booth].\n\n1.11 ANetwork Protocol for Online Games 107\n\nAdditional Techniques\n\nIdeally, two packers with identical payloads should show as lire correlation in their\nbit patterns as possible, to frustrate analysis of the payload. An eisy way to remove all\ncorrelation between two sees of data is to combine them with a sequence of random\nbits, using the exclusive-or (KOR) operator. Assuming the previously described\npacket replay defense, che sender and receiver already have synchronized random\nnumber generators. Thus, the sender can generate a sequence of random numbers for\ncach packet and NOK these into the packer payload; the reeciver generaces the same\nsequence of numbers and retrieves the original payload in the same Way.\n\nEven the fact that two packers have the same length can give an attacker a clue\nthar the packets encode similar dara. To further frustrate autacks, each packer can con-\ntain a variable amount of random “junk” data, meant only to vary the length of the\npacker. The length of the junk dara is determined by yet another synchronized state\nmachine. The sender checks its stare machine to determine how much junk to gener-\nate and inserts that number of random bytes into an ourgoing packer. The receiver\nsimply ignores che junk data, Increasing the ammount of junk data helps to further hide\nthe payload bur costs additional bandwidth, In typical applications in which band-\nwidth is limited, the average length of junk data should be made small compared to\nthe average payload size.\n\nReverse Engineering\n\nThe hardest problem to address, and ultimately the downfall of any scheme to stop\nprotocol tampering, is that the client contains the entire encryption algorithm and\nthus can always be reverse engineered. Some steps you can take to make reverse engi-\nneering harder are as follows:\n\n* Remove all symbols and debugging information ftom any code released to the\npublic,\n\n* Dont isolate buffer encryption and decryption in their own functions: instead,\ncombine these with some other necwork code, This is one area in which it can be\nworthwhile co trade maintainability for security.\n\n* Compute “magic numbers” {such as initialization seeds) at run time instead of\nplacing their values directhy in the executable,\n\n* Include a good encryption scheme in every version of the client, even early betas.\nIf any client version lacks encryprion, a user can record a stream of unencrypted\npackets from one client and then use knowledge of the packet payload to help\nbreak the encryption in a larer version.\n\n* Remember thar your goal is to make cheating prohibitively expensive, not impos-\nsible.\n\n108 Section? Programming Techniques\n\nImplementation\n\nThe implementation included with this article includes a ‘C++ class SecureTransport\nthar uses all the previously described techniques ..A Securetransport object encapsu-\nlates a two-way connection between a sender and a recipient. For each direction, the\nobject maintains four linear congruential random number gencrators as protacol state\nmachines, These are initialized to static values, with the understanding that the server\nwould send random seeds in its first message to the client. The class uses the stare\nmachines as follows:\n\n1. It MORs the length field at the start of che header. (This is unnecessary if the\nunderlying protocol provides a packet length as in UDP)\n\n2. A message sequence number is used to prevent packet replay.\n\n3. It determines the length of junk data in each packer.\n\n4. It generates random bits to XOR the payload.\n\nA separate random number generator is used to gemerace che actual junk dara.\nDuring debugging, it is usefiel to set che junk data to a known constant value.\n\nReferences\n\n[Booth97] Booth, Rick, Juwer Loops, Addison-Wesley Developers Press, 1997,\n\n[Knuth98] Kauth, Donald, The Art of Computer Programming. Volume 2: Sensinn-\nmerical Algorithens, third edition, Addison-Wesley Longman, Inc., 1998.\n\n[Plumb93] Plumb, Colin, “md5.c,available online ar hmp://src.openresources.com/\ndebian/see/admin/HTML/S/rpm_2_4.12.orig%20rpm-2.4.12%201ib%20md5.\n«hem, 1993.",
      "page_number": 99,
      "chapter_number": 11,
      "summary": "This chapter covers segment 11 (pages 99-106). Key topics include packets, bits. What\nwe really wane is an abstraction of bitwise operations char gives us all the benefies but\nhides che unpleasanc details,\n\nOverview\n\n————\nThe three (C++ classes in this article implement arrays of bits.",
      "keywords": [
        "bits",
        "array",
        "Fast Bit Arrays",
        "packet",
        "random number",
        "Bit Arrays",
        "Bit",
        "packer",
        "number",
        "che",
        "bit array classes",
        "Bit Arrays Andrew",
        "random",
        "BitArray",
        "state"
      ],
      "concepts": [
        "packets",
        "bit",
        "bits",
        "arrays",
        "operations",
        "operators",
        "operate",
        "protocol",
        "number",
        "implement"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 7,
          "title": "Segment 7 (pages 121-141)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 5,
          "title": "Segment 5 (pages 79-99)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 6,
          "title": "Segment 6 (pages 100-121)",
          "relevance_score": 0.61,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 56,
          "title": "Segment 56 (pages 532-540)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 54,
          "title": "Segment 54 (pages 522-529)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 12,
      "title": "Segment 12 (pages 107-114)",
      "start_page": 107,
      "end_page": 114,
      "detection_method": "topic_boundary",
      "content": "1.12\n\nsqueezing More Out of Assert\n\nSteve Rabin\n\nAlmost everybody uses assert, but not everybody is getting the most out of it. This\narticle contains seven cool lite tricks that can be used to squeeze more functionality\nout of assert. If you're already familiar with assert, skip down to “Assert Trick #1.\"\nOrherwise, read on ...\n\nThe Basics of Assert\n\n—— Sa\nEvery programmer should religiously use the assert macro. The assert macro is a\nsimple, painless way to double-check your assumptions, and it will save you every\nume. By giving the assert macro a condition to evaluate, you're asserting thar this\ncondition should be TRUE. Ifthe condition evaluares co FALSE, assert brings up a\ndialog box telling you thar a problem has occurred, You can then choose to ignore the\nassert and continue executing your code, abort the program, ot break directly into\nthe code where the assert failed.\n\nThe assert macro lets you program defensively. IF you know a pointer should be\nNULL, you should assert thar it is NULL. By making assert a habit in your code,\nyou'll catch mistakes before they have a chance to bite you.\n\nVector normalization is an example of an important place to use asserts. In the\nfollowing function, three assumptions must be met for the code co execune without\nwreaking havoc, The sre and dit vector pointers must both be valid, and the length af\nthe sre vector must not be zera.\n\n#include sassart.h>\nvoid Vectoriormalize! Veo\" sre, Vac* dat j\n{\n\nfloat length:\n\naisert( sre l= 0 }; if Gheck that the sre veetor is not HULL\nansert( dat I= 0 ); if Gheck that the dst veeter is not NULL\n\nLangth = sqrt( (8ré->x\"sre->x) + (sre->y*src->y) +\n(sre->2*ere->F) jj\n\n109\n\n110 Section 1 Programming Techniques\n\nassert( length t= 0 ); Ii! Check that the length is nagt zero\nfi (to aveid dividing by zera)\n\nd6t->% = 6ro->%e / length:\ndst-sy = sre-sy / langith;\ndSt->2 = sre->z / langth;\n\n}\n\nSince the VectorNormalize function needs to be blazingly fast, we cant afford to\nwaste time checking the assumptions in release builds, However, while the game is in\ndevelopment, we need to be aware of any problems that come up. Thar’s where\nassert makes a lot of sense. The aesert macro doesn't get compiled in release builds,\nso assumptions can be tested during development and automatically removed when\ncompiled in release. This allows you to sprinkle asserts throughout your code with-\nout worrying about removing them before your game ships.\n\nSince the assert macro is nor compiled under release builds, its incredibly\nimportant that you dont change the stare of your program within the assert. As a\nrule, don't call functions or alter any variables inside ir. The result would be behavior\nthar differs between your debug and release versions, which could be disastrous.\n\nWhy not just puc permanent error checlang inside the VectorNormalize func-\ntion? This function is so low level that it doesn't have a clue how co remedy any prob-\nlems. Hopefully (cross your fingers), cvery piece of code char calls VactorNormalize\nchecks for these assumptions because it can direcely deal with problems. Ifa piece of\ncode fails to check those assumptions, the assert will be triggered inside vectermor-\nmalize, anda programmer can then know to fix the actual code char caused the error.\n\nAssert Trick #1: Embed More Information\n\nOne of the drawbacks of che traditional assert macro is that it doesnt cell you much\ninformation. [Fassert(sre t~ 0) fails, it brings up the suring “sre f= 0\" in the assert\ndialog box. Unforrunarely, this doesn't give you much to go on. Unless you're running\nthe game from your debugger, it's not very clear whar the problem is. One technique\nis to embed more information inside your condition. Consider the following vec-\ntorNormalize function:\n\nFinctluda <assert.h>\nvoid VectorNermalize( Veco\" src, Vac* det ]\ni\n\nfloat length;\n\nagsert( are l= 0 && “VectorNormalize: src vector pointer 4% NULL\" 4;\naaeert( gat t= 0 Bk “Vectoriormalize: dst vector pointer is NULL\" 4;\nLengen = sqrt, (Sre->x\"sre->x) + (sre-sy*are-ry) * tsre->z\"sre->z) J;\n\nassert( length §'= 0 && “VectorNormalize: sre vector is zero length\" };\n\n1.12 Squeezlng More Out of Assert 411\n\nG6t-=\" — sro-3e / Langen;\n\nF\nget->y = ere-sy / Langth:\ndat-*2 = sré-sz / length:\n\nWhen the first assert fails in this onde, the assert box displays the sting “src\n'= 0 Sh “VectorNormalizea: sre veeter pointer is NULL\"*. Even if your besters are\nrunning the game, they can tell you the function name where the assert failed, along\nwith the reason,\n\nAssert Trick #2: Embed Even More Information\nSe ee ht iat bee beeline inf\n\nSometimes programmers simply type assert (0) if the program exceution reaches an\nugly spot. You can pull the same trick of inserting a descriptive string simply by megan\ning the string to make it false. For example:\n\nSfeert, 6 WectorNoraalize: The code should newer get here\" hz\n\nThis line accomplishes the same thing as assert (0) while also giving you some\ngrear debugging information.\n\nAssert Trick #3: Make It Less Awkward\n\n‘The first wo cricks can be combined in seconds by writing a simple macro. This\nmacro takes two arguments, the first being the condition to evaluate and the second\nbeing the descriptive siring. This mimics the first owo cicks bur makes it easier to\ntype and read:\n\nWdefing Accert(a,b} assert( a 4& b }\n\nThe following ewe lines use che new macro:\n\nassert{ are t= 0, “VectorNorm@alize: src vector pointer is NULL* li\nassert( 0, “VectorNormalize: The code should never get here\" ):;\n\nAssert Trick #4: Write Your Own\n\nEventually cveryone should use an assert macro that’s been truly customized. The\nidea is to write your own aseert dialog box code so that you can have more control\nover adding feapures,\n\nA very annoying problem of the standard C assert is thac it breaks into the\ndebugger in the file assert.c—not che line in your program where the assert appears,\nBy writing your own assert macro, the debugger breaks directly to the assert linc\nthat you typed. ‘This avoids the needless step of backtracking up the stack ro get to the\nspot you're actually interested in, The following is an example of a custom assert\nmacro:\n\n112 Section 1 Programming Techniques\n\nWit defined, DEsuUG }\nextern bool CustensssertFunctiont bool, chars, int, char® );\n\nedafing Aseert( exp, description } 4\nif( CustomAssertFunction( (int)(exp), description, _ LINE_,\\\nfats | as\n{ 35m { int 3} } /ithis will causa the debugger to break hare\n\nfolse\nMdetine Assert( exp, description }\nPandit\n\nThe above macro calls GustanAssertFunction, which you have vo write yourself.\nGustomiseertFunction should bring up a dialog box stating the assert information\nand allow the user to either continue or break. IF the user chooses wo break, Custem-\nAssertFunction should retum TRUE, and the debugeer will break on the Assert\nlime (thac’s whac the int 9 instruction does on the PC), Otherwise, the function\nshould return FALSE, and the program will continue executing.\n\nAssert Trick #5: This One Is Priceless\n\nOnce you have a custom assert macro, you can add an “Ignore Always” option to\nyour assert dialog box. This is an amazing fearure thar lets you ignore an assert once\nand have it remember to never bother you again. It’s particularly useful when an\nassert is failing every frame, bur you still wane to run your game without clicking\nthrough a million asserts. To implement this feature, each assert keeps track of\nwhether it should be ignored and purposely suppresses itself if it should fail in the\nfucure.\n\nPractically, the way to implement “Ignore Always” is to place a static boolean\nwithin the assert macro. This boolean then remembers whether the assert is to be\nignored. Initially, the boolean is set to FALSE, When the code execures, it checks this\nboolean before it even evaluates the assert condition. If the boolean is FALSE, it calls\nthe GustomAssertFunction with the pointer to the boolean as an argument. If the\nassert condition fails and the user selects “Ignore Always” in the assert dialog box,\nit then sets the boolean vo TRUE. The following is the code for the macro:\n\n#if defined( DEBUG }\nextern bool CustonAssertFunction{ bool, char*, int, char\", bool\" };\n\nWdetine ASsert{ exp, daseription } |\n{ Static bool ipnoraAlways = false; 4\nif( tignoreAlwaya ) { 4\nif{ Custom4esertFunction( {int} (exp), deseription, |\n— LINE _, _ FILE, dignoredAlways } ] ) 4\n{ _asm { int 3} 4} 4\nyA\n}\n\n1.42 Squeezing More Out of Assert 113\n\n#elee\n#dafine Assert({ exp, dasoription }\nFondit\n\nAssert Trick #6: Only Hf You're Totally Hard-Core\n————— OOOO\n\n‘There's a nagging problem with assert chat shows up clearly in the VactorNormalize\nsample function. The problem is thar the source of the error is not inside VeetorNor-\nmalize. I'he true error is in the function that called vectorNormalize, which narrows\nit down to only several hundred routines! If this type of assert fails without the\ndebugger running, the assert is virtually useless, Surprisingly, this is a common situ-\natbon, since testers rarely run games from the debugger.\n\n‘The simple solution is to provide stack information inside the assert dialog box!\nJohn Robbins, a writer for Microsoft Systems Journal, coined rhe name superaseert to\ndescribe this implementation. In his column “BueSlayer,” he worked our a Windows-\nspecific example, complete with source, which can be used as a reference [Rob-\nbins99).\n\nAssert Trick #7: Make It Easier—Copy and Paste\nee\n\nIts really cool when a simple trick makes work a lot easier. This trick falls into that\ncategory. Ifthe assert provides cons of great debugging information such as the stack,\nwhy not make it really easy for testers to pass it along?\n\nIn the Windows environment, you can have a burton on the assert dialog box\nthat copies the information to the clipboard! With a few simple mouse clicks, anyone\ncan easily copy and paste the assert into an e-mail or bug report. This simple, pow-\nerful idea will help your resters convey accurate, meaningful information back to pro-\ngrammers.\n\nThe following code copies an arbitrary string into the clipboard. You'll want co\nalter it slightly and pur it inside your CustomAssertFuncticn,\n\nif( Opentlipboard, MULL } }\n{\n\nHGLOGAL Alem;\nchar szAssert[ 256];\nchar *pWen:\n\nSpraintt( szAssert, “Put assert info here\" ie\nhillem = GlobalAlloc GHND|GNEM_DDESHARE, atrlen( szAgsert }41 43\n\nif( hMam ) {\nPifan = (char \")Globaliock( hitgm 4;\nstrcpy( pen, szAsgert };\nGloballinlock( hWam };\n\n114 : Section 1 Programming Techniques\n\nEmptyClipbaard ):\nSatelipboarddatal CF_TEXT, hMem );\nI\n\nClosetlipboard! );\n\nReferences\n\n[McConnell$3] Metconnell, Steve, Caste Complere, Microsoft Press, 1995,\n\n[Rebbins00) Robbins, John, Debugging Applications, Microsoft Press, 20000.\n\n[Rebbins$9] Robbins, John, Micros? Seren Journal: BugSlayer, available online at\nwww. microsoft.com/msj/defaulttop.aspipage=/msj/0299/bugslayer/bugslayer029\nStop-hom (code available at weew,microsoft.com/msj/0299code/FebSBugSlayer\nap), February 1959.\n\n[Saltzman?9] Salzman, Marc. Game Design: Secrets of the Sager, Brady Publishing,\n1999.\n\n1.13\n\nStats: Real-Time Statistics\nand In-Game Debugging\n\nJohn Olsen\n\nEveryone spends more time debugging than they would really like to. This huge time\nsink has led to the development of a system I call Stats, a real-time debugging and\ndata-cditing system. This system can make life for you, che programmer, easier\nthrough simplified debugging and data tracking in a live system as it executes on the\ntarget platform. This technology has been used on commercial products for both PCs\nand consoles. The name is derived from the word staristics hecausc the original inspi-\nration for the idea was the display of numeric statistics from within a game solely for\nthe purpose of debugping.\n\nThe tool set described here is fairly simple to implement, highly extensible, and\nhighly applicable to many facets of game software design and testing. Chis means that\nit is easy for you to customize to your particular needs, which often vary from one\nproject to the nex\n\nWhy: A Need-Driven Technology\n\nBoth PC and console systems have problems with debugging full-screen, real-time\napplications. On the PC, you must resort co network-based debugging, multisereen\nsystems, or the ability to pop between windowed and full-screen mode during the\ndebugging sesion. Sometimes the debugging environment docs not allow access to\nsome or all of the data while the system is running, and hitting a breakpoint at the\nwrong point in a real-time loop can lock up your system. In the case of video game\nconsoles (referred to simply as consoles hereafter), you have no keyboard, so something\nlike a drop-down winclow fora command-line interface, such as is often used by firse-\nperson shooters, is pretty much outas a debugging toal. We are trying oo fix the shore-\ncomings of debugging environments, bur it would also be nice to have a way to\nreduce the edin/compilefrun loop a bit.\n\nEvery programmer who has worked with a real-time loop is sure ro have war sto-\nries of the nasty bug that took forever to find. Sometimes the code runs differently\n\n4115\n\n116\n\nSection 1 Programming Techniques\n\nwhen you single-step through it. Sometimes you need ro debug a live network game\nto reproduce a problem, or better yet, debug both ends of a network game at once.\n\nConsoles have the added difficulry of having a limited path back to mass storage,\nif the path exists at all. (On some console development systems, it is possible to access\nthe development PC file system vo read and write files, but once you go to CD or car-\nmidge, the data path back to the PC prows very restricted. About the only option left\nis to stere data onto memory cards, then read the memory cards on a development\nsystem that has access to a PC file system.\n\nConsole game systems, and embedded systems in general, have some problems\nthe PC crowd may not run into, The debuggers for console systems have been petting\nbetter over time, bur there is still a great deal of room for improvement. Furthermore,\nnot a lot of debugging can be done once you burn your game onto a CD.\n\nAt some point, almost every project has puc a frame-rate counter on the screen or\ndisplayed some other sort of data from a live system. Other common items thar are\nhard to get at with a debugger but are easy co crack in a live system are the polyersn\ncount, culling efficiency, and general execution times based on the content of che\nviewport. It makes you want to build a system for displaying arbitrary lists of num-\nbers, It certainly gor under my skin, and eventually | did something abour ir.\n\nThe idea of an in-game display can be expanded to include editing of the data,\nwhich can help in a number of ways. First, debuggers don't typically ler you rcad and\nwrite data files. Second, with an in-game editor, whether keyboard of controller\nbased, you can edir the actual game dara as you run the game. Third, che edited data\ncan be loaded and saved on a PC or console development system.\n\nHow: An Evolutionary Process\n\nThe code included in this chapter evolved over the years from a simple displayed list\nof numbers that could noc be edited to a list of cexr labels and read-only numbers,\nultimately to the current version, which includes multiple pages of dara that can be\nedited while the game is running, The text-based display is simply an overlay dis-\nplayed on cop of the garne itself,\n\nFor many projects, it has worked our co be a lot easier no use an editable version\nof Stats rather than cheat codes. Stars can be used to toggle particular features on and\noff, and a set of related features can all be displayed together on a single page. With\nthis setup, you can get to some really detailed dara on system behavior while the sys-\ntem is still running.\n\nConsoles, with their debugging drawbacks, can benefit particularly well from an\nadditional method of debugging that does not rely on the tool set provided by the\n\nconsole manufacturer,",
      "page_number": 107,
      "chapter_number": 12,
      "summary": "This chapter covers segment 12 (pages 107-114). Key topics include assert, debug, and debugging. Covers debugging. This\narticle contains seven cool lite tricks that can be used to squeeze more functionality\nout of assert.",
      "keywords": [
        "Assert",
        "assert macro",
        "Assert Trick",
        "Assert Steve Rabin",
        "assert dialog box",
        "assert dialog",
        "sre",
        "code",
        "macro",
        "debugging",
        "Trick",
        "Programming Techniques assert",
        "game",
        "system",
        "custom assert macro"
      ],
      "concepts": [
        "assert",
        "debug",
        "debugging",
        "code",
        "game",
        "time",
        "char",
        "length",
        "simple",
        "line"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 8,
          "title": "Segment 8 (pages 142-159)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        },
        {
          "book": "Python Architecture Patterns",
          "chapter": 10,
          "title": "[ 329 ]",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 3,
          "title": "Segment 3 (pages 27-35)",
          "relevance_score": 0.61,
          "method": "sentence_transformers"
        },
        {
          "book": "makinggames",
          "chapter": 8,
          "title": "Segment 8 (pages 60-68)",
          "relevance_score": 0.61,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 40,
          "title": "Segment 40 (pages 368-375)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 13,
      "title": "Segment 13 (pages 115-123)",
      "start_page": 115,
      "end_page": 123,
      "detection_method": "topic_boundary",
      "content": "1.413 Stats: Real-Time Statistics and In-Game Debugging 117\n\nWhat: A C++ Class-based System\n\nTo start, the full code: for each class and its member functions ean be found on the\nbook's accompanying CD-ROM. You might want to refer to it as you go through the\nfollowing material.\n\nAsmilar implementation of this Stars system took less than a week to desipn as a\nC++ class using a common Star base class and derived types for each displayed data\ntype. The system consists of a base Stat class, which is the container for everything,\nand separace pages, which each contain a number of entries.\n\n‘There is a tradeoff with the way you end up printing Stats to the screen. If you\npur your printing code in the derived Stat class, ic is less portable, but you can do\ninteresting things such as having a Stat thar is rendered as a bar graph. If you simply\nhave the Stats fill in a string to be dumped to the display device, as in the provided\nsample, you have a highly portable implementation that can be used more easily for\ncross-platform developmen.\n\nThe base of the system is a class chat holds a linked list of pages and some other\ninformation that needs ro be global to the Stats system. An Initialize() function\ntakes the place of the constructor because it is a fully static class that may nor have an\ninstance created, resulting in no call to a constructor. The base system has a Print{}\nfunction that calls the Print() function for the current page.\n\nThe Windows-based sample code also has keyboard input processing, which\ntakes an array of boolean key states as input. The array is built by tracking wa_KEYDOWN\nand W_KEYUP messages from Windows in the eventt-procesing loop of the program.\nOn a console, you pass in an array containing the coneroller state. With each pass\nthrough the real-time loop, both the CheckInput(} and Prant() functions need ro be\ncalled. Pages are added automatically by having their constructor call the base\nAgsPage(), since itis simpler to not make the programmer remember to do it for each\npage he or she adds.\n\nThe initialization is needed simply to guarantee that the base isn't pointing at ran-\ndom cata that would be interpreted as a page. Ir also sets up the limits for how many\nlines belong on a full sereen.\n\nEach page in the linked list owned by the base class contains zero or more entries,\nOne of these pages is always the current page, whether it is displayed or hidden.\nEntries are added to pages using che common entry parent class. The constroctors for\nentries automatically call the AgdEntry() function, similarly co the way the page con-\nstructor calls AddFaget 4-\n\nEach page contains a linked list of enrries. The entry constructor is used to set up\nthe initial state of the Stat, including the page on which it appears, a cext Label, and\nthe relative prioricy of the entry (which can be thought of asa line number). Denved\ntypes also have an inittal value, should the derived pepe need to be initialized with a\nparticular value. The virtual functions of the default class cstatentry are to be over-\n\nSection 1 Programming Techniques\n\nfidden in cach derived class so that the parent system can access each Stat type\nthrough a common interface.\n\nAdding a new class is dane by copying one of the classes derived from ¢Statentry\nto a new class name, renaming it, and adding an appropriate variable w hold the\nvalue. Once that is done, you need to rewrite parts of the member functions to match\nthe new data type.\n\nThe actual data stored ina Stat varies based on the Stat type and is included in the\nderived Stat classes. Fach data type has its own Print() function co replace the base\nelass virtual function. This function is very useful because che base class can then po\nthrough a list of generic Stat pointers and tell cach to print without having to worry\nabout whar type it is. Navigation is also simplified by basing all Stats on a common\nparent class. Using the parent type as a generic Stat pointer helps keep things orga-\nnized and under control. With multiple pages and each page having a current item to\nkeep track of, it can get a bit confusing otherwise,\n\nOne typical use for Stats is converting fixed-point statistics to printable floating\npoint equivalent values. Stats can be a bit of a processor pig on large pages, but it can\nsave a great deal of development time. The value 1.75 is casier to read than 5G and\nhaving to mentally divide by 32 to get the floating-point equivalent of a certain six-bit\nfixed-point number.\n\nAdding Stars to an application requires three things:\n\n. Call ¢StatBase:: Initializes) at startup.\n\n- Call GStatBase::CheckInput() each pass through the real-time loop to update\nthe Stats keyboard state or the concroller stare on a console.\n\n3. Call cStatéase: :Print() alter rendering the screen to display the Stats on top of\n\nyour real-time image.\n\nfd\n\nImplementation time for a new Seat type varies depending on complexity, but a\nsimple numeric type can be added in under 10 minutes. A type using enumerations,\nVectors, Matrices, ar something more complex takes longer but is preety straighefor-\nward as well.\n\nA derived Stat type in the sample code called a cStatIatetr deserves a litle bit of\nextra explaining because of iss slightly difference inverface and the interesting things\nyou can do with it. The value stored in the Star is a pointer to an integer. When it is\nprinted, the value of the integer being pointed ar is shown. This feavure allows you to\ndeclare a Stat and have it automatically updare the displayed value as ie changes\ninstead of having to set che value of the Star im each frame. It also allows you to\ndirectly edit the value of the number being pointed to, one of the more powerful\nadvantages of this system. You have direct access ca a variable within your running\ncode by adding just one line of debug code to declare an instance of a Stat.\n\n‘Typical execution time for running a similarly designed implementation of Stats\non a Sony PlayStation has been under 2 milliseconds per frame, with enough Stats\nbeing displayed to cover che entire screen. For reference, one frame ar 30 frames per\n\n1.13 Stats: Heal-Time Statistics and In-Game Debugging ; 119\n\nsecond takes 33.3ms, so Stars uses less chan 69 of the processor when showing a full\npage of data. Since you obviously want to compile withour Stats for your release build,\nthis ime is given back to che rest of the program when development nears completion.\nThe percentage of processing time used on a PC citle should be quire a bis smaller.\n\nOne word of warming on this implementation of Stats, It isn't designed to work\nwith pages and entries appearing and vanishing. All page and entry instances should\nbe declared static. It isn't too hard to change it over to allow for dynamic creation and\ndeletion of Stacs, but having static Stars has always been sufficient, so the extra effort\nwas never put into it, You can change the classes to enforce this current behavior by\nbuilding destructors into each function with an assert chat halts che program when ir\ndiscovers a Stat being destroyed duc to its going out of scope.\n\nWhere: Applicability\n\nOne readily apparent use of Stats is for user interface protoryping, where you want co\nset up your screen flow without having real screens available yer. A typical menu can\nbe set up in a few minutes, allowing you ro bypass unfinished user interface code. You\nhave much less wo design, since the cext-hased interface is already implemented in\nStats. Sumply write your bypass Stars, and you are off and running again instead of\nwaiting for someone else to finish some critical chunk of code.\n\nYou could incorporate Stats into a racing title for in-game editing of direction\nand path indicators, Stars can be set up to tigger loading, moving, and saving the\ndirection markers while the game is running, It's also been used previously to edit Al\ncapabilities and to load and save several kinds of dara files, including the batch pro-\ncasing of script files into memory dumps of a class. (See the article Fast Data Load\n‘Trick’ for derails.) It can also be used to trigger the export of frame caloularion time\nbased on world position to build charts that indicate high load areas,\n\nStars also give a convenient way to jump to arbitrary levels within a game. There\nare any number of things you might want to override or curn on and off while the\ngame is running! Some examples are highlighting collisions, tweaking camera behavior,\nindicating player speed, setting environmencal lighting, and so on. It greatly simplifies\nthe life of the modeler if ir is possible to edic che camera offsets and field of view in the\napplication as well. Then those numbers can be easily plugged into modcling software\nence instead of looping through the build-test-build-test sequence a dozen times.\n\nSummary\n\nOn che projects [ have worked on in which we have wsed the Stats system, it has saved\na great deal of time, nor only for the software designers but also for art and level\ndesigners. Stats is an easy way to add a debug incerface to an application, whether for\nPC or console. It's even pretty easy to retrofit Starts into an existing application, should\nyou be halfway through development when you find that brick-wall bug that stops\n\nyou in your tracks.\n\n1.14\n\nReal-Time In-Game Profiling\n\nSteve Rabin\n\nProfiling code is a routine step in most software development, but it's an even more\ncrucial step in games, Since games are constantly pushing the envelope, they need to\nbe frequently monitored for hot spots or stupid mistakes that can hog down the frame\nrate. When che frame rate curns south, the source of the problem could be anyone's\nguess uncil a real measurement is taken. Was it the Al code char was tweaked last\nnight, or was it the collision detection code that was altered this morning? Or even\nworse, it could be an area of code thar hasn't been touched for weeks that's now inter-\nacting badly with some new dara. The only way co know is to profile it.\n\n‘This article shows you how to add profiling code directly inside your game. Not\nonly will you be able to quickly find the hot sports in your code, but in addition, any-\nene— other programmers, producers, designers, artists, and testers—can pop this\ninformation on screen. This information makes profiling an accessible wool char ulti-\nmately helps fine-tune your code and find bugs. For example, if the frame rate tanks\nevery time a big fire-fight occurs, is it the complexity of the graphics or the collision\nlogic thar’s responsible? When profiling is at your fingertips, a simple press of a button\ncan cell you the answer.\n\nSome people are adamant abeut not profiling their code until they're close to\nbeing finished with a module. “Why should I worry about speed when I’m still crying\nto make it work?” they reason. Although there is some cruth to this thought, irs\ninvaluable to be able co see haw your code is actually performing. Many cimes I've\nprofiled a module in the middle of development only to discover thar the function I\nthought was being called all the time never goc called or gor called cwice as much,\nObviously, this is a cool chat can help debugging at any point in development.\n\nGetting Down to Specifics\n\n120\n\nThis real-time profiler allows you t monitor any spot or segment of code you're inter-\nested in. It works by calling a function at the beginning and at the end of the area you\nwant to profile, Each sample, consisting of a Profilefegin and a Profilecnd, is iden-\nwified with a unique name that you choose. Using the supplied code, you wrap Pro:\nFiloBogin( “InsertSampleNamgHere\" ) and ProfileEnd( “InsartSenpleNaneHere\" )\n\n1.14 Real-Time In-Game Profiling 424\n\naround the code you want to look ar. Irs impertane to note chat the string names\nneed to match exactly (asserts carch any cases where they don‘).\n\nThe Overhead of Profiling\n\nOverall, the profiler takes a negligible amount of time to keep wack of your samples,\nespecially since you're going to watch only a handful of spots ara time. Unfortunately,\ndisplaying the results on screen probably hurts your frame rate a little, depending on\nhow it is implemented and how much text is displayed. If your on-screen text is badly\nimplemented (or not implemented at all), you could always represent ir graphically\non screen or ler the data accumulate and dump it to a tex: file. Furthermore, as with\nany debugging code, you can always wrap it so that it doesn't compile when building\na release version. However, until you get close to shipping, you definirely wane oo be\nable to activate the profiler in your optimized builds.\n\nSince the monitoring does take some amount of time, don't monitor very small,\nsimple snippets of code, especially if they are executed hundreds of times a frame. The\nmonitoring takes more time than the code fragment and causes it te look worse than\nit really is. An example is monitoring a function such as VectorNormalize() char is\ncalled hundreds of times a frame. The profiler accurately rells you how many times it\nis called, bur the timing information is useless. In this case, resort to using a profes-\nsional profiler.\n\nIts important co note thar this real-time profiler shouldn't replace a traditional\nprofiler. A real profiler can give you benefits that can’t he duplicated using this tech-\nnique. Rather, this real-time profiler should augment the profiling thar you'd nor-\nmally do. Think of this profiler as a quick-and-diry way to find our useful\ninformation. When youre ready for Very accurate Measurements, switch wo a profes-\nsional profiler.\n\nWhat Will the Profiler Tell You?\n\n‘This profiler gives you the following information at the end of each frame. You'll mast\nlikely want to have this information printed to rhe screen or some other output\ndevice. This article won't help you render the on-screen text (refer to the article “The\nText Utilicy Library,” by Dante ‘Treglia H, in this book), but it gives che following\nimportant clata:\n\n1. Unique name of the sample poing\n\n2. Average, minimum, and maximum percentages of frame time spent on that\n\nsample\n3. Number of times the sample was called per frame\n4. Relationship of this sample point to other sample points (parent/child)\n\nThe profiler tries to be smart about samples and keep track of parent/child rela-\nHonships. For example, if you sample the main loop of your game and the graphics\ndraw routine that’s inside che main loop, the parent/child relationship is taken into\nconsideration. The results shown in Table 1.14.1 are displayed.\n\nSéction 1 Programming Techniques\nTable 1.14.1 Sample Results |\n\nAve | Min | Max | # | Profile Mame\n14.3: | 11.8 | 34.9 | 1 | Madn Game Loop\na5.7 | 65.1 |] 88.1 |] 1 | Graphics Draw Routine\n\nHere are some observations about the results shown in Table 1,14,1;\n\nI. The Graphics Draw Routine accounts for 85.796 of the frame rare.\n\n2. Everything other than the Graphics Draw Routine accounts for 14.3% of the\nframe rate.\n\n3. The Graphics Draw Routine is called inside che Main Game Loop (noted by the\nindentation).\n\n4. The Main Game Loop should take 100% of che frame time, bursince the Graph-\nics Draw Routine is being profiled inside of the Main Game Loop, it’s subtracted,\n\n3. The Main Game Loop spikes with 34,99, whereas its average is a low 14.3%,\nindicating that some code within the Main Game Loop is periodically hogging\nthe frame time. Pechaps it's the Al code or physics code; add more samples to the\nprofiler to find our.\n\n6. The Main Game Loop and the Graphics Draw Routine are both called once per\nframe (noted under the # column),\n\nAfter adding more profiler samples to better identify the spiking problem, the\nresults shown in Table 1.14.2 might resule.\n\nTable 1.14.2 Sample Results fl\nAve | Hin | Max | # | Profile Mane\n2.4) | 1.8 | 2.6 | 1 | Main Gane Loop\n2.2 | 1-5 | 2.3 | 1 | Game Object Update\nP68 [9 6.5] 27.4 | ae | AI Update\na] 0.8 | Tad | 1 | Gollision Detection\n1-0 | o.5 | 124 -| 1] Physics\nBS.7 | 65.7 | a8.1 | 1 | Graphics Draw Rowtine\n\nFrom the results shown in Table 1.14.2, we can see chae chere are 32 calls to the\nAl Update sample (probably 32 game objects thar require Al). The Al Uplate is\nClearly the sample thar’s spiking, with 27.4% on some frames. There must be some\ncode inside the Al Update thar is periodically called. Perhaps che work thar the onde\ndoes can he spread over several frames so that the frame rate doesn't hiccup anymore.\nContinue to add profile samples uncil the exact segment of code is identified. Track-\ning down problems with che profiler is thar easy.\n\n1.14 Real-Time In-Game Profiling 123\n\nAdding Profiler Calls\nSS\nAs mentioned earlier, you must wrap the code you want to profile with Profile@egin\nand Profileénd. You should always wrap the main loop of your program and then call\nFrotilabumpoutputTosetter as the last thing in your game loop. ProfileDumpOutput -\nToButter formats the profile information into a text buffer so that you can display it\nto the screen somewhere inside the main loop. The following is an example of a prop-\nerly wrapped game loop:\nVoid main {\n\nJiinitialization Code Here\nProtileInit(); //¥ou must ¢all this batore the main loop\n\nwhile( IExitGane } {\nProtilebegin( “Main Loop\" };\n\nReadinput();\nUpdatedameLagie( );\n\nProtileBegin{ \"Graphics Draw Routine\" }:\n\nRandarscene| 3\n\nRanderProfileTexthutter(); //Dutput profile text fran last\nif Tram\n\nFrofileEnd( “Graphics Draw Aowtine* };\n\nProfileEnd({ “Main Loop\" };\n\nProfileDump output ToBbutter( }: ffiaffer will be drawn next\nff Trane\n\nProfiler Implementation\ni et a ee ee\n\nOn a given frame, each profile sample needs the following information:\n\ntypada? atrut {\n\nbool bValid; J/Whether this data is walid\n\nuint iProfileingatances; fff of tines ProfileBegin called\n\nint itpenProtilas: f/f of tises Proftilefegin wio\nProfileind\n\nChar szNane [256]; {fame of sample\n\ntloat fStartTina; ffTHe current open profile start tine\n\nTloat fAéccumulator: FP AlT samples this frame added\ntogether\n\nTlost fChildren$ampleTine; f/Time taken by all children\n\nwint LNunParents; HiNuaber of profile parents\n\n} Profilesanple;\n\nOver many frames, we need to keep history information on samples taken. The\nfollowing information will be stored over the long term:\n\n124 Section 1) Programming Techniques\n\ntypedef struct {\n\nbool bValid; iiWhether the data is valid\n\nchar szName[256)]; //Name of the sample\n\nTloat TAve; ffAverage time per frame (percentage)\nTLloat Twin; {{iindmum time per frame (percentage)\nTtloat TWax; /iMaxinum time per frame (percentage)\n\n} FrotilaSamplekistory;\n\nPor simplicity and speed, pre-allocate an array of ProfileSample(s) and Profile-\nSanplekistory (2). Pre-allocating the data makes it so we don't take a hit on allocating\nand destroying memory every time a sample is taken, Before any samples are taken,\ncall Profiletnit co initialize both arrays and record the start time.\n\n‘Two functions are used for referring to time: GetTime and GetElapsedtime. Get -\nTine should return system time in seconds (at the exact time it’s called). GetELapsed-\nTame should return the amount of time passed since the last frame (calculated by\ni/current_frane_ rate).\n\nfdefine WUM_PROFILE SauiPLes 50\n\nProftilesample g_samples[NUM_PROFILE_ SAMPLES];\nProfilesampledistery g_history[NUM_PAOFILE SavPLes);\nfloat g startProfile = o.07:\n\nfloat g_endProfile = o.of:\n\nvoid ProfileInit({ vodd }\nL\n\nuint i;\nfor( 1-0; 1<NUM_PROFILE SAWPLES; i++ } {\ng_sanples|i)].bVvalid = false;\n\ng@_histery|2)]-bVvalid = false;\nI\n\ng_startPrafile = GetTime(};\n\nDetails on ProfileBegin\n\nWe're now ready to record a sample, so let's look at the function ProfileBegin in List-\ning 1.14.1. When this function is called, it first needs to check whether or not a sam-\nple by the same name exists. If it finds one, it means that this sample has been called\nbefore on this frame. In that case, we want (to increment i0penProfiles, increment\niFrofileinstances, and mark the tStertTime.\n\nThe variable i0pen?rofiles is incremented by ProfilaBegin and decremented\nby ProfileEnd. In effect, it keeps track of how many profile samples have begun and\nnot ended. Note thar this implementation does not deal properly with recursive calls\n\nfa sample begun more than once before being ended). For that reason, there is an\naesert char carche: this condinan.\n\n1.14 Real-Time In-Game Profiling 125\n\nThe variable iProtileinstances is incremented by ProfileSegin in order to\ncount how many times the sample has been called on a frame. As you might remem-\nber, this is one of the key pieces of information thar is displayed in the ourpur. IF the\nsample has never been called this frame, the code finds a sample in the array char isi't\nbeing used and initializes it.\n\nDetails on ProfileEnd\n\nAlthough Prefilesegin is faisly straightforward, the real work is done in Profileend.\nThis is the function that tallies che results and properly accounts for parent/child rela-\nGonships.\n\nThe first step in Protileend is to find che sample in the array, Once the sample is\nfound, the end time is recorded and the variable iOpenProtiles is decremenced. Then\nthe code loops chrough all samples, counting how many open samples currently exist\n(parents) and remembering the index of the most recently opened one (the immedi-\nate parent}. The number of parents is then recorded in inumParents. If there weas a\nparent, the sample time is noted in the immediate parent's structure (to be subtracted\nfrom its sample time larer).\n\nSince this sample might be opened again on this frame, chis sample time is saved\nin the Accumulator so that another sample can use tStartTine. Listing 1.14,2 shows\nthe Profilefnd function.\n\nDetails on Processing the Profiling Data\n\nAll thar’s left is to process, format, and dump the data into a text buffer. This is done\nat the very end of the main game loop in the function ProfiledumpoutputTaBetfer.\nListing 1.14.3 shows this function. Nore that two functions, CleartaxtBuffer and\nPutTextiuffer, are used for outputting the text to the buffer. You have to supply these\nfunctions. PutTextautter puts the text string you give it into a vertically scrolling\nbuffer so chat each successive call inserts the new text suring at the end of the last one.\nClearTextButter simply clears the vertical scrolling buffer.\n\n‘Two other functions, StereProfileIndistory and GetProftileFronHistory, are\nalso referenced, Both are outlined in Listing 1.14.4. These functions help keep crack\nof the average, minimum, and maximum frame rare percentages foreach sample. By\ncalling StereProtilelniistory, YOu are averaging the current measurement with\nevery sample taken in the past. Then GetProtileFromMistory recrieves the new aver-\nages for you to display.\n\nFurther Enhancements\n\nAs you probably realized, this profiler is written completely in C (except for the C++\ncommenting style). By converting it to C++, irs possible to eliminate the need for the",
      "page_number": 115,
      "chapter_number": 13,
      "summary": "This chapter covers segment 13 (pages 115-123). Key topics include profiling, profile, and time. Asmilar implementation of this Stars system took less than a week to desipn as a\nC++ class using a common Star base class and derived types for each displayed data\ntype.",
      "keywords": [
        "Main Game Loop",
        "graphics draw routine",
        "Game Loop",
        "Stats",
        "sample",
        "code",
        "main loop",
        "frame",
        "time",
        "graphics draw",
        "Main Game",
        "loop",
        "draw routine",
        "game",
        "main"
      ],
      "concepts": [
        "profiling",
        "profile",
        "time",
        "timing",
        "sample",
        "functions",
        "calls",
        "code",
        "char",
        "frame"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 59,
          "title": "Segment 59 (pages 567-580)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 53,
          "title": "Segment 53 (pages 511-519)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 17,
          "title": "Segment 17 (pages 326-347)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 33,
          "title": "Segment 33 (pages 662-682)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 14,
      "title": "Segment 14 (pages 124-131)",
      "start_page": 124,
      "end_page": 131,
      "detection_method": "topic_boundary",
      "content": "126\n\nSection 1 Programming Techniques\n\nProfiietnd funcion. The cick is ro exploit Class constructors and destructors. Care-\nfully examine the following code, which profiles the tor loap:\n\nProtileinstance profile ingtance{ \"Timing tha For Loop\" 1:\n\nfar( int 120; i<ib000; ivr );\n}\n\nIn the code, a Profilelnstance abject is declared and initialized with a cescrip-\ntive string. When its constructor is called, the string is recorded along with the system\ntime. This information is then saved to global dara structure much like the Profilo-\nBegin funcrion.\n\nSince the objece profile_instance is within the curly brackets, ir is destroyed\nwhen program execution leaves that scope. Therefore, the destructor is called imme-\ndiately after the for loop. The destructor records the system time and saves the infor-\nmation to the global dara structure, exactly as the Profileend function does.\n\nSince the profiling line is now a little more awkward, we can streamline it by writ-\ning a simple macro:\n\ndefine Profile(a) Protilelnstance profile_instance(a)\n\nThe profiling example with the macro looks like this:\n\nProfile( “Timing tha For Loop\" 3\n\nfor( int 250; i=10000: i++ ):\nI\n\nThe beauty of this enhancement is that the profiling code now occupies a single\nline. Even better, it doesn't require a rerminating statement containing a perfectly\nmatching string. Profiling has never been so easy!\n\nPutting It All Together\n\nAmazingly enough, it decent tke much to put together a fairly competent profiler,\nSimply realizing it is practical is the hardest part, On the CD thar accompanies this\nbook, you'll find the completely implemented profiler. In no time, this line profiler\nwill become one of your most important debugging pools.\n\nListing 1.14.1: ProfileBegin\n\nvoid Profilefegin( char* nane }\n4\nvint i =o;\n\nwhile( a <= NUM_PROFILE SAMPLES £4 g sanples[i].bvalid =-- trug ) {\n\n1.14 Real-Time In-Game Profiling\n\nif( stromp( g_samples[i].szName, nang } == 0 } {\n‘fFound the sample\ng_Samples[i]-idpenrrofiless+:\ng_samples[i).iProfileinatances++;\nO_samples[i).fStartTime = 0SGetTinet};\n\n127\n\nBSsarti g sénples/ij.iopenProafiles == 1); //max 1 open at once\n\nreturn;\n\nitt:\n\nif( i >= NUM_PAOFILE SAMPLES ) {\nassert( [\"Excgeded Max Available Profile Samples® 4;\nretura;\n\n}\n\nstrepy( @ samples[i),szNane, name };\ng_sanples[i).bvalid = TRUE:\ng_sanples[i].i0penProfiles = 1;\ng_sanples[i].iProfileinstances = 1;\ng_samples[i]-fAccumulatoer = o.of:\ng_samples[i]-fStartTine = GetTine();\ng_samples[i)-?¢hildrenSaspleTine = o.or;\n\nListing 1.14.2: ProfileEnd\ni tee a tilt a\n\nWold Profiletnd( char* name }\n\n4\n\nuint 2 = @;\nUiNt hunFarents = Oo:\n\nwhile( i < NUM_PROFILE SAMPLES £8 g samples(i].bvalio == true )\n\n{\nif{ Stremp( g_sanples[ij].szName, name } == 0 }\n{ f/Found tha sanple\nuint inner = Oo;\nint parent = -1;\nfloat tindTime = GetTima{):\ng_sanmples[i].idpentrofilas—:\n\nPiGount 212 parants and find the inmediate parent\nwhilal 9 Samples[inner].bValid == true ) {\nif{ 9 fanples[inner).i0penProfiles = 0 }\n\ni ffFound 4 parent (any apen profiles are parents)\n\nUna rent sss;\n\nif( parant <9 )\n\nqi ffieplace invalid parent (index)\nparéot = inner:\n\nI\n\nelse if( g_sanples[inner] .fStartTime ==\n\ng_sanples[parent).fStartTime }\n\n{ /fReplace with mare immediate parent\nparent = inner:\n\n128 Section 1 Programming Techniques\n\n}\n}\ninneres;\n\n}\n\nffRemenber the current number of parents of the sample\nQ_Sanples[i] iNusParénts = numParants:\n\nif( parent >= 0 }\n{ J/fRecard this time in téhildrenSampleTine (add it in)\ng_sanples[parent) .tthildrenSanpleTime += fEndTime —\nog sanples[i].TitartTime;\n}\n\nifSave sanple time in accumulator\n§_Samples[i)-fAccunulator += fEndTine =\ng_senples[i].?StartTime:\nreturn;\n}\nLes;\n\n}\n\nListing 1.14.3: ProfileDumpOutputToBuffer\n\nveld ProfileQumpoutputTobutter( void j\n\n{\nuint i = g;\np_endFrofile = GetTine/);\nClearTextauttert }3\nPutTeNtBatfer( \" Ave + Min : Wax :  # > Profile Neame\\n\" 3;\nPutTentBuffer( \"---------------------eeeeessece|n® j?\n\nwhile( i < NUM_PROFILE SAMPLES && g samples{ij]-bvalid == TRUE If\nuint indent = oO:\nfloat sampleTime, percentTime, aveTime, minTima, maxTime:\nchar line[259], mane[—256], indentedName[256]:\nchar ave[i6], min[16), max[16), num[i6]:\n\nitd 9 sanples[ij.i0penProfiles « o ) {\nassert( I *Profile€nd() called without a ProfileBegin()\" $;\n}\nelse if{ g_sanples[i].i0penProfiles > 0 } {\nassert | *ProtileBegin() called without a Profileind()* };\n}\n\nsampleTime = 9 samples[i).fAccenulator —\ng_Samples [4]. fChildrenSanpletTine;:\n\npercentTime = ( sampleTine { (g_endrrofile - g startProfile } }\n* 100.0f:\n\naveTine = mintine = saxTina = percentTime:\n\n1.14 Real-Time In-Gamo Profiling 129\n\n//Add new measurement inte the history and get ave, min, and nax\nStoreProfilelndistory( g sanples[i].sziana, percentTime };\nSatProtilefromistory{ G_sanples[i].seNane, kaveTime,\n\nEninTime, kmaxTine );\n\nifFormat the data\n\nsprintt( ave, “33.1T\", avoTine iG\n\nSprint®{ min, “23.1f\", minTine };\n\nSpraintt( max, \"33.1%\", maxTime };\n\nsprintf, mun, \"Sad\", g_sanples[i).iProtileInstances i\n\nBircpy( indantedNane, g_samples[i].szName hs\n\nfor indent=o; indent<g_samples[i].iNumParents; indente+ id\neprintt( mame, \" 4&5\", indentedMama Vi\nStrepy( IndentedNanc, name };\n\nSPrintf (ling, \"95s 2 MSs : bSe : Sas : Ssin\", ave, min, max,\nnun, indentedName) ;\n\nFPutTextButfer{ Line }; f{Send the line te text buffer\nitt;\n}\n{ ff Reset sanplee for next trans\nunit a;\nfor( i=0; T<NUML_PROFILE SAMPLES; i++ } {\ng_sanples[i].bValid = FALSE;\nQ_StartProfvile = GetTimel):\n}\n\nListing 1.14.4: StoreProfilelnHistory and\n\nGetProfileFromHistory\n= SSS\nwold Stararrotilelnkistery( chars name, T32 percent }\n4\nuint i = 0;\nfloat oldhatio;\nfloat newAatio = p,\nift nowhatio > 1,o¢\nmhewhatio = 1.04;\n\nST * GetElapsedTime(};\n}\n\n{\noldkatio = 1.0f - nawFraction;\n\nwhile( i < NUM_PROFILE SAMPLES 44 g history[i].tvalida == TRUE If\nif{ stremp( g_history[i].szNane, name } == 9 }\n{ /iFound the sanple\ng_history[i].fave = (g_history[i].fAve*olonatio) +\n(Percent *newRatio j=\nif percent < g_history[i)].7Min } {\ng_history[i].TWin = parcent;\n}\n\n130 Section 1 Programming Techniques\n\na eee\n\nelse {\ng_histery[i]-fiin = (p_history[i].fWin*oldAatio}) +\n(percent*newhatio):\n}\n\nif{ percent > g_history[ij.fWax } {\ng_history[i]-fitax = percent;\n\nelse {\n\ng_history[i] tax = (gp hdatory[i].fWax*aldfatio}) +\n(percent\"newhatio};\n\nreturn;\n\ni++;\n}\nif(t i= MU PROFILE SAMPLES }\n{ ffAdd ta history\nstrepy( g_history[i].szMane, nama j;\nghistory[i].bValid = TRUE:\n\ng_history[d),.fAve = g history[i].TWin = g history|i]-fitax =\npercent;\n\nelse {\nBSeert( i*Exceeded Max Available Profile Samples!*);\n}\nI\n\nvoid GeatProfilerromistory( char™ name, f22\" ave, f32\"* min, ta2* max }\n|\n\nuint 1 = 0;\nuhile( i «= NUU_PAOFILE_SAMPLES &4& g hastory[i)-bValid == TAVE } {\nif({ strcemp( g history[i].szWame, mane } == oO j\n{ //Found the sanple\n*ave = g history[i].fAve:\n\"min = g history[i].tilin:\n‘max = g history[i] .filax:\nreturn;\n}\n\nber;\n\n\"ave = “nin = “max = 0.07;\n\nI\n\nReterences\n\n[Abrash97] Abrash, Michael, Michse! Abrasts Graphics Programming Black Book, The\nCoriolis Group, 1997,\n\n[McConnell93) McConnell, Steve, Cade Complete, Microsoft Press, 1993.\n\n[Meyers95) Meyers, Scott, More Effective C++, Addison-Wesley Longman, Inc.,\n1996,\n\n2.0\n\nPredictable Random Numbers\n\nGuy W. Lecky-Thompson\n\nA large proportion of the success of a game in today’s marketplace depends on a suffi-\nciently detailed backdrop against which the game action can take place. Not only\nthat, bur the backdrop could also take an active role in the interaction berween player\nand game. In search of this elusive mix, the traditional approach has been ro simply\nhand-craft level data and store it in a relatively complex and space-consuming level\nfile, to be replayed in real time.\n\nOccasionally, however, the cepth of some games falls below the expectations of\nthe audience, This disappointment is caused by the fact that the game is sometimes\nsimply net big enough; onee the bates have been fought and the blood spilled, the\nplayer is left with something of an anticlimax.\n\nEven with huge resources at their disposal. game designers often run out of che\nspace needed to distribute a large and complex game, especially when the images used\nfor rendering are photorealistic and the sound awesome, with thumping music and\nsampled explosions. These are important ingredients, but designers might often feel,\nrightly, that they are sacrificing something in return. This is especially evident in\nresource-limited environments such as we find in the handheld and console market.\n\nOnc example of a huge and complex game is Elite. This fame was originally writ-\nten by David Braben and lan Bell for the BBC Model B computer in 1980, Ir has\nsince been ported to all home computer formats and is still as widely played now as in\nits heyday. The original game ran on a machine with 32KB of memory (16KB ROM\nand 16KB RAM), bur it still boasted a depth of play that has yer to be matched: near-\ninfinite planets, each with names and individual characteristics,\n\nThis article is a study of'a technique that can be used co provide the depth of play\nthat the audience deserves, even in limited-resource environments, such as that faced\nby the original Elite, without sacrificing any of the other viral ingredients thar make\nup the perfect game.\n\nPredictable Random Numbers\n\nThe underlying principle of this technique is that, to provide the illusion of infinity in\na game universe, we need to satisfy nwo conditions of resolution. These we can term\n\n1343\n\nSection 2 Pdathematics\n\nmacre-infteite and micre-infreite, The first relates to the size of the universe in ques-\ntion, of the number of discrete entities. The second condition indicates the level of\ndetail that cach object supports, We shall see in the course of this article how both of\nthese conditions can be achieved using the same underlying technique.\n\nTo avoid the storage of vast quantities of level data that will mever satisfy che reso-\nlution requirements we have identifed, we need to be able to generate che universe in\nreal time, from the point of view of the player. Not only that, bur this universe must\nalso have the same appearance each time the game is restarted or played on a different\nplatform or machine.\n\nIn order to simplify the issue slightly, we can assume that exch object in the uni-\nverse is expressed by its placement within the universe and a sec of properties chat\nindicate how ic is to appear to the player. Each object can also interact with the player,\nwhich we discuss later in the article.\n\nBy way of example, let us consider as game universe a simplified model of our\nown. That ts, we have a container object, the Galery, which contains a number of\nStars. At game time, we would like to populace che Galaxy with Stars in a fashion char\nis both repeatable (it always “looks” the same from the player's perspective) and con-\ntains cnough planets to provide a reasonable illusion of infiniry.\n\nTo achieve chis poal, we construct a series of Star objects and set the placement\nanribures of each one such chae they exise ac given points within the Galaxy. Consider\nthat the placement aceributes consist of an x and ay coordinate, and it is obvious that\nwe need co generate values oo plaice in these holders. This is where the predictable ran-\ndom number sequences are used; we can use a series of generated random numbers to\nprovide us with coordinares for each of the Stars.\n\nThe simplest approach is provided by the ANSI C specifications and gives us the\n\nfollowing two functions:\n\nrand [seed)\nrand}\n\nEvery tite We feed a bist [ats tla af numbers, We need a Dwoe ste operation. The\nfirst seeds the generator with a given value, which is used to propagate che sequence.\nThe same sequence is generated every time we seed with the same value. Thus the\nseqjuence is repeatable, but we do mot need to store it anywhere, because it can be cre-\nated on the fly, Thus we can generate a near-infinite galaxy entirely in game time,\nreducing our static storage requirements beyond measure.\n\nThe following is very simple pseudocode showing this concept in action for a\ngiven Galaxy of limited size. Assuming a possible grid of 100 x 100, we have 10,000\npossible spaces into which we can place Stars. Notice that the seeding is performed\nence and once only per sequence of numbers; in the following case, we are seeding on\n\ngalaxy number 1:\n\nsrand (1)\nfor galaxy_x = 1 to 100\n\n2.0 Predictable Random Numbers 135\n\nfor galaxy y = 1 to 100\nprobability = rand{) % i100\nif probability > 70 then\nuniverse (galaxy x,galaxy y}) = star\nalsa\nuniverse (galaxy_x, galaxy_y}) = no_star\n\nObservant readers might have nociced a possible drawback: we still need to store\nthe location of each Star somewhere, which requires about 10,000 bytes of space in\nreal time, This size would never have fir inside a machine with IGKB of RAM. Even\nif it could, it i nor scalable, crn by a factor of LO,\n\nTherefore, we should refine the technique a litle. From the preceding example,\nwe see that there is a 70% chance of a Star EXISINE at a given points, y. The number\nthar determines this percentage is created from a seeded sequence based on the simple\nseed 1. Given thar we would like a near-infinite population, it makes more sense to\nperform this calcularion on an as-needed basis, as in the following code:\n\nint StarAt (int nGalaxy, int nX, int nv}\nint x, ¥, MReturn:\n\nBrand (mGalaxy) ;\nTor (y = 0) yo s= mv; yet}\n1\n\nFor (x = 0; x <= mW; x44)\nnieturn = rand() % MAXIMUM VALUE;\n\n}\nreturn sheturn;\n\nAlternative Algorithms\n\n——\nMany and varied chaotic and semi-chaotic algorithms give rise to the kind of behav-\nior thar we use here. This is not a mathemarics paper, and some of the advanced alga-\nmithms that could be used require more processing power than is available,\nconsidering all the other operations that are being performed during game play, so we\nshall restrict ourselves to the discussion of a simple approach,\n\nThis approach can be represented by che following pseudocode:\n\nChass two large integers, Geni and Genz, such that one\nig double the other\n\nCheest a seed value that is between 1 and tha smaller\nof the Large integers\n\nChoose a value Max that represents the highest nurber\nthat is te be returned",
      "page_number": 124,
      "chapter_number": 14,
      "summary": "This chapter covers segment 14 (pages 124-131). Key topics include profiles, samples, and sampled. The cick is ro exploit Class constructors and destructors.",
      "keywords": [
        "PROFILE SAMPLES",
        "SAMPLES",
        "Techniques Profiietnd funcion",
        "Programming Techniques Profiietnd",
        "profile",
        "history",
        "sanples",
        "Profiietnd funcion",
        "game",
        "Predictable Random Numbers",
        "Techniques Profiietnd",
        "time",
        "max",
        "Random Numbers",
        "Galaxy"
      ],
      "concepts": [
        "profiles",
        "samples",
        "sampled",
        "game",
        "max",
        "parent",
        "inner",
        "char",
        "stars",
        "number"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 8",
          "chapter": 37,
          "title": "Segment 37 (pages 343-350)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 38,
          "title": "Segment 38 (pages 764-785)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 13,
          "title": "Segment 13 (pages 117-125)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 59,
          "title": "Segment 59 (pages 567-580)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 15,
      "title": "Segment 15 (pages 132-139)",
      "start_page": 132,
      "end_page": 139,
      "detection_method": "topic_boundary",
      "content": "136 Section2 Mathematics\n\nFor each iteration,\n\nWultiply Geni by the seed, and add Gonz\n\nThe new s#éd is renainder of this value diwided by Max\nReturn s6@ed as the random value\n\nThis code works by first taking a repeatable sequence of numbers, which follow a\npattern with a given starting point (a multiplication and addition) and then breaks\nthe pattern by taking the remainder of a division. This result is then used to begin a\nnew sequence with the same base equation. In this way, a fairly random sequence is\nbuilt up. The source code for this sequence follows. This is taken from the Psreudoran-\ndom class, whose source code is provided on the accompanying CD.\n\nPaeudofandomizer: i:Pseudofandomizer(unsigned long uldeni,\nunsigned long ulSeed,\nunsigned long ulMax)\n\n{\nthis-=ulGent = ulGeni:\nthis-=ulGen? = ulGenl * 2;\nthis--ulSeed = ulead;\nthis-=ulMax = ulWax:\n\n}\n\nunsigned long Pssudehandomizer: :Pseudohandon j\n{\nunsigned long ulNewSeed;\nUliewSeed = (this->ulGeni * this->yu1Seed) = this->ulgen2;\n\ni 7 Use seadulo aperator to ensure = ulllax\nUlfiewSeed = ulMewSeed & this->uliax;\n\nthis--ulséed = ulNewSeed;\nreturn this->ulSeed;\n\nThere is one final limitation. The largest number that can be generated using this\nsystem is 4.294,967,295. It follows from the previous algorithmic description that the\nsequence begins to repeat itself after the 4,294,967,295th iteration. This is a limita-\ntion of che dara ype used, a 32-bit unsigned integer. If greater numbers are required,\nir is necessary co move oo a difference representation.\n\nAlgorithms for Infinite Universes\n\nSo far, we have seen how we can decide on the existence of a game feature ata given\nlocanon, We have sacisfied half our bricl chat of macro-infinite resolution, Mow it is\ntime to tum our attention to the use of pseudo-random numbers on the features and\ndetail of the game objects: micro-infinite resolution.\n\n2.0 Predictable Random Numbers 137\n\nIn essence, micro-infinite resolution is all about zooming in on a point and sccing:\nwhat we find there. To take our current example, we might say that cach Sear is\norbited by zero or more Planets. These Planets orbit at a certain distance from the\nstar, They have other characteristics we examine later; specifying their location is\nenough for now.\n\nIn order to specify these items, we mighr choose to add an attribute to our Star\nclass which gives the number of Planets, and calculate this. The following code extract\nshows how we can calculare an atoribure of our Star class, che number of Planets:\n\nf* Taken from header file *!\n\nclass star {\nprivate :\n\nint x_position, y_position;:\nint number_of planets;\n\npublic :\nVoid SethumberttPlanets( |:\n\nhe\n/* Taken from implementation file */\n\nveid star: :SetNunberOtPlanetsd) {\nPeeudorandom-+seed(this->x_position + (this->x position\n* this->y position);\nThis->nunber_of planets = PSCudorandom-*generate() % 20;\n\nWe have skipped into a slighty higher gear with this code, some of which bears\nexphining. First, we are seedling on a unique value for che Star, based on the position\ngiven by the x and y coondinate propertics of the Star object, This means chat for each\nStar, we can generare values that are seeded for thar particular object. Thus we reduce\nthe probability of having two identical Star objects in circulation.\n\n4 second point to note is chat we have taken the modulo of the generated num-\nber in order to limit the number of planets chat may orbit this Star. ‘To introduce more\nrealism {and hence, a larger micro-infinite resolution), chis code could be adapred\nbased on other attzibutes of the Star, such as size, intensity, or proximity,\n\nArmed with this information, we can now consider how we might use a similar\ntechnique thar will enable us to generate a distance value for a given planer. As noed,\nthe important starting point is the seed thar is used to determine the features of the\nobject. Bearing in mind that the seed should be unique to each possible planer, we\ntrust somehow incorporate the position of the parent Sear as well as chat of the Planet.\nThe following code extract shows a possible approach:\n\n!* Taken from header file \"s\n\nSection 2 Mathematics\n\nclass planet {\nprivate =\n\nint distance fram star;\npublic :\nWoid SeibistanceFronstar(int planet_number,\nint star_x_position, int star_y position);\n\n}\n/* Taken from implementation file */\n\nYoid planet::SetDistancaFronSter (int planet_sumber\nint star_x position,\nint ater_y positian) {\n\npseudorandom-=seed(planat_nunber + (Star_x_pasition +\n(star_«_position * this->star_y_position) \\);\nthis=->distance_from_star = pseudorandon->genarate(} & 20;\n\n}\n\nSo, we have cHectively “zoomed in” from Universe to Star oo Planet, as far as spec-\niffing positions is concerned. To complete the backdrop (and our discussion of\nmicro-intinite resolution), we should start to add properties using more sequences of\npredictable random numbers.\n\nThe key vo chis next stage is the ability te isolate for a given object in the universe\na set of artributes that describe the object. After we have done that, it is necessary to\ndecide on the representation of these aceributes, given that a constant stream of ran-\ndom numbers is available.\n\nEach of these attributes may in itself be an objece (as Planet is to Galaxy is to\nUniverse), with properties of is own char can be set in a similar way, by seeding on a\nunique reference. For the next example, we shall ascume that we require a map of the\nPlanet object and thar this map is represented by a simple gid into which we can\nplace other objects. The whole code for che Universe, Galaxy, Planet, and Map\nobjects is contained on the CD that accompanies this book. The pseudocode might\nlook like this:\n\nfi Dating the map size (side x sida)\nhap->9rid side = pseuderandon-+generate() % 100\n\nff Plate an abject on the map for a given position x,y\nPSeuGOrandon->Seed { (tap=>grid sida * wi + x)\nRap-»grid square(x,¥) = pseudorandom->generate(}) % 2\n\n(The modulo value 2 could be taken to mean that 0 is water and 1 is land, for\n\nexample.)\n\n20 Predictable Randeam Numbers 138\n\nIn the preceding examples, che seeding has been omitted, As can be seen from the\nsupplicd code examples, the seed is gcncrated on an object-by-object basis ar instanti-\nation of the object. In fact, the supplied code also stores a number of acrribures used\nto generare the seed. which have been omitted here for che sake of brevity.\n\nIt can be proven from watching the ANSI srand and rand functions working\ntogether thar there is more to choosing the seed chan first meets the eye. Earlier, we\nproposed:\n\nerand (x_position + (x dimension * y position))\n\nwhere the generator is seeded on the unique reference generated for che point (x, y}\nbased on the dimension of the target container. However, repeated runs using srand\nand rand show thar this method produces a result that is far from chaotic. (See the\narticle “Real-Time Realistic Terrain Generation,” which contains a figure shawing a\npattern that is a result of using ehis technique with the ANSI generator.)\n\nThe CD that accompanies this book contains the entire code for che Pseudoran-\ndom class, but the following algorithm, which can be used for seeding the generator\nproperly using just the ANSI functions or used along with the Pseudorandom class\ninself, is warth repeating here:\n\nsrand (y_ position)\n* = x position\nwhile x > O\n\nrand}\nLt Te\n\nThe next call to rand yields the required number, which can be considered the\nfirst in the ensuing sequence,\n\nConclusion and Future Developments\n\nIn this article, we have seen how we can use macro- and micra-infinite resolution\ntechniques, propagated by sequences of pseudo-random numbers, seeded ona unique\nobject reference. These techniques enable us to create near-infinite fame universes\nwithin the constraints of a limited-resource environment, by run-time generation,\n\nDevelopers may choose to use this information “as is” or enhance it further. For\nexample, events can also be approached in the same way, seeded on the play history, or\nin real ume. This technique would ensure that if a fire occurred at a tavern at a given\npoint in time (possibly in connection with actions made by a player), we could pre-\ndict when it would happen and thus ensure that it took place at the same time in each\nBame sossion.\n\nThe key to stecessful use of predictable random numbers lies in the judicious use\nof the seed in parallel with the object properties and play state,\n\n140 Section? Mathematics\n\nReferences\n\nLecky-Thompson, Guy W., “Algorithms for an [nfinite Universe,” Gannascutn, avail-\nable online ay www.pamasutra.com/ feacunes! 1999091 7/infinite_O1.hem, Septem\nber 17, 1999: contains a detailed discussion of the effects that can be achieved\nusing this technique.\n\n2.1\n\nInterpolation Methods\n\nJohn Olsen\n\nHave you ever wanted to have your program move samething from ene location to\nanother gradually over time? There are dozens of ways to do thar, with varying\ndegrees of flexibiliry and varying CPU requirements. Four of these methods are dis-\ncussed in this article, giving details on how each method behaves:\n\n* Frame-rate-dependenc ease-out using floating-point mach\n* Frame-rate-dependent ease-out using integer math\n\n* Frame-rate-independent linear interpolation\n\n* Prame-rate-independent case-in and ease-out\n\nAll these methods share some common ground. You start ara specific poinr, you\nwant to be at some other point, and you might er might not have a time limir in mind\nfor how long it should rake to get there. The source and destination could be any\nnumeric value or combination of values. For instance, they could be a temperarure,\naltitude, 3D position, a direction or velocity vector, or any number of things. The\ninterpolation is meant simply to take you from one value to another along a smooth\npath of some sort.\n\nShould you want to perform these interpolarion methods on a vector, for instance,\nyou apply the algorithm to each component of the vector separarely.\n\nFrame-Rate-Dependent Ease-Out Using Floating-\n\nPoint Math\n\nee\nThis method behaves in a frame-rate-dependent manner, so it behaves differently if\ncalled ar 10 frames per second than it does ar, for instance, 20 frames per second. This\nmeans that you want to use this method only if accuracy is not your prime concer,\n\nThe concept behind this method is that you want to compute a weighted average\n\nof the current value and the desired value, with a heavier weight on the current value.\nThis can be done with Equation 2.1.1. The new x value equals x,, the original value,\nmaultiplied by a weighting factor, added co che final destinarion x value. The sum is\ndivided by the total weights to properly preserve the scale. The resulting x is used as x,\nfor the next pass through the equation.\n\n141\n\nSection 2 Mathematics\n\nx = (x, * (teighe = 1) + 2,9 | weighs (21.1)\n\nThe weight must be a value greater than one to get the expected behavior from\nthis equation. Higher weights make it take longer to reach the desired position. This\ngenerates a smooth curve, as shown in Figure 2.1.1, which shows how the value\nchanges rapidly ar first, then settles toward the destination value as it approaches,\nwhich is called ease-ove,\n\nThe sample C++ class that can be used for floating-point ease-our interpolation is\nnamed GEasedutOividelnterpolation and can be found in Listing 2.1.1. You call\nSetup() when you are beginning an interpolation, passing in your starting and ending\nvalues anc a scale factor that controls how quickly che interpolation occurs. With each\npass through your real-time loop, you call Interpolate() to do che work, then call\nGetValue() to reteve the current interpolated value. Inccrpolare rewurns TAVE when\nthe interpolated value is no longer changing, indicating you are as close as you are\ngoing to get to the target. With this floating-poine code, it could rake a very long time\nto reach a steady stare.\n\nFrame-Rate-Dependent Ease-Out Using Integer Math\n\nThis method is very CPU friendly because ir uses no division. This method is more\nimportance on console systems or older hardware with limited floating-point support.\nIt works fast but has some restrictions on flexibility, even: compared with the previous\nmethod.\n\nGf Bb\n\nherd lions\n\nFIGURE 2.1.1. Floating-point casc-our.\n\n2.1 Interpolation Methods 143\nee\n\nThe process of building a weighted average using integer math has some interest-\ning side cffects. The rate of change tends to stick at specific levels during the interpo-\nlation, and you are likely to never quite reach the destination point due to round-off\nerrors. Equation 2.1.2 shows che modifications used. The values for (2\"— 1) and ware\nthings you want to hard code for speed, which gives a form similar to Equation 2.1.3,\nwhere “>=\" represents a shift operaror, as in the C language. The computations have\nsome difficultics with round-off, as shown in Figure 2.1.2, which is much less smooth\ncompared with Figure 2.1.1 and the floating-point method.\n\nx={x,*{2\"—]j)+ x) >> 8 (2.1.2)\n\nx=(x* 7+ x) => 4 (2.1.45)\n\nEven with the less-than-smooth curve, this method is very useful for larger values.\nIr tends ta work well with fixed-point math, where some number of bits in your inte-\nger value is defined to be the fractional portion. For instance, a 32-bit number may be\nthought of as 20 bits for the integer portion and 12 bits for the fractional portion. To\nconvert from the integer representation to the fixed-point representation in that case,\nyou divide by 4,096, Increasing the scale in thar way allows for much smoother\nbehavior, resulting in a curve more similar co the one shown in Figure 2.1_1-\n\nListing 2.1.2 contains a sample C++ class called CeaseQutShift Interpolation\nthat can be wed for integer-based case-out interpolation. You call setup) when you\n\nFIGURE 2.1.2. Integer ease-cut.",
      "page_number": 132,
      "chapter_number": 15,
      "summary": "This chapter covers segment 15 (pages 132-139). Key topics include value, point, and planets. Covers method. The source code for this sequence follows.",
      "keywords": [
        "Wultiply Geni",
        "star",
        "position",
        "diwided by Max",
        "Predictable Random Numbers",
        "number",
        "Planet",
        "code",
        "int star",
        "method",
        "che",
        "seed",
        "Random Numbers",
        "object",
        "Star class"
      ],
      "concepts": [
        "value",
        "point",
        "planets",
        "code",
        "star",
        "generated",
        "generate",
        "generator",
        "generation",
        "objects"
      ],
      "similar_chapters": [
        {
          "book": "Building LLM Powered Applications",
          "chapter": 39,
          "title": "Segment 39 (pages 326-333)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 17,
          "title": "Segment 17 (pages 154-161)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 16,
          "title": "Segment 16 (pages 145-153)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        },
        {
          "book": "makinggames",
          "chapter": 30,
          "title": "Segment 30 (pages 266-273)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "Segment 33 (pages 314-325)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 16,
      "title": "Segment 16 (pages 140-149)",
      "start_page": 140,
      "end_page": 149,
      "detection_method": "topic_boundary",
      "content": "144 Section2 Mathematics\n\nare beginning an interpolation, passing in your starting and ending values and a shift\nfactor that controls how quickly the interpolation occurs, With each pass through\nyour real-time loop, you call Interpelate() to do the work, then call Getvalue() to\nretrieve the current interpolared value, Interpolate() reruns TRUE when the interpo-\nlated value is no longer changing, indicating you are as close as you are going to get to\nthe target. With the integér-based code, this will likely happen before you actually\nreach the desired target.\n\nFrame-Rate-Independent Linear Interpolation\n\nIn the case of a linear interpolation, you want to compute an ideal velocity at the\nbeginning of the move and simply apply thar velocity each frame. This method gives\na straight line when charted, as shown in Figure 2.1.3. A bit of entry-level physics\nshows how to get that velociry in Equation 2.14. If you are measuring x in feet and ¢\nin seconds, that gives you a velocity in feet per second.\n\nv= (xp—ax) le (2.1.4)\n\nNext you need to apply thar velociry co each frame. To do this properly so chae it\nis frame-rate independent, you need to know how long the frame took. Once you\nhave thar time per frame, you can caleulare the change in position, using the already\ncomputed velocity, and add it co che original valuc, as shown in Equation 2.1.5. Ifyou\ntake a shoreut and calculate che velocity as distance per frame instead of distance per\nsecond, you lose the frame-rate-independent fearure but can gain a litde time by\navoiding the multiply in Equarion 2.1.5.\n\nxex,tt,*p (2.1.5)\n\nThe sample (++ class thar can be used for linear interpolation in Listing 2.1.3 is\ncalled CLineariInterpolation. You call Setup() when you are beginning an interpola-\nHon, passing in the starting and ending values and how long you want it to take to pet\nthere, With each pass through your real-time loop, you call Interpolate;) with che\nlength of time you want eo process, chen call GetValue (} to retrieve the current inter-\npolated valuc. Interpolate returns TAVE when the specified time has expired and you\nare at the desired target point.\n\nFrame-Rate-Independent Ease-in and Ease-Out\nsaa ee\n\nNow were getting co the point where a lire more background in physics comes in\nhandy: In order to produce a proper ease-in and ease-out, we need to begin with a zero\nvelocity, speed up ara constant acceleration ro same maximum velocity at the halfway\npoint, then slow back down to be ar a zero velocity as we arrive at the destinarion\npoint. This process is shown in Figure 2.1.4,\n\n21\n\nInterpolation Methods 145\n\nfoenb=\n\nherntions\nFIGURE 2.1.3. Linear interpolacion,\n\nThe first step is to calculase che acceleration required. The acceleration is simply\ninverted for the second half of the wip. Any physics rext should give you the necessary\nmath, shown in Equation 2.1.6. We need to solve this equation for acceleration. We\nWA tO Start at zero velocicy, with x representing the average of the start and end\npoints rather than the final destination, which gives Equation 2.1.7.\n\nex tug toa (2.1.6)\n\nc= 2258! (2.1.7)\nt\n\nnce the acceleration is known, you need to apply chat acceleration to cach\nframe. This method is similar to the way it was done in the linear interpolation in that\nyou must take the time per frame inno account. To start, che velocity is zero. At each\nframe, it is determined whether you are in the first or second half of the trip so you\nknow whether co accelerate or decelerace. The velocity is incremenred or decremented\nby some amount using Equation 2.1.8, then the velocity is applied co the PAPSItiom, as\nshawn in Equation 2.1.5, the same as in che lincar interpolation version buc with a\nvelocity that changes each frame. This velocity should be very near zero by the time\nyou expect to be ar the destination point, but it might not be an exact match due ro\nroundoff errors,\n\nv=p tat (2.1.8)\n\nSection 2 Mathematics\n\nAcca\n\nerations\nFIGURE 2.1.4. Fsse-tn and ease-out,\n\nThe final sample C++ class for chis article is in Listing 2.1.4 and is one thar can be\nused for case-in and ease-our interpolation, named CEaseInOut Interpolation. The\ninterface is identical to che linear interpolation clas, which makes it convenient to\nswap one out for the other when testing. You call Setup() when you are beginning an\ninterpolation, passing in che starting and ending values and how long you want it to\ntake to gee there. With each pass through your real-time loop, you call Interpolate(}\nwith the length of time you want to process, then call GetValue()} to retrieve the cur-\nrent interpolated valuc.\n\nDanger Zone\n\nThere are some things that you need to be very careful with as you apply interpolarion\nin various portions of your software. Angles are problematic, since the naive version of\nthe algorithm would tell you that the angle halfway benween an angle of 1°and 359°\ni 180°, when the proper answer might be 0°, depending on how you wane the inter-\npolation to behave. You need to be careful to assure that your numbers are in the\nproper ranges before interpolating angles, quaternions, or any values for which chere\nare multiple ways to show the same value.\n\nFurthermore, when referring to the sample code, you will likely want to take che\nideas shown in the code and optimize them to meet your specific needs rather than\n\nuse the code as it is,\n\n2.1 Interpolation Methods 147\n\nListing 2.1.1: CEaseOutDividelnterpolation\n\nDefinition\n$$\n\nclass CEaseQutDividelnterpolation : CEasedutShittintarpolation\n\n{\npoblic-\nbool Setup(float from, fleat to, float divisor)\n\nif(diviser <= oO)\n\n{\n}\n\n_Walue = from:\ntarget = tor\ndivisor = divisor;\nreturn trues;\n\nreturn false;\n\n}\nbool Interpolate() // Note: Not time dependent.\ni\nTicat oldVvalue = value;\nif(_divisor > 0)\ni\nValue = (value * {_diviser-1,.0T) +\n_target)/ divisor;\n}\nff Not likely to be true very often.\nreturn (_valué -= gldvalue};\n}\nTloat GetValue}\n{\nreturn value;\n}\nprivate:\n\nfloat value;\nficat _target:\nTioat divisor:\n\nListing 2.1.2: CEaseOutShiftinterpolation\n\nDefinition\nSs\nclass CEasefutShiftInterpolation\n{\npublic:\nbool Setup(int from, int te, int shitt)\n\nif(shitt <= 0)\n{\n\n}\n\n_value = from;\ntarget = to;\nshift = shift;\n\nreturn false;\n\n146. Section? Mathematica\n\nreturn true;\n\n}\nbol Interpolate() J / Mote: Hot time dependant.\n{\nint oldVvalue = value;\nif({_shift > 0)\n{\nvalue = (_Valuea = ((1 =< shift} = 1) +\ntarget) => shift:\n}\nff lots more likely to ba tru than with float version.\nreturn {value == oldValue);\n}\nint GetValue(}\n{\nreturn value:\n}\nprivate:\n\nint value;\nInt target;\nint shift;\n\nListing 2.1.3: CLinearinterpolation Definition\n\nclass ClinéariInterpolation\n\ni\npublic:\nbool Setup(tloat from, float to, float tise]\n{\nif(ting = 0)\n{\nreturn false:\n}\n_fenainingTime = tine:\n_value = from:\nStep = (to-from}/tine; // Calculate distance per second.\nPreturn true;\n}\nHf Agtuen TRUE when the target has been reached or passed.\nbool Interpolata(float deltaTime)\n{\n_emainingTine -= deltaTine;:\n_valug += _steptdeltaTing;\nreturn (_remainingTime <= o};\nI\nfloat GetValuel}\n{\nreturn value;\n}\nprivate:\n\nfloat walue;\nfloat step;\nfloat _remainingTine;\n\n2.1 Interpolation Methods 149\n\nListing 2.1.4: CEaseinOutinterpolation Definition\ncs\n\nClaas CEaselingutinterpolation\n\n{\npublic:\nbool Setup(tloaat fron, float to, float tine)\n{\nif(time <= oO}\n{\nreturn false;\n}\nvalue = from;\n_target = to;\n_apeed = 0.04;\nff derived fren w=x0 + wot = a'¢eq/o\nacceleration = (to-from)/(tine*tima/4):\n_remainingTime = totelTime = tine;\nreturn true;\n}\nbool Interpolate(fleat deltaTime)\n{\n_remainingTime -= deltatine;\n1T(_remainingling < _totalTiae/z)\n{\nfi Deéeleration\nSpeed «= acceleration * deltaTime;:\n|\nalse\nff Acceleration\nSpeed += acceleration \" deltaTime;\n}\nValue 4 _speod*deltatine;\nreturn (_PémainingTime <= oO);\n}\nfloat GatValue[)\n{\nreturn value;\n}\nprivate:\nfioat value:\n\nTloat target;\n\nTloat _remniningTime;:\nTlaat totalTime:\nTloat speed;\n\nTioat acceleration:\n\n2.2\n\nIntegrating the Equations of\nRigid Body Motion\n\nMiguel Gomez\n\nThis article is intended as a nutorial on the theory and practice of simulating rigid\nbody motion. The Newton-Euler equations of motion are derived, and some simple\nnumerical integration methods are given. The reader is assumed to have caken col-\nlege-level introductory courses in classical mechanics, linear algebra, calculus, vector\nanalysis, and differential equation theory.\n\nKinematics: Translation and Rotation\n\n150\n\nIn order to derive che differential cquations that describe the motion of a rigid body,\nwe need to lay some groundwork. First off, let's give ourselves a fixed coondinare frame\nwith respect to which all our dynamic variables can be specified. By a fixed coordinate\nframe, we mean three linearly independent veetors (the basis) and a reference position\n(the origin) that is nor translating or rotating (an inertial frame). Let's be easy on our-\nselves and use mutually orthogonal unit vectors for our basis (an orthonormal basis).\nWe call this fixed frame the world frame, ar world space. Any point in space can be\nspecified with respect to this coordinate frame by three numbers, as shown in Figure\n22.1.\n\nAn independent piece of mantez the volume of which is negligible is called a par-\nfacie. When the volume of a piece of matter becomes significant, it is called a dudy.\nThe amount of matter in a particle or a body is its mass, and the amount of mass per\nunit volume is its density. In general, a body can have any shape and even deform aver\nume. If the matter inside a body is distributed unevenly, it has mom-wnifarne density.\nNo marrer how a body's mass is distributed, at any instane in time there is a point in\nspace that is the center of wna of the body, r_. The position af the center of mass is\ncalculared with a weighted sum of every mass element, m,, in the body:\n\not oh ¥ cm,\n\n> m M\n\na\n\n2.2 Integrating the Equations of Rigid Body Motien 151\n\nx\nFIGURE 2.2.1. The vector © extends from che oripin, ©), no the poine P.\nWhen mass is continuously disribured chroughour its volume, this sum becomes\nthe integral:\nJrpwiav  [rp@)av\n\nIn this case, cach mass element is caleulated by multiplying a volume element 4”\nby a three-dimensional density function py)\n\nm, = pra.\n\nIt is helpful to associate a focal coordinate frame with a body, For our purposes,\nthe best choice for the origin is r_.. which we can take to mean the position of the\nbody. Qurormhonormal basis R = {R°, R', R*) corresponds to the local X, Yand 2 axes\nof the body (Figure 2.2.2).\n\nXx\nFIGURE 2.2.2. The vectors R°, R!, Ro define the x, y, and 2 aves of the local body frame.\n\nSection 2 Mathematics\n\nIr is also convenient co think of R®, R!, and Re? as the colurans of a matrix R, oo\nthac:\n\nsts\nR=|R RR\nRene,\n\nThis makes it easy to transform a vector from a body's local space to world space, and\nWOE VETS:\nView = Ry and vi = Riva {since R’ = RO for an\northonormal basis)\nTransforming a poinc is just as easy:\nKerid = Rist + fim AMI Niner = PY (erie — oe)\nIf at time # a body's position is r,, and at time #, its position is r, (Figure 2.2.3),\n\nthen its aecnge eeloctty between # and % was:\n\nhor Ac\nv_=——=—.\nfF Ar\nAs we sample che crajectory at smaller and smaller time intervals, we approximate:\nthe Jnsantancous velocity of the particle, which is the true velocity of the particle at\nany time, f, and is equal to the derivative of its position with respect to time:\n\noo Ar\nv=ln—=—.\nare Ar dt\n\nSimilarly, if its velocity changes from one instant to another, it is said to be accel-\nerating, given by:\n\nIn addition to translation, a body can undergo rotation, The amount of rotation\nthe body experiences per unit time is called its angular velocity (also called rotational\npelocitp), piven by:\n\ni a]\nlim — = @,\nfra Ag\n\nwhere dO is a very small rotation (in radians) and @ is the angular velociry about che\ncenter of mass\n\n22 Integrating the Equations of Rigid Body Motion 163\n\nx\nFIGURE 2.2.3. A body moves from rf, toe) over a time Ar= 6-4.\n\nRepresenting a finite rotation with a vector is kind of a cheat, Strictly speaking,\nfinite rotations, no matter how small, cannot be considered vectors because they are\nnot commataer. This means that if a body were rotated abour the first axis by the\nfirst angle, then rotated abour the second axis by the second angle, it would nor neces-\nsarily achieve the same orientation as if the operations had been reversed. On the\nother hand, infinctesmal rotations (if you believe in them) are not order dependent,\nso they can be considered vectors. This is why angular velocity can be choughe of as a\nvector [(Chow5).\n\nIfa vector r is rotating ata constant angular velociry, then its time derivative with\nrespect to the feed world frame is:\n\nIfthe length of r is mar changing, chen the derivative simplifies to:\n\nar\n\n—= 0x r.\n\nalt\n\nUsing this relationship, the time derivacive of Ris:\nGu\ndt\n\nwhere the antisymmoecric matrix:\n\n=aR,\n\n0 -a, a,\no=|o, 0 -w,\n—O ge | 0",
      "page_number": 140,
      "chapter_number": 16,
      "summary": "This chapter covers segment 16 (pages 140-149). Key topics include interpolation, interpolate, and interpolated. With the integér-based code, this will likely happen before you actually\nreach the desired target.",
      "keywords": [
        "Body",
        "time",
        "velocity",
        "frame",
        "interpolation",
        "Linear Interpolation",
        "Equation",
        "Rigid Body",
        "Rigid Body Motion",
        "float",
        "che",
        "call Interpelate",
        "acceleration",
        "target",
        "Interpolation Methods"
      ],
      "concepts": [
        "interpolation",
        "interpolate",
        "interpolated",
        "values",
        "time",
        "frame",
        "returns",
        "float",
        "velocity",
        "rotation"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 8",
          "chapter": 18,
          "title": "Segment 18 (pages 172-180)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 33,
          "title": "Segment 33 (pages 652-672)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 22,
          "title": "Segment 22 (pages 207-219)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 12,
          "title": "Segment 12 (pages 113-120)",
          "relevance_score": 0.46,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 16,
          "title": "Segment 16 (pages 148-160)",
          "relevance_score": 0.46,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 17,
      "title": "Segment 17 (pages 150-158)",
      "start_page": 150,
      "end_page": 158,
      "detection_method": "topic_boundary",
      "content": "154 Section 2 Mathematics\ntakes the place of the cross product [Baraff)7a].\n\nDynamics: Forces and Torques\n\nNewton's first law of motion states that a body remains stationary or maintains a con-\nstant velocity unless acted on by an external force. This is also known as the law of\nconservation of fincar momentum, The linear momentum vector, p, of a body is cal-\nculated by multiplying irs velacicy, v, by its mass, se:\n\np> #F¥.\n\nThe rate of change of momennum with TeSPece te time is equal co che sum of all\nthe forces (the mer force) on this bevel:\n\n= in eae\nF.. me F, FF me er ma\n\nWhen a body is moving relative to a point of reference and its motion is not\ndirectly coward or away from thar point, it is said to have angular mortennint with\nrespect to thar point. The angular momentum vecwor, L, is defined as the cross prod-\nuct of the position vector rand the linear momentum vector p. The vecsor L is there-\nfore orthogonal to both rand p (see Figure 2.2.4).\n\nWhen a force acts to change angular momentum, it is said to cause a tongue. The\ntime derivative of the angular momentum is equal to the net torque on the body:\n\nL=rxp\n\nx\n\nFIGURE 2.2.4. Angular momencum, L, is orthogonal to both rand P-\n\n2.2 Integrating the Equations of Rigid Body Motion 155\n\nSpecial Properties of Rigid Bodies\n\nIf every element of mamer in a beady is unable co cranslate or rotate with respect to\nevery other element of macter within that body, this object is called (oddly enough) a\nriga éody. (True rignd bodies don't exist in nature; every body, no marrer how stiff,\ndeforms somewhat when disturbed or when rotating. Deformation rediscribures mass\nand changes the inertia tensor, complicating motion even further.)\n\nRigid bodies have a couple properties thar make their motion easier te deal with,\none of which is that cheir center of mass is fixed. When a gid body is rotating, every\nlinde piece of mass, mi, within it has angular momentum with respect wo the center of\nmass, r.. The body's coral angular momencum {in world space) about its center of\nmass is the sum of all chese infinitesimal parts:\n\nie vs p=) 5 x (my)\n\nwhere r; (also in world space) is the vector from r,, to m7. Since the velocity of nm; is\n\ngiven by:\n¥, 2a x 4,\nWe Can write:\n\nee ¥ or, x(oxr)= -¥ mr, * (rx wo) = —¥ mora,\n\nwhere\nto Fy\ni S| 0 7\n—F Fr 0\n\nSubstituting and multiplying through gives:\n\n* q\nAn, i +r ) Sh My TT\non 2 I\nL.. = ¥ TT le mt Ue + ri, TN le\n2 i\n=F MTFs i (r + r)\n\nDime; +m) S-mzrs, as\n= » hit. T yy mi (rs, +) ¥ —my,7, .\n>» FTF, Fe, ¥ SHIFT 3m, ir — 5)\n\n‘This symmetric matrix of sums is called the svertia tener, 1, where:\n\nSection 2 WMathamatles\n\nat Le\nfend ote\ni pee\n\nThe diagonal elements are called the moments of inertia, and the off-diagonal ele-\nments are called the preduct af inertia. For rigid bodies with continuously distabuted\nmass, the sums can be converted to the integrals:\n\nI, = lim Smibg +12) = | 3 +P )pwdv,\nmpl\n\n1, = lim} -mz,7, =—[nr,podv,\na mel x ul 1 =P\n\nand so on. The angular momentum about the center of mass can now be given in\nterms of the inertia tensor:\n\nL._ = Ia.\n\nThe fact that to this point, the vector ¢ has been specitied with respect to world\ncoordinares implies chat the inertia tensor depends on the body's orientation and must\nbe recalculated every time the body rotates. However, we can avoid having to reevalu-\nate the invegrals after every rotation by aiagomalizing the inertia tensor. Diagonalization\nof a matrix involves changing to a basis in which all the off-diagonal elements become\nzero, This basis is unique and consists of the eigensectors of the matrix. The diagonal\nelements with respect to this basis are called the eigenmalues of the matrix,\n\nIn general, the eigenvalues and eigenvectors of a mawrix are not necessarily unique\nor even real. Fortunately, the eigenvalues and eigenvectors of a symmetric matrix are\nalways real and mutually orthogonal [Lang87]. The normalized cigenvectors of the\ninertia censor are called the principal axe of the rigid body, and the eigenvalues are\ncalled the principal momenss of inertia. With respect to a body's principal axes, the\n\ninertia tener reduces Tor\n\ni. o--0\nI =|0 vee ot\no oOo f\n\nand the integrals simplify to:\nTae = [Jf > + eG ys zhdedneds\nf= if (x? + 2\")plx, y, zldedydz\nTa, = [ff G2 + yee, », hdd\n\n2-2 Integrating the Equations of Rigid Body Motion : 157\n\nwhere x, ¥ and 2 are in the body's local frame. For rigid bodies, these integrals need to\nbe calculated only once, and the inertia tensor in world space is given by:\n1=RI,R* [Baraff97al.\n\nThe inverse of 1 is simply:\n\n-1 _ ln\nI =RI,R,\nwhere:\ndeers\nAes\nI = peg\nfe\nWe hee\nf\n\nIris often accurate enough to approximare the principal moments of inertia for a\nrigid body with those of a rectangular box of constant density, Luckily, the principal\naxes of a box are parallel to its edges, so the principal moments of inertia turn our to\n\nbee:\n\nf\n\nMe M 2 Moos\n= = To +di)f,. = 7p te +a°), and J = ia: +7),\nwhere @,. 4, and d, are the bax dimensions in x, y, and z, respectively [Baraff7a]. For\namore complete discussion on calculating ineria tensors of irregularly shaped bodies,\nsec [Mirtich 6].\n\nIn order to calculate the rotational motion of a rigid body, we need to know how\nangular velocity changes with respect co time. Ditterentiating the original relationship\nof angular velocity and angular momencum, we get:\n\nd. a al ao dia\nNL. = — = — (ia) = —w+lI— = I i—.,\n=e =, la) Pik ae a x (le) + 5 [Baraf97b]\nwhich ultimately gives:\n@ -1[n,,- ox 0a)\nar\n\nWe can now stare the differential equations thar describe the translational and\nrotational motion of a rigid body. The translational motion of the center of mass fol-\nlows the relarionships:\n\n158. Section? Mathematics\n\nar\nee\nat\nareal\nar it ard\nand the rotational motion is described by-\nce = aR\nds\nat)\n\nFa r[n.. — x (a)\n\nTogether, these equations are known as the Newton-Fuler equations of rigid boaly\nmotion. Now that we have these equations, ler's explore some simple methods for inte-\ngrating them.\n\nIntegrating the Equations of Motion\n\nGiven an initial position, rp, the next position of the body, r,, can be approximated\nthrough che relation:\n\nar =\n= ee\n\nalt Ar\nSolving for ©, gives:\nt= ty, + vet.\nThis method, known as Euler inteenaian, is the simplest method for integrating\n\nsolutions to initial value problems. The same technique can be used co integrate che\nremaining dynamic variables:\n\nvy —'¥— te As\n\nR, =R,+a°R,Ar\n\na, =m, + rr, - wx (Lea) |e\n\nUnfortunately, integrating orientation in this way introduces error, and R must\nbe re-orthogonalized every frame. Furthermore, for high angular velocities, this inte-\n\nBradion is very inaccurate. A better way te integrate orientation is to find a rotation\n“vector” by multiplying the angular velocity by the time step:\n\n22 Integrating the Equations of Rigid Body Motion 155\n\nAG = a,Ar\nThe angle through which co rotate the basis is:\na= |Ad,\nand the axis abour which to rotate the basis is:\nAg\nAs\nThe basis R. can chen be rotated by multiplying it by the matrix:\n\n5\n\n1-2y' +2\") 2xy— 2 Jez + Ly\nM, =| 2y+2m 1=2x' +2\") 292 =I\n2az — Dy dye t+ 2or 1 — 2x7 + 97)\n\nwhere s = cos($), and (x, y, z) = a sin($), $0 that R, = MLR, [Ware 2000).\nIf orientation is stored as a unit quaternion, q, then:\n\n4!\nar 3 4\n\nwhere @ is the pure quaternion @i + aj + ode The orientation can now be inte-\ngrated with the formula:\n\nl\nTi Peete\n\nIt ts important to normalize q after each step to prevenc “drift” in the solurion\n[Baralf97a].\n\nAlthough the Euler method is the simplest way to integrate differential equations,\nit is alse ehe least accurate and least stable. [f the angular velocity pets too high, the\nangular velocity grows exponentially to infinity. A simple hack co keep the solution\nfrom exploding is to multiply the angular velocicy by a scale factor nor much less than\n1 (maybe 0.999) every frame. This method works, bur it has the unforrunare effect of\nslowing the rotation ro a stop. For discussions of more advanced integration tech-\nniques, see [Derrick7), [Gerald99), and [Flairer?3].\n\nReferences\n\n[Baraff97a] Baraff, David, “An Introduction to Physically Based Modeling: Rigid\nBody Simulation 1—Unconstrained Rigid Body Dynamics,” available online at\nweew,.cs,cmuedu!-baralfipbm/pbm_brml, 1997.\n\nSection2 Mathematics\n\n[BarahS7b] Barat, Dravid, “An Ineroduction to Physically Based Modeling: Rigid\nBody Simulation [I—Nonpenevation Constraints,” available online at\nwow. cr.cmuedu!-baraffipbm/pbo_heml, 197.\n\n[Chee)5] Chow, Tai L., Clesiea! Mechanter, John Wiley & Sons, Inc. 1995.\n\n[Decrick®7] Derrick, William R., and Grossman, Stanley 1,4 First Cowrse in Duffer-\nential Equations with Applications, third edition, West Publishing Company,\n1987.\n\n[Gerald99] Gerald, Curtis F. and Wheatley, Patrick ©, Applied Nionerical Analysis,\nsixth edition, Addison Wesley Langman, Inc., 1999.\n\n[Hairer)3] Hairer, E., Norsest, $8. P, and Wanner, G., Solving Ordinary Differential\nEquation: [: Nonsiff Problems, second edition, Springer-Verlag, 1993.\n\n[Lang87] Lang, Serge, Linear Algeéra, third edition, Springer-Verlag, 1987-\n\n[Mirtich96) Mirtich, Brian, “Fast and Accurate Computation of Polyhedral Mass\nProperties,” Journal of Graphics Took (vol. 1, no. 2): pp. 31-50, 1996.\n\n[Warr2000) Warr, Alan, 3.0 Computer Graphic, third edition, Addison-Wesley, 2000,\n\n2.3\n\nPolynomial Approximations to\nTrigonometric Functions\n\nEddie Edwards\n\nThe way we approach specific problems changes as hardware evolves. Take, for examn-\nple, the trigonomerric finctions sine, cosine, and arctangent. It used to be thar we\nwould never even dream of calculating these on che fly; we would use a table lookup.\nUsing a table has its drawbacks—quantization errors being che main problem—Ivut it\nis very fast. Or at least, ir used to be.\n\nThese days, CPU speed seems to be increasing much faster than RAM speed.\n‘True random acces is particularly slow, since many types of RAM are optimized for\n¢ache line refills rather chan individual word accesses (RDDRAM being a case in point).\nMeanwhile, the time it rakes a CPU to do a floating-point multiply has gone down\nfrom more than 10 cycles to just 1 cycle in some archirecuures. Now that the CPL is\nso much Faster than the RAM, it makes sense to reassess our assumptions about table\nlookups. We can generally doa lot of calculation in the time it takes to access a single\nmemory location, and these calculations do not suffer from quantization errors to\nanything near the same degree. Maybe we should consider calculating values for sine\nand cosine rather than just looking them wp ina table.\n\nThis proposal raises the very interesting question, “Hew?” The ubiquitous solu-\ntion co calculating complex functions is through polynomial approximation; we find\na polynomial that approximates che function we wane. We then stuff our value of x\ninto this polynomial and out pops an approximare value for the function, Since mul-\nplies are so cheap these days, this looks like a very fast way to evaluate the function.\nIn che first part of this article, | describe in some detail how polynomial approxima-\ntions work and how co manipulate polynomials ro your own ends.\n\nThe problem of calculating che function is now transformed into the problem of\nfinding a geod polynomial to use as an approximation. This is a search for a ser of\n“magic” numbers—the polynomial coefficients—that give good results.\n\nThe best-known method for obtaining these numbers is to look at the Taylor\nseries for the function, The Yaylor series is an infinite polynomial char is equivalent to\nthe function (for some range of x). If we truncate the Taylor series, we pet a finite\n\n161\n\n162 Section? Mathematics\n\n——— ————— eS\n\npolynomial, which we assume to be a good approximation to the function. Larer in\nthis article we demonstrate how Taylor series work and discuss their limirarions.\n\nThere are alternatives to the Taylor series method char are nor so well known. The\nmain thrust of this article is to explain one technique, the Lagrange series, which has\nsome very specific advantages over the Taylor series. The Lagrange series is capable of\nentirely removing certain errors in the approximation and on average gives results that\nare Many times more accurate.\n\nPolynomials\n\nA palynomial is simply a sum of powers of a variable Gx}, cach multiplied by a coeffi\n\ncient. The stanclard way to write a polynomial is as follows:\nafO) + aff + af2) x + a(3)\"x\"x\"e + ... afaf*por(xd)\n\nThe numbers a// are called the coefficients: of the polynomial. The number ais the\ndegree of che polynomial. We can demonstrate chese elements in C++:\n\nfloat Poly::Evaluate(float =}\n\n{\nfloat powx = 1;\nfloat sim = oO:\n\nfor (int n= 0; n <= d: nt+]\n\nSum += a[n] * pown;\npom A= ee\n\n}\n\nreturn Sun;\n\n}\n\nThis is the most obvious and straightforward way to cvaluate the polynomial with\na program, although many alternative methods exist. These alternatives rely on fac-\ntorizing the polynomial in some way, I do not recommend the alternative methods,\nfor two reasons:\n\n1. Factorizing often leads to a divide per factor, which means your coefficients are\nsusceptible to rounding errors (especially in single-precision fMoating point).\n\n2. Calculating using factoring has a critical path containing all the multiplies. Calcu-\nlating the simple way has a critical path containing just onc mulriply and one add,\nso the simple method pipelines much better on CPUs where chis ix important.\nFor instance, one alternative method that requires no divides is this factorization:\nafO] + x\"(aft] + <af2} + x*a[3] ...))\n\nThis method is evaluated in C++ code like this:",
      "page_number": 150,
      "chapter_number": 17,
      "summary": "This chapter covers segment 17 (pages 150-158). Key topics include integrating, integrals, and integrate.",
      "keywords": [
        "Rigid Body Motion",
        "Rigid Body",
        "body",
        "Rigid",
        "angular",
        "angular momentum",
        "Body Motion",
        "motion",
        "Rigid Bodies",
        "Polynomial",
        "angular velocity",
        "Rigid Body Dynamics",
        "Unconstrained Rigid Body",
        "inertia",
        "Equations"
      ],
      "concepts": [
        "integrating",
        "integrals",
        "integrate",
        "integration",
        "polynomial",
        "methods",
        "body",
        "bodies",
        "motion",
        "angular"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 33,
          "title": "Segment 33 (pages 652-672)",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 16,
          "title": "Segment 16 (pages 148-160)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 55,
          "title": "Segment 55 (pages 529-536)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "Segment 33 (pages 314-325)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 34,
          "title": "Segment 34 (pages 673-695)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 18,
      "title": "Segment 18 (pages 159-166)",
      "start_page": 159,
      "end_page": 166,
      "detection_method": "topic_boundary",
      "content": "23 Polynomial Approximations to Trigonometric Functions 183\n\nfloat Poly::Evaluate(float x)\n{\nfloat sum = afd];\nfor {int a= gd — 1; n= 07 ne]\n\nSim = sum * x # ajn];\n\n}\n\nreturn SLM;\n\n}\n\nNote that each iteration multiplies against the resules of the previous iteration, sa\nthe loop cannot be broken down and pipelined. This method does have the advantage\nthat only one accumulator register is required, so it might be a good choice for che\nx86 architecture's scalar FPU.\n\nDomain and Range\n\nThe domain ofa function is the area over which it can be called. The range is the\nrange of values it returns, over its domain. You might think thar the domain of one af\nthese polynomials is infinite. Not so!\n\nWhen we look at the evaluation of the polynomial, we see it is the sum of terms\nof the form:\n\nain] “ports, m1)\n\nEach of these terms must itself be a floating-point number, so each one must be in the\nrange of a floac, which is approximately 0 to 24127 (ignoring sign, and assuming\nIEEE single-precision format).\n\nIfwe take the base-2 logarithm of this polynomial, we gel:\n\nlog 2(afn] * powtx,n)) = log2fain]) + 2 * lope) < 127\n\nwhich gives us a series of inequalities thar Jog 2(x) must obey. Quite clearly, this is not\ninfinite! For instance, if che degree of the polynomial is 10 and the value of all the\ncocflicienss is 1, we have:\n\ndog Noe) =z 12, F\n\ngiving an effective domain on x of 6000 co +6000.\n\nThe range of a function is often well known. For instanec, the range of sine is\n—1.0 to +10. The range of other functions is infinite; for instance, tangent gets larger\nand larger as its argument approaches 90 degrees.\n\nWe now come to a classic numerical accuracy problem. Suppose we want to cal-\nculate sin(6000.0) with a 10th degree polynomial.From the domain analysis, we\nknow that the floating-point terms will become very lazee—up to just under\n2*127—but we know that the final result is berween —1,0 and +1.0. The final resule\n\n164\n\nSection2 Mathematics\n\ncomes from the final sequence of additions, and since cach number added is very\nLarge, they must all jst cancel out to give the small numbers expected.\n\nUnfortunately, the single-precision floating-point format stores only 23 bits of\nprecision, which means thar for numbers as large as 24127, there is no precision at all\nin the range 0.0 no 1.0. In fact, che lowest bit has value 24104! So we can expect to\nhave errors of the order of 24100 in a value thar is of the order 1.0, which is as ood\nas saying we have no idea whar the answer is (In fact, it is like saying, “Although I\nknow my keyboard is on my desk, my calculations tell me it is acmually on a small\nplanet somewhere in the vicinity of Betelgeuse.”)\n\nTr turns out that this is nota problem for sine and cosine, since they are periadic\nfunctions, fyou need tm know sf(6000.0), you can subtract 2\"pi repeatedly uneil it is\nina better range (=pr to +7) and then apply the polynomial. A fast way co do this is\n\nat Feullonws:\n\nMultiply che value of x by 65536/2\" pt.\n\n(Cast + to an integer.\n\nShift it left 16 bics (on a 32-bir processor).\n\nShift it night 16 bits, arichmerically (to estend che sign).\n(Cast » back ro flaat.\n\nMultiply che value of x by 2*90/65536,\n\nPr a a pd\n\nThis method gives the correct value of x berween —pi and +p, with 16 bits of resalu-\ntion.\n\nYou may wane to work exclusively in the number system obtained after Step 3,\nwhere all the significant bits are art the top of a machine word. This format is a fixed-\npoint format representing the number of cums, with 32 bits of fraction and 0 bits of\ninteger, 30 if you add owo angles together you ger the expected result wichour any\nmodulus operation (in effect, the finite word length of the computer does the modu-\nlus operation for you).\n\nThis unit of measure is called a renatien, alchough in my experience every com-\npany gives the unit a difference name, chosen as the most confusing term posible!\nSince the number is che number of rotations, stored as an unsigned 32-bit fraction in\nfixed point, the name nfwtion socms to be the most suitable.\n\nIt is usually most efficient to convert between radians and rotations only when\nyou need to use radians and vo use rotations the rest of the time.\n\nChanging the Domain\n\nThe preceding example shows how we can change the units oF Our function. Far\ninstance, the sine function cakes radians, hut by pre-multiplying by 2*p2/65536, we\ncan make it cake notations as a signed 16-bit fraction (5.15, 1:0:15).\n\nWe can, in fact, change the units of our function intrinsically by changing the\npolynomial coclicicnts. Suppose we have a function that takes radians, but we want\nit to take degrees. We could juse do the following:\n\nee] Polynomial Approximations to Tigonemetric Functions 1645\n\nTisat mult = (2.0 * pa) | 360.0:\nreturn SinePoly::Evaluate(x * mult};\n\nOr we could rewrite Evaluate:\nfloat Poly: :Evaluate(float x)\n{\n\nfloat mult = (2.0 * pi) f 360.0;\nfloat powe = 1;\n\nfloat pownult = 1;\n\nfloat sum = O;\n\nfor (int n= OF; n <= d: net]\n{\nSUR += a[f] \" pows * powult;:\npow *= x;\nprMult “= mult;\nI\n}\n\nNow here’s che trick: We replace cach af) with afi} * pournult according to this\ncode, and then we can use the original code to evaluate the function with the new\nunits. So we do the following:\n\nvoid Poly: :Changelmits(float old_units, float new unite)\n{\n\nfloat mult = old_units / new_units;\n\nfloat powmult = i:\n\nfar (int mn = O; m <= ds mtt+}\n{\na[nj] *= pownult;\npommel? \"= quit;\nI\n}\n\nThis method, of course, works only if mew_ smite is not zero.\n\nBe very careful using this technique. If the new range is coo high (and 360 prob-\nably is), we get the same exponent problems we looked at in che last section. This\nmethod cannot be used to create a polynomial that directly takes signed 16-bir frac-\ntional rotation values, since the evaluation will overflow. However, it can be used ra\nchange a polynomial’s range slightly. by a factor of up to around 4.0, depending on\nthe polynormial’s degree.\n\nWe can also add am offset into the domain, but this process is much more\ninvolved. It involves substiruting the value (x + off) into the polynomial in place of x,\n\nPor instance, substimuing (x + 2) for x in the polynomial (‘J + x) gives (7 +\n(x+2)\"(x+2)), which simplifies to (7 + ¢\"x + x%x). Therefore, che value of poly atx =\nfis 10, which is the value of the old poly arx = J + 2 = 3, This replacement is tedious\nif done by hand; the methed offsetdomain() on the CD thar accompanies this book\ncan be used to do it mechanically,\n\nSection? Mathematics\n\nTf you do want to change the domain, we recommend you simply do it to x by\nhand before inveking the polynomial evaluation method. This method adds ane or\nwo cycles wo che evaluation, but it is highly robust and very easy.\n\nChanging the Range\n\nCompared with the domain, the range is casy 00 deal with, and the resulrs are just\nwhat you expect. To change the ourpur units of a polynomial, simply multiply each\ncoefficient by the factor, as follows:\n\nwoid Poly: -ChanpeQutputUnits (float old_units, float new_units)\nfloat mult = new_units | ald units;\nfor (int on = OF no ds nee}\n: a[n] \"= mult;\nI\nThis solution works, since:\nproce \"(afO) + af + af) ete +.) = mised a /0] © monde taf 1] + mnultaf2] xe\" +...\nTo offset the output, simply add the offset to aff), since:\noffer + afO} + aff fx +... = (offer + afOl) » afl] x + ...\n\nSo, you can change the range of a polynomial incrinsieally and at zero cost to the\nfinal evaluation procedure.\n\nEven and Odd Polynomials\n\nWhen you come to manipulating polynomials on che computer, you will find thar\nmany coefficients become very small—e.g., 1.546 \" 24-80. You may well ask, “Is chis\nthe comect coefficient, or should the coefficient actually be zero?” The answer ro this\nquestion comes from the analysis of even and odd polynomials.\n\nAn even function is one where:\n\nft-s) = fit)\nThat is, its graph is symmetric abour che line x = 0. An odd fimction is one where:\nfi-x) = =f)\n\nThar is, its graph is anti-symmetric. In crigonemetry, sine is an odd function, and\nCOSINE fs ain even function.\nNor all functions are cither even or odd. For instance, fy + J) is neither.\n\nfoi Polynomial Approximations to Trigenometric Functions 167\n\nA polynomial is made up of swms of che functions 1, x, x\", x%x\"x, etc. Each one\nof these basic functions is either odd or even.\n\nPele EVEN\nx=—(—x) & ODD\nxr = (xx) & EVEN\n\nas = Or) ODD\n50:\nafn i EVEN ifn i EVEN, and ODD ifn ODD\n\nIt should be reasonably clear that if 2 polynomial conrains all even powers of x,\nthe polynomial itself is even, and that if it contains all odd powers of x, the polyno-\nmial itself is odd. (This is where the terms even and eda come from in the first place.)\nIfa polynomial contains some odd powers and some even powers, it is neither even\nmor coded\n\nNow the important point: If a polynomial approximares an even function, the\npolynomial itself should be even. It's no use if your polynomial says that sin‘) does\nnot equal —sim(—), because ir does!\n\n[f you can cell by analysis that a coeficient should be zero (even if a program tells\nyou the coefficient is 1.546 * 24-80), you should set it to zero. This is the correct\nvalue, and the bogus non-zero enefficient is the result of floating-point rounding\ncmors, Leaving the incorrect value in could lead to unexpected results.\n\nThis implies that if the function is even, aj] is zero whenever m is odd; if the\nfunction is ode, an) is zero whenever nis even. IF you have a supposed polynomial\napproximation to sim(x) thar has 2/2/, mot zero, you know the approximation is\nwrong.\n\nTaylor Serles\n\nThe Taylor series has its roots in a very simple procedure we can use to copy polyno-\nmuals, which is based on the simple mathematical operations of evaluation and differ-\nentiation. We have seen evaluation already; mow we must look at differentiation.\nFortunately, differenciacion of polynomials ts quite straightforward.\n\nWhen we differentiate a polynomial, we get-\n\nafl} + af2]*2\"x + a [3] 3x + afd] axe +. + afd “a “poww(sc, =I)\n\nEach cocthicienc is multiplied by its power, and then the power is reduced by one.\nThis process can be deseribed as a method:\n\nvoid Poly: Differentiate}\n\n168 Section 2 Mathematics\n\nfor [int © = 13 mn <= dj n++)\na[fa-1] = alm) * a;\nafd) = 4;\n\nif (d > 0) d--s\n}\n\nNote that the derivative of the polynomial «/0/ (degree zero} is 0 (also degree\nzero), which explains the “special case” lines of code in the preceding example.\nLet's differentiate again, which gives:\n\naf2]*2 + af3P°3 2% + aféP FF +...\n\nEach time we differentiate, the degree of the polynomial goes down by one. Now\nlook at a/r//O! at cach stage. (Here, the first array subscript denotes che number of\ndifferentiations, starting with zero differentiations):\n\nafO/f0} = aft]\n\naf Ij{O} = aff]\naf2i[0} = 2*a{2}\nafSfo} = 3°2\"a/3}\naf4}{0} = 4°3°*2*a[4]\nafm} [0] = nf * ain]\n\nEach coefficient is rotated in curn into 2/@!, and multiplied by x.\n\nWe can obtain a/t/ from the polynomial object by calling Evaluate (0); by calling\nDitferantiate(), we can rotace cach coefficient into «/0). So, by calling both func-\ntions, we can take the polynomial apart:\n\nwoid Poly::CopyPoly(Poly* p)\n{\nfloat nfact = 1;\n\nd= 0;\na[O] = p->Evaluate(0);\np->Differentiate(};\n\nwhile (ip->Isfero())\nne\ninfact *= di;\nafd] = p->Evaluate(o) / afact;\np->Differentiate():\n}\nI\n\nIszero() ts the function that tells us if the polynomial is zero everywhere (ic.,\nEvaluate(x) = 0 for all x}:\n\n2.3 Polynomial Approximations te Trigonometric Functions 168\n\nbool Poly; iiszero{)\n\nreturn ({d == 0) && [a0] == o));\n\nThe important thing to note here is that we created the new polynomial from the\nold polynomial only through its operations IsZera(), Evaluate(), and Ditferenti-\nate().We never directly asked for cither the polynomial’s degree or for any of its cock-\nficients.\n\nThis point is interesting because in mathemarics these three operations make\nsense for a vastly wider class of objects chan just polynomials. This wider class is rech-\nnically known as infinitely differentiable functions and includes all the functions with\nwhich you are most likely to be familiar. In fact, only strange functions such as true\nfractals and the Dirac delta function (which contains an infinity at x=0) give prob\nlems in practice. The other chiss of functions thar give problems are those with\ndiscontinuities or sharp corness (which are equivalent to discontinuities in the differ-\nentidted function), but we look at some ways to deal with chese functions later.\n\nIn ebject-oriented terminology, the class Poly is itself a subclass of Dif ferantiable-\nFunction, which has virnual methods IsZero(), Evaluate(}, and Differentiatat }.\n\nThis is how Taylor series are caloulated—or racher, how the subset of Taylor series\ncalled “Taylor series expanded about x = 0” is calculated. The following function cal-\nculates Taylor series in their full glory;\n\nwold Poly: :WakeTayLlorseries(DitferentiableFunction® f, float pt}\n\ni\nfloat nfect = 1;\n\nd = 0;\na[O] = f-*Evaluate(pt);\nf--Ditterentiate(};\n\nmhile (it->Iszera())\n{\ndee;\nnfact “= d\na[d] = f->Evaluate(pt) | ntact:\nF->Differentiatal yi\n}\n\nOf fsetOomain (pt);\n}\n\nThis function calculates the series for ffx — pt) and then offsets the domain to\nmatch. You may ask why you would use valucs of pr other than 0. The answer is thar\nsome functions have no well-defined value at x = ( (e.g., Jc is not defined there), so\nwe move away from that specific poine to prevent problems with infinities.\n\n170 ; Section 2 Mathematics\n\nEzample: Sine and Cosine\n\nThe derivative of sine is eosine, and the derivative of cosine is sine, so we cam use\nfunction poinrers no define the class TrigFunction thar behaves like these nwo:\n\nGlass Trigfunction : public OitferentiableFunction\n{\npublic:\nTrigFunctiont} { fptr = sing sign = 1; }\n\nbaal [szero() { return false; }\nFloat Evaluate(tioat x) { return Sign * float(fptri(doubleqxy)); J\nFloat Bifferentiate(}\n\nif {(fptr == sin)\nfptr = c05;\n\nelse\n\n{\nfptr = sin;\nSign = -sign;\n}\n}\n\nprivate:\n\ndouble (*fptr) (double); // stdlib math function sin or cos\nFloat sign; if sign of function —1 or +1\n\nhi\n\nLinfortunarely, although the MakeTaylorSeries function accepes an object of this\nclass, it never recurs, because the derivative never becomes zero. Houston, we have a\nproblera!\n\nThere are several ways around this dilermma:\n\n1. Specify the maximum degree of the polynomial thar wakeTaylorSeries will\nreturn.\n\n2. Specify the minimum coefficient value. Since the enefficients are probably\"\ngoing to get smaller and smaller, since a! gets larger and larger, we can terminate\nthe routine once the last coefficient is tere small,\n\nThe frst way is guaranteed to work; the second way might still fail. Why? Because\nthe coefficients might mer get smaller and smaller. The mathematical analysis of this\nconcept is beyond the scope of this article, bur you can rest assured that mast functions\nyou will deal with wilf have coefficients that per smaller and smaller, Nevertheless, you\nshould always set a large limit on the degree, just in case.",
      "page_number": 159,
      "chapter_number": 18,
      "summary": "This chapter covers segment 18 (pages 159-166). Key topics include functions, function, and polynomial. Covers function. This method does have the advantage\nthat only one accumulator register is required, so it might be a good choice for che\nx86 architecture's scalar FPU.",
      "keywords": [
        "Polynomial",
        "function",
        "Functions",
        "float",
        "Evaluate",
        "Range",
        "Polynomial Approximations",
        "Poly",
        "Odd",
        "che",
        "Domain",
        "Odd Polynomials",
        "thar",
        "units",
        "return SLM"
      ],
      "concepts": [
        "functions",
        "function",
        "polynomial",
        "float",
        "evaluation",
        "evaluate",
        "sign",
        "returns",
        "differentiation",
        "differentiate"
      ],
      "similar_chapters": [
        {
          "book": "More Effective C++",
          "chapter": 13,
          "title": "Segment 13 (pages 124-132)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 18,
          "title": "Segment 18 (pages 174-181)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 27,
          "title": "Segment 27 (pages 537-558)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 18,
          "title": "Segment 18 (pages 352-373)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 19,
      "title": "Segment 19 (pages 167-175)",
      "start_page": 167,
      "end_page": 175,
      "detection_method": "topic_boundary",
      "content": "2.3 Polynomial Approximations to Trigonometric Functions afi\n\nTruncated Taylor Series\n\nThe Taylor series for sine was a polynomial of infinite degree. Which is a shame,\nbecause we can only evaluare (or even store) a polynomial of finite degree. In fact, for\na game, a small degree is quite desirable.\n\nWhen we truncate the series, an error is introduced (aver and above the usual\nHoating-point error) because the terms we ignore do make a contribution wo the final\nresult. It can be shown chat the error impresses as x increases, which is another good\nreason to limit che domain of your polynomial.\n\nYou can analyze the error mathematically, if you like, bur we won't go into the\ndetails here. The best thing to do in reality is practical experiments:\n\n1. Sample the errors in your estimate, using the double-precision sin) and cos)\nfunctions to compare. Get the average and maximum absolute errors. Asa rule of\nthumb, get the error below J /p, where p is che number of pixels diagonally across\nthe screen. For console games ar G40 480), pis around 200; for PC games ar\n1,280 x 1,024 or abore, pcan be more than | G00.\n\n2. Serup a large, slowly rotating sprite thar fills the screen. Use your sine function tw\nrotate it, Watch for artifacts such as jerkiness or expanding and shrinking in size,\nIgnore the harsh jibing of those who say, “Ooh, you can rotate a sprite!” in a sar-\nCastic tone.\n\nFor single-precision float and for a range —pi!2 to +pé!2, taking the first five coef-\nficients of sin and cos works well. This method is also quite fase on current hard-\nware—indeed, one current vector FPU chip actually implements his series on-chip in\nmicrocode. However, it is something of a pain to use this range, since it requires same\nrather tedious manipulations of the angle before the series can be used—a fact thar\nthe designers of the hardware seem co have missed,\n\nIf you extend the five-coefficient series for sine and cosine to —pi and +i, you get\nan error of around | part in 300. The unfortunate thing is that you get the following\n\nwalwes:\ncafé) = a0\nsin(pi) = 003\n\nsin(—pi) =—0.003 fobviansly, sitce site ix adel)\n\nThis problem shows up in the rotating-sprite test as a “jerk” when the angle passes\nfrom +pi to —p2. The erroris 1 part in 300, but this is doubled across the boundary, so\nthe rotation vector jumps from y = 0,003 ro y= +0.003—a jump of 0.006. Ic is cer-\ntainly noticeable at 410 x 480.\n\nWith the Taylor series, there is nothing we can do to fix this problem excepe\nincrease the degree of the polynomial. However, there is more to polynomial approx-\nimation than just the Taylor sezies,\n\n1 72 Section 2? Mathematics\n\nLagrange Series\n\nThe Lagrange series is my name for a type of approximation series derived using\nLagrange’s formula. Unlike the Taylor scries, there is not one single Lagrange series for\na given function. There is instead a whole family of series, from which we choose\nbased on which results we want co be exacely correct and which results we allow to\nwander from the correct value.\n\nFor instance, we can say that we require sin to be exactly correce for the well-\n\nknown points:\n\nsin(—pi) = 0.00000\nsin(—pil2) = — 1.00000\n\nan(O) = CLooogG\nsin(pa2) = J.00000\nsin(pi) = @.OO00R\n\nIf our approximation were exactly correct for these points, we would know that:\n\nlL. The size of the object would not grow when it wat rotated 90, 180, or 270\ndegrees. It would exacely match the original size.\n\nThe sin function would pass through © as it crossed the 360-depree boundary,\nwould therefore remain concinwous ar that point, and would cherefore exhibir no\njerkiness,\n\n[+\n\nA theorem proved by Lagrange states thar for any given V points there is a unique\n(NOJ)th degree polynomial that passes exacey chrough all che points. If we calculace\nthis polynomial, we have an approximation thar has the properties listecl.\n\nSuppose we want to find a Srh-degree polynomial for sine. We need this polyno-\nmial to be unique, so we must choose 10 points at which sine must be exacthy correct.\n‘This is unfortunate, since we want to have a spmmentical point distribution aboutx =\n0. With one point ac x = 0, we must have an odd number of points to achieve the\ngoal. If we put an extra point on one side, we couldn't guarantee that it would be\nmatched on the other side,\n\n‘To get an odd number of points, we use a 10th-degree polynomial. Fortunately,\nwe know that sine ts odd, so we know thar 2/0] = 0, so the 10th-degree polynomial\nis the same as the Sth-degree one,\n\nThere are many choices of poines (infinitely many!). so we choose points ar well-\nknown values. You could instead choose points that are evenly diseribured. The only\ncritical points are at =1 30 and +180 degrees, since chese points ensure continuity over\nthe boundary and hence mo jerkiness.\n\nNotice that by choosing points, we assume no prior knowledge of our function.\nWe dont assume, for instance, that it can be differentiated. This can be a useful fea-\nture if, for instance, we want co approximare a sampled waveform wing a polyne-\nmial—bur it cin also be a big problem, since we can miss importanc “Fearures” of the\n\n23 Polynomial Approximations to Trigonometric Functions 4173\n\nfunction graph. ‘The message here is, make sure you know whar your function looks\nlike (in other words, graph it} before you choose your data points.\n\nCalculating the Lagrange Series\n\nThe Lagrange series is obtained as a sum of polynomials—a different polynomial for\neach point.In this exposition, our daca points are x/f/, ..., xfeff, and the desired fumc-\ntion values at these points are y/O/, —, pied].\n\nFirst, consider the simple polynomials:\n\n(or — xen)\n\nEach polynomial is first degree, and there are (ae!) of them in total, The mh palyne-\nmial is zero when x = xfm/ and non-zero for all other values of x.\n\nUwe multiply all these polynomials together, we gee a polynomial of degree\n(@+1).This polynomial evaluates to zero at every data point, since one of its factors is\ngeno at that point. For instance, ic is zero at x/2) because ome of ies Factors is fe — aff).\n\nNow, if we instead multiply aif due ome of the polynomials together, we get a paly-\nnomial of degree @ that ewaluanes to zero at each dara point exveps for the one we mined\nour. This is because it does net have a factor (x —xj/nj) for che data point xf. The\nvalue at that data point is given by substituting x/r/ for x in the product polynomial;\n\ncfr] = Cefvm] — xf) (slap — xf t})._.oeen] — xcfm— 1) cfm] — xfime+ 1 ])...oefm — xfadt)\n\nThe next step is co multiply the product polynomial by y/m//c/m/, a process called\nformalization. The result is a new polynomial thar is equal to yim ac dara point x[m/\nbut is equal to 0 at every other data point. (Nore thar multiplying the polynomial by\nyim [ef] ts equivalent to changing the output unirs by chat factor, as discussed car-\nlier}\n\nThis concept gives us the bu ilding block for che Lagrange series. To gt the\nLagrange series itself, we need to generate all (@2J) of these polynomials and then add\nthem all together. Ar each data point «nj, all bur one of the polynomials evaluates to\nzero, Whereas the other one evaluates to piny. Wre have therefore conswucted a poly-\nnomial that is equal ro p/n/ at each point x/i/, as desired.\n\nPor example, suppase we have the simple three-point case:\n\nxfof=s =]\nxfij=0\nyif=2\nxf] a J\nyl2]=4\n\nThe simple polynomials are (x—x/OJ), (x —x/1)), and ( —x/2/), which are equal to (x\n+ 2), (e— 0) and fx — J). Let's look at dara point x/6/, We multiply all the simple\npolynomials except (x — x/0)/) together, which gives:\n\neee Secticn 2a Matiemnas\n\n&—O) \"(e-I=x—x\nWe evaluate this at x/@!, which gives:\nefo} =—J*y_—(¢rj=2\n\nWe want 7/0/ to be 4, so we multiply this polynomial by 4/2 «= 2 (changing che\nOutput units), piving:\n\neee —\nNow we inser x/0/), <fI}. and xf2/ to check chis our:\n\nxfOf = —7 22-1) 7-1) — 24) = 4\nafif-022°00-20=0\nxf2f—e F22°F2 —271=0\n\nSo we do indeed have zero at all the data points except the first, where the value ts 4,\nas expected.\n\nCompleting the work for the other ewo points gives the following polynomials\nfor cach dara point:\n\nxO): 2°\" — 2%\nxfi]:2— 2x\"\napap: 2 ee 2%\n\nYou can check thar each polynomial is equal to y/n/ at its own dara paint, and zero at\nthe others.\nFinally, we add these three polynomials together, which gives:\n\nxy a De 2 Pee et Pe a oe et 2\n\nYou can quickly check that this polynomial matches the dara at every point\n\nThe member function YakeaLagrangeseries() on the CD char accompanies this\nbeok does the hard work, so you don't have to. [t can be very tedious constructing a\nShearer Lagrange series by hand!\n\nNote that there are errors in the results from WakeLagrangeSeries( )—normal floar-\ning-point errors, as you would expect. The calculations are very complex and they iter-\nate, so errors build up. If you are making a Lagrange series that must be cither even of\nodd, make sure you ignore the values of any odd or even cocfhcients that have to be\nzero. You can do this by calling the member functions ForceOdd() or Forcefven().\n\nComparison with Taylor Serles\n\nFor a 9th-order sine and 10ch-order cosine, we have already seen che continuicy prob-\nlem at the 360-degree boundary. The Lagrange series does not have chis problem. In\ngeneral, the Lagrange series gives you much finer control over the fearures of your\napproximation, such as continuity and specific values that must be correct.\n\n2.4 Polynemial Approximations to Triganometric Functions 175\n\nThe program on the CD (main.cpp) does 2 comparison of average and maximum\nabsolute errors over the range —pi to +pi. The difference is quite pronounced. The\nTaylor series exhibits a maximum error of 1 part in 150, with an average error of 1\nparc in 1,500. Compare thac with the Lagrange series, which has a maximum error af\n1 part in 11,000 and an average erpor of only 1 pare in 77000. (Note thar these errors\nwere measured in double-precision eating point.)\n\nThe Taylor series is an exact march for a function, provided you take infinitely\nmany terms. [he Lagrange series is intrinsically limited by the number of data points\ntaken. This fact seems ro imply thar the Taylor series is the better approximation, but\nthese data prove otherwise. In this case, the Lagrange series has a steiner error one-\nseventh the size of the Taylor series’ avensge error!\n\nA Note on Humbera\n\nWhen you are dealing with exact numbers in floating-poinr norarion, the output of\nprintf() quite often doesn't cut i; it only prints a few decimal places, and floating.\npeint numbers are noc decimal-based (which means that a decimal rendition is at best\nan approximation vo the floaring-poinc value). In the Print(} member fanction of the\nPoly class, you can print our the coefficients as hexadecimal values. ‘This enpures thar,\nwhen you move the numbers into your own code, chey are exactly what they were\norginally. Ir can be somewhat painful to do this in C++, bur one trick involving\nunions in Print() can be used the other way around to get the floating-point num-\nbers from the hexadecimal form,\n\nNore also thar to get the best out of this code, you should define the Number class\nto be double, even if you are going to use single precision in your game, You can sim-\nply convert to float when you print the coefficienes.\n\nDealing with Discontinulties\n\nDiscontinuitics arise in practice fairly often, and neither Taylor nor Lagrange series\nhandle them very well. Polynomials are always smooth, eo the discontinuities become\nsmoothed our, which may not be desirable. Fortunately, it is usually quire easy to\nwork around these problems.\n\n©ne familiar discontinuous function is the tangent function. Ar +/— 90 degrees,\nthe tangent function pecs to infinicy and chen jumps to negative infinicy. This dis-\ncontinuity can be dealt with in owo fundamental ways. First, you can simply calculate\ntangent as sine divided by cosine. This method avoids the problem entirely (as long as\nyou do a divide-by-zero check!). Second, you can restrict the range of your tangent\nfunction to be just the range over which it is continuous—Le., from —90 to +90\ndegrees. Por the Lagrange series, chis means taking points only from inside chis range.\n\nIfyou have a function that has a step-like discontinuity, you can often remave the\ndiscontinuity by subtracting a step function. This gives a continuous function, which\nean be approximated using Taylor or Lagrange methods. You then add the step func-\n\nSection 2 Mathematics\n\ntien back in to get back to the original function. If instead your function has a sharp\npeak, it will be smoothed out by the polnomial, bur you can often subtract a trian-\ngular function before approximating, to again yield a smooth function.\n\nThese heuristics are all based on simple adjustments of the basic algorithm vo deal\nwith special cases. This is an area in which you can exercise your creativicy to deal with\nwhatever comes your way.\n\nConclusion\n\nIn this article, we have taken a quick tour of some quite basic mathematics and\nseen some very important results. We have seen how polynomials can be manipulated\nin various ways and how they can be copied without direct access to the coefficients.\nFrom these methods, we discovered Taylor series. We then found Taylor series to be\nsomewhat inadequate for many applications and saw a powerful alternative in\nLagrange series.\n\nNeither the Taylor series mor the Lagrange series are all chings ta all people, If you\nuse these numerical recipes in your own code, I urge you to do the experiments and\nlook at the results. Make sure your code always works as you expect, and watch out for\ndiscontinuities in the original function.\n\nWith that caveat, you now have che machinery to approximate a wide range of\nfunctions. Use it wisely!\n\n2.4\n\nUsing Implicit Euler\nIntegration for Numerical\nStability\n\nMiquel Gomez\n\nChoosing a method of integrating initial value problems is an important patt of writ-\ning an interactive application. Due to its case of implemencarion, explicit Euler inte-\ngration seems co be the integration method of choice. Unfortunately, this method\nsuffers from the problem of fstabrlizy in which errors build exponentially and che\nsolution quickly becomes infinite. This article describes the feplicit Euler method, an\nefficient and highly stable integrator. Two examples are used to illustrate this tech-\nnique: exponential decay and the damped spring equation, Finally, difficulties in\nderiving implicit solutions are discussed. We assume the reader is familiar with calcu-\nlus, classical mechanics, and differential equation theory.\n\nIntegrating Initial Value Problems and Stability\na a al at tL tl\n\nInitial value problems are simply differential equations with initial conditions. For\nsome equations, an analytic solution can be found and used to calculate the trajectory\nof a body. In most cases, however, no analytic form exists, and the solution must be\nintegrated numerically,\n\nThete are many different approaches tm numerical integration, and the method of\nchoice depends on the requirement of the application. In some systems and under\ncertun conditions, errors in the solution propagate exponentially and the solution\napproaches infinity. This situation is called imbilim and the method of integration\nis said co have become wareette under these conditions. For example, you might\nmodel the suspension system of a car as damped springs attached to a rigid body. If\nthe springs are made too stiff for the time step, the integrated solution becomes unsta-\nble and quickly heeomes infinite.\n\nOne way to improve stability is co subdivide the time step. A better way wo\nimprove stability isto use a Runge-Kutca method, or something similar, without sub-\ndividing the time step; however, even these methods become unstable ar some point.\n\niff\n\n176 Section 2 Mathematics\nThis is why we seck a simple, efficient method that guarantees stability regardless of\n\nthe equation paramecess or the time-step size,\n\nThe Explicit Euler Method\nAs a first example, let's take che initial value problem:\n\nar\nThe analytic solution is:\n\nxz] = xf\"\n\nEvaluating the exponential function for every dara poinc is simple and exact, buc it\nis extremely imeflicient. Most CPUs take about 30 cycles ro evaluate elementary func-\ntions in hardware. If the CPU must emulate this process in software, you're out of luck!\n\nFortunately, there are more efficient ways to evaluate the solution. We can use a\nfinite difference approximation of the first derivacive:\n\nCees! el\nae ge\n\nwhere x, is the solution after a time step Az. Solving for x, we get:\nax\n\nxy = on aa igh Ar.\nait\n\nWhe derivative is evaluated atx, we get:\nx, = xy — Axpdit = x, (1 — Ar),\n\nThis approach is known as the explicit Euler integration methed. With only one\nsubtraction and two multiplies, even a fixed-point processor could handle this method.\n\nAlthough the explicit Euler method is very efficient, it is nor very stable. We can\ndemonstrate this instability wich the following argument: Since che solution is an\nexponential function, it must decay to zero over time, implying thar\n\nx, 3S %,-\nSubstituting and solving gives the relationship:\nbar S 2.\n\nSo if f= 1 and Ar=2, then x, =—x,, and the solution is stable, although not very accu-\nrate. If this condition is not met, x quickly becomes infinite, and the object whose\n\n24 Using Implicit Euler Integration for Numerical Stability 178\n\nmotion youre simulating disappears. As mentioned, the Euler method can be made\nmore stable by simply decreasing che ime step, requiring the calculation of more data\npoints. Flowever, if & is made too large, subdivision of the time step may become pro-\nhibitively expensive.\n\nThe Implicit Euler Method\n\nThe method deseribed is an explicit method because it relics solely on previous values\nof the solution to caloulare the derivative. The implicic Euler method, on the other\nhand, evaluates the derivarive ar x; instead of x, (Figure 2.4.1), giving:\n\n= Xp & (be, Ar.\nSolving for x; gives:\n= Sept\n(1 + 4Az)\nSubstituting this into ghe stability condition pives:\nOs br\n\nsaa\n\n‘This is significanr. We've found a simple, efficient method chat is stable, no mat-\nter how large & or Ag get! [Hainer]\n\n(a) (b)\n\nxy HY\n\nng +o\n\nFIGURE 2.4.1. The explicit Euler method evaluaces che derivative at x (a), whereas the\nimplicit Euler method evaluates the derivative ar x, (bh).\n\nLet's look ata more complicated example. Imagine a mass mm is artached to a fixed\nanchor by a spring char gives & Newtons per meter push or pull when the mast ix not\nat its equilibrium position. Let's also assume there is some force thar is negatively pro-\nportional to its velocity by some constant 6, causing the system to lose energy. If we\nset the equilibrium position to be at the origin (x,, = 0), then the differencial equation\nthat describes this motion is:\n\ndx oer fe;\nae ar\n\noi",
      "page_number": 167,
      "chapter_number": 19,
      "summary": "This chapter covers segment 19 (pages 167-175). Key topics include points, functions, and function. Sample the errors in your estimate, using the double-precision sin) and cos)\nfunctions to compare.",
      "keywords": [
        "Lagrange Series",
        "Truncated Taylor Series",
        "Taylor Series",
        "afi Truncated Taylor",
        "Series",
        "Functions afi Truncated",
        "Lagrange",
        "Euler method",
        "Polynomial",
        "points",
        "function",
        "Taylor",
        "method",
        "Truncated Taylor",
        "Explicit Euler Method"
      ],
      "concepts": [
        "points",
        "functions",
        "function",
        "polynomial",
        "error",
        "gives",
        "giving",
        "method",
        "series",
        "degree"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 19,
          "title": "Segment 19 (pages 182-189)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 18,
          "title": "Segment 18 (pages 174-181)",
          "relevance_score": 0.45,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 16,
          "title": "Segment 16 (pages 148-160)",
          "relevance_score": 0.36,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 19,
          "title": "Segment 19 (pages 173-181)",
          "relevance_score": 0.31,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 20,
      "title": "Segment 20 (pages 176-183)",
      "start_page": 176,
      "end_page": 183,
      "detection_method": "topic_boundary",
      "content": "Section 2 Mathematics\n\nsubject co che inicial conditions:\n\nx{0) = x,,\nx(0) = o(0} =o.\n\nSolving for the second derivative, we get:\n\nae = =f)\" x — sa ae bs\nar® at 2a\n\nwhere we've subsrinured @ = (£ and A= ay for simplicity. IF the condition oF >\nAC is met, the solution is: \\\n\nxe) = xye * cos{ eae] [Chow].\n\nThis second-order differential equation can be rewritten as a system of cwo firse-\nonder differential equations, giving:\n\n= 7\n\n= -w'x — Ay,\n\na. | & |B\n\nEvaluating the derivatives at x, and 2, pives:\nx, = Xp) + 0,4,\nVv, = vy — Ox, = Ay,.\nFinally, solving for », gives:\n2, = — eo\" gle\n; 1+AAr+ (core)\n\nwhich is stable for all positive values of & 4, and Az (see Figure 2.4.2).\n\nKi od PR uy\n———\n\nFIGURE 2.4.2. A mass mis attached vo a spring with a constant. The damping is negatively\nproportional to velociry,\n\n24 Using Implicht Eulor Integration for Numerical Stability 181\n\nInaccuracy\n\nThe implicit Euler method is noc as accurare as its explicit counterpart. Even without\ndamping, the solution slowly loses all irs energy. In most applications, we are more\nconcemed with the effect than its accuracy, so this is usually net a problem, bur it is\nsomething to keep in mined,\n\nFinding Implicit Solutions\n\nFinding an implicit evaluator for x, ix not always easy. For instance, if the spring force\nis proportional to x, instead of x, we get a quadratic relationship for x). For systems in\nwhich it is impossible to solve for x,, numerical root finding such as Newton's method\nmay be required [(Gerald99]. Such cases make an implicic integraror impractical for\nreal-time applications.\n\nConclusion\n\nThe implicit Euler method is definitely something to keep in mind when stability\nbecomes an issue. There are many other types of implicit methods that could suit dif-\nferent meeds. For a more in-depth discussions, see [Gerald99], [Hairer96], and\n[Hairer93}.\n\nReferences\n\n[Chow95] Chow, Tai L., Clauiea! Mechorics, John Wiley & Sons, Inc., 1995.\n[Denick§7] Derrick, William R., and Grossman, Stanley L, Fire Conese i Difer-\nential Equations with Applications, third edition, West Publishing Co., 1987-\n[Gerald99)] Gerald, Curtis FE, and Wheatley, Patrick ©, Applied Numerical! Arsalysis,\nsixth edition, Addison Wesley Longman, Inc., 1999.\n\n[Hairer93) Hatrer, E., Norsett, 5. B, and Wanner, G., Solving Ordinary Differential\nEquations [: Nonstiff Probleme, second edition, Springer-Verlag, 1993.\n\n[Hairer96)] Hairer, E., and Wanner, G., Solving Ordinary Differential Equations LH:\nSaif and Differential-Algebraic Problems, second edition, Springer-Verlag, 1996.\n\n2.5\n\nWavelets: Theory and\nCompression\n\nLoic Le Chevalier\n\nWe generally associate wavelets with a compression method. But the word suveders\ncovers atonce a mathematical cheory, a compresion method, and a data analysis cool.\nThis is a powerful paradigm that has many applications.\n\nThe Principle\n\nWhatever the wavelet application (compression, analysis, etc.), the point of departure\nis a group of M values: scalar or vector. From these NV values, we build a cree such as\nthe one shown in Figure 2.5.1, At each level of the cree, we calculate che average of\ntwo values, which becomes the value of the next level, The tree obtained is a binary\nmee with N{N+ 12 nodes, corresponding to the respective averages. One built, this\ntree cam be used to factor che initial values. Nore thar factoring is noe compressing.\nFactoring enables us co keep all the information in reduced form, whereas compres-\nsion causes a loss of information, The basic principle of wavelets is thus a reversible\nprinciple: At any time, we can go back ro the initial values without losing informa:\ntion.\n\nTo the tree that we've built, we add new values on the branches correspondi ng to\nthe difference berween the two extremities of the branch—i.e., che distances that sep\narate two values, linked by one branch and differing by one level. As shown in Figure\n2.5.2, the magnitudes leaving from a rede are opposite, because the average value is\nequidistanc from the two values, (For cxample, the average of 2 and 8 is 5, which is at\na distance of —3 from 2 and of 43 from 8.)\n\nFor the moment, there is no factoring. On the contrary, the scructure has grown\nfrom one vector of NV values co a cree of AYfNe 22 walues for che nodes, plus\n(N+ [2 —I values for the branches! The next step thus consists of choosing a tree\nlevel—ie., a factoring level, , between 1 and dogs. A level is thus composed of node\nvalues and the lower branches that grow from it (see Figure 2.5.3).\n\nOnce the factoring level, p, has been chosen, we obtain the level p compressed\nvalues, with O<pelog.N, by sequentially calculating levels 1 chrough p, inclusive (sce\n\n2.5 Wavelets: Theory and Compression 183\n\niF\n—\noes (a, +4,)/2 Se\npane |\nNevalues our, Ze = —'¥ a;\nTh =\na\na (ity y hat) {2\na Nal wf\n\nty\n\nfag, NV levels\n\nFIGURE 2.5.1. Building the wee.\n\na, =(o, +a, )/'2+ta,—a,)/2\na = [at +a,)/2+l4, —2,)/2 |\n—\n\n#, = (a, +4,)/2—a, ,\n\n#,=(u, +4,)/2td,, and\nHay_,-4,,)/2 d,,=(a,—4,)/2\n\n= a\n\nyy.\n\nFIGURE 2.6.2. Calculating distances.\n\ndog 5M\na,\n(4, +4;)/2 +.\nbs oe ,\ncae an wet\n\nFIGURE 2.5.3. Choosing factoring level.\n\n184\n\nSection? Mathematics\n\ncocficiemt foros\n\n| aj\n\n((2, +2,)/2,¢,,)\n\nCa ran Renan\n\nyy (cm + aty)/ Body 2-4)\n\nLevel I Lewel 2\n(Initial values) (Comprcied values)\n\nFIGURE 2.5.4. Compressed values.\n\nFigure 2.5.4). We thus have a principle that doer nor lose information, the Eimear cost of\nwhich is a function of NV.\n\nOnce factored, we restore the initial values by reversing che operation. This resi-\nnution operation has, itself, a finewr cast in N, It is important w note that to restore the\ninitial values from a level p, we must maintain this level's scale factors as well as all che\ndetail coefficients fom levels 1 through p, inclusive.\n\nAn Example\n\nImagine, for example, a linearly coded image having, to simplify, a resolution of 4 pix-\nes by 4 pixels in 16 shades of gray. The initial values are thus a scalar vector of 16 val-\nwes between O and 15, Figure 2.5.5 shows the tree associated with this image.\n\n‘Thus, if we choose factoring level 3, we keep the couple of scale factors (6, 10)\nand all the detail coefficients from levels 3, 2, 1, and 0, Note that level 0 never has\nscale coefficients: They are all implicitly null.\n\n[fwe now wane co return to the 16 initial values, we calculate the level 2 scale fac-\ntors by adding or subrracting level 3 coefficients, and se on, until we rerun to che\nlewel O Geter, which are the initial valees,\n\nApplications\n\nThe preceding construction principle is exactly the one that is used by image pyra-\nmids for mipmaps, which, in fact, represenc the waveler compression method. These\nwavelets are also called Haar waveles. They are very well suited for eating discrete\n\n2.5 Wavelets: Theory and Compression 165\n\nFIGURE 2.5.5. An example cree.\n\nvalues, such as scalar vectors about which we, theoretically, know nothing. Bur many\nother kinds of wavelets are useful for treating continuous or other functions. The the-\nory behind these other wavelets closely follows the previously described principle.\n\nWavelets have many applications. The first and most well known is image com-\nfresion. Compression and decompression by wavelets requires an additional phase,\nhowever, compared with the above principle. The preceding principle is lossless; in\nother words, the entire image can be recomposed precisely from any level. Bue this is\nof no interest to us in compression, so we can secrifice values co lose che least informa-\ntion possible, By thus minimizing error, we obtain very impressive resules. For cxam-\nple, an image of a few hundred kilobytes can be compressed co only a few kilobytes\nwith very little perceptible loss. Simply put, areas of little derail are highly com-\npressed, while those of greater details are less compressed. Visually, chen, the loss of\ninformation is barely perceptible. Figure 2.5.6 is an cxample of a compression rate of\n116: The original image is 6.25MB, compared with 53KB for the compressed image.\n\nAnother well-known application of wavelets is dat analysis, an alternative to\nFourier transforms for aperiodic functions. We can also cite multiresolution produe-\nHon of images or 31) models enabling one to adjust the level of details of an image\n(infinite zoom, etc.) ora 3D model (LOD, subdivision, etc.).\n\nFIGURE 2.5.6. An comple oF image compression.\n\nReferences\n\nAn Introdiction to Wirvelers, Institute of Electrical and Electronics Engineers, available\nonline at www.amara_com/TEFEwave/IEEF wavelet. html.\nThe Wavelet Organization meta-sire, available online at wwew.wavelet.org.\n\nInteractive Simulation of\nWater Surfaces\n\nMique! Gomez\n\nWith ever-increasing computing power, simulating realistic outdoor environments in\nreal time is finally becoming possible. Dynamic water is one ching that can add\ntremendous aesthetic appeal to any ourdoor game scene, This article describes a sim-\nple, efficient approach for simularing realistic wave motion over water surfaces. Using\na central difference approximation of che two-dimensional wave equation, you can\nsimulate the horizontal motion of water with only a few arithmetic operations per\npoint. Briel discussions of other approaches are given as well. Physically based models\nfor buoyancy and drag are also described. Finally, implementation and optimization\nideas for the rendering process are discussed,\n\nThe Wave Equation in Two Dimensions\n\nA water surface can be though of as a tightly stretched clastic membrane in which\ngravity can be ignored, As infinicesimal sections are displaced, their direct neighbors\ncaert linear “spring” forces (surfer tension) to minimize the space between them.\nSince horizontal forces are equalized, particles move in only the z-direction. The ver-\ncal position with respect to time and space can be described with the partial differ-\n\nential equation:\ndz Y oz ds\nSe ee eee\nae ie” ay\"\n\nwhere ¢ is the speed at which waves travel across the surface. If the boundary candi-\ntions are Jomegeneous (ie, the edges don't move up and dewn) and the initial z-veloc-\nity of the surface is zero, the general solution for a square x J. section of warer is:\n\n187",
      "page_number": 176,
      "chapter_number": 20,
      "summary": "This chapter covers segment 20 (pages 176-183). Key topics include values, compression, and compressing. The damping is negatively\nproportional to velociry, 24 Using Implicht Eulor Integration for Numerical Stability 181\n\nInaccuracy\n\nThe implicit Euler method is noc as accurare as its explicit counterpart.",
      "keywords": [
        "level",
        "Wavelets",
        "factoring level",
        "Compression",
        "initial",
        "Solving Ordinary Differential",
        "image",
        "che",
        "implicit Euler method",
        "che inicial conditions",
        "Principle",
        "applications",
        "levels FIGURE",
        "factoring",
        "method"
      ],
      "concepts": [
        "values",
        "compression",
        "compressing",
        "wavelets",
        "level",
        "image",
        "equations",
        "difference",
        "differing",
        "differ"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 8",
          "chapter": 16,
          "title": "Segment 16 (pages 148-160)",
          "relevance_score": 0.46,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 46,
          "title": "Segment 46 (pages 440-447)",
          "relevance_score": 0.32,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 7,
          "title": "Segment 7 (pages 57-65)",
          "relevance_score": 0.32,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 19,
          "title": "Segment 19 (pages 181-188)",
          "relevance_score": 0.31,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 21,
      "title": "Segment 21 (pages 184-194)",
      "start_page": 184,
      "end_page": 194,
      "detection_method": "topic_boundary",
      "content": "1B\n\nSection 2 Mathematics.\n\npsp A. sn =) inl \"coco,\nir 2\nn= 7 a (ex) + (xy)\nThe cocfticients A_, are found by evaluating the integrals:\n\nHee Zip [, fl=.y) sin = sin =\n\nwhere fix, y) is che initial shape of the water surface [Trim0). If the surface is mod-\neled as an evenly spaced grid of z-values (a Acight field), as in Figure 2.6.1, the preced-\ning integrals become diserete and can be evaluated with the Fart Fourier Tamar\n(FFT) algorsein [Press92].\n\n2(x, ye]\n\nP| be\n\nE= A(N-f)\n\n21 N-1\n\nFIGURE 2.6.1. An fx J height field wich WV poinds along each side is used 20 approximaze\nthe water surlace.\n\nWe could approximate a solution by evaluating only the significanc terms of the\nseries, bur even though this approach is straightlorward and stable, ir is ery inefhi-\nclenr. On most CPUs, a single evaluation of a trigonometric function takes around 30\neyeles. Dropping all but the first three modes along x and y requires evaluating nine\nsinusoidal functions per point per time step, which is prohibitively expensive for large\ngtids in interactive applications. This major drawback should motivate us to find a\nmore cfficient numerical solution.\n\nUsing central differences to approximate the partial derivatives gives:\n\nzy = 22) + ak : aha) ee tein + 535 85)\n— fii gel’ sei\nAz? be\n\nThe value 24, is the height of the #, jth grid position at time m. The values =\"j and\n2% are the heights at times #) = % —Arand ¢, = % + Av, respectively. Solving for zy}\ngives:\n\n26 Interactive Simulation of Water Surfaces 1688\n\n24 3 rt be\n+i cr n ] dec he =o\nry = i (za, Fy FEF zo) + 2 - re if = jim\n\nThis relationship simply says thar the motion z,, is influenced only by its nearest\nneighbors (Figure 2.6.2). Since the grid spacing is constant, the reciprocal of /* can be\npre-calculated, leaving only multiplies, adds, and subtracts. Furthermore, if edocs not\nvary benween cells, all coefficients can be pre-calculaned, and successive z-values can be\ncalculated with only two multiplies and five adds! (And if you're really cheap, you can\nmake #* = 20A@, climinating the middle term. This approach restricts either ¢ or A,\ndepending on the application.)\n\nAr first glance, it might seem necessary to store three separate grids for the =\nvalues at times ¢), f, and 3; however, if 2°! is replaced with z~/ in place, only ewo\nends are necessary. Ac the end of the pass, the memory pointers to the 2**’ and 2* val-\nues are swapped, Ar the next iteration, che 2\" has become 2\", and 2\"*! has become 2\".\nThis code snippet shows how this space-saving trick can be implemented:\n\ni/precalculate coefficients\n\nconst float A = (e*dtfhp\"(e'dtyny\nconst float B = 2— 45a:\n\nlog 4, 4;\n\nffedges aré unchanged\n\nTor( i=1 3 i4N-1 5 dt }\nfort j=1 3 J<N-1 7 jaa)\n{\n\nffintegratea, replacing z[n-1) with z[n#1] in place\n\nE1[a}(i) = A*¢ zli-1) 03] + 2la+1) fi] + zlagf{j-1) * =lailli+i] }\n+ B*z[i][]] — 2ifi}[i;\n\n/fapply damping coefficients\n\nZI(AN(i] *= dLantjl;\n\nI\n\ni/swap polnters\nSwap z-phata, zi.pbata 4;\n\nZij+t\n\nHl wy Zissj\nijt\n\nFIGURE 2.6.2. The horizontal movement of the point z, is influenced only by its nearest\nneigh boss:\n\n7190 Section 2 Mathematics\n\nBoundary Conditions: Islands and Shorelines\n\nin nature, bodies of water are usually not square. Rivers, lakes, and oceans have inreg-\nular shorelines of varying slope, and islands might exist within these bodies of water as\nwell, Ifthe bank is very steep or even vertical, waves reflect off the shoreline with very\nlittle energy loss, whereas if the bank is genely sloped, a wave might have a very weak\nreflection or none at all. If che waves do not come in straight, chey reflect off ar an\nangle,\n\nThese effects ean be simulated by scaling the 2**! value by a local damping coeffi-\ncient, @,; [see the preceding code snippet). A coefficient of 1 allows free movement of\nthe height value without any energy loss, whereas a coefficient of 0 restricts all move-\nment of the water at that location. If these coefficients are distributed and scaled\naccording to the terrain features, waves react to the shoreline more naturally. For\ncxample, if the bank is steep, the damping coefficients should make a quick transition\nFrom 1 (water) to 0 (land). On the other hand, if the bank is gently sloped, the damp-\ning coefficients should make a gradual transition from 1 to 0. In practice, it is usually\nbetter to use damping coefficients thar are slightly less chan 1 in wet cells to produce\na litde energy loss. Otherwise, wave motion continues indefinitely,\n\nImplementation Issues\n\nInstability\nThe previously described integration method is called an expliat method because it\nwees only previous and currenc values of z;; to evaluate 2\"*! IF the condition:\n\ncar\n\n=\n\nha | =\n\nis mot met, the integration method becomes anche and successive z-valucs grow\nexponentially.\n\nAn implicit method, on the other hand, can he used to guarantee stability.\nUnfortunately, finding a solution implicicly involves solving sets of simultaneous\nequations for z\"*'. For more in-depth discussions of implicit integration methods,\nsee [Crerald 99], [Hairer93)], and [Hairer96].\n\nParallel Processing\n\nAlthough some processors have single-instruction, multiple-data (SIMD) instructions\nthat evaluate several floating-point values in parallel, memory alignment requirements\ncan decrease the efficiency {or even prohibit the use) of these instructions for inte-\ngrating a solution. Processors that can operate on four single-precision floating-point\nnumbers in parallel usually require 16-byte alignment, so rows must be padded if Nis\nnot a power of 2. Regardless, some memory accesses are unaligned (Figure 2.6.5).\nEven if che CPU allows unaligned memory accesses, a penaley is usually incurred.\n\n26 Interactive Simuletion of Water Surfaces 181\n\nFIGURE 2.6.3. Eves though the rows of the grid are padded to ensure 16-byte alignment,\nsome dara accesics ane not aligned.\n\nInteracting with the Surface\n\nSplashes\n\nSplashes can be creared by instantaneously displacing one or several z-values at a par-\nticular location, As the solution progresses, waves radiate from this location. This con-\ncept illustrates another advantage over explicitly evaluating che general solution: If\nany discontinuity in 2{f) occurs, new values for 4, must be computed with a ciscrete\nFourier transform.\n\nBuoyant Objects\n\nWhat good is water if things can't float on cop if ir? Objects flaar because heir overall\ndensity is less than thar of che surrounding water. The force of buoyancy on an object\nis equal to the weight of the water displaced by thar object. This force is actually in the\ndirection of the pressure gradient, but in most cases, the direction normal to the water\nsutface is appropriate.\n\nIfthe shape of the hull is approximated as a set of discrete points, normals, and\narea patches (Figure 2.6.4), the force of buoyancy can be calculated by performing a\nvolume integral over the submerged portion. The volume of water displaced by asec-\ntien of the hull is:\n\nAV, = SA, (far zs Pine Pitee\n\nwhere 2, i the bilinearly interpolated water height at py (Bilinear interpolation is\nrecommended, since other methods might produce primary or first order discontinu-\nities. It is also probably the most efficient interpolation method far a regular grid.)\nThe buoyant force ac this position is:\n\nSection 2 Mathematics\n\nand the torque is simply:\nN,=1, * F,.\n\nwhere ©; is the vector from che center of mass to py. The total force and porque are cal-\nculared by summing the contributions from each hull vertex. Remember also that\nonly the swéemerged portions contribute to the buoyancy.\n\no\n\nFIGURE 2.6.4. The shape of the buoyane object is approximated with a set of poine, p,\ndistributed “evenly” over its surface, Also stored are the unit surface normals, i, and che\nlocal area patches, Ady.\n\nThe number of poincs needed depends on the shape of the object and the level of\naccuracy desired. A cube mighc need around 20 or 30 points, whereas a tree with\nbranches mighe need hundreds of points to behave realistically.\n\nA vector normal to any parameterized, right-hand-oriented, chree-dimensional\nsurface can be calculated with the formula:\n\n39{u;0) Beis)\nae Cen aaE Spa [Davis 1]\n\nIf we think of and y as our paramerers, the water surface can be described by the\nVEcror:\n\nApproximating the first derivatives with central differences gives:\n\naS Eis TZ y-1y\na 1, ————> b\nthe 2h\n\nos F | 0 | Se i+! 7 By i\ndy a a\n\n2.6 Interactive Simulation of Water Surfaces 193.\n\nThe normal al the Ath grid location is then:\n\n_ | Sry FE Fa\nn,, =|—- ae  _\n2 an\n\nScaling this vector by 24 does not change its direction, so an equally valid normal is;\na= le. — Eis Ep. ~ jer 2h\n\nwhich must then be socmalized.\nTo keep the object from sliding over the surface like a surfboard, a drag force can\nalso be calculated by summing contributions from each vertex:\n\nE,.. = ear = 3 Bf ce = (v.. +H x nf\nThe velocity term v,,., is the velocity of the hull redarive to the water at x, So if, in\n\naddition to height values, a chree-dimensional velocity is associated with every grid\nlocation (a pecrer eld), the current carries floating objects.\n\nRendering\n\nAll chis theory is preat, bur if you can't see it, what's the poinc? The following are some\nideas on implementing and optimizing the rendering process.\n\nEnvironment Mapping\n\nWhen drawing water, you can use alphe blending to give the appearance of trans-\nparency. In onder to draw alpha-blended triangles properly, however, you must draw\nthe ones farthest from the viewer first, without the help of the 7-buffer. Furthermore,\ndouble blending occurs whenever a triangle is visible chrough another.\n\nIn reality, lighr doesn’t pase straight through water It bends as it poes from one\nindex of refraction to another. Water also reflects light from its su rrourudlings, These\neffects can be achieved with exsironment mapping. Environment mapping a water sur-\nface involves reflecting and refracting rays of light from the eye and intersecting them\nwith an environment map surface to calculate a texture coordinate [Figure 2.6.5].\nEach onangle is then texture mapped with these coordinanes.\n\nT cannot emphasize how incredible refraction mapping leoks if dane well; you\nhave co see it co believe it. With reflection only, water appears too metallic, like liquid\nmercury. See [War2000) for more environment-mapping techniques and related for-\nmulas.\n\nAlthough environment mapping gives stunning visual results, using it on a large\nscale may not be feasible without hardware support due to computation requirements.\nThe results are iM pressive enough, however, ves justify a scaled-down softacure imple-\n\nmentation,\n\n184 Section? Mathematics\n\nfenore space\n\nFIGURE 2.6.5. Bouncing rays from the eye (camera) position to the environment map\nBenerars a texture coordinate (x. e) for each verten,\n\nLevel of Detail Management\n\nRendering distant portions of the height field at lower resolutions can give cremen-\ndous speed increases without significantly decreasing visual quality. Care must be\ntaken, however, to ensure char vertex normals along LOD transitions march. Other-\nwise, discontinuities are visible in environment mapping and lighting. For an elegant\nadaptive quadtree approach to terrain LOD management, see [Ulrich2000].\n\nReferences\n\n[Davis#1] Davis, Harry FE, and Snider, Arthur David, fureduction to Vector Anahyis,\nsixth edition. William C. Brown Publishers, 1991,\n\n[Gerald99) Gerald, Curtis FE, and Wheatley, Patrick O., Applied Numerical Analysis,\nsixth edition. Addison Wesley Longman, Inc., 1999.\n\n[Hairer93] Hairer, E., Norsent, $. BR, and Wanner, G., Solving Ordinary Differencial\nEquations {: Nonsilf Problems, second edition, Springer-Verlag, 1993.\n\n[Hairer$6) Hairer, E., and Wanner, G., Solving Ordinary Differential Equations fT:\nSniff and Differensial-Alecéraic Problems, second edition, Springer-Verlag, 1996.\n\n[Press92] Press, William H., Teukolsky, Saul A., Vereerling, William T., and Flannery,\nBrian P, Nesmerieal Recipes in C second edition, The Press Syndicate of the Uni-\nversity of Cambridge, 1992,\n\n[Trim?0] Trim, D.W., Appited Perel Diferennial Equations, PWS-Kent, 1990.\n\n[Uirich2000) Ulrich, Thacher, “Continuous LOD Tensin Meshing Using Adaptive Quad-\ntrees,” Cumann, available online at www.gamasurrs.com/fearures!2000228/\nulrich_OL-him, 2000,\n\n[Watr2000) Wart, Alan, 3D Comparer Graphic, chird edition Addison-Wesley, 2000.\n\n2.7\n\nQuaternions for Game\nProgramming\n\nJan Svarovsky\n\nQuaternions are useful for representing and processing 3D rotations of points, Appli-\ncations include skeletal animation, inverse kinematics, and, generally, any 3D physics\nand graphics engine. This artiele is organized by first explaining enough abour quater-\nnions for you to be able to use them in your 3D game. Ir then gradually reaches\ndeeper into their mathematical basis.\n\nTreat Quaternions as Matrix Replacements\n\nYou can use quaremions in a game as a straight drop-in réplacemenc for rotation\nmatrices. They can describe any rotation around any axis in 3D space. They take less\nspace, four numbers rather than nine, and many operations such as multiplication are\ncheaper. Some operations such as interpolation berween quaternions are also more\nvisually pleasing. Ar points when you need a matrix (such as to rorare a vector), yOu\ncan easily convert quaternions to rotation matrixes and back again.\n\nff a black-box quaternion type that can replace 3x3 matrices\nclass Quaternion\n{\nprivate:\n\nTloat x, ¥, Z, wif! These will be explained later\npualic:\n\nQueternion Inverse(] canst:\nhi\n\nGuaternian quaternion_from_matrix(MateLxaa mat }:\nMatrixd3 matrix _from_quaternion(Quaternion &quat):\nQuaternion interpolate(duaternion 4a, Quaternion &b, float b_amt);\nQuaternion operator *(duaternion &a, Guaternion 4b):\n\nSome other functions exist chat would be more difficult on produce for matrices:\n\nVectord Quaternion: :AxisOffotation(}) sonst;\nTloat Guaternion::AngledfRotation() const;\nff rotation that will get you fram vo to wi\nQuaternion AotationArc(Vectors vO, Vectors v1):\n\n195\n\nA typical use of quaternions is to store all your matrices (such as orientations of\nbones for an animating character) as quaternions. All the matrix multiplicarions are\nreplaced with quaternion calculations, and only ac the end of the pipeline, where vec-\ntors must be rotated into world space or onto the screen, de you turn the quaternions\ninto matrices.\n\nThree-by-chree retation matrices can be represenced directly by quaternions. A\nquatermion and a translation vector can represent 4 * 4 matrices that encode a rota-\ntion and cranslation,\n\nWhy Not Just Use Euler Angles?\n\nQuaternions do not suffer from gimbal lock. With a three-angle (roll, pitch, yaw) sys-\ntem, there are always certain orientations in which there is no simple change to the\nthree values to represent a simple local rotation, You often sce this roration having\n“pitched up\" 90 degrees when you are trying wo specify a local yaw left or right.\n\nWhat Do X, Y, Z, and W Represent?\n\nThe four numbers in the quaternion, often denoted (x, yz, w), have some physical\nsignificance, If we consider all rotation matrixes to represent a rotation of an angle @\nabout an axis. 4 (A), Fy, 2), shown in Figure 2.7.1, the quaternion Q will be:\n\nFIGURE 2.7.1. Rotation of angle 6 abour axis,\n\n27 Quatermions for Game Programming 187\n\nQ=(GX_ st Kp 12, o)\n\nsasin (f/f 2}\ncao (8/2)\n\n‘This leads to ovo things: It is easy CO extract the angle of rotation (see the method\nmentioned previously) as being twice the inverse cosine of the w term. It is similarly\neasy to extract the axis of rotation.\n\nNote that cwo quaternions represent each rotation matrix. Ifa general rotation is\ndefined by an axis and an angle, each rotation will have an equivalent with the oppo-\nsite angle and the opposite axis of rotation. In quaternion terms, you can make the Os\nof the two quatcrnions different by 2x (or 360 degrees). Since the terms are in (8 / 2),\nthis adds m inside the sin and cos terms:\n\nrent (Of + 70) = —rrn (oe)\ncos ff +7) = oer ee)\n\nThis can lead to problems in interpolation, where two quite numerically different\nquaternions represent very similar rotations. ‘The fixes for this “gotcha” can be seen as\nextra tests inside the implementation of any quaternion library.\n\nFrom What Math Is This Derived?\n\nThe quaternions we use here are a subset of general quatemions. General quaternions\nare an extension of complex numbers. Complex numbers are defined in terms of i, the\nsquare root of —] (which cannot be represented by a “conventional” number):\n\ni™p=—f\n\nAlthough # is different from “real” numbers, we can include it in expressions like\nany other variable, with the magic property being thar its square is —1. Any multiple\nof fand areal number must be left in terms of %, making a “complex” number (a + bi}\nfor some g and #. For example, multiplication of pwo complex numbers:\n\n(a+ bi) \"fe + dt) = ate + adi + etl + bd\n\n=e — bal + fat + thle\n\nQuaternions extend the concept of a square root of -1 to have three square POOLS\nof -1, being £ j, and &\n\n#*g=-]\njtje-l\nk*k=—]\n\nMultiplication of pairs of these clements together behaves much like the cross\nproducts of the usual three axes in 31D space:\n\ne*joj*i=k\n\nF “b=—6 “I =f\n\nSection 2 Mathematics\n\nk* peop *k =}\nWhar this all means is that quaternions are defined, similazly to complex mum-\nbers, in terms of a real number and an 4 jf, and #& term. Because #, 7, and & behave so\n\nmuch like axes, quatermions are sometimes written as a vector (here v) amd a sealar (5)\nor asa vector of their four ceems.\n\ngewexityjeck\ngq = ise] where s = wand p = /x y zi\ngz-ixyew! note scalar “se” at the end\nAddition and muldplication of quaternions are defined in the obvious way, Much\nlike multiplication of “normal” complex numbers, the result of multiplication is\nanother quaternion:\n192 = (t)+x;1 +7 J +2, A) fey + xt +a} + = &)\n= fy €y— xp Xz— Fy Fr — Ey 5z) +\n(Vp Zp — yp Sy + Cy Xp t Cp Kah et\n(By Xp — 5) p+ Cy a + Cp Yad f+\n(Ky ¥e— Xp Fe + fy Zy+ cy a) ik\nA lot of symmetry can be seen in this example, which is made more obvious in\nthe condensed notation:\n\nGr Fx = (ty + wy) (iz + Uy)\n\nwhere 2+ fis the dot product and a # is the cross product.\nA few other definitions are useful. The norm of a tjuaternion is:\n\nNig) = 22 + phe t+ we?\nThe conjugate of a quaternion can be thought of in ewo ways:\n\nq’ = x—y— wf\ni\nThe multiplicative inverse of the quaternion:\nHg = g* / Nig)\nThe subset of quarernions we use for representing rotarions is the sec of unit\n\nquaternions, where [gl = J, or x? + y? + 2° + w? = J2, These have the property that\ntheir inverse is equal to their conjugate.\n\nHow Do Quaternions Represent Rotations?\n\nThe rotation of a vector P [x y x] by the unit quaternion gis done by creating the\n“pure” quaternion p and the conjugate of g:",
      "page_number": 184,
      "chapter_number": 21,
      "summary": "This chapter covers segment 21 (pages 184-194). Key topics include quaternions, mapping. On most CPUs, a single evaluation of a trigonometric function takes around 30\neyeles.",
      "keywords": [
        "quaternion",
        "water",
        "rotation",
        "Water Surfaces",
        "quaternions represent",
        "Quaternions Represent Rotations",
        "surface",
        "vector",
        "numbers",
        "coefficients",
        "che",
        "terms",
        "complex numbers",
        "represent",
        "grid"
      ],
      "concepts": [
        "quaternions",
        "mapping",
        "map",
        "grids",
        "rotations",
        "rotation",
        "rotated",
        "surfaces",
        "waves",
        "normal"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 11,
          "title": "Segment 11 (pages 203-224)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 6,
          "title": "Segment 6 (pages 103-120)",
          "relevance_score": 0.46,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "Segment 63 (pages 609-616)",
          "relevance_score": 0.45,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 23,
          "title": "Segment 23 (pages 441-462)",
          "relevance_score": 0.44,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 22,
          "title": "Segment 22 (pages 207-219)",
          "relevance_score": 0.43,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 22,
      "title": "Segment 22 (pages 195-204)",
      "start_page": 195,
      "end_page": 204,
      "detection_method": "topic_boundary",
      "content": "2.7 Quatemions for Game Programming 186\n\npaxieyjrzé pure means ne scalar term, w= 0\nKori?) =g pq\"\n\nThere is some derivation to do to see that this works, Rather than bulldozing\nthrough it here, we summarize: You consider rotaring the vector P by an angle @ about\nan axis. A. Using geometry, you can work through che math, expanding everything out\nuntil eventually some terms in co?(@) and sir(8) cum up. These can be rurned inte\neen 28) and sin(20) terms, and very soon you end up with a formula thar looks a lot\nlike the quaternion multiplication worked through previously [Glassner0]_\n\nThis representation of rotations can be used to convert the quatemnion inte a rota-\nHon matric A retion matrix can be seen as che rotation of the unit matrix by a quater-\nnion, where the unit 3% 3 matrix is che three vectors (1, 0, 0), (0, 1, 0), and (0,0, 1,\nA4 4 romoon marrix is equivalence to the 3 * 3 case bur with an cota row and col-\numn appended where the extra terms are 0, exeept for the bottom right, which is 1.\n\nReferences\n\n[Glassner90)] Glassner et al, Graphics Genus, Academic Press, 1990.\n[Downs] Downs, Laura, “Using Quaternians to Represent Rocation,” Available\nonline at heep://hetp.cs.berkeley.edu/-laura/es] 84/quar/quarernion. html.\n\n2.8\n\nMatrix-Quaternion\nConversions\n\nJason Shanke!\n\nQuarerions are convenient for representing 3D rotations. Quaternion multiplica-\ntion is faster than matrix multiplication, and quaternion interpolation generates\nsmooth animations. But matrices have their uses, too. In particular, matrices are\npreferable to quiatermions for performing vertex transformation. In addition, mast 3D\nAPIs store their rotations in matrix form.\n\nThis article demonstrates quaternion-to-matrix and Matrie-to-guatemion eon-\nversions. We use both four-dimensional veeter and veceor!scalar nomenclature to rep-\nresent quaternions. Thar is:\n\nq = [epee] = [av]\n\nwhere v = (xz) isa three-dimensional vector and wis a scalar.\nWe alto use , g and g” to designate quaternions. q' and g” are distiner from q\nand should not be confused with the first- and second-order derivatives of g.\n\nQuaternion Rotations\n\nLet gq = [ev] = [oos(8),usin(@)) be a quaternion where u is a unit vector. Let qely'y']\nbe a quaternion (nor necessarily unit) representing a pointe in three-dimensional\nhomogeneous space.\n\nThe operation gq”! rotates about axis u by 20. Proof is provided by [Shoe-\nmale 4],\n\nQuaternion-to-Matrix Conversion\n\nTo convert the quaternion g into an equivalent rotation mamrix, we must express\nqq q°! as a matrix operation.\n\n2.6 Matrix-Quaternion Conversions\n\nQuarerion multiplication takes the form:\nqo = Leaw][rersw) = [ae !—wev', vw & ree + er ¥]\nwhere @ is the vector cross product and © is the vector dot product,\nThis expands to [x Uy\" 3a] such thar:\nXm ye’ — ay! + ee + ce\"\nyo = ay — xa + uy + pte’\n=z\" = xy — yn + geht + nr’\nwe = fee — sae\" — yp = ee\"\n\n‘This expansion can be expressed as a matrix multiplication:\n\nPag == ¥ xix\noH gots AN id\n=F x w sie\n\n<x —F EF wir\n\nThe multiplication g” = gq expands to:\nxs ypEe-—zyswhy ecw\nysek—xE + wy + ype\nEf =K)—yh + wes zy\nnr” = ww —xe—yy— EE\n\nwoof —y xix\nPe ah ay Pte\n= ft\n\nyocx ow zfs of\n\n—— oF =x a\nPor a quaternion g = [wv], gq! = [1 —¥] Mig).\nJVilg) = reste tet = 1 for unit (ustemions, 50 q! = [uty—¥]_\nSubstituting g = q7! in &, yields:\n\ni es\n\nLit toot) ee pad\nlek\n\nT\n\n202 Section 2 Mathematics\n\nThe matrix equivalent of the operation gg! can be found by concatenating L,\nancl Rare\nMeL; -\nw—oy x | [we yx\n\nS wex y zou xy\njx £ yx wr\n\n—x—y-zeur| |x y zy\nweet yet Pipe) Dey exe) 0\n2(xyeme) wexteptig? Dye wer) o\n2Gez—un) — Dipeeue) wettest o\n0 0 0 Pa ae\n\nx7 ep 7+e 2+ 1, so Mf simplifies to:\n\nI-2(y*+27) 2bqewe) 2 my saz)\n2ixytwz) 127427) 2lyo—nex)\n2ixe—wy) = yee wc) 1—2le*+y*)\n\nth o 0\n\ni — si —\n\nMatrix-to-Quaternion Conversion\n\nThe relationship between a rotation matrix and the components of its corresponding\nquatemuion is given as fin the previous statements.\nProm J, we can derive the following six relations:\n\n1. Mya + Mz = xy\n2 My + My, = dyz\n3, Mya + My) = dex\n4. Mj, = My, = 40x\n3. Ma) = M3 = day\n6, Af. — My, = 4we\n\nFrom these relations, ir is clear chat if you know one component, yOu can com-\npute the other three by division. Since any but not all of che components can be zero,\nwe want ta determine which component has the prearest absolute value and use ir to\ncalculate the other components. The largest component of a unit quaternion has an\nabsolure value of at lease 4.\n\nSolving for Ww\n\nThe trace of a matrix is che sum of the diagonal components. ‘To determine |id, we\nstart by calculating the mace of che matrix JM. For the manrix M, the trace is:\n\n2.8 Matrix-Quatemion Conversions 203\n\nTr=4- ditty *ex7) = all = (x+y tee\" })\n\nRecall that a unit quatemion q = [w,v] = [cos(6),v'sin(0)] where v'= (x72) isa\nunit vector, We can therefore express the trace of Af as;\n\nTr = 4(1 — (x\"*+y\"*+27)sin(6))\n\nSince (xlyiz) is a unit vector, x@+y7+27 = 1,\nThe trace of M reduces to:\n\nTr = 4(1 —sin*(0)) = 4e0s\"(B) = 47\n\nor:\n| = Tr?/2\nSo, if Tr 1, we plug dn = +2Tr'* into cquations 4, 5, and 6 and solve for x »\nand =:\n\nx= (May —Mgs)(2Tr!\"?\nye Wa, — AM, 3)/2Te\"?\n\nNote that it doesn't mater whether we use the positive or negative root of Tr as\nthe basis for ew, since q and —g represent identical rotations.\n\nSolving for X, Yorz\n\nIf |u| < %4, we can determine which of the remaining componencs is the largest by\nexamining the first three values along the diagonal of Mf. Suppose M,, > Mf, ,. This\nexpands te:\n\n1—2x*— 22? > 1] —3y?- 22?\nSimplifying, we get:\n\n—2x* > —ly*\nOr:\n\ned < [71\n\nSimilar arithmeric applies to other comparisons berween the diagonals. So, the\nlargest component of the vector (Af, ,, Ady2, My3) corresponds to the largest value of\nthe vector (xz.\n\nOnce we have the largest component of (Mf), Ma ;, 4,4). we suberact the other\ntwo elements, and the equation reduces co a single teem. For example, assume M2 is\nthe largest term:\n\n204 Section2 Mathematics\n\nya tls — My = My, + 1)'\"12\nIn general,\n\nAs with w, ic doesn't mamer which root we use. Once we have a suitable ¥,, We can\nsolve for y;, vand w by substitution:\n\nv= UM, + M4)\n\nv,= (My + M,i(4y)\n\naw = (My = Addy)\n\nFor the calculation of w from equation 4, 5, or 6, 4, and & must be in sequential\nonder, That is, f = 1 + (7963) and & = 1+(7903).\n\nReferences\n\n[Shomaket!4] Shoemake, K., Quazernfons, available online at fips/fftp.cis.upenn.edu/\npub) praphics/shoemake/quaturt.ps.2, May 1994.\n\n[Eberly99] Eberly, David, Quarernion Algebra anal Calculer, available online at www.\nmagic-software.com/sre/praphics/quar/quat.pdf, July 1999.\n\n2.9\n\ninterpolating Quaternions\n\nJason Shanke!\n\nQuatemions are four-dimensional extensions of complex numbers. (See “Qhuater-\nnions for Game Programming” in this book for a discussion of quatemions and\nquaternion mathematics.) This article presents four techniques (Lerp, slerp, squad,\nand spline) for interpolating between pairs or sequences of quaternions. The actual\nderivations of each of these techniques are detailed ar the end of the article.\n\nQuaternion Calculus\n\nBefore getting into quaternion interpolation, we need to define some calculus furc-\ntions of quaternions.\n\nLet g@ = cos(@) + vsin() bea unit quaternion (¥ is a three-dimensional unit\nVector).\n\nEuler's identity for complex sumbers applies to quanermions:\nq = cos(@) + vsin(@) = exp{v8)\n\nFrom this identity, we can define the power function for quaternions:\nq = [cos(@) + vsin(6)]* = exp(ve8) = costs) + vsin(:6)\n\nWe can also express the logarithm of a quarernion using this identity:\nlop(g) = log(exp(vé)) = vé\n\nWe can express the derivative of gf” as:\n(99 = g'log(a)\n\nApplying the chain cule, we cam express che derivarive of ge:\n(ge) =F '(elg\"log(g)\n\nApplying the chain rule for functions of ewe independent variables, we can\nexpress the derivative of oft}! (¢ omitted for clarity}:\n\n206 Section 2? Mathematics\n\nig) = fal logig) + gfg\n\nQuaternion Interpolation\n\nSince quaternions can be used to represent 3D) rotations, we can use four-dimensional\nvector interpelation techniques to gencrate smooth 3D animations.\n\nLet gy and gq, be quarernions. The general formula for interpolation between q,\nand 7, is given as:\n\ngle) = folégy + fildg, (Sr 1)\nwhere fi(f) and /[(2) are scalar funetions such that:\n\nflO) = 1\nfll) = 0\nAt0) = 0\nAi) = 1\n\nLinear Interpolation\nLinear interpolation is given as:\n\nlerp(tigg.g) = (1 — egy + gy = lg, — go) + Go\n\nLinear interpolation does not preserve magnitude, so it is importance to normalize\nthe resule if you're using it as a rotation.\n\nLinear interpolation is fast, bur it does mot generate smooth animation. This\nmeans thar che animation speeds up and slows down over the course of the interpola-\ntion, even if you vary t at a constant rate. Although this variation in speed might be\nacceptable for some applications, it is not ideal. To achieve smooth animation between\nquaremions, we must we spherical linear interpolation.\n\nSpherical Linear Interpolation\n\nJust as three-dimensional unit vectors define points on a sphere, unit quarermions\n\ndefine points on a four-dimensional hypersphere. Smooth animation is achieved by\n\ninterpolating values along the great arc connecting the two points (see Figure 2.9.1).\nSpherical linear interpolation (slerp) is given ax\n\nslerp(rigy.gy) = [qysin(@(l — r))+q,sin(Br)]/sin (8)\nwhere 8 is the angle between q, and 4).\n\nWe can find © by treating q, and q, as four-dimensional vectors and calcularing\n\nthe dot product:\nFoF, = XX; + uM + Shy + Wye, = costB)\n\nFIGURE 2.9.1. Spherical lincar interpolation.\n\nUnlike lerp, slerp preserves magninude, so there is no need to normalize the\nresult.\n\nIf gag) <0, then @ > 1/2. Since g and <9 represent the same rotation, it is best.to\ninvert g org, in this case, minimizing the angular distance the interpolation has to\nfollow. This inversion reduces unnecessary spinning over the course of the interpola-\ncicen.\n\nTF |gja\"47)| is clase to 1, we fall back to lerp, since sin(8) approaches 0 as |go*q,/\napproaches 1.\n\nSee Derivacion 2.9.1 for a derivation of slerp,\n\nSpherical linear interpolation can alen be expresed as a power function of gy\nand fj:\n\nslerp(tgpeg.) = golqy gy)\nFrom this, we can express the derivative (slerp') as:\n\nalerp (t3y.q)) = dolgy 'y) loglen \\qy)\n\nThe power form of slerp and ins denvative are used in denving spline interpola-\ntion, See Derivation 2.9.2 for a derivation of the power form of slerp.\n\nSpherical Cubic Interpolation\n\nslerp produces smooth animations, but it always follows a great arc connecting ro\nquaternions. Just like using straight lines to connect a series of points, using slerp to\ninterpolate through a series of quaternions produces a jaeged path. In practice, chis\nmeans that your animations change directions abrupdly at the control poine. To\nsmoothly interpolate through a series of quaternions, use splines (see Figure 2.9.2).\n\n208 Section? Mathematics\n\nLinear Interpolation\n3Hore8e-0-e -=------- §pline interpolation\n\nFIGURE 2.9.2. Linear vx. spline In rerpolacinn.\n\nThe basis for spline interpolation is spherical cubic interpolation, or squad:\nsquad(r:p.¢.4.0) = slerp(2e(1 — ):slerp(s-¢.¢),slerp(ica, b))\n\nThe animation from p to g does not follow the great arc connecting p and g but\ncurves toward the are connecting « and 5.\n\nIt is common for sleep implementations wo invert ane of the input quaternions\nwhen the angle between the two exceeds 90 degrees. Although it is cruc that q and\n—q tepresent the same rotation, slerp{mp.q) does mot produce the same result as\nslerp(p.q). Since the control points a and # are chosen to work with p and g, not —p\n\nor —q, it is best not co invert the input quaternions in the version of sleep used with\nsquad.\nSpline Interpolation\n\nLet [fpete Pal ino nt) be Sequences of N quaternions.\n\nLer $42) = squad(tigq deste)\n\n‘To generate a sequence of smooth interpolations, {,.6,} is given as:\na, = 8, = quexpl—lloglg, “gaa) + loplg. qa.) 4]\n\nSee Denvation 2.9.3 fora derivation of spline interpolation.\n\nSample Code\n\nThe sample code on the CD that accompanies this book provides implementations of\nlerp, slerp, squad, and spline interpolation as well as quaternion exponential and log-\nanthim functions.",
      "page_number": 195,
      "chapter_number": 22,
      "summary": "This article demonstrates quaternion-to-matrix and Matrie-to-guatemion eon-\nversions Key topics include quaternions, interpolation, and interpolating.",
      "keywords": [
        "Linear Interpolation",
        "interpolation",
        "spherical linear interpolation",
        "quaternion",
        "slerp",
        "quaternion interpolation",
        "unit",
        "vector",
        "Linear",
        "unit vector",
        "spline interpolation",
        "matrix",
        "spherical linear",
        "Mathematics Linear Interpolation",
        "unit quaternion"
      ],
      "concepts": [
        "quaternions",
        "interpolation",
        "interpolating",
        "interpolate",
        "interpolations",
        "matrix",
        "vector",
        "unit",
        "rotations",
        "rotation"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 22,
          "title": "Segment 22 (pages 207-219)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 10,
          "title": "Segment 10 (pages 182-202)",
          "relevance_score": 0.42,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 9,
          "title": "Segment 9 (pages 160-181)",
          "relevance_score": 0.38,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 20,
          "title": "Segment 20 (pages 190-197)",
          "relevance_score": 0.37,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 11,
          "title": "Segment 11 (pages 203-224)",
          "relevance_score": 0.37,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 23,
      "title": "Segment 23 (pages 205-212)",
      "start_page": 205,
      "end_page": 212,
      "detection_method": "topic_boundary",
      "content": "29 Interpolating Quatemions 209\n\nDerivation 2.9.1; Deriving Slerp\n\nslerp preserves magnitude, so slerping between unit quaternions always produces a\nunit quaternion, Given the basic ineerpolation function:\n\nqel=foltge + flag,\nwe want to show thac if we conscrain gle) so that AMigll) = 1, we gee:\n\nAl) = sin(8(1 = )/sin(8)\n\nile) = sin(Be)/sin (8)\n\nTo clarify che notation, the time-dependene variable has been omitted in the fol-\nlowing (q = gfe), fo= 60). ete).\n\nLet gs [xt + yf + hs we] = ge + fig = slerp(t;4,.9))\nLet g = ens (g.0q)\n\nSince g is a unit quarernion, x+y°+27+n7\"=1. Expanding 2°, y*, 2° and x gives:\nss Ofte + fix)\" = (fox)? + folie + (fix)?\ny= (foro + for)? = Cfare)* + 2fvfirar + Ge?\n\nzs (fot + fei)\" = (foto)? + Bafizus + (fiz, }? 3\nie (foto + furl = (fomry)* + afi Mots + (Aw)\n\nAdding these equations together gives:\nfu +2 fofileox t+ yoy 402) +m Qe +f? = fo +2 oh go-gi +h? = |\n\nWe can express this 24 a matrix multiplication:\n\nea\n\nwhere ¢= gy\"q, = cos(8).\nThe manrix JW can be ee bor\n\neg FAs met da\nM=)siaj3 3p\n\n= f\" Mf =1\n\narya Roe ed\n= BT\nie | 2n 2/3 | = RcR\n\na\n\nLeto = 42 RE\n\nw= | (l+)'\" au 2\n0 ale | — TaD | nA\n\nMultiplying this out gives us:\n\na= [C+ f2+22) 2.18 — G2 — 2427/2]\n\nFrom here on, we need to show the time-dependent variable. u(¢) is a ewo-dimen-\nsional unit vector, so it can be written as:\n\n210\n\nSection2 Mathematics\n\nule) = [cos{eor), sin(tar))\n\nwhen:\n\ncoset) = (Fle + H(O)(2 + 29/2\nsin(ens) = (4(8 — f(O)(2 — Be) \"V2\n\nLet A= (2 4 2e)\"979, B- (2 —20}\"/2\n\nMultiplying cos(tae) by BIAB and sin(wr) by ALAS yields:\n\nAl®) + £8 = Boos(en/AB\nAl) — Alf = Asin()/AB\n\nSolving for 6 and f yields:\n\nAn) = [Boos(an) — Asin(oe)]/2A8\nile) = [Boos(ae) + Asin(me))/2A8\n\n248 = (1 — 2)\"\" = (1 — cos{O))\"? = sinf)\nA748 = 1, so A = cos(yf) and # = sin(yf) for some phase angle w.\n\n‘There are owo values of y thar satisfy A and 8, Wp and w,. Given this, we can\n\nrewrite jf and jf}:\n\nJolt) = [sin(yfghcos( one) — ons ( yt, )sin(oae) |/sin(®)\nJil) = [sin(y,)cos(enr) + cos(y, )sin (eae) } ‘sin (®)\n\nRecall the trigonometric identities:\nsin(ajcos(£) + sin(éjons(a) = sin(ae+6)\nsin(a)cos(2) = sin(@)cos(a) = sin(a—6)\n\nSo, we have:\n\nfle = sini, — ce)/sin(Q)\n\nfilo = sin(y, » cor)/sin(8)\n\n(siven the boundary constraings on f, and £, we can solve for y,, w, and oo:\nWO) = sin(y,)sin(®) = 13 y, - 6\n\nfi(0) = sinfy,)/sin(@) = 0 y, =0\n\nJoU1) = sinty, — 03)/sin(8) - 0 w= yw, = 8\nSo, WE Can rewrite f, and fj again:\n\nJl) = sin(BC1 — A)isin(8)\nult) = sin(Oe/sin(Q)\n\nDerivation 2.9.2: Deriving the Power Form of Slerp\n2 _———_—_————— ry\n\nStart with the definition of slerp:\n\n29 Interpolating Quaternions 217\n\nsherp(Fsdeocgy) = [gosin(@(l —¢)) + qysin (8 #)]/sin(8)\ndp is a unit quaternion (as is g,), 50\n\nGut = 1\n\nFrom this, we can rewrite a, as:\n\nhh © Fogo th\n\nLet's expand gly):\n\ngo 1 = [oh + Vo*¥ ne MOY) + HY) — A1¥0]\n\nNotice that the scalar part of q37!qy = 41, + Votw,- This is the same as the vector\ndot product of g, and g,, which is the same as the cosine of the angle between g, and\nFis a.\n\nSince qo 'q, isa unit quaternion and we know thar its sealar part is cos{8), we can\nrewrite gy gy asc\n\n4a 4) = cos(@) + usin(8)\n\nwhere w is a wnit vector,\nChay, so now we have:\n\n) = qolcor(8)+usin(6))\nIfwe plug this into the slerp formula above, we get:\nslerp(tiqyg)) = [qpsin(O(1 — 4)) + qolcos(@) + usin(@))sin(8 4))]/sin(8)\nFrom the trigonometric identity, we know char:\nqosin (O(1 — 4) = qyflsin(@)cos(8y) = ons(8)sin (64)\nSubstinuting this inte slerp and simplifying gives us:\nslerpltigoafi) = qyloos(Gr) +usin (Os)\nFrom the power function for quatermmions, we can rewrite this as:\nslerp(ia.q)) = qyleos(B)+usin(8))*\nAh, but cos(@) + usin(@) = g9\"9,, so one more rewrite yields:\n\nslemplriqut)) = qalge qi)’\n\nDerivation 2.9.3: Deriving Spline Interpolation\n\nLet (2,0) be a sequence of quaternions,\n\n212 Section 2 Mathematics\n\n‘To derive spline interpolation, we want to find ja.) such that the derivatives of\nS.{@) at the conerol points: (0 and t£1) are continuous. In other words, §.\"(0) =\n5.2 (1) for all 7.\n\n‘To do this, we first have to express the derivative of squad.\n\nLet Of = slerp(s3p.q). V = slerp(r:2.6), W= UV\nGiven the power form of slerp, we can rewrite squad:\nsquad(r:p,4.2,6) — ULF Yyell-d Lr eli-0\n\n‘The derivatives of U7, Vand Ware:\n\nUO\" = plp'g)'log(p\"'g) = Ulog(p-'g)\nV= ale 46)'log(a'b) = Vogtaa!)\n= 'Y'- oy\nApplying the product rule, we can express the derivative of squad:\nsquad (rp.g.¢.6) « UW)\" + Ue\nwhere [TH ]\" = (2-4 W2\"“Joe( 1) + 21-3\nWhew. Luckily for us, we only need to calculate squad’ for e-0 and r=1:\n\nLi(0) = p\nTiO) = 2\nWO) = p's\n\nC(O) = plog(p-'g)\n\n[Wet )'(0) = 2log(p-tz)\n\nsquad'(0;9,9.2.6) = p[log(#*g) + 2log(p-\"a)]\nCA) = ¢\n\nVil) «6\n\nWL) = g's\n\nOM) = glogip-'g)\n\n[We#!—87'(1) = —2log(g 4)\nsquad'(1ip,9,4,6) = g[log(p-'g) — 2log(g-'4)]\n\nPlugging in S'_,(1) = 5\\(0) gives:\nfalloglg. yg.) — 2logly,\"'é,)) = g,[log(g.\"g..1) + Zlog(g.',)]\n\nThis gives us one equation and ovo unknowns (a, and 4,). The only constraint\nwe have so far is that chis function must pass through all che control points and have\na continuous derivative. We musa select che value of the derivative at the control\npoints ourselves. A reasonable value to select for che derivative aca control parint is the\naverage of the tangent values of the nwo functions:\n\nSell) = 9,7, = §°,(0) where\n\n29 Interpolating Quaternions 213\nel re a re i a ee\n\n7, > Llogig,-‘ga.1) + log(g,y\"'g.)]/2\n\nSo now we have two equations:\n\nqullogtg,.-'g,) — Zlog(g.'5,)] = q,lloglg. tg,.1) + logtg. 1g.) !2\nGullogtg.‘dy.1) + Zlogtq.*a,)] = g,[log(g\"g,,;) + logig, 77 q.1/2\n\nSolving for a, and &,-\n7, — b, — qoexp[(loglg, ;—'g,) at log(q. daar]\nFor a unit quaternion ¢ = [s¥]:\n\nq=q'=([5-)\n(pgi\" = q\"p\"\nlog(qé*} = —log(g)\n\nFrom these rules, we can say:\n\nloglg. 1 qa) =—log(lg,*g.)\"\") = -logig, *g,-1)\nPlugging this inta the equation for {a_,6,} yields:\na, = 6, = qexp|—(logtg. ge) + logig. ge.) V4]\n\n2.10\n\nThe Shortest Arc Quaternion\n\nStan Melax\n\nThis article shows a short routine called Astationare(). Given two vectors vy and pv,\nthis function returns a quaternion g where g*yg==»,. The implementation is fairly\noptimal and avoids a common numerical instability picfall.\n\nMotivation\nmee ee eee ee\n\nYou might be wondering where you would ever want 00 use such a function. Consider\na guided missile in your video game. This is an object chat uses orientation (3D0F),\neven though it is only the forward direction (2DOF) of this radial-symmetric object\nthat is important for its Al. As is the case for all rigid bodies, a quaternion g is needed\nto reoment this object from its current direction v, to the direction we want it to be\ngoing v,. Although we can choose from an infinite number of axes of rocation, it is\nbest to choose the obvious axis of rotation that minimizes the (arch angle af rearienta-\ntion—thac is, the obvious axis that is perpendicular ta both vectors. This routine is\nalso useful for implementing a “virtual trackball” for spinning objects with che mouse\n{as in a VRML viewer). The SpinLogo demo program included on the CD that\naccompanies this book uses RotationArc() co implement this feacure.\n\nNumerical Instability\n\nThis algorithm could easily be done by raking the normalized cross product to get an\naxis of rotation and then taking the acas{) of the dor product tx pet the angle\nbetween the vectors. This axis and angle would be fed into che constructor of a\nquaternion. However, that is not a good solution, because as the vectors 2 and », get\nclose together, the cross product (being propartional to the sin of che angle between\nthe two vectors) becomes small and potentially unstable when we wy to normalize it\n(see Figure 2.10.1). Deriving the angle can also cause grief. It is possible that taking\nthe dot product of nwo unit length vectors that are parallel can result in a small over-\nflow (greater than 1). ‘This can be problematic when deriving the angle. Try executing\nacos(7.00000001). In these cases, using the standard quarernion constructor char\n\n2.10 The Shortest Arc Quaternion 215\n\nV% Vi\nle sv\n\nFIGURE 2.10.1. Cross product shrinks as vectors converge.\n\naccepts an axis and an angle is mot appropriace. The solution is to generate the quater-\nnon in a more direct manner.\n\nThis problem first hit us during the development of the guided missiles for the\nvideo game MDK2 [Bioware0O). This is not an obscure problem that showed up only\nin our development. It has been noticed by many others and could happen co you.\nReal-Time Rendering [Moller99] briefly mentions the subject. This article provides a\nmore thorough explanation and provides code to add to the Gane Programming Gems\nmath library (or to your own quaternion library). If you want to avoid introducing a\nnasty bug, you should use the code provided in this article for generating a quaternion\nfrom two direction vectors.\n\nDerivation of Stable Formula\n\nFor this discussion, let ¢= [¢.¢,-¢,] = cross(2.0). and the quaternion qwe are trying to\nderive has the elements ¢,.q.-q.. The angle (unknown) between che ewo vectors (rp\nand »)) is. Let a be the dot produce 2 = dot(s,.e1);\n\nThe g.qp-4, components of a quaternion g have a length that is sin of half the\nangle (#2), As mentioned, the cross product's length is che sin of che anple ¢, There-\nfore:\n\nsin(t / 2)\nsin{s)\n\n$0 mow we have to determine a stable formula for che si(2!2\\simst) term. Recall\nthe half-angle formula:\n\n[q., Ty» Fel = le Fe |\n\nainfe { 2) = {Eee a\n\nand the circle identity:\n\n= 2\nAn +oo 2]\n\n216 ; Section? Mathematics\n\nThen:\nsin(s/ 2) - vil = cos(r))/2\nsin{t} 1 — cos*(e)\n\nWe know conf) vo be the det product (#) of the two vectors. Therefore, we replace\nit in the formula and continue the simplification:\n\nya-ai2_ | et ees\nvi-@ V20+a0—-a) Joea\n\nSubstituting back im:\n\n1 [ent yrtgl\nGor 7 po) =\n: 20+ 4)\n\nDeriving the g,, component (angle) of che quarernion is fairly straightforward\nusing the half-angle formula for cos(t2):\n\nrae colt | 2) = | et \" pte\n\nIn order te optimize our C++ function to use only one call to sqrt(}, we multi-\nply the inner square root term of our g,, formula by 2/2. Ag a result, che term within\nthe square root is now the same as for the other quaternion elements. In other words,\ngis dezived using the equivalent formula:\n\n- 3\nThese new formulas for our quaternion elements remain stable as # approaches\nv, and as the dot product @ approaches 1.\n\nRemaining Instability Condition\n\nNote thar this function still becomes numerically unstable as vy approaches —y). This\nis not surprising, because when vy equals —w, there is not a unique solution; any axis\nof rotation on the plane perpendicular no iy will do. Remember thar v, and p, are\ndirections, not orientations. A check could be added to the function in order to detect\nthis case and avoid the possibility of dividing by zero. However, we did not do this,\nbecause it is so unlikely that one would be calling this function in that case. The\nobjective of using a function such as this one is to orient an object toward a target.",
      "page_number": 205,
      "chapter_number": 23,
      "summary": "This chapter covers segment 23 (pages 205-212). Key topics include quaternion.",
      "keywords": [
        "sin",
        "quaternion",
        "cos",
        "Interpolating Quatemions",
        "Slerp",
        "che",
        "unit quaternion",
        "angle",
        "log",
        "slerp preserves magnitude",
        "vectors",
        "function",
        "product",
        "clarify che notation",
        "Shortest Arc Quaternion"
      ],
      "concepts": [
        "sin",
        "cos",
        "quaternion",
        "function",
        "functions",
        "vector",
        "angle",
        "derivation",
        "derive",
        "derivatives"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 22,
          "title": "Segment 22 (pages 207-219)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 6,
          "title": "Segment 6 (pages 103-120)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 16,
          "title": "Segment 16 (pages 148-160)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 6",
          "chapter": 14,
          "title": "Segment 14 (pages 235-252)",
          "relevance_score": 0.49,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 26,
          "title": "Segment 26 (pages 240-247)",
          "relevance_score": 0.49,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 24,
      "title": "Segment 24 (pages 213-226)",
      "start_page": 213,
      "end_page": 226,
      "detection_method": "topic_boundary",
      "content": "2.10 The Shortest Arc QGuatermnion 2if\n\neee\n\nConsequently, ry rarely approaches <2, but instead converges to », after repeated mis-\nsile-tracking Al updates.\n\nSource Code\n\nquaternion AotationArc(vector’ wO, vectors wi) {\nquaternion q:\nvO.normalize(); f/ Skip if known to ba unit leagth.\nvi.normalize(); // Oo only if needed.\nVEttord ¢ = CrossProduct(v,vi1);\nTloat df = BotProduct(voO,vi):\nTloat a = (float)sqret((i+d)*2):\nq.% 8 c.u f 8;\n\nq.¥ = c.y / 8;\nq.2=cG.2 / 5;\nq.w=e f2.0f;\nreturn qi:\n\nVirtual TrackBall\n\nAs a bonus, this article includes code for implementing a virtual trackball function.\nAlthough such functionality might noc be necessary in the user interface of your fin-\nished game, it is very handy during development to be able to grab any of your game\nobjects and spin them around with the mouse.\n\nAn cosy way of implementing object spinning is te rotate the object abour the }-\naxis When the mouse is moved parallel oo the X direction and about the X-axis based\non vertical (F) mouse movermenct. This method doesn allow for rotation abour the\naxis (normal to window), and ic simply doesn't feel “intuitive.”\n\n‘There are a variety of other user interface methods for spinning objects. This arti-\nde explains one simple approach, The old and new mouse positions (2D [X, ¥]) are\nconverted into rays (3D) chat point from che viewpoine into the window. Next, we\ndetermine where these rays would intersect a sphere around the object the user is\nmanipulating. [fa ray does not intersect the sphere, the closest point on che silhouerne\nof the sphere is used. The sphere is rotared so thar the point of intersection from the\nold mouse ray coincides with the point of intersection from the new mouse ray. This\nisachiewed by passing these two points (using the cenrer of the sphere as the origin of\nthe coordinate system) a3 input to RotationArc(). This returns the quaternion thar is\nused to adjust che object's orientation. The source code for the virtual trackball fune-\ntion and extracting che direction vectors from mouse input are available in the SpinL-\nogo source code on the CD that accompanies this book.\n\n218 Section 2 Mathematics\nReferences\n[BiowareO0) Bioware, Shiny, and Interplay Productions, MDK2, 2000.\n\n[Moller99] Moller, Tomas, and Haines, Eric, Regl-Time Rendering, A. K. Peters Led.,\nLo,\n\n3.0\n\nDesigning a General Robust\nAl Engine\n\nSteve Rabin\n\nCreating a multimillion-dollar game that spans several years of development is a\npretty big undertaking. The underlying structure of your Al engine will have huge\nimplications in terms of whar your game can and can't do. Therefore, rather chan let\nan engine simply evolve, it is best co build in generaliry and safety precautions from\nthe start, The generalicy allows you to make your AI characters do anything you can\ndream up. The safery precautions both prevent bugs and help you track them down.\nAfter all, the only thing standing between you and the ship party is a couple thousand\nbups.\n\n° The ideal Al engine helps solve a ton of problems for you. The following list con-\ntains just a few:\n\n1. Easily allow communication between game objects\n2. Offer a general and readable solution to implementing Al behavior\n3. Facilitate keeping debug records of every event (you want to catch all chose bugs,\n\nThis article consists of several parts. Any one part by itself might scem obvious,\nordinary, or insane, bur put together, these ideas create a very powerful system. So, as\nyou read through the article, try to keep in mind the big picture and how each con-\ncept interacts with the others. In addition, realize that the Al engine presented is\nimplemented in © as opposed to C++. (© was chosen on purpose to show that chis\nengine doesn't rely on any object-oriented code to work and is generally applicable,\n\neven to console development.\n\nEvent-Driven vs. Polling Objects\n\nAfter working on several games, you'll start to see some precty big patterns in Al\nengines. The first is that you need each of your game objects co update its logic every\ntick or so. The second is that these objects need to communicare with each other.\nThere are basically two ways for game objects to react in the world: by actively watch-\ning the world (polling) o: by sitting back and waiting for news (event driven).\n\n222 Section 3 Artificial intelligence\n\nSince games usually have hundreds of game objects in chem, the only reasonable\nsolution is to make the objects as cvent driven as possible. Imagine for a moment that\na missile explodes, causing area damage that affects 15 of so unies. Each unit could\npoll for nearby explosions every tick as though chey were actually aware of their envi-\nronment, or the exploding missile could simply tell cach unit chac it was hit and bow\nhard. Although it’s more cool oo chink that cach game object could sense its environ-\nment and react appropriately, the fact is thar the end result is the same either way.\n\nWith that quick-and-dirty analogy out of the way, you'll probably agree thar\n\nevent-driven communication is the way to go!\n\nThe Message Concept\n\nSince the poal is co have eventedriven behavior, we need to design a robust communi-\ncation system for making that happen. For nov, let's look at the concept of messages.\nFor our PUIposes, a mentee 1s an object that has five fields: a descriptive mame, che\nname of the sender, the name of the receiver, the time at which ic should be delivered,\nand any relevant data. IF 1 was handed a message, I should have all the informacion\nnecessary to pass it to the correct game object at the right time. The receiver of the\nmessage gets the message along with all of the goodies inside it, such as who senc it\nand any extra dara\nHere's an cxample of a message:\n\nnane:danaged, Tromidragon, to:knight, delivar_at_tima:245,.34, data:19\n(anount of danege)\n\nIn effect, messages become an electronic paper trail of what's happening in our\ngame. ‘This is a powerful concept that pives us all kinds of benefits. One of the incred-\nible uses of chis concept is chat we can recond every message that is sent and dump it\ntoa file. That way, if there’s a bug, we can look at the file and examine what triggered\ncertain actions, This ability becomes invaluable when the problem involves the inter-\nactions of tens of game objects over a fraction of a second.\n\nAnother great use of this concept is chat any pame object can “listen” to any other\ngame object's mesages. Since messages have the intended receiver built in, it's easy to\ndifferentiate who the message was meant for. Call it snooping, sniffing, or just peck-\ning, but this ability gives you the power to solve some tricky logic problems. Imagine\na manager game object thar owns several ocher game objects. The manager can then\nsnoop its children’s messages to listen for key events, such as members being attacked\n\nThe messages | am describing also have a field for delivery time. By sending mes-\nsages that should be delivered at a fucure time, we wrap a really cool timer system into\nthe mesage concept. In the real world, people and creatures usually have reaction\ntimes. By delivering messages slighely into dhe future, depending on che event, reac-\ntion times can be simulated. After all, dant you hate it when you're playing a game\n\n3.0 Designing a General Robust Al Engine 223\n\nand things tend to happen in lock-step, all ac once? Even within a single game object,\nit can send a message wo itself, to be delivered at a future time, in order to stagger\nbehavior changes. You could even fenerate a random time within some window in\nonder to add some much-needed chans.\n\nState Machines\n\nA state machine is a siraple Al concept thar delivers a lor of power with very litele com-\nplexity. The basic idea is chat a game object has a different state for cach main sepment\nof behavior it exhibies. The goal is to break down a game object's behavior into these\nlogical stares. In a baseball game, for example, the pitcher might have the states\nReadyForWindup, Windup, WairForHir, InterceptBall, CoverBase, and so on. Imag-\nine how useful it would be if ar any time during your baseball game you could simply\ndisplay on-screen the current and pase states of all nine players on the field. Alterna-\ntively, if you came across a bug, you could dump toa file all che past state information\ndlong with whac caused each state transition. For example, if your Tight fielder never\nresponded to the ball being hit, you can see why he wasn't in the night stare to listen\nfor that event. So, state machines not only break behavior into manageable bite-sized\nchunks, but they also give you instant access to che mindset or thoughes of your Al\nobjects.\n\nAn Event-Driven State Machine Using Messages\nee\n\nPutting these three major concepts together, we now have a powerful foundation for\nin Al engine. Individual behaviors are built using stare machines, whereas all com-\nmunication and event notifications are accomplished with messages. Note that each\ngame object running a state machine doesn't preclude it fom using fuzzy logic, neural\nhets, or any other exotic Al technique. The stare machines simply provide a standard-\nized peneric interface that can be exploited any way you like.\n\nAlthough state machines are a simple concept, let's review some important quali-\nties that would make a stare machine more elegant and more robust, Below is a cheek-\nlist of fearures we need:\n\n- The state machine can have an arbierary number of states,\n\n- States can be easily defined and ser.\n\nWhen a state is entered, we should be able to execute any initialization code.\nWhen a stare is exited, we should be able to execute any clean-up code.\n\nWe can easily listen for messages and execute any code in response.\n\nWe can easily listen for the update tick and execute any code in response,\n\nWe can wansparently record which messages have been received and whether\nthere was a response.\n\n- We can transparently record state changes and the message that criggered them.\n\n- We can listen fora message within only cerain states or globally over all states.\n\nON yp\n\nod\n\n224 Section 3 Artificial Intelligence\n\nTable 3.0.1 Paeudocode for State Machines\n—————————_——_—SSaa_——————————— —————— EE\n\nBevin StateMfachine Stans dhe stare machine defininion\n\nEedStateMachine Derminates the state machine definition\n\nStaret MamoOeS tate) Designates tbe begamnarig ofa particular Stare\n\nOErnter Responds co a state being entered; allows for initialtation code\nOnExit nds to a state being exited: allows for clean-up code\nOnU pdate : nds to the a re e tick\n\nOnhisp(NameOt Message) Reiponds to any defined message\n\nSerStace(Name()Srare} Changes states: sends OnExit to old state amd QnEnter to new state\n\nSendM Seni: message to any game abject\nSend Delayed Mse() Sends a delaped message to any game object\n\n10. We can send messages to any game object, including ourselves,\n11. We can send messages with a delay built in so char the message is delivered at a\nfuture time.\n\n12. The overhead for running the state machine should be minimal.\n\nOur state machine needs to support all these fearures. Table 3.0.1 is pseudocode\nfor all the constructs we'll need.\n\nIn order to make chis concept concrete, let's look at an example of a sentry robot\nbent on killing. Ler’s also use the pseudocode from Table 3.0.1 to represent our stare\nmachine, Chur state machine has two states: Pacrol and Amack. However, the scare\nmachine stars out in none of these states, Instead. a global section ar che top of the stare\nmachine is ahways active, regardless of the current state. When the stare machine runs\nfor che first time, the OnEnter response is triggered, Inside this response, che first state is\nset with a SetState command. In chis example, it sets che starting state to Patral.\n\nBeg instateWachine\n\n//Global Responses\n\nOnEnter {\nSetState( STATE_Patral }\n\n}\n\nOnMsg( WSG Bead | {\nf/Destray this gama object\n\n}\nStatet STATE Patrol } 7\nOnEnter {\nifSat initial goal point for patrol\n}\nOnUpdete {\n\nif{ /*see the enemy*; }\nSetState( STATE_Attack }\nelse if( /*goal point raached*; }\n\n3.0 Designing & General Robust Al Engine 225\n\ni/set next patrol point as goal\n}\n}\n\nStete( STATE_Attack } {\nOnEnter {\nffSet goal to be aneny\n\nI\nOnlipdate {\nif{ /*enemy dead*/ }\nSetState! STATE_PATAOL }\nelse if] /*enemy within weapon range*/ }\nffShoot enemy\n}\n\n}\n\nEndStateWachina\n\nSince this state machine is even driven, the only way it executes is by getting a\nmessage. It can get a message when a state is first entered (oninter), when a stare is\nexited (OnExit), when a game tick occurs (OnUpéate), or on any other defined message\n(Onmsg y).\n\nWhen looking at the state machine, envision a message being delivered to it. The\nmessage first goes to the currenc stare, [f there is a response for that message, the mes-\nsage is consumed and the response is executed. If there is no response for the message\nin that state, the message is resent to the global responses at the top of che state\nmachine. ‘This behavior creates a powerful stare machine concept: the idea thar indi-\nvidual states can have message responses or thar you can have a global response to a\nmessage, regardless of the current state, Even more powerful, you can have a global\nresponse (0 a mestage while sometimes overriding that response within certain stares.\n\nBecause there are these global message responses, a stare change might happen\nfrom outside the current state. For this reason, the OnExit message response is crucial.\nIfa global message response changes the current state, you can rely on getting che\nOnExit message in the current state to clean up anything before the stare is actually\n\nchanged,\n\nConfession Time\n\nNow I have a very big confession to make. The pseudacode you just examined der\ncompile with a normal C compiler! (That is, it docs so provided some comments are\ntutned into real code.) All you need to do is use these macro definitions and place the\nstate machine within che following function:\n\ndefine BaginStateMachine if{ STATE_Global == state } {\n\nSdefine Statela) if(O) {return( true }: } } 4\nelse if{ a == state } { af(0} {\nSdefine OnEnter return tre); } else af¢ 4\n\nMSG_AESERVED Enter == fag->name } {\n\n226 Section 3 Artificial Intelligence\n\ndefine OnExit return({ true jj } #lse ify 4\nM5G_AESEAVED Exit == msg->name } {\nfdefine OnUpdate return{ true ji } | else ifi 4\nMSG_AESERVED Update —- msg-sname } ¢{ 1\nfdefine OnWsg(al} return, true j; } \\\nelse if{ =2 fag-snane } {\nfoeting SatStatela) SetStatelmiamedbject( go, (intja };\n\n#defing EndStateachine return] true }; } } 4 else { assert)\n!\"Invalid State\" ; \\\nreturn( false };} return( false }:\n\nbool ProacessStateWachine( GaneObject*® go, unsigned int state,\nWegobject* asqg }\n{\n\nff! Put State machine inside this funetian!\n}\n\n(-style macros are a funny thing. Normally youd want to stay away from them\nbecause they can be misused ancl lead to bugs. In this case, we can exploit macro def\nINitiOns to COMSEMUCE a new state machine language! We certainly don't have to use the\nmacros to make the state machine work; it simply makes the coding more error free,\nsimpler to read, and faster to write. Now char's a good use for macros!\n\n‘You might have noticed that a bunch of return statement are embedded in the\nmacros. Conveniently, these return starements report whether a message was handled\nor whether it fell through withour being consumed. This information is critical for\nknowing whether a message thar wasn't handled in a local stare needs to be sent to the\nglobal responses, The return value also helps log whether or nor a particular message\nwas handled by the state machine.\n\nAnother Small Confession\n\nIhave another small confession. The macros are constructed so that you don't need to\nuse all chase curly braces! The braces are there to make che stare machine more C-like,\nbut they aren't needed ar all. By not using the curly braces, you can make the scate\nmachine more elegant and perhaps more readable. The following ix an example state\nmachine without the curly braces:\n\nBeginStateWachine\n\nCnEnter\nffInitialization sede here\nOnvsg( WG SomeMessage }\n//REEDONSe code hore\n\nState( STATE_Boan }\nOnUpdate\n//Update code hare\nOnEXit\n\n2.0 Designing a General Robust Al Engine 227\n\nf/Cleanup code here\n\nEngStatavaehine\n\nState Machine Building Blocks\n\nThese C macros were constructed very carefully in onder to make something cool hap-\npen. Think of them as building blocks thar can be stacked however you like. Because\nof this stacking ability, che minimum you need ix the following:\n\nBeginStateWachine\n\nEnd2tateWachine\n\nFrom this minimum, you can add stares and listen for any messages within those\nstates. Since it's not required to have stares ar all, you could simply have message\nresponses!\n\nThe state names and message names are simply enumerated types—in effect,\nunsigned integers, Since simple if-else starements replace che macros, the procesing\nrequired is quite minimal.\n\nState Machine Message Routing\n\nQM course, there's a bir more support code to roure messages and make this stare\nmachine work properly. Figure 3.0.1 shows an overview of the structure.\n\nThe only outside source of messages co the game objects comes from the player\ninput and the game tick update loop. Other than those, messages are spawned by the\nstate machines themselves. When a message is sent, it always goes co the message\nrouter. The router then sens it through the game object and on to the state machine\n\nMessage Rooter\n\nFIGURE 3.0.1. Oveniew of FICsSage MMIULE,\n\nSection 3 Artificial intelligence\n\nthat the game object owns. In case a message should be delivered at some time in the\nfuture, the router hangs on vo ic until che delivery time has passed.\n\nNerte that in Figure 3.0.1, owo different game objects point to the same state\nmachine. Obviously, if you have nwo or more objects thar should behave the same,\nthey should execute the same exact code. Therefore, it's important to recognize that\nall variables and state information are stored inside the game object and nor the state\nmachine. Multiple game objects use the same state machine, so you should always be\nconscious of that fact.\n\nIn onder to explain the message router and state changes, we need to know more\nabout some variables inside each game object and message object. The following is the\nbare minimum definition of cach:\n\ntypedeT atruct\n\n{\nunsignad int unique id;\n\nffState machina info\nStateWachinelD state machine id:\n\nunsigned int state: {ifthe currant state\nunsagned int néext_state; ifthe next state\nbool force _state_ change; (fhas 6 state change been\n\ni irequested\n\nJ/Put other gaae object info in hare\n} Ganeojact;\n\ntypedef struct\n4\nMSQNBME mame: ‘fame of message\nunsigned int sender_id-\nunsigned int receiver id:\nfloat delivery time: iideliver message at this tine\n\nffRote that the sender_id and receiver_id are not pointers to\n(fgane objects. Singe messagaa can be delayed, the sender or\nffreceiver may get removed from the gane and a pointer would\n(fbecone dangerously invalid.\n\nff¥au can add right here any data you want to be passad\nffalong with every massage — sometimes it's helpful to let\n(fetsiges convey gore info by using extra data,\n\n(fFor exasple, a damaged message could carry with it tha\n{famount of dane.\n\n} MagObject:\nThe following is the code that is called when a stare change is requested. Nore\n\nthat the stare change is asked for and doesn't occur uncil the current message is done\nbeing handled. In addition, realize chat this function is called by the setstate macro.\n\nwoid SetStateInGameObject( GameObject™ go, unsigned int state j\n\n2.0 Designing a General Robust Al Engine 229\n\nQo->next_state = state:\ngo->foree_state change = true;\n\nI\n\nThe rower takes a formulated messige that's ready ro be sene and makes sure it\ngets senc to the righe states. Ic also deals with changing states if a request has been\nmade. You can see che code for the router in Listing 3.0.1. Since the router needs to\n\ndeal with delayed messages (a concept that is explained later in this article), che func-\ntions it references are in Listing 3.0.2,\n\nSending Messages\n\nIn order to send a message from inside a stare machine, it would help if there were a\nsimple function to call. The following is an example of a send message interface:\n\nveid SendMsg( Megane name, unsigned int sender, unsigned int\n\nreceiver }\nMsg0bject msg:\nMeg.name = mane; / {The name of the neeeage\nMeg. sender = sonder: fiThe sender\nmeg.receiyver = receiver: ifthe receiver\n\nmeg.delivery time = GetCurTime(); //Send the message NOW\n\nhouteWecsage( amsg }\n}\n\nNote thar when a message is sence, the state machine immediately roures it to the\nintended receiver. This is a great feature for debugging because a breakpoint inside a\n\nstate machine lets you see the stack and, consequently, who sent che message,\nSending Delayed Messages\n\nAs mentioned before, messages can be given a future time co be delivered. The rourer\ndeals wich this command by storing delayed messages for future routing, Somewhere\nin the main game loop, che function SendOelayadMessages needs to be called so char\nthe messages are eventually sent at the correct time. The following is the interface\nfunction for sending a delayed message:\n\nwold SendDelayogWsg( MagName name, float delay, unsigned int sender,\nunsigned int receiver )\n\n4\nKestbject msg;\nhig. hime = name: {/The nema of the sessage\nhag. sender = sander: {ithe sendar\nfag-receiver = receiver; {The receiver\n\nnag.delivery time = GetCurTime() + delay; //Send a future Neseage\n\n230 Section 3S Arthicial intelligence\nRouteMessage( &msq }:\n\nNote chat all messages contain the sender and receiver as unique [Ds, nor as\npointers. Since messages can be delayed, it’s possible thar the sender or receiver has\nbeen removed from the game. Since a poincer has no way of knowing this, it's noc safe\nto reference the game objects by a pointer only. Instead, the receiver of the message is\nlooked up using its unique ID. This method ensures that mesages are sent only co\nvalid game objects.\n\nDelayed messages arc an incredibly useful teol for the state machine. Consider\nthe following state machine for a heat-seeking rocket, The rocket is fired, and if it\ndoesn't contact anything within five seconds, it should automatically explode. This\ntask is accomplished by sending a delayed message (wSG_Se1fDestruct) when the stare\nmachine is initialized. After five seconds, the message is delivered to the state machine\nand consumed in the global responses. Ac thar time, the state is set to Explode, and\nthe rocket vall soon be history.\n\nBeginstatemMachine\n\ni fGlobal Aeeponses\nOnEnter //Triggered when state machine first starts up\nSandbelayedMsg( MSG_Selfestruct, 5.0, go-*unigque_id,\npo-SLnigque id ps\nSetState( STATE_Arned 3;\n\nOnlsg[ MSG Selfbestruct |\nZatitate( STATE_Explode };\n\nStata STATE_Armed }\nOnMsg( MSG Collision }\nSetState{ STATE _Explode };\n\nOnligdate\nfifidentify closest visible enemy and steer toward\n\nState, STATE Explode }\nOnEnter\nff/Esplode rocket - cause area damage\n‘(Delete game objact\n\nEnds tateWaching\n\nDeleting a Game Object\n\nDeleting a game object from within the state machine takes a little thought. Since the\ngame object owns the state machine, we cant delete ic while we're executing code\ninside the state machine. The solution is co set a flag identifying chat the game object\nshould be deleted. When the execution steps outside the state machine, it’s then legal\nte delete it,\n\n3.0 Designing a General Robust Al Engine 21\n\nEnhancement: Defining the Scope of a Message\n——— a\n\nA problem that creeps up is that sometimes a message is valid only inside a particular\nstate. Unfortunately, the potential exists for a delayed mesage to be consumed by the\nwrong state. Consider the following code:\n\nBeginstatemachine\n\n' {Global Responses\nOnenter\nsetitate( STATE_Aliva 3\n\nState( STATE_Alive }\nOmnEnter\nSendDelayedisg( MEG Tinedut, 3.0, go-=unique_id,\ngo-sunique_id );\n\nOnMso( MSG_Tinedut }\n‘iPlay & Sound\n\nOnMeg( MSG Dead }\nSetatate! STATE Dead |:\n\nState{ STATE Dead )\nQnEnter\nSencdtlayadWsg( MSG_Timedut, 50.0, go->unique id,\ngo-Sundque_id };\n\nOnllsg( MSS Tinetut )\nSetState( STATE_Alive };\n\nEndatateMachine\n\nThe problem is that both states send and respond co w8G_Tinedut. If the Alive\nstale pets a MSG_Dead before it gets back che wSG_Timedut, the Dead state then incor-\nrectly gets the WSG_TimeQut spawned by the Alive state. This was clearly not intended.\n\nThe solution is to mark a message as valid only within a particular state. If the\nstate is no longer active at the time of delivery, the message should be thrown away. In\neffect, the message now has a scope and is valid only within chat scope.\n\nThis enhancement can easily be added with an extra variable called “stare” inside\ncach message object. When the message is delivered, it first checks whether che mes-\nSage ‘state’ marches the current state of the game object. Only then is the message\ndelivered. However, most of the time you want messages to he delivered regardless of\nthe current state, so messages should default to not performing this checks.\n\nSince only delayed messages sent to yourself should ever be marked with a stare,\nwe can create 2 new helper function for sending that particular kind, The following is\nan example of the code. (If this enhancement is made, the other send message func-\ntions need ro mark the message stare as invalid.)\n\n232 Section 3 Artificial Intelligence\n\nvoid SendbelayedisgToCurrentState( WagName name, tloat delay,\nGanelbject™ go }\n{\nMeploject nap;\nNeg.ame = name: ffTh® mame of the message\nNEQ.State = Po-+5tate: fi The state in which the msg is valid\nMeg.sander = go->unigue_id; i/The sender\nmepg.raceiver = go-sunique id; J/The receiver\nmeg.delivery tine = GetCurTime() + delay; /sSend a future message\n\nRouteWessage( Bnsg )j\n\nEnhancement: Logging All Message Activity and\nState Transitions\n\nWith the current structure, it’s wrivial to snoop the current state of each game object\nand perhaps display it on screen. You could even watch all the message eraffic that\ncomes through the message router and display that on screen. Bue for real hard-core\ndebugging, the ideal situation is ro individually track each game object, logging all\nmessage activity and state transitions along with a time stamp. Surprisingly, this task\nis easy to do,\n\nThe trick is to modify the stare machine macros. When we insert some simple\nfunction calls into che macros, the task of monitoring every state machine becomes\ntransparent. The following macros log message responses and state transitions:\n\nfdefine OnEnter Feturnd trug Jr 4\nelise it{ Ma _RESEAVED Enter == msg->nanme } {4\nLogWassagel ga, @8g, GetCurTimed) 3:\n\n#define OnExit return( true ji } 4\nelse if{ MSG_RESEAVED_Exit == msg->nane } { 4\nLogWessage( go, @99, GetCurTimal) }:\n\n#oetine Onlpdate réturn( true ji } 4\nalse if WEG RESERVED Update == msg->name | { \\\nLogWessage( go, #89, GetCurTime() };\n\nfiating OnWsg(a) réturn( true jr } 4\nalse iff a == msg--name } { 4\nLogWesesage( go, mag, GetCurTime() };\n\nfidatine SetState(a) SetStateInGanefbject( go, (inthe j: 4\nLogitateChange( go, state, (intja, GetCurTime() }:\n\nThe functions Laglessage and LogStateChange can store the informarion in\nwhatever way youd like. One suggestion is to keep a circular buffer of history dara for\neach game object. You can then either browse che history on screen or dump it to a\nfile when something interesting happens. Since each event is time stamped, you could\ncompare the logs of different game objects to see how rhey interacted. As mentioned\nbefore, this feature is incredibly helpful if there are three or more game objects all",
      "page_number": 213,
      "chapter_number": 24,
      "summary": "This arti-\nde explains one simple approach, The old and new mouse positions (2D [X, ¥]) are\nconverted into rays (3D) chat point from che viewpoine into the window Key topics include state, message, and objects.",
      "keywords": [
        "state machine",
        "State",
        "Message",
        "game object",
        "State Machine Message",
        "machine",
        "game",
        "object",
        "current state",
        "stare",
        "che",
        "che state machine",
        "MSG",
        "message responses",
        "time"
      ],
      "concepts": [
        "state",
        "message",
        "objects",
        "machines",
        "game",
        "code",
        "coding",
        "stares",
        "msg",
        "time"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 19,
          "title": "Segment 19 (pages 161-168)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 20,
          "title": "Segment 20 (pages 385-402)",
          "relevance_score": 0.45,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 19,
          "title": "Segment 19 (pages 367-384)",
          "relevance_score": 0.44,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 44,
          "title": "Segment 44 (pages 418-425)",
          "relevance_score": 0.43,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 11,
          "title": "Segment 11 (pages 111-118)",
          "relevance_score": 0.42,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 25,
      "title": "Segment 25 (pages 227-237)",
      "start_page": 227,
      "end_page": 237,
      "detection_method": "topic_boundary",
      "content": "3.0 Designing a General Robust Al Engine 233\n\ninteracting over a fraction of a second. Very complex interactions are mow casy §O\ndebug.\n\nEnhancement: Swapping State Machines\n\nWithin complex characters, it's very hard to design one stare machine that serves all\npurposes. The solurion is to make bite-sized state machines that are more manageable\nand more specialized. With this functionality, a character can choose to run the state\nmachine thar best fits the situation, This function avoids overly complex state\n\nmachines char became unmanageable,\n\nEnhancement: Multiple State Machines\n\nThere is no rule chat a game object can run only one state machine at a time. In fact,\nits quite useful for an Al character to run several state machines simultancously.\nImagine that each character has one state machine that serves as the brain and one\nthat serves to keep crack of the movement goals (not the movement execution). The\nbrain could even control che movement state machine by sending it commands in the\nform. of messages.\n\nSince not all types of movement are the same, you can apply the idea of swapping\nstate machines. The brain can then run the appropriace movernenc state machine that\nfits each given situation.\n\nEnhancement: A Queue of State Machines\n\nThe dedicated mavernent state machine brings up an interesting enhancement, It\nwould be incredibly powerful to be able to queue up several movement state\nmachines. In this scenario, only the top one on che queue wauld be active; the others\nwould be temporarily disabled.\n\nThe idea is that maybe a player has directed an Al character to go to three sepa-\nrate places in succession (think RTS), For each Spot, a separate movement state\nmachine would be thrown onto the movement queue. As the first state machine\nreaches its goal, it destroys itself, and the next state machine on che queue becomes\nacuve. This approach actually solves a large number of command issues in RTS\n\nee.\n\nConsider the act of patrolling. Parrofling is going to a sequence of places and re-\npeating that pattern over and over. By employing the state machine movernent queue,\neach patrol spot can be placed on the queue. However, when a state machine reaches\nits goal, it needs to put itself on the back end of the queue in order ro maintain the\ncrcle.\n\n234 Section 3 Artificial Intelligence\n\nScripting Behavior Outside the Code\n\nThe AI engine described in this article is clearly not scripted fom ourside the code.\nHowever, that fact doesnt exclude a programmer from cleverly influencing che behav-\njor through the use of ourside dara. IF we create variables chat impact decision making,\na state machine can be customized for a particular character. In fet, many characters\nshould be able to use the same state machine yet have wildly differing behavior due ro\nattributes such as aggrestivencss or fear,\n\nInterestingly, the original implementation of this Al engine supported state\nmachines scripted solely outside the code. Puring the logic outside the code creared a\ndebugging nightmare for everyone involved. The original intentions were admirable,\nbur the result was 2 frustrating programming environment that wasted many people's\ntime,\n\nThe lesson to learn was that logic should be inside the code and data should be\noutside. Unless the design goal is to let users write their own Al, there isn't a com-\npelling enough reason to support arbitrary scripting of Al behavior. (For a more\ndetailed discussion of data and scripting, look ar the article “The Magic of Data-Dri-\nven Design” in this book.)\n\nConclusion\n\nEven if you never use chis exace implementation of an Al engine, many of the Ereat\nideas presented here can be applied 0a any Al engine or stare machine. Some of the\nmore notable ideas are as follows:\n\n- Standardized communication with messages\n\nStandardized imers throwgh the use of messages\n\n- Using event-driven methods as opposed to polling\n\n‘Tracking communication and state changes over all Al objects\n\n- Using global responses in state machines thar are always active, regardless of rhe\nCunenk stane\n\n. Allowing a global response in a state machine w be overridden by the current\nstate\n\n7. Allowing an Al to swap stare machines\n\n8. Allowing an Al to simultaneously run multiple state machines\n\n9. Allowing an Al to quewe up several state machines\n\n10. Keep complicated logic inside the code as opposed to scripting it from ourside\n\nThe Al engine as presented here is a powerful tool for enforcing a standard sruc-\nture on Al objects, Because of the macro state machine pscudolanguage, it’s incredibly\nquick and easy to prototype new behaviors. It’s so easy in fact, thar there is a real ten-\ndency to put too much code inside the state machine. The challenge comes in deciding\nwhere to draw the line. As a general rule, probably only high level decision-making\n\nigh Wwf\n\nos\n\n3.0 Designing 4 General Robust Al Engine 235\n\nsould be held within the state machine. Other systems of an Al character, such as\nmovement execution and animation. should certainly exist elsewhere.\n\nListing 3.0.1: Message Router\n\nWold Aoutelessage( MSG Object* msg }\n\n{\n\n}\n\nGameObject* go = GetGOFromIO( cur_mag->receiver_id }; //Funetion not\ni {supplied\nif( !qo }\n{ Jffeceiver doesn't exist anymore - diseard the message\nPeLUrn;\n}\n\nif( msg--delivery time > GetCurTime() }\n\n{ J/iThis message needs to be stored until its time te send it\nStoreDelayedWessage( msg 3\nreturn;\n\n}\n\nif( RouteWassageHelper( oo, go->state, msg } == false j\n\n{ #/Currant state didn*t handle msg, try Global state (0)\nRouteliassageHelper( go, 0, még );\n\n}\n\nJi Chack for @ state changa\n\nwhile{ go->forca_state_change }\n\n{ /fNote: circular logic (state changes causing state changes)\nffcould cause an infinite loop here - protect against this\n\nHMGreate & general msg for initializing amd cleaning up the state\nfchenepa\n\nMeg0bjact tenpnsg;\n\ntempmeg.receiver = go--umique id:\n\nTempmsg.tender = go-*unique_id:\n\ng0->Torce_state_change = false;\n\nifLet the last state clean-up\nTempmeg- name = WG RESEAVED Exit:\nROuteWessageHalper( go, go->state, Btempmsg 4;\n\n‘(Set the new state\n@0-setate = go-snaxt_state;\n\nfflet the new stata initialize\nTEeNphsg.name = 5G AESERVED Enter;\nAouteMessageHolper( go, go->state, Etenpmag };\n\nbool RouteMessagekalper| Gamedhject* go, unsigned int state, Wagobject™\nmsg }\n\n{\n\n236 Section 3 Artificial Intelligance\n\nPfLOSk Up correct state machine for this Game Object\nfad Send mesgage to that particular one\n\nii(et inplemented here - this always calls the same one}\nreturn{ ProcessStateWachinal go, State, meg ) ;\n\nListing 3.0.2: Functions to Deal with Delayed\nMessages\n\nvoid StoreQelayedMessage( Wag0bject™ msg )\nfiStore this message (in some data structure) for later routing\n‘fA priority queve would be the ideal data structure (but not required)\nita store the delayed messages - Check out Mark Neleon's article\nfi\"Prierity Queues and the STL° in the January 1996 Or. Dobbs\" Journal\n(fhttp: //www.dogma.nat/markn/articles/pq stl/priority.hta\nffiiete: In main gama loop call Sendbelayedwessages() every gam\nff tick to chack if its time to send the stored messages\n\n}\n\nwoid SendtelayedMessages( void }\n{ f/This function is called every game tick\n\nwhile{ /\"loop through all delayed mossages*/ }\n{\nif( cur_msg->delivery_tine <= GetCurTina{) )\n{\n\nRouteWessage! curmsg };\nRenoveDelayedWessage cur_msgq |;\n\n}\n}\n\nwoid RengveDelayadMassage( Messagefbject\" msg |\n\nfifienove this massage from the delayed messages data structure\n\nReferences\n\n[LaMothe?5] LaMothe, Andre, “Building Brains into Your Games,” Gare Developer,\nalso available online at www.gamasutra.com/feamres/programming/061997/\nbuild_brains_inco_games.htm, August 1995.\n\n[Nelson$6] Nelson, Mark, “Priority Queues and the STL,” Dr. Dobbt Journal, avail-\nable online at www.dogina.net!markn/articles!pq_suliptiority,htm, January 1996.\n\n[Moodcock99] Woodeock, Steve, “Game Al: The Seare of the Industry\" Garne\nDeveloper, also available online at wwew.gamasutra.com/features!19990820/\nFame_ai_Ol hem, August 1999,\n\n3.1\n\nA Finite-State Machine Class\n\nEric Dybsand\n\n‘This article defines a generic finite-state machine (FSM) C++ cass. Fld are eom-\nputer science and mathemarical abstractions thar have been useful for many years ina\nvariety of ways. This article is not a discussion of the theory behind the FSM; instead,\nIT téa simple presentation of a basic building-block tool, the FSMelssr which you can\nuse to help develop your own complex artificially intelligent decision-making\nprocesses in your computer game,\n\nThe first thing you should know abour FSMs is char chey are simple machines\nthat consist of a finite number of stares (obvious, don't you think?). A seate is really\nonly a condition, For instance, consider a door; its states can be apen or closed and\nlooked or unlocked.\n\nThe next aspect one should know about FSMs is char there is an fipet to the\nFSM, which affects a sate sransition from one state to another. An FSM ean have a\nsimple (or complex) stare transition function that determines what state will hecome\nthe currens sare,\n\nThe new current stare is called the enter state of the mate transition of the FSM,\nor the stare to which the FSM has transitioned based on the input. If chis concept is\nconfusing, again think of a door as an cxample FSM. When the door is in a dosed\nstate and a locked state, perhaps the inpur of see bey will cause the door to transition\nto the unlocked stare (the onepur crave of the state transition and the mew current stare\nof the door). Then the input of ase And will cause che door to wansition to the open\nstate. When the doer is in the open state, the input of see Adama will transition the\ndoor back to the closed state, When the door is in che closed state, the input of ree dep\nwill cransition the door back to the locked state. While the door is in the locked state,\nthe input of ws Ave would fail co transition che door te the open stare, and the door\nwould remain in the locked stare. Furthermore, once the door was in the open state,\nthe input of use fey would fail to cransicion the door co the locked stare.\n\nSo, in summary, an FSM is a machine that has a Spite memder of states, one of\nwhich is 2 curment sate, The FSM can accept input chat will result in a sate sransition\nfrom the current state to an owtput state, based on some state transition Jfenction, and\nthe oatpar sate then becomes the new current state.\n\nNow, how does this concept apply to Al in computer games?\n\nSection 3 Artificial intelligence\n\n‘The answer to that question is that the possibilities are really endless! ESMs can\nform the basis for managing the pame world, simulating the emotion of a nen-player\ncharacter (NPC), maintaining the status ef the game, parsing input from che human\nplayer, or managing the condition of an object.\n\nConsider the attitude of an NPC monster in an adventure game, for cxample,\nLet's say that the monster can have the following states: berserk, rage, mad, annoyed,\nand uncaring. Furthermore, let's say thar you have AI game code that does different\nthings based on the state of the monster's attitude. We ean use an FSM to manage the\nmonster's attitude and the way it transitions from one state to another based an inpur\nfrom the game itself. Let's furcher say that inputs are pdeyer seen, player attacks, player\ngone, monster burt, and monster healed, Then the state diagram shown in Figure 3.1.1\ncan be drawn.\n\nUsing these inputs and stares, we can set up a state transition matrix that looks\nsomething like the one shown in Table 3.1.1.\n\nTable 3.1.1 A State Transition Matrix for the Monster Game\n\nCurrent State rut Output State\nInca rine layer seen iipoyed\nu Meco player armacks mad =\nmiacd monster hurr _fage\nria monster healed uinearin\nrage monsrer Burt berserk\nrage manster healed annoyed\nberserk fmenster burt beeper\nberserk indnaster healed ra\naT layex uncarin\nannoyed player antacks rabiee\nannoyed monster healed uncaring\n\nPlater dteacks\n\nPlover Gene ox Memstus Haskd\n\nPlayer Ablacks\nFIGURE 3.1.1. A sample finire-state machine.\n\na1 A Finite-State Machine Class 230\n\nSo, depending on the current state of the monster's attitude and the input co the\nPSM, the attitude of the monster will change. Game code that performs behavior\nbased on the attitude of che monster will then cause the monster to act differently.\n\nObviously, we could add more state transitions, based on more states and inputs.\nDoing so would affect how our monster's attitude is evaluated and determined, and\nthar is how we create the Al thar uses this monster's attitude.\n\nThe FSMeclass and FSMstate\n\nNow how do we put this idea to work? That is whar the FSMclass and its subordinate\nFS$Mstate class will show in the following implementation, as illustrated in Figure\n3.12,\n\nThe FMclass provides structure for any number of stares that are provided by\nthe FSMstate class. These ewo classes work with each other eo provide the functional-\nity for 2 generic finite-state machine. A generic FSM implies that these objects are gen-\neralized, able to support a variery of types of states, a variety of types of stare\ntransitions, and any number of stare transitions, as well as any number of states within\nthe FSM. With such variery and generalization as a design goal, these classes and their\nmembers were selected az you see in the following discussion,\n\nDefining the FSMstate\n\nHere is the class definition we use to representa state for our FSM:\nclases FiMstate\n\nunsigned m_ustumberotiransitions:; ff mexi0e number of states\n/f supported\nint *m_pilnputs; ff input array for transitions\nint \"m_pidutputstate; /f output state array\nint m_istatelD; ff the unigue ID of this state\npublic:\n\nfi ganstructor accepts an ID for this state and the number of\ni} transitione to support\n\nFoustate{ int istatelD, unsigned usTranaitions };\n\nfi destructor cleans up allocated arrays\n\n-FaMstatel);\n\nif @oetss the state Io\n\nFohstate\nFSMclage Aa number of FEMfstabes\n\nFIGURE 3.1.2. The FsMedass can use any number of PSMstares.\n\nSection 3 Artificial Intelligence\n\nint GetiIo() { return ®_iStatelo; f\n\nff add a state transition to the array\n\nvoid AddTransition{ int iinput, int i0utputID };\nff remove a state transition from the array\nvold DeleteTransition{ int igutputID };\n\nff get the output state and offact a transition\nint Getoutput( int ilnpat };\n\nSee Listing 3.1.1 for the FSMstate class constructor and destructor implementa-\nmons,\n\nThe member variables and functions of the FSMstare class are as follows.\n\nThe Falistate::n_usNumberOftransitions controls the number of state transi-\nHons that this stare is able to support. Seating this valuc also determines the size of the\ninput and output arrays. Since we are creating a “finite” state machine, this value sets\nthe finite-state transition limit for chis scate.\n\nThe FStstate: im _pilnpwts is an ary of m_usNunbarOfTransitions size char\ncontains the input values to be used during state cransition. The input array is used by\nthe state transition evaluation function co compare to the input received and deter-\nmine the coresponding output state.\n\nThe Foustate::m_piOutputstate is an array of mwsNumberOfTransitions size\nthat contains a comesponding ourpur stare identifier that indicates the new transition\nstate during a state cransition.\n\nThe Féustate::n_i$totel0 isa unique identifier used to identify this instance of\nan PSMstate and is the value char would be ouput by any transition to chis stare fom\nanother state.\n\nThe Faustate::GetlD(} provides public access to che unique identifier of this\nanstance of the FSMstare class. See class declaration for this implementation.\n\n‘The Fawstate::AddTransition(} provides a means to add new inpur values and\nOUurpUL state arrays to this instance of the FSMstate. See Listing 3.1.2 for this imple-\nmentation.\n\n‘The Feustate::Delet oTransition() provides a means to delete an existing input\nand its corresponding owtput state identifier. See Listing 3.1.3 for this implementa-\nron.\n\nThe Feuistate::Getutput() provides the state transition function that uses che\ninput value oo determine the transition output state identifier and return it. See List-\ning 3.1.4 for chis implementation.\n\nDefining the FSMclass\n\nSew we need the actual FSMclass implementation. The FSMclass works by main-\n\ntuning a collection of FSMstate objects.\nclass FoMclags\n\nState Map nmap; {/ Gap containing all states of this FSM\n\n2.71 A Finite-State Machine Claes P|\n\nint m_iturrent$tate; // the m_iStatelD of the current state\n\npublic:\nFSuiclass( int iStatealp }; i/ set initial state of the FSU\n—-FoMolass | )5 ff clean up memory usage\n\nff return the current state Io\n\nint GetCurrentstate() { return m_iCurrentState: }\n\nff set current stata\n\nvoid SetCurrentStata( int istateID } { m_iCurrentState = istatelo; }\n\nif return the FSWstate object pointer\n\nFoustate “GetStatel int LStateID };\n\n{f add a FaMstate object pointer to the map\nvoid Addatate( FSlistate *pState |;\n\n{i delete a FSWstata object pointer from the map\nvoid DelateState( int istateall };\n\n{/ perform state transition based on input & current state\nint StateTransition{ int ilnput }:\ni\n\nSee Listing 3.1.5 for the FSMelass class constructor and destructor implementa-\ntion,\n\nThe member variables and functions of the FS Melass class are as follows,\n\nThe Faéelass::m_map is the collection of FSMstate objects (pointers to FSMstare\nobjects, in this case) and is implemented from an 5TL <map>:\n\ntypedef map< int, Filetate*, less<int> > State_Map;\n\nA discussion of the specifics of STL and <map> collections in general is beyond\nthe scope of this article. For information abour STL, please see the Gem “Using che\nSTL. in Game Programming, The above function declares State_Map to be an STL\n<map> with an int for a key; the map contains pointers to FSMstate objects, and the\ncomparison function to use during access is the less<> operator for ints.\n\nThe F5Wclass::n_idurrentState is che stare identifier for the FSMstate object\nthar is considered co be the current stare of the FSM.\n\nThe Fsiiclass::GetCurrentState() provides public access to the unique idenci-\nfier of che stare of the current PSMostace object. See class declaration for this imple-\nmentation.\n\nThe FaMiclass::SetCurrentstate() provides public access to set the unique iden-\ntier of the state of a mew current PSMstate object for the FSM. See class declararion\nfor this implementation.\n\nThe FeMclass::Getstate() provides a method to obtain a pointer to any FSM-\nstate object contained within the FSM. See Listing 3.1.6 for this implementation.\n\nThe Fatclass: :AddState() provides a method for adding FSMobject pointers to\nthe <map> contained within the FSM. This is the method that one uses to record the\n\nZaz Section 3 Artificial intelligence\n\nstate relationships within the FSM that are defined by FSMstate objects. See Listing\n3.1.7 for chis implemeniarian.\n\nThe Fatclass: :DeleteState() provides a method for deleting FSMobject point-\nes from the <map> contained within the FSM. This is the method one uses to\ndynamically remove state relationships from within the FSM. Nore: When you want\nto delete the current state from che <map>, be sure to set a new current state using\nFSilclass::SetturrentState() before deleting che old current state, See Listing 3.1.8\nfor this implementation.\n\nThe FSvclase::StateTransation{) provides the method for initiating a state\ntransition, using the inpur value received and returning the output state identifier. See\nListing 3.1.9 for this implementation.\n\nCreating States for the F5M\n\nTo use our FSMclass and FSMstate classes in a game, we first build che FSMsrare\nobjects:\n\nFEMState “pFSMetate = NULL;\n\nfi create the STATE_10 UNCARING\ntry\n\nff FaMstate( int istateID, unsigned usTransitions }\npFSistate = new FoMstate( STATE_ID UWEARING, 2 MF\n\n}\ncatch{ ... }\n{\n\nthrow:\n}\n\nii now add state transitions to this state\nPFSMstate-sAddTransition( INPUT_ID_PLAYER_SEEN, STATE_ID ANNOYED }-\nprSWstate->AddTransition( INPUT_ID_PLAYER_ATTACKS, STATE_ID MAD );\n\nAnd then create an FSMelass object:\n\nf/f ereate the FSitclass object\ntry\n1\n{i FSWolass( int iStaterID 5\nM_PFSMclass = now FSMclass(STATE_I0 UWGARIWG);\n\n}\ncateh{ ... }\ni\nthrow:\nI\n\nNow add the FSMstate object to che FSMelass object:\n\ni} Tow aid thas state to the Foul\nM_AFSWelass-sAddState| pFSlistate };\n\n3.1 A Finite-State Machine Class 243\n\nRepeat the process of creating FSMstate objects and adding chem to the FSMeclass\nobject for all che stares you want to have in your FSM.\n\nUsing the FSM\n\nTo use our F3Mclass, we need only te pass it an input value (which is game depen-\ndent) and receive am ourput stare (also game dependenc), chen act on the output state.\nSo in your game code, you would have something like this:\n\nff something happans in the game that causes an input\n\niTnputiIO = INPUT_IO PLAYER_ATTACKS;\n\nfy have the FSi do the transition to an output state\nB_LOUTpPUtState - m_pFoelass->StateTransition(iInputIby ;\n\nfy S0M8 game AL cade tests for the output state\nif({ m_i0utputState == STATE_ID MAD j\n|\n\n}\n\ni) som code for the monster to act mad\n\nIts usage is thar simple!\n\nIn conclusion, this FSMclass is not an end-all solution to your computer game Al\nneeds. Ir is a starting point, or a building block, for you to use to create your own\nFSMs that are specific t your game needs. FSMclass objects could even be placed in\nlists or maps and used to form networks of FSMs char are interrelated.\n\nThis FSMelass could be expanded to suppor different input ype data or state\nidentification dara types. A state or input-specific wansition funetion could be easily\nadded so thar, based on the type of input received or che current state, the transition\nto the ourpur state could be determined uniquely.\n\nHave fun with this concept, and you will gain a powerful tool for making com-\nplex computer game Al.\n\nListing 3.1.1\n\nFeMstate: :FaMstate{ int LStateID, unsigned ustTransitions }\n{\nif don't allow 0 transitions\nif{ JusTransitions }\nmusNunberOtTransitions = i;\nelse\nmusNunberOtTransitions = usTransitions;\n\nfi save off id and number of transitions\nH_istatelpD = istatelD;",
      "page_number": 227,
      "chapter_number": 25,
      "summary": "This chapter covers segment 25 (pages 227-237). Key topics include state, objects.",
      "keywords": [
        "State",
        "state machine",
        "state transition",
        "current state",
        "machine",
        "Swapping State Machines",
        "movement state machine",
        "FSM",
        "Output State",
        "Multiple State Machines",
        "state machine reaches",
        "input",
        "game",
        "transition",
        "complex state machines"
      ],
      "concepts": [
        "state",
        "objects",
        "msg",
        "games",
        "classes",
        "provides",
        "provided",
        "machines",
        "stares",
        "transition"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.77,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 30,
          "title": "Segment 30 (pages 590-610)",
          "relevance_score": 0.67,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 1,
          "title": "Segment 1 (pages 1-18)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 51,
          "title": "Segment 51 (pages 488-496)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 38,
          "title": "Segment 38 (pages 764-785)",
          "relevance_score": 0.61,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 26,
      "title": "Segment 26 (pages 238-247)",
      "start_page": 238,
      "end_page": 247,
      "detection_method": "topic_boundary",
      "content": "}\n\nSection 3 Artificial Intelligence\n\nif tow allocate cach array\n\ntry\n{\nm_pilnputs = new int[m_ushunberOtTransitions| +\nfor{ int is; i<m_wsNumberOitransitions; +#1 }\nM_pilnputs{ij = ao:\n}\ncatch{ ... }\n{\nthrow;\n}\ntry\ni\nm_pidutputState = new int[mushumberOtTransitions| ;\nfor{ int i=0; i<m_usNusberOfTransitions; +42 }\nh_pidutputState[i] = 0;\n}\ncatch{ .-. }\nt\ndelete [}] m_pilnputas:\nthrow;\nI\n\nFaMetate: :-FSMstate t }\n\n{\n\ndelete [] m_pilnputs;\ndelete [| m_pidutputState;\n\nListing 3.1.2\nSe a cn a el\n\nvOld FSMatate::AgdTransition{ int iInput, int idutpetID }\n\n{\n\nif the s_pilnputs[] and m_pitutputstate[] are not sorted\nff 30 find tha first non-zero offset in m_pidutputState[]\nff and use that offeet to store the input and OutputIo\n‘i within the m_pilnputs[] and m_pidutputState| ]}\nfor{ int i=0; i<m_usNunberOfTransitions; +#4 }\n{\n\nif( Im pidutputState[i} }\n\nbreak;\n\n}\nff only @ valid offset is used\nif( i = a_usMunberd?Transitions j\n{\n\nm_pidutputState[i] = iduepytip;\n\nM_pilnputs(ij = iTaput;\n\n2.1 A Finite-State Machine Class S45\n\nListing 3.1.3\n\nwoid FoMstate: :DeleteTransition( int idutputIo }\n\n{\n\nff the g_pilnpute[] and m_pitutputState|] are mot sorted\nff so find the offset of the output state ID to remove\nfor[ int 1=0; 1<m_usNumberdfTransitiongs; +44 4}\n{\n\nif{ m_pidutpwtStateli] == idutputio }\n\nbreak:\n\n}\nff Teat to be sure the offset is valid\nif({ i == n_ustumberOfiransitions }j\n\nreturns\n\nff ramive this output 26 and ite input transition value\nn_pilnpute[i] = 0;\nn_pioutputState[i] = 0;\n\nif since the m_pilnputs[] and m_pidutputState[] are not\nif sorted, then we peed ta shift the remaining cantents\nfor({ ; is(e_ushumerOfTransitions-1)5 ++i }\n{\nAf{ In_pidutpetState[i] }\nbreak;\n\nfi_pilnputs[i] = m_pilnputs[iri];:\nf_pitutputState[i} = m_ploutputStatel ie];\n\nff and lear the last offset in both arrays\nMn _pilnputea[ij = o;\nMN pidutputState[ij = o;\n\nListing 3.1.4\nee a eae\n\nint FSWSstate: GetOutput( int ilnput }\n\n{\n\nint idutputI® = m_istatelo; i! output state to be returned\n\n/i for gach possible transition\n\nfor( int i=0; i<n_usMumberOfTranaitiens; ++i }\n\n{\nif zeroed output state IDs indicate the end of the array\nif( !m_patutputstate(ij j\n\nbreak:\nif State transition function: look for a match with the input\niv walue\nif{ ilmpet == a_pdinputs[i] }\n{\nidutputio = m_pidutputstatel il; If output state id\nbreak;\n}\n\n246 Section 3 Artificial Intalligance\n\nff returning either this m_istatelD to indicate no output\nff state was matched by the input (i.e., no state transition\nff Can aceur) or the transitioned output state ID\n\nreturn( idutgutIo ):\n\nListing 3.1.5\n\nSr\nFEMclass!:FaMelass{ int iStatelD |]\n\ni\nm_iturrentState = iStateID;\n}\nFaMoGLase: :-FSMelass(}\ni\nFaustate \"pState = MULL:\nState Mapiiiterater it:\nff only perform this if there are pointers in the map\nif( lo_map.espty() 4\n{\nff first delete any Falstate objects in the map\nTor] it = mmap.begin(); it != mmap.end(): +4+it }\n{\npState = (FiMetate *)((\"it)-secend);\nif{ pState |= NULL }\ndalete pState;\n}\nff Let the map dter() erase the actual pointer out of the map\nI\n}\nListing 3.1.6\n\nrr\n\nFaWatate “FGliclass::GetState( int iStatelD }\n{\n\nFolistate \"pState = MULL;\n\nState _Map::iterator its\n\nff try to find this FSWstate in the map\nif( Immap.empty() }\n{\nit = m_map.find( iStateID };\nif{ it != mmap.end() }\npotate = (FSMstate \")((*it). second):\n}\n\nPetUrn( pState i:\n\nListing 3.1.7\n\na\n\nWold FiMclass::AddStatel FaMstate *pliawState }\n\n3.1 A Finite-State Machine Class 247\neee\n\nFiMistate “patate = NIALL:\nState Map: :iterater it;\n\nff tery to tind this FaMstata in the nap\nif( !'t_map.enpty{) 3\n{\nit = mmap.find, pMewStete->GetIo(} }:\nifq it [= mimap.end{) }\npStake = (FaMstate *}((*it).secand);\n\nff if the FSilstate object pointer is already in the hap, return\nif{ pState f= NULL |}\nreturn:\n\nff otherwise put the FSMstate object pointer into the nap\nmap. ingsert{ SM_VT(pilewState->GetID(), plewStata) HA\n\nListing 3.1.8\nSS\n\nwid FiMclass::DeloteState( int aStateID }\n\n{\nFoMstate *pState = NULL:\nState _Map::iterator it;\nff try to find this FiMstate in the sap\niti If_@ap.enpty() J\n{\nff gat the iterater object of tha FSWstata object pointer\nit = mmap.tind( iStateIo };\nif{ it I= mmap.end{) }\nPpstate = (FSWstate \")((*it) second) ;\n}\nff confirm that the FSWstate is in the map\nif{ pState != HULL &&\npState->GetID,) == iStatelD )\n{\nM_tap.erage( it }; i? Pengva it Trad the map\ndeleto potate; ff delete the object itself\n}\n}\nListing 3.1.9\n\n———\n\nint FSllclass::StateTransition( int iInput }\n{\nff the current state of the FSM must be set to have a transition\nif Im_iCurrent&tate }\nreturn m_iturrent$tate;\n\n248 Section 3 Artificial Intelligence\n\nff get the pointer to the F5Mstate object that is the current state\nFoMstate \"potate = GetState( m_icurrentState 1S\n\nif{ pState == NULL }\n\n{\n\nif signal that there is a problen\nn_iturrentStata = oO;\nreturn m_iturrentstate;\n\n]\n\n‘if OW pass along the input transition value and let the FSWstate\ni! do the really teugh job ef transitioning for the FSM, and save\nif aff the output state returned as tha new CUrrent state of tha\nff FSM and return the qutput state to the calling process\nm_iturrentState = pState->Getdutput{ input 13\n\nreturn a_iourrentState;\n\nReferences\n——————\nMore information on FSMs can be found at these World Wide Web links:\nhep:/fesr.uvicca!-mmania/machines/intohom\nweew erlang/se/documentation/dac—4.7,3/docldesign_principles!fsm.heml\nweew. ticroconsultants, com tips! fsm/fsmarce] hem\nAnother implementation of an FSM in C++ code can be found at httpafuw7doe,\nsco.com/SDK_c++/CTOC- Using Simple Finite_State_Machi html\nAn implementation in (C can be found at httpalw3execnet,com/Les/Writing/Finite'™\n20State%20Machines. html\n\n= \"4\n\nGame Trees\n\nJan Svarovsky\n\nFor many games such as chess and checkers, we can define the sume ee as a cree on\nwhich the nodes are game states, and children of each node are the positions thar are\nreached fram it by one move. A computer player for these games works by consider-\ning this game tree as far as it can or wants co inco the furure from the current game\nposition. Ir also has an evaluation function chat atrempes to quantify how good a par-\nticular game position is for one player. This is because at some point the search must\nstop, due to time constraints. Ac thar point, some estimate will be made of the value\naf the remaining game position.\n\nThe assumptions are that whar is good for one player is bad for the other and that\none player plays to maximize the beard evaluation function and the other to minimize\nit. This “my gain is my opponent's loss\" type of game is known as a zero—men game,\nFor example, tic-tac-toe is a zero-sum game; part of a tic-tac-toe game tree is illus-\ntrated in Figure 3.2.1. In a one-ply (one-level-deep) search, a player obviously simply\ngoes for the move that produces the best board as a result, as defined by the board\nevaluation function. In a ewo-ply search, Player One assumes that whacever he does,\nPlayer Two will then do the described one-ply search, Mayer One, therefore, plays\n\nS\n\n<\n\nee\n\nane\n\nNS\n\nail\n\nx\n=\no\n\n|\n\nFIGURE 3.2.1. Part of the game tree for the opening of “tie-Lac-toe\".\n\nie SS\n\nip\n\n249\n\n250 : Section 3 Artificial Intelligence\n\nwhichever move leaves Mayer Two (who will chen de the best move for himself) with\nthe worst possible best option. These assumptions are extended to as many ply\nseatehes as is possible in che time allowed,\n\n‘The following function (with avery similar counterpart, minimize )) retums the\nbest expected board value, looking ahead a given amount. Trivially, saximiza()\nshould be called onee for each available move at the moment, and che one that returns\nthe best value should be taken.\n\nint maximize(int ply)\nif (ply == 0 || gase_over()) return évaluate current _board():\nint best = -intinity;\n\nTor (Mowe \"m= first_available move(j; m f= NULL:\nMm = Mext_avadlable mowed)\n\nmake oova[m}:\nint fewwalue = minimizetply — 1);\nUNtake mows (mj:\nif (ftwivalue = best) best = naw value;\nf\nreturn best;\n\n}\n\nMove “which move_shall I take{int ply)\n\n4\nMave “best move:\nint best_value = -infinity;\n\nTor (Move \"m = first available move(}; m := MULL;\nN= Next_available novel) )\n{\nnakée_move(m);\nint naw_value = maximize(ply):\nunmake_ move (6);\nif {new_value > best_valua)\n{\nbest_walue = new_value:\nbast move = m;\n\nI\nreturn best_nmove;\n\nThe Negamakx Variation on the Minimax Algorithm\neS\n\nRather than writing two funetions, one char aims to minimize board stare and the\nother to maximize it, we insert a negation and turn this into just one function. Note\nthar now the evaluation function must return the qualicy of the board for the current\nplayer, rather than always returning low values, meaning a good boand for one player\n\n3.2 Game Trees 251\n\nand high for the other. Board stare must therefore include or imply which player gocs\n\nNexe;\nint negamax(int ply)\n\nif (ply == 0 || game_over(}) return evaluate current_board(};\nint best = -infindty;\n\nfor (Move *m = first_available move(}; m f= MULL;\nm= next_avallable _mowe())\n\n{\nmake mowe(m) ;\nint mew_value = -negamax(ply — 1):\nUnneke move fm) :\nif (few_value < best) best = naw value;\n}\n\nreturn best;\n\nThe most efiictene system for this function is to have che beard/game stale Put\nforward and reversed by the make_neve and unnake_move functions, as shown, and for\nthe evaluation function to be calculated incrementally rather than calculared from\nscratch every dime ir is called.\n\nAlpha-Beta Pruning\n\nNewell, Simon, and Shaw invented alphe-dera pruning in 1958. This concept is based\non the observation that im some cases, it is clear char further investigation of part of\nthe game tree is pointless, as ilhestrated in Figure 3.2.2.\n\nHere, a5 so0n as we see that Player Bs move P will produce a board of value 1, we\nknow that Player A will never let B get co che point char it can make move P Player A\n\nA's move (maxinizer)\n\n2.\nbe ceiel pha\nB's move (maximize ee | ee\n\nFIGURE 3.2.2. Sometimes part of the game tree can be terminated,\n\n232 Section 3 Artificial intelligance\n\nalready knows he can force B into situation , where the best B can hope for is 2\n(remember, B is seeking to minimize board value). Therefore, exploring P's siblings is\nunnecessary, because Player A will never lec situation R happen. It is already clear thar\nR is worse than © for PlayerA.\n\n‘This concept can be generalized to the statement char if we know thar the oppos-\ning player can get a better outcome elsewhere, we know thar the current board prosi-\ntion will never be made available by thar player, The search naw “prunes” the rest of\nP's siblings and goes straight on to 5.\n\nThis effectively means we add an extra parameter to the search. This is the hese\nwe know the other player can get based on the parts of the tree searched so far. As\nSon a3 OWF current search returns something that is bemer for us (and worse for the\nether player) than this “current best,” we know chat we don't have to search here any\nmore. OF course, this actually becomes owe parameters. One is the best the opposing\nplayer has gocten so far (called fens), and the other is the best we have gotten so far\n(called afpéu). Alpha is passed to the recursive call for the other player's move, where\n\nalpha and beta are swapped:\nant alphabeta(int ply, int alpha, int beta)\n{\nif (ply == 0 || ganc_ovar()) return evaluate_current_board[};\nfor (Move nH = firét_awailable mova(j: m i= HULL:\n© = next_aveilable_movel))\n{\nmake_mowe(mp;\nint new_value = -alphabeta(ply — 1, \"bata, -alpha);\nUntakKe_ move [mp >\nif (new_value > beta) return now_value; // prune\nif (new_value = alpha)\nalpha = méw_value; | update our ‘best se far’\n}\nreturn alpha:\n}\n\nYou can see that ideally, you want to find your pruning moves as soon as possible.\nThis means you want to consider the best move first at each point. That might seem\nimpossible (because finding the best mave is the whole point of searching), bur in fact\nseveral methods exist, and in practice game programs almost always succeed in sorting\ncorrectly. This method gives a theoretical square-rooting of the cose of the search,\nwhich means the search can be performed to twice the depth.\n\nMove-Ordering Methods\n\nOne move-ordering method is irerated deepening, Instead of straight-away searching ar\nfull ply, search at a gradually increasing ply, using the results of che previous level of\nsearch to sort the moves for the next level. This method might seem like lots of extra\n\na2 Game Trees 255\n\nwork, but, because of the exponential nasure of che search, che lasr ineration is by far\nthe most significant cost.\n\n‘The results of the previous level can be stored as a hash table [Sedgewick98], stor-\ning calculated values of board positions. This table hashes board states to board val-\nues. It helps in another way: to avoid recalculating board walues when different\nsequences of moves producc the same game state,\n\nGame-specific heuristics can be used, such as always considering capture moves\nfirst in chess. Finally, there is the “killer” heuristic: fa move turned ous to be the best\nin a sibling node in che tree, ory ic first in chis one,\n\nRefinements on Alpha-Beta\n\nAlpha and beta are effectively a lower and an upper bound on the expected board\nvalue. Alpha is the lower bound because it is the least you expect co be able co force\nplay into. You know che other player will be able to force you into not getting any-\nthing more than bera. If you are pretcy sure what the return value for the alpha-beta\nsearch will be, instead of seeding the search with negative infinity and positive infin-\nity, seed it with a range around whar you expect the rerum value to be, If the return\nvalue hits either side of your range, you know that the answer was actually outside the\nTange, 80 you have to expand the range and try again.\n\nA ftved-depth search is bad because of the Aorizen effect. If a particularly bad\nmove is going to happen soon, the computer will do all sores of other moves as long as\nthey mowe the terrible one just after the end of its search depth. This is because ir can-\nnot sec the terrible move happening if it is too far in the future, and therefore lows of\nother bad delaying moves seem like a better idea. Many methods exist for choosing\nwhen to increase the ply for some branches of the tree, bur these are out of the scope\nof this article.\n\nReferences\n\n[Eppstein] Eppstein, David, “Strategy and Board Game Programming,” available\nonline at wyw.ics.ucLedul-eppstein/ 180a/970401-heml,\n\n[Sedgewick98] Sedgewick, R, Alporithms in C++, Addison-Wesley Longman, Inc.,,\n1398.",
      "page_number": 238,
      "chapter_number": 26,
      "summary": "This chapter covers segment 26 (pages 238-247). Key topics include returns, game, and state.",
      "keywords": [
        "int",
        "move",
        "state",
        "player",
        "Game",
        "output state",
        "board",
        "game tree",
        "search",
        "int ply",
        "map",
        "ply",
        "Listing",
        "pilnputs",
        "pState"
      ],
      "concepts": [
        "returns",
        "game",
        "state",
        "values",
        "ply",
        "search",
        "player",
        "listing",
        "map",
        "transitioned"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.7,
          "method": "sentence_transformers"
        },
        {
          "book": "makinggames",
          "chapter": 13,
          "title": "Segment 13 (pages 103-111)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        },
        {
          "book": "makinggames",
          "chapter": 30,
          "title": "Segment 30 (pages 266-273)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "makinggames",
          "chapter": 35,
          "title": "Segment 35 (pages 308-315)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 27,
      "title": "Segment 27 (pages 248-255)",
      "start_page": 248,
      "end_page": 255,
      "detection_method": "topic_boundary",
      "content": "3.3\n\nThe Basics of A* for Path\nPlanning\n\nBryan Stout\n\nThe Problem\n\nThis article examines the basic solution tw the problem of planning a path for an\nauLOROMOUs agent fo move fom one location in a game world tm another, a common\nSituatien in computer game AL. On the CD thar accompanies this book is a copy of\nmy PathDemo program, with which you can play to understand how A* (and ocher\npath-planning techniques) works.\n\nThe mast common issue involved in path planning is the avoidance of obstacles,\nincluding cul-de-sacs to be ignored (oz, sometimes, discovered and explored). The\nnext most common issue is perhaps the awareness of different verrain and secking our\nthe most efficient path among a variery of choices: exploiting roads or clear terrain,\navoiding swamps, and so on.\n\nAn Overview of the Solution\n\nThe A* (pronounced 4 star) algorithm is an old workhorse in the academic AI com-\nmunity, used since 1968 for solving different kinds of problems, of which the 15-puz-\nze is the favorite teaching example; fortunately, it is also very useful for the\npath-planning problem.\n\nA* is an algorithm that searches in a stare space for the least costly path from a start\nstate to a goal stare by examining the neighboring or adjacent stater of particular states.\nIn the 15-puczle, a state consists of a configuration of the 15 niles in che 4 x4 array, and\nan adjacent stare is reached by sliding ane tile imto the blank area. In the path-planning\nproblem, a state consis of the agent occupying a particular location in the game\nworld, and an adjacent state is reached by moving the agent co an adjacent lacation,\n\nIn essence, the A* algorithm repeatedly ceamines the most promising unexplored\nlocation it has seen. When a location is explored, the algorithm is finished if that loca-\ntion is the goal; otherwise, it makes note of all chat location's neighbors for further\nexploration.\n\n3.3 The Basics of A* for Path Planning 255\n\nIn more detail, A* keeps track of two lists of states, called Open and Closed, for\nunexamined and examined stares, respectively. At the start, Closed is empty, and\nOpen has only the starting state (the agent in its current position), In each iteration,\nthe algorichm removes the most promising state from Open for examination. If the\nstate is nor a goal, the neighboring locations are sored: If they're new, they're placed\nin Open; if they're already in Open, information abour those locations is updated, if\nthis is a cheaper path co them; if they're already in Closed, they are ignored, since\nthey've already been examined. If the Open list becomes empry before the goal is\nfound, it means there is no path to the goal from char start location,\n\nThe “most promising” stace in Open is essentially the location with che lowest\nestimated path that would go through thar locarion. Each state X includes informa-\ntion to determine this: the cost of the cheapest parh chat has led to chis stare from the\nstart (which we'll call costFroastart(X)); a heuristic estimate CostTodoal(X) of the\ncost of the remaining distance to the goal; and che total path estimate, defined as\nCostFronStart(X) + CostTaGeal(X). The cotal path estimate is the lowest Total-\nCost(X) value that it determines is the next state to examine. In addition, each stare\nkeeps 2 pointer to its “parent” state, the state that led to this one in the cheapest path\nto it; when a goal state is found, these links can be raced back to the start in order to\nconstruct the path from start to goal. Please nore that in the lirerame, you'll find\nCestFromstart(*)} called g(X), CostToGoal(X) refernec co as h(X), and che oral path\nestimate named f0X). We'll use our names for greater clarity in this article.\n\nListing 3.3.1: The A* Algorithm\n\nIn pseudocode form, here is the A* algorithm:\n\nOpen: priorityquewue of searchnoda\nClosed; list of se#archnodp\n\nAStarSearch( location Startloc, location Gaalloc,\nagenttypa Agent } {\nclear Open and Closed\n\nif initialize a start moda\n\nStarthode Loc = Startboc\n\nStarthede CostFromstart = 0\n\nStarthode.CostTaGeal = PathCestEstinate( Startloc,\nGoalie, Agent j\n\nStarthode.Parent = null\n\nPuan Starthode on Open\n\n{/ process the list until ewesess ar failure\nwhile Open is not anpty {\npop Made from Open /f Node has Lowest TotalCost\n\nff i? at a goal, we'ra done\nif (Node is a goal node) {\nConstruct @ path backward from Node to Startle\n\n256 : Section 3 Artificial Intelligence\n\nreturn success\n} else {\nfor each successor NewNoda of Node {\nNewlost = Node .CoatrromStart + Traversetest{ Node,\nHewhode, Agent }\ni} ignore this nade if existe and no inprovament\nif (Wewiode is in Open or Closed) and\n(NewNode.CostFronftart <= Mewtost) 1\ncontinue\n} else { ff stere the new or improved\ninforfiation\nNeeWode. Parent = Mode\nNemNode.costhronstart = NowSost\nNeenode.CastTogoal = PathGastEstimatée( Newiode.Loc,\nGoalloc, Agent |\nNewtone.Totaltoest = Nowigda.Costrromstart +\nNewttnte.CostTaGoal\nif [Newiode 44 in Closed) 4\nremove Neetodé from Closed\n\n}\n\nif (MawNode 18 in Gpen) {\nadjust Newlode's location in Open\n\n} else {\nPuen Mewiode onte Open\n\nI\n\n}\n} of! now done with Node\npush Node onto Closed\n\n}\nréturn failure J) if na path found and Oyen is empty\n\nProperties of A*\n\nA has several useful properties. (They are not proved here; readers who are interested\nin the proofs can look in the References.) First, A* finds a path from the start vo che\ngoal, if one exists, Second, it finds an optimal path, as long as the CostToGoal(X) esti-\nmate is ddmasidle, which means CostToGoal is always an underestimate—thar is,\nGostTogoal(X) is always less than or equal to the actual cheapest path cost from X co\nthe goal. Third, A*° makes the most efficient use of the heuristic: No search thar uses\nthe same heuristic function CostToGoal(X) to find optimal paths examines fewer\nstates than A*, not counting tie breaking among states with equal cost.\n\nApplying A* to Game-Path Planning\n\nLet's new look in detail at how the aspects of A* can be applied to path planning in com-\nputer games. Much of this discussion depends on the mature of the game and its internal\nrepresentation of the world: the following discussion is meant to suggest possibilities,\n\n3.3 The Basics of A\" for Path Planning 257\n\nState\n\nAs stated above, the principle component of a state in the path search is /ocution.\nHowever, it need noc be the only component. An agent's orientation and/or its velec-\nity can also be important. For example, vehicles can often go only straight ahead or\nturn slightly, and che amount of curn possible is reduced the faster a vehicle moves.\nMost vehicles can go backward only after coming to a stop. It is quite possible vo plan\na route based only on locations, bur ir could be desirable in some situations to plan\nbased on velocity and orientation as well, to avoid planning a route through terrain or\naround obstacles that would be difficule to navigare.\n\nEven considering location alone, the issue of which locations to consider is not\ntrivial. In some games, the world is naturally tiled—real-sime strategy games often\nhave an underlying square grid, and many war games use a visible hex grid—but\nmany games do not divide the space that way, especially games that use a 3D), firse-\nperson, or oblique view of the world. In such cases, it is important to choose a set of\nlocations among which to search. Figure 3.3.1 shows a pach-planning simarion and\nseveral ways of partitioning the space.\n\n©\n\ni pee ee\n\nHiterngm =I\n\nFIGURE 3.3.1. A vaniery of means of partitioning 2 continucus space.\n\nSection 3S Artificial Intelligence\n\nThe ways of partitioning the space are 2s follows;\n\nRectangular grid. The simplest way is to partition into a regular grid of squares,\nas shown in Figure 3.3.1b, The locations can be cither the center poines or the\ncomers of the squares; if appropriate for the game, the grid can be considered to\nconsist of che terrain most comman to the area it covers,\n\nQuadtree. Another way to partition the space is inte squares of differing sizes.\nThe quadtree recursively devides a square into four smaller squares, until each\nsquare has uniform (or at least mostly uniform) terrain, as shown in Figure\n3.3.1¢. Again, the locations for the search can be either the centers or che corners\nof the squares. This method has a couple of advantages: The larger (and fewer)\nsquares allow for a faster search, and the representation is easy two store.\n\nConvex polygons. A more complex yet possibly more robust scheme is co break\nup the space into convex polygons made up of uniform terrain (Figure 3.3.1d).\nThis scheme could already exist in che map's representation, so it can be used\ndirectly in the path search, There are several methods that can be used to parti-\ntion a space inte polygons if the existing mesh is useless or inefficient. (C-cells are\none way to partition the space; each vertex is connected co che nearest visible ver-\ntex, and the connecting lines partition the space, Another is maximum-area\ndecomposition, where areach convex vertex the edges connected oo the vertex are\nprojected out until they hit an obstacle or wall, and between chese lines and the\nline to the closest other vertex, che shortest is chosen as a boundary. Navigation\nmeshes, a third method, are discussed in another article in this volume (“Simpli-\nfied 30 Movement and Parhfinding Using Navigation Meshes\"). Similar tech-\nniques can be used to divide variable-cost terrain into convex polygons of\nuniform terrain. After the polygons are laid out, search locations can be chosen at\ntheir center and/or along various parts of their perimeters.\n\nPoints of visibility. Not all techniques divide the space into regions bur instead\ncome up with locations directly. Points of visibilicy are concemed mainly with\nobstacle avoidance: Place a search location just a little beyond each convex vertex\nof cach obstacle, just far enough away to avoid collision with che obstacles (as in\nFigure 3.3.1e). The shortest path around obstacles cypically passes near these ver-\ntices, as though a rubber band conmected the stare and goal locations. One could\npossibly extend this method to consider terrain cost by adding these points to\nthese derived from convex uniform polygons.\n\nGeneralized cylinders, Another technique concerned mainly with obstacle avoid-\nance is generalized cylinders: The space between neighboring obstacles can be\nconsidered a 21) cylinder, the shape of which changes as it goes along. Berween\neach pair of neighboring obstacles (including the walls or boundaries of che map),\ncalculate a ceneral axis (Figure 3.3,1F). The intersections of these lines provide the\n\nlocations for the search.\n\n3.3 The Basics of A\" for Path Planning 259\n\nFor most of these schemes, when a search is done, the start and goal locations are\nusually not members of the search locations, so they need to be added to them for the\nduration of that search.\n\nWhichever scheme ts used for quantizing a continuous space, it probably must be\nexperimented with and tweaked before it suits the game's demands optimally: There\nneed to be enough locations so char ne reasonable route is unconsidered, bur not too\nmany, or the search will rake too long, Another issue is that most paths found from\nany quantization scheme seem jagged and a bit artificial, which means che route needs\nto be smoothed, either before it is assigned to the agent or in the means che agent uses\nto Follow it.\n\nNeighboring States\n\nThe neighbors of a state are determined by che map representation and the quantiza-\ntion scheme. Some schemes use only their adjacent locations as their neighbors—a\nsquare grid would consider cach interior point as having eight neighbors, four if diap-\nonals are excluded—whereas in other schemes, a location's neighbors are all other\nlocations visible to ir.\n\nA location's neighbors are also determined by the terrain. Some terrain might be\nimpassable, which means it is not a neighbor to its nearby locations after all. The type\nof agent could also enter chis determination; for example, land vehicles cannot travel\non the sea, and infanery can traverse terrain forbidden to some vehicles,\n\nWe need an efficient way to compute each location's neighbors, for the sake of\nseach speed. Grids have a natural way of calculating neighbors: The neighbors of (x,\nye are (eel, yh Geel, ptt), G5 yt J), etc. Most other schemes require that some dara\nstructure store the neighbor information for fase lookup, since the neighbor calcula-\ntions are often expensive.\n\nCost\n\nThe cost function for the path benween nwo locations (CostFreaStart above) repre-\nsents whatever it is the path is supposed to minimize—typically, distance traveled,\ntime of traversal, movement points expended, or fuel consumed. However, other Frc-\ntors can be added into this function, such as penalties for passing through undesirable\nareas, bonuses for passing through desirable areas, and aesthetic considerations (for\nexample, making diagonal moves more costly than erthogonal moves, even if they\narent, to make the resultant path look more direct; see the article on acstheric oprti-\nmizations, “A\" Aesthetic Optimizations,\" for more discussion.)\n\nJust as with connectivity considered previously, in many games, the cost is net the\nsame forall agents—for cxample, roads offer a great speedup for wheeled vehicles but\nlittle if any for infantry. What's more, in some gFamies, travel cost is asymmetric: Going\nfrom Ato B may be more costly than going from B to A, such as is the case if B is\nuphill from A. That is why the code in Listing 3.3.1 has the cost functions dependent\non the agent traveling as well as the wo endpoints of the travel.\n\nSection Artificial Intelligence\n\nAgain, these terrain costs need to be quickly looked up during the search and in\nface are probably best stored with the connectivity information. In chat way, one\nlookup can determine whether two locations are neighbors, and if so, the cost for the\ngiven agent.\n\nEstimate\n\nThe estimate of the path cost to the goal is the complement to the known distance\nfrom the stare. If you want to guarantee thar an optimal path is found, this distance\nshould not be overestimated. A common way to do this is to multiply the actual map\ndistance from che given location to the goal times the minimum cerrain cost per unit\ndistance. Since the route cannot be shorter than the most direct, “crow’s flight” line,\nthis figure will be an underestimane (unless your game has chings like instant-trans-\nport locations). In many games, this minimum distance is che Euclidean measure\nbetween two points in 2D or 3D, bur in games with strict square or hexagonal tiles,\nthe shortest tile parh is usually a little longer than the Euclidean distance berween che\ntile'’s center points. Therefore, in a square grid, a tile (3, 5) away has a minimum dis-\ntance of 2 + 3*sqr(2), not the Euclidean sqn(34), This actual shortest distance can\nthen be multiplied by a typical terrain cost. This cost should include all the previously\ndiscussed factors concerning the cost between neighboring nodes,\n\nHowever, guarantecing an optimum path is not the only consideration; chere is\nalso the speed of the search, and che qualicy of the GostToGeal value has a tremendous\nimpact on the search efficiency. Look at Figures 3.3.2 and 3.3.3. In Figure 3.3.2a, the\nGastTobeal has been set to zero, which, after all, san underestimate, and we see char\nthe search spreads in a circle neil it hits the goal, because it has no heuristic informa-\ntion to guide it im the correct direction. In Figure 3.3.2b, we see that an accurate\nheuristic weight of | per square sends the search in a straight line to the goal. In Fig-\nure 3.3.3, the start and the goal are in costly terrain (8 per square}. Since the estimate\nof | per square is a large underestimare, the search frontier is nearly as circular as the\nuninformed search in Figure 3.3.22. In Figure 3.3.3b, we see thar even an estimate of\n2 per square focuses the search considerably. It is therefore important, perhaps crucial,\nthar the estimate be fairhy accurate. In Get, in some sivuations, one might want ro\noverestimate the cost to the goal in order to get a fast search, ar the risk of getting a\nsuboptimal path (the article “A* Speed Optimizations” ralks about this concepr). So\nrather than using a mifienins terrain cost per unit, we could use a qypical cost, which\ncan cither be fixed or dynamically determined by sampling the terrain berween the\nstated start and goal,\n\nGoal\n\n‘The goal is typically a single location, but it does mot have ro be, For example, if a\nvehicle low on fuel is trying to plan 2 route to the closest refueling station, with cach\nnew node N in the search th ietitiate 1s made of che Pe Ccalrnitee distance To eich o0-\ntion, and the minimum of them is used as the CostToGeal(N) value. This method\n\n3.43 The Basics of A* for Path Planning 261\nei la)\n\nPOE ny\naeagpap\nma “\n\nFIGURE 3.3.2. A* search in clear terrain, 2: With a heuristic weight of 0, 6: With a heuristic\nweight of 1.\n\nFIGURE 3.3.3. A* scarch in costly terrain. a: With a heuristic weight of 1, & With a heuristic\nweight of 5.\n\nguarantees thar the search figures owt both the closest goal and che best route co it\n\nsimultaneously,\n\nWeaknesses of A*\n\nAlthough A® is about as good a search algorithm as you can find, it must be used\nwisely; otherwise, it can be wasteful of resources. On a large map, hundreds or even\nthousands of nodes might be in the Open and Closed lists, which can rake up more\nmemory than is available on systems with constrained memory, such as console sya~\ntems. On any system, A\" can take too much CPU time to be affordable,\n\nThe case in which A” is most inefficient is in determining that no path is possible\nbetween the start and goal locations; in that case, it examines every possible location",
      "page_number": 248,
      "chapter_number": 27,
      "summary": "3.3\n\nThe Basics of A* for Path\nPlanning\n\nBryan Stout\n\nThe Problem\n\nThis article examines the basic solution tw the problem of planning a path for an\nauLOROMOUs agent fo move fom one location in a game world tm another, a common\nSituatien in computer game AL Key topics include path, location, and locations.",
      "keywords": [
        "Path",
        "path planning",
        "Open",
        "goal",
        "search",
        "locations",
        "location",
        "che",
        "cost",
        "state",
        "Planning Bryan Stout",
        "terrain",
        "agent",
        "Closed",
        "goal locations"
      ],
      "concepts": [
        "path",
        "location",
        "locations",
        "searches",
        "search",
        "agent",
        "planning",
        "plan",
        "costly",
        "state"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 25,
          "title": "Segment 25 (pages 240-248)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 25,
          "title": "Segment 25 (pages 234-242)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 10,
          "title": "Segment 10 (pages 91-99)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 34,
          "title": "Segment 34 (pages 321-328)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        },
        {
          "book": "AI Agents In Action",
          "chapter": 5,
          "title": "Segment 5 (pages 33-40)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 28,
      "title": "Segment 28 (pages 256-265)",
      "start_page": 256,
      "end_page": 265,
      "detection_method": "topic_boundary",
      "content": "262 Section 3 Artificial Intelligence\n\naccessible from the start before determining thar the goal is not among them, as\nshown in Figure 3.3.4. The best way to avoid this problem is to de a pre-analysis of\nthe map, manually or algorithmically, so chat che program can look up whether wo\nlocations are accessible from cach other—say, on che same island. If chey are not, the\nsearch is not even attempted.\n\nFurther Work\n\nThere is much more derail thar we could eover, because there are many different path-\nplanning and parh-following situations. With an understanding of the workings of\nA*, one can often figure out how to adape it to their needs, Take a look at the other\narticles in this volume for further discustion on the ways to partition a floor space for\nuse in A\", as well as efficiency and aesehetic considerations.\n\nReferences\n\nWebsites\n\n[Woodcock] Woodeock, Steven, “The Game AI Page: Building Artificial Intelligence\ninto Games,” available online at wew-gameaicom. The “Resources and Links”\nsubpage of this site has many links to Websites that discuss A*, some of which\nhave sample codc.\n\nGeneral Al Texts\n\nThe following are two recent, very good general Al textbooks, both of which happen\nto use the agent-centered paradigm for diseussing Al:\n\n[Russell] Russell. Stuart, and Norvig, Peter, <rcifictal Jncelligence: A Modern Approach,\n\nPrentice Hall, 1995. Perhaps the best current Al cext, it has a couple chapters on\nsearch techniques, including A”.\n\nSSH\n\nitis\n\nFIGURE 3.3.4. Search in a situation in which there is no path co the goal.\n\n2.3 The Basics of A\" for Path Planning 263\n\n[Nilsson98) Nilsson, Nils J., Artificial foteliigence: A New Synthesis. Morgan Kauf-\nmann, 1998. Since Nilsson was one of the developers of A*, his discussion of ix is\nvaluable if one wane to understand the theory behind it. This text presences for-\nmal proofs of properties of A*.\n\nSearch Texts\nThese books discuss the general issues of search, which dare back to the early days of\n\nAl research:\n\n[Barr81] Barr, Avron, and Feigenbaum, Edward A. eds., The Handbook of Arsijicial\nfntetigence, volume 1, Addison-Wesley, 1981. A good multivolume survey of\nmajor Al issues and important Al programs. This volume includes che discussion\nof search, including A”.\n\n[Kanal&3] Kanal, ES and Kumar, Ve, eds, wadral Im Artificial Freelligence, Springer-\nVerlag, 1988. A collection of good articles for those who want to get into the\nadvanced considerations of scarch, including variations on A* (with imaginative\nnames like B,C, and D!).\n\n[Pearl84] Pearl, J., Hewnisties: Invelligent Search Strategies for Computer Problem Solving,\nAddison-Wesley, 1984. This is perhaps the most complete reference on search\nalgorithms and is referenced by practically everyone else,\n\n[Shapiro] Shapiro, Stuart C., and Eckroch, David, eds., Encyclopedia of Arcificial [nret-\nHgence, 2 volumes, John Wiley & Sons, 1987. A truly excellent collection of arti-\ncles abour most aspects of Al research. Good articles pertinent to this article are\n“Search,” “A Algorithm,” and “Path Planning and Obstacle Avoidance.”\n\nA* Aesthetic Optimizations\n\nSteve Rabin\n\nComputing a path fora character is more than merely an exercise in search algo-\nrithms. It also involves creating an aeschetically pleasing path and resulting execution.\nComputed paths for characters can be improved in three main ways: making the path\nstraighter, making it smoother, and making it more direct. The execution of the path\ncan be improved by simply maximizing responsiveness, All these optimizations result\ninan experience that is more aesthetically pleasing to the player. Since providing a sat-\nistying experience is the ultimase goal, these things are fairly important and directly\nimpact the code within and surrounding A*,\n\nStraight Paths\n\nPaths calculated by A* often look like they were constructed by someone who was\ndrunk They weave and bob their way efficiently to the goal, but it sure doesn't look\nnatural, This is a serious problem that undermines the believability of any game's AL\nThere are two ways to deal with this issue, The first is to promote straight paths\nwithin the A* algorithm; the second is tw clean up the mess after the path has been\ncalculated.\n\nPromoting straighter parhs involves careful cost weighting within the A\" algo-\nrithm, Consider the owo pachs computed by A* chat are shown in Figures 3.4.1 and\n3.4.2,\n\nThe amazing observation is thar both paths crawel che exert same distance. Since\nboth paths have identical costs, A* is unable to differentiate between them and simply\nchoases the first path ic stumbles upon. The cick char will make A* choose the\nstraight path is held within dhe cost function. Simply factor in an extra cost (penalty)\nif the new step being considered is mot straight with the last step. Note that we are not\nlooking at the overall straighoness of the path, just penalizing new considerarions chat\nare not in line with the last step.\n\nA reasonable penalry is half che normal cost to step in a given clirection. The cruch\nis that. on a regular grid, any penalry at all (0.000001) for nan-straight choices causes\nA® to choose the straightest one, However, this is not the case on an arbitrary net-\nwork.\n\nFIGURE 3.4.2. Straightenedd A“ path,\n\nA word of caution: Penalizing non-straight paths results in more work being done\nby the pathfinder, thus slowing the computation. Obviously, the algorithm has co\nconsider many more permutations in order to find the straightest one. In fact,\nsearches can take significantly more time. However, if hierarchical methods are used,\nthe extra time might not be an issuc. Make sure you understand the tradeoffs.\n\nStraight Paths In a Polygonal Search Space\n\nWith a polygonal search space, this trick is not very useful. Because criangles aren't\nuniformly spaced, as a rectangular grid is, similar paths that cost che same are quite\nrare. Therefore, there is no need co find the straighter path. Instead, there's a different\nproblem: Since triangles can vary greatly in size and proportion, paths are more\ncrooked than ever. The trick is to optimize for straightness after the pach has been eal-\nculated. Greg Snook's path-finding article, “Simplified 3D Movemenc and Pachfind-\ning Using Navigation Meshes,” discusses an excellent way to handle this problem.\n\nSmooth Paths\n\nUnfortunately, paths computed by A® are usually riddled with sharp curns. Even if\nyou employ a technique to make straighter paths, sharp curns still have che potential\nto make your characters look like robo. By applying rotational dampening to your\n\nSection 3 Artificial Intelligence\n\nturns, you can probably mask chem a line, but you'll swing wide on every sharp cor-\nnet. There's a much beter way.\n\nStraight from the field of computer graphics, there's an algorithm that makes\nyour paths (simply series of poincs in space) smooth for you. A simple Catmull-Rom\nspline does the trick because it creates a curve that nails all che control points in the\noriginal path (unlike a Bézier curve, which is smoother but docsn't go through the\ncontrol points}. Obviously, irs beer to go directly through your points because A*\ndeemed them clear and free of obstacles,\n\nBut how do you actually input a list of points and get a smoother list back? The\nCacmull-Rom formula requires four input points and gives you back a smooch curve\nbetween the second and chird points. Figure 3.4.3 cuplains this concept a little berrer,\n\n‘To get the points between the first and second inpur points. you simply give the\nfunction the first point cwiec, then the second and third. To get the points berween\nthe third and fourth, give che function the second and third, and double upon the\nfourth.\n\nFach time you use the Carmull-Rom formula, it gives you a point roughly ws\nbetween the second and third inputs, where wis a number you pass in. The following\nis the formula (poines can be 2D or 3D):\n\nDUCPUE_ Point = point_t * (-0.5T*utu\" + ut - O.5t#u) +\n\nPoint_2\" (1.57*u\"u*u + =2.85f \"| + 1.0T) 4\npoint 3 * (-1.4f*u*utu + 2.0f'u\" + O.5T*%u) 4\npoint 4 * (0.5f*u*u*s - O.8f*u\"y);\n\nNore thar if w is zero, the formula gives you point_2. When wis 1, ir gives you\npaint_3. As you can see, the spline really does go direcely through the inpur poines.\n\nInpet Chere! Pants\n\nFIGURE 3.4.3. Geing spline points from control point.\n\n3.4 A\" Aesthetic Optimizations 267\n\nA Pre-Computed Catmull-Rom Formula\n\nSince speed is an issue, you might want co dicrare that you want u only ar cerrain\nintervals, such as 0.0, 0.25, 0.5, and 0.75. By freezing all instances of u, you can pre-\ncompute the formula at each u. Note thar the formulas can take either 2D or 3D\npoints. The following are some formulas at various intervals:\n\nifu= 0.0\noutput_point = point_2;\n\n‘fou = 0.25\nCURT point = polnt_i * -0.0700125F + point_2 * O.B671BT5f =\nPoint_j * O.2265625F + point_4 * -0. 0234375;\n\nffw=0.5\noutput point = POint_i * -0.0é285f + point_2 = O.5625T 4\npoint_j * O.5828f + point_4 \" -0,0625T:\n\nMu = 0.75\nGUEAUT PONT = poOlnt_i * -0.0204376f + point? * O.226583T «\npolnt_3* O.887187SF + point_4 * -0.0703125f;\n\niiu = 1.0\noutput_point =| point_a;\n\nEquipped with che Carmull-Rom formula, all you need to do is walk: through che\npath thar A” found and create a new path. Remember to double up on the first input\npoint when you start, and double up on the last inpur poine when you get po the end.\nIf the A* path has only rwo points to begin with, simply dont apply the spline to che\npath,\n\nSince you have a new pach with four times the number of points, you might want\nto look inte getting rid of redundant points, Running the new path through a func-\ntion that prunes co-linear points should dramatically reduce your list.\n\nFigure 3.4.4 shows a typical path before and after the Catmull-Rom spline has\nbeen applied. Notice how it’s still just a series of points (picce-wise linear), but the\npath is now much smoother, In the large scale of things, this path is perfectly smooth.\n\nFIGURE 3.4.4. Pach poincs before and after a spline is applied.\n\n260 Section 3 Artificial Intelligance\n\nImproving the Directness of Hierarchical Paths\na Rat lara at eeectcabaet teal lt clerics Tha La\n\nAvery important A* technique is Avenarchica! pathing. However, the problem is thar the\nresulting paths can be less than ideal. In hierarchical pathing, you parthfind in two dis-\nminct steps. You first find the large-scale path, and chen you pathfind ar the local level.\nFor example, a castle might be broken up into rooms. You might want co get from the\ndungeon to the throne room. The idea is thar you fine find the Large-scale path\nbetween the rooms (by running A* on the connectivity graph of the rooms). Once that\npath is found, you can then path-find between each connecting mom as you encounter\nit. The result ig a huge savings of rime. Unfortunately, the overall pach can look rather\nbad because the goal poine will always be the door to the next room, thus causing the\ncharacter to always travel through the center of each door. When doors are arbitrarily\nlarge, this can look rather bad. Figure 3.4.5 illustrates the problem.\n\nThere is a simple, clegant way co get the ideal path, bur ic rakes roughly ewice the\ncomputation. The trick is to always path-find to the door beyond the next door.\nThen, whenever the character crosses through the first doorway, chrow away the rest\nof the path and repeat the process. While che second half of the path is always wasted,\nit really does create the most direce and aesthetically pleasing route. Figure 3.4.6\nshows the final path.\n\nThis technique always finds the optimum passage through the deorway because it\ntakes into acoount the furure path. The following is a step-by-step sample path execu-\ntien guide to show how chis method works;\n\n1. Find the best room-to-mom path using A* on the connectivity graph of the\nPoms.\n2. The result is co crave! the following sequence of rooms 1, 2, 3, 4.\n\nFIGURE 3.4.5. The pach through several rooms.\n\n2.4 A® Aesthetic Optimizations 269\n\nFIGURE 3.4.6. The optimized path through several rooms.\n\nParhfind from Start to subgoal l (Figure 3.4.7 a).\n\nLet the character walk until he enters Room 2.\n\nThrow away the remaining path and pachfind to subgoal 2 (Figure 3.4.7b).\nLet the character walk until he enters Room 3.\n\nThrow away the remaining path and pathfind to che final goal (Figure 3.4.7).\nLet the character walk to the final goal.\n\nyes\n\nce\n\nHierarchical Pathfinding on Open Fields\n\nThere is no real difference berween a set of connected rooms and a set of connected\nfields. The same principles apply. The resulting path is not completely straight, bur it\n\n2 Le ES be is be cee 5 co Cpa ep F\n\nFIGURE 3.4.7, The computed path durtnp various steps.\n\n270\n\nSection 3 Artificial Intelligance\n\nFIGURE 3.4.8. The computed path during various steps.\n\ncomes pretty close. You also meed ro realize that these fields are fairly large relative to\nthe player, Figure 3.4.8 shows the hierarchical steps applied to open fields.\n\nEliminating Pauses During Hierarchical Searches\n——————&—&{—————————\n\nNote that every time the character enters a new room, a new local path must be com-\nputed. Since this obviously takes time, the character appears to pause as he enters each\ndoorway, The search inself can't be sped up, bur the new path request can be ancici-\npated and computed slightly before it's needed. This simple trick keeps the character\nmotion fluid throughour the pach.\n\nMaximizing Responsiveness\n\nController responsiveness is critical to game play. When a player issues a move com-\nmand in an RTS, they expeer the unit to respond immediately. However, in the world\nof pathfinding and search algorithms, sometimes it can take awhile co find that path.\nThat's where we need to pull a few tricks in order to give the feeling of instantaneous\nresponse.\n\nThe first trick is to stall by playing a sound byte that identifies the unit as having\nreceived the command. This erick gives immediate feedback that the unir is aware of\nthe command and will execute it shortly. Meanwhile, the pathfinder is working ar full\nspeed trying to find the pach.\n\nAnother ick is co stall by playing a “get ready to move\" animation. The meve-\nment of the character signifies that he’s going to move—even though he might not\nactually take any steps. You can even rotate the character to the “hest-guess” direction\neo that he'll be ready to move when the final path is available, thus stalling even\n\nlonger.\n\n3.4 A* Aesthetic Optimizations art\n\nYou can take the idea further by moving the character in the “best-guess” direc-\ntion before the final path is ready. Unfortunately, you could be dead wrong in your\nguess, and the character will have to backrrack. Unless the pathfinder is extremely\nslow, irs probably best to avoid using this method,\n\nMoving large groups of people ar once can take even longer. If the player grabs 20\nunits and asks chem to move across the map, you could be waiting a long time wo get\nthe 20 paths processed, There are nwo cricks no dealing with this situation. The first is\nto queue the path requests and let each unit move as its request is serviecd. This way,\nit looks as though there's immediate feedback, because at least some of the units start\nto move immediately. Tr looks a bit like popeom popping as cach unit starts 6 move,\nbut overall, it's fairly satisfying to the player, The second wick is to choose a leader in\nthe group of 20 and find a path for only him. Then cell che other 19 units ta follow\nthe leader, However, this method can get complicated because there could be massive\nbunching, the leader could dic halfway through the path, and each unic should even-\ntually stop ata unique destination.\n\nConclusion\n\nAll these techniques are designed ro make pathfinding more transparent to the player.\nThe goal has always been to find good, direct paths instantancously. Since that’s a\ntough problem, hopefully you can apply these gems to your current pathfinder in order\nto get berter-looking paths that ultimately feel better to the player.\n\nReferences\n\n[Patel99] Parel, Amic J., “Amit's Thoughts on Pathfinding,” available online at\nhetps!/theory.stanford.cdu/-amitp/GameProgramming/, November 27, 1999.\n[Stout] Stour, Bryan Wi, “Smart Moves: Intelligent Path-Finding,” Game Devel-\naper, October/November 1996, pp. 28-35, also available online at www.gamasu-\n\ntracomfearures/ 1999021 2/sm_O1.btm.",
      "page_number": 256,
      "chapter_number": 28,
      "summary": "This chapter covers segment 28 (pages 256-265). Key topics include path, points, and figures. The best way to avoid this problem is to de a pre-analysis of\nthe map, manually or algorithmically, so chat che program can look up whether wo\nlocations are accessible from cach other—say, on che same island.",
      "keywords": [
        "path",
        "point",
        "search",
        "Artificial Intelligence",
        "che",
        "Straight Paths",
        "character",
        "Artificial Intelligence accessible",
        "che path",
        "Artificial",
        "Building Artificial Intelligence",
        "Path Planning",
        "final path",
        "Aesthetic Optimizations"
      ],
      "concepts": [
        "path",
        "points",
        "figures",
        "search",
        "searches",
        "straight",
        "cost",
        "character",
        "way",
        "ways"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 32,
          "title": "Segment 32 (pages 296-313)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 25,
          "title": "Segment 25 (pages 234-242)",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 56,
          "title": "Segment 56 (pages 544-551)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 29,
          "title": "Segment 29 (pages 271-278)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "Segment 33 (pages 314-325)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 29,
      "title": "Segment 29 (pages 266-278)",
      "start_page": 266,
      "end_page": 278,
      "detection_method": "topic_boundary",
      "content": "A* Speed Optimizations\n\nSteve Rabin\n\nTraditionally, A* is a slow algorithm thar never runs as fast as you'd like, Since there's\na long list of optimizations that you could make, its very important to understand\nwhy its slow so you cin wisely use your optimization time.\n\nThe first ching to notice about A* is thar it is at the mercy of the search space. Usu-\nally, the sheer number of connections to search is a good indication of how fast At\nworks. In a rectangular grid of 1,000 by 1,000 squares, there are 1 million possible\nsquares to search. To find an arbitrary path in that kind of world simply takes a lor of\nwork, no matrer how optimized your code. The solution is to optimize the search space.\n\nOnce the search space has been optimized, it's time to look deeper into the actual\nA implementation, Since A* churns through alot of memory, it’s critical to optimize\nmemory allocation as well as cach of the data accesses. A also demands a lor of sart-\ning, bur this can be dealt with quickly and efficiently using some specialized dara\nstructures.\n\nLastly, the best way to speed up A* is by not using itar all for simple cases. Con-\nstruct some Kind af test to determine whether you absolurely need to fire up the\npathfinder. Many times, simple routes can be determined without using the full-\nblown A* implementation. For example, try running a blind straight-line path to the\ngoal, resting to see if it collides with walls or other objects. Undoubtedly, there will be\n\ntimes when this simple solution works amazingly well.\n\nSearch Space Optimization\n\nSimplifying the Search Space\n\nThe biggest win always comes from searching through less data. If you can represent\nyour world as a simplified connectivity graph, A* will work all the faster. Practically,\nthere are several options to choose from, Since speed isn't the only consideration,\nsome other pros and cons are also discussed here. A simple diagram of each technique\nis provided in Figure 3.5.1.\n\n3.5 A* Speed Optimizations 273\n\nRectangular or Hexagonal Grid\n\nDeseripian\n\nA uniform rectangular or hexagonal grid is overlaid onte the world, The size of each\ngrid space is proportional to the size of the smallest character. Therefore, a character\nin a grid space blocks thar space during the A* search. See Figure 3.5. 1a.\n\nPros\n* Obstacles and characters can be easily marked in the grid allowing for avoidance.\nThis creates a one-step solution to finding a path through static and dynamic\nobjects.\n© Works well for 21D tile-based worlds.\n\nCons\n* Typically recules in the largese search space.\n* Rectangular grids don't map very well onto 3D worlds.\n* Paths cend co look like moves on a chessboard,\n\nActual Polygonal Floor\n\nDesorption\n\nIn a 3D game world, the floor polygons are specifically marked and used direcaly as\nthe search space. This polygonal floor is identical to the rendered geometry, thus\nbeing arbitrarily simple or complex. See Figure 3.5. 1b.\n\nPros\n* Data strocture already exists in the 3D world,\n* Can be walked through quickly with a BSP tree.\n\nCans\n* Three-dimensional worlds can have arbitrarily high numbers of polygons on che\nfloor.\n* Cant represent obstacles such as tables or chairs (because the floor exists beneath\nthese objects).\n* Requires algorithmic solution for choosing path points within a polygon.\n\nA B t o\nFIGURE 3.5.1. Four options for representing the search space.\n\nSection 2 Artificial Intelligence\n\nPolygenal Floor Representation\n\nDescription\n\nAn artist or level designer creates a polygonal floor representation thar is used exelu-\nsively for pathfinding. The polygons can be eliminated in places where characters are\nnot allowed to walk, such as under tables or chairs, See Figure 3.5. 1c.\n\nPros\n* Simall search space representation,\n* (Can be walked through quickly with a BSP erce.\n* Obstacles can be incorporated in the representation.\n\nGores\n* Requires artist or level designer to construct.\n* Cant represent characters within che space.\n* Requires algorithmic solution for choosing path points within a polygon.\n\nPoints of Visibility\nOescriptian\n\nPoints are placed at convex comers in the world (sticking out a little from each cor-\nner). Each poine is then connected to all other points that it can “see”. This creates a\nconnectivicy graph that describes the minimal paths required to get around walls. See\nFigure 3.5. 1d\n\nPros\n* Creates minimal search space representation,\n* Obstacles can be incorporated in the representation,\n* Resulting paths are perfecely direct.\n\nCons\n\n* Requires alporithmic or designer assistance co create the graph,\n\n* Obstacles canit be removed from the graph if chey should be destroyed.\n\n* Cant represent characters within che space.\n\n* Doesn't work well with entities that have large widths, such as a wide formation\nof characters.\n\n* Worlds with curved walls could cause the graph to become unnecessarily com-\nplex.\n\nAs you can see, there is no obvious choice, Each representation has its trade-offs,\nIf your world is 31 with few dynamic obstacles, then using points of visibiliry is a rea-\nsonable choice. IF your world is 2D tile-based or there are hordes of moving characters\n(as im a large RTS game), a rectangular grid might be che best choice. Just remember\nthat your decision in choosing a search space representation has huge repercussions in\nterms of speed and flexibility,\n\n3.5 A* Speed Optimizations = 275\n\nPoints of Visibility Explained\n\nSince using points of visibility is an extremely viable oprion, it's worth explaining a lie-\ntle better, The technique requires that you build up a praph thar can be used to get\naround the world. Points are placed at convex comers and connected to all other\npoines they can see. It's as though a freeway system has been constructed for che sole\npurpose of petting around walls, The problem now is how you get on and off the free-\nway:\nTo get on the freeway, you test the visibiliry berween che starting point and every\npoint on the freeway. Since you can potendally compare thousands of points, it's\nimportant that you use other space-partitioning techniques (such as hierarchical\npathfinding). Once you have a list of potential on-ramp points, you pur them on the\nA® Open list and begin running the algorichm. With each point you explore, you\nmust test its visibilicy with the goal poinc. If you find a point char can see the goal\npoint, you have a potendal off-ramp. Figure 3.5.2 shows a simple example.\n\nHierarchical Pathfinding\n\nHierarchical pathfinding is an extremely powerful technique char speeds up che\npathfinding process. Regardless of which search space represencation is used, this\ntechnique im effect simplifies that space. Therefore, if your world representation is\nlarge, there's still hope. The hey is to break up the world hierarchically.\n\nConsider a castle. Itcan be thought of as a single, large building or as a collection\nof rooms connected by doors (a large-scale connectivity graph). The pathfinder works\nin two distiner steps. Ic firsc finds the room-to-room path, knowing the starting and\nending room. Once thar room-ro-room path is known, the pathfinder then works on\nthe micro problem of getting from the current room to the next room on the list.\nThus, the pathfinder doesnt need ro compute the entire pach before it takes the first\nstep. The micro path is figured our on a need-to-know basis as each new room is\nentered. This method significantly cuts down on the search space and the resulting\ntime to compure the path.\n\nThis technique really shines if your world is already constructed hierarchically.\nEven a 3D world could be constructed using a simple building-block paradigm. Con-\nsider a circular staircase. Normally, a circular staircase causes most pathfinders a lot of\n\nFIGURE 3.5.2. Points-of-visibiliy example.\n\nSection 3 Artificlal Intelligence\n\nFIGURE 3.5.3. Hierarchical pathfinding on a circular staircase.\n\ngricl, The structure is very 3D, mostly circular, and could spiral for a very long dlis-\ntance. A spiral staircase could be built using a quarter-turn piece of the staircase. This\npiece could then be duplicated indefinitely co create a very tall spiral staircase,\n\nA hierarchical pathfinder could blazingly compuse a path up the scaircase if it\nwere constructed in this fashion. The pathfinder would first compute che large-scale\nroute through each connecting quarter-turn piece and then would quickly find the\nlocal path from the start co the end of each quarter-turn piece, All of a sudden, a cam-\nplicated path over some rather complicated geometry becomes trivial to compute.\nFigure 3.5.3 shows an example.\n\nHierarchical pathfinding isn't restricted to rooms with doors. You can easily\nextrapolate the idea co huge fields of landscape thar are stitched together. Although it's\ntrue that there isn't one easily identifiable “door” spot anymore, the entire seam from\none field to another becomes the door.\n\nlinagine an immense world created with these stitched pieces of land. Now imag-\nine telling a character to walk from ome end to the other. No problem! The pathfinder\nfirst finds a route through the network of land pieces and then finds the local path\nfrom the current land piece co the next. With a litle work, you can even imagine\nplanning a route from the throne room of one castle to the ninth-level dungeon below\na completely different castle—even thaugh the castles might be 10 miles apart!\n\nAvolding Pauses While Computing Local Pathe\n\nSince a path is computed every time the character enters a new room, it’s important\nthar the character not pause at each door while his new path is constructed. In order\nto aveid a pause, the pach request must be anticipated and completed before the char-\nacter actually needs it. This simple trick keeps the character motion fluid throughout\nthe execution of the path.\n\nAlgorithmic Optimization\n\nPlaying with the Heuristle Cast\n\nDesigning an algorithm for the heuristic cost can at times seem more like voodoo\nthan science. The idea behind the heuristic cost is to estimate the crue cost from a par-\n\n2.5 A\" Speed Optimizations 277\n\nticular node to che goal, Here's an inceresting fact: If you always knew the true cost to\nthe goal, A* would beeline a path to che goal without wasting any search time going\ndown the wrong path. Bur if the heuristic estimate happens co overestimate the crue\ncost, the heuristic becomes “inadmissible,” and the algorithm might noc find the opti-\nmal path (and might find a terrible parh).\n\nThe way to guarantee that the cost is never overestimated is by calculating che\nfeomenic distance beeween the node and the goal. When coding A” for the first time,\nthis is the best ching co do undil irs time co optimize. Since the cost will never be more\nthan this distance, the optimal pach will always be four.\n\nOverestimating the Heuristic Coast\n\nInteresting fact #2: Using a heuristic chat routinely overestimates by a little usually\nresults in faster searches with reasonable paths. However, how much should the cost\nbe overestimated? To answer this question, you need to understand what happens\nwhen this remaining pach cost is artificially bloaced_\n\nTf the heuristic part of the total cost (tote! core = cost so mode + Desristic cost) is big-\nger than it should be, ir distorts the reasoning by which nodes on the Open list arc\npicked off. Since A* always picks the node with the least total cost, this distortion pro-\nmotes nodes closer to the goal to be picked.\n\nWhen yout look at an wA* search that’s trying to fined its way around a wall, you can\nsec a shape that develops from the modes explored (nodes on the Closed list). This\nshape is the easiest way to see the effects of playing with the heuristic estimate.\n\nWhen the heuristic equals zero, the search evolves as a circle around the starting\npoine, When the heuristic uses the Euclidean distance to the goal, the search looks\nlike an oval, with che stare and goal points the foc. When the heuristic is overesti-\nmated, che shape changes to be more of a diamond or hexagon, with the start and goal\npoines ac che extreme corners of the shape, Figures 3.5.4, 3.5.5, and 3.5.6 show the\ngrowth of the search using various heuristic costs while trying to overcome a large\nobstacle.\n\nLd = =\nGon OAL &3 : Gs)\n\nFIGUBE 3.5.4. The heurtetic cost of zero.\n\n278\n\nSection 3 Artificial Intelligence\n\ntt] = a\nWRAL. ool. OOaL\n\nFIGURE 3.5.5. The heuristic com using Euclidean distance to goal.\n\nFIGURE 3.5.6. The heuristic cost overestimaned.,\n\nWhat does all chis mean? It means that by overestimating the heuristic, the search\npushes hard on che closest nedes to the goal. This causes pressure for the search co\novercome large obstacles chat are between the start and goal points of the search. If the\nactual solution requires backtracking before going to the goal, an overestimating\nheuristic slows the search. However, if most of the time there's a way to get around\nlarge blocking obstacles, che overestimating heuristic is faster. Figure 3.5.7 illustrates\nthis point as the non-overestimating heuristic explores three times more nodes than\nthe overestimating heuristic.\n\nUlumarely, getting the right amount of overestimating requires experimentation.\nUnfortunately, if the search space is not on a grid, ir's probably not possible to accu-\nrately observe the shape of the search. Instead, you need to measure indicators such as\nthe size of the Closed list and the maximum size of the Open list.\n\nThe final size of the Closed List cells how many nodes were explored: the maxi-\nmum size of the Open list is a good indicator of how long it takes to explore each\nnode (since Open list operations take a relatively long time as the list prows big).\nWhen tuning your heuristic, you can ery cypical searches and watch che Open and\nClosed list sizes in order to identify good heuristic values, By testing searches on your\nactual game, you'll be able to tune the heuristic co something reasonable.\n\nDecoupling Pathfinding Data from the Search Space\n\nA® requires a large amount of memory in order to store the progress of each search.\nTraditionally, this memory is held inside each searchable node. If the search space is a\n\n35\n\nA* Speed Optimizations 279\n\nSL.\n\nB Walk\n\n4? Fae Feih\n\nSooners Latiog Mewriate Chrepestind otha Vewrtarle\n18 Ex plonnd Mocks $0) Explored Sanna\n\nFIGURE 3.5.7. A DOn-cwencstimating heuristic va. an overestimating heuristic.\n\nrectangular grid, cach grid square contains pathfinding mode data. If the search space\nisa polygonal mesh, each triangle contains pathfinding node data. Since an individual\nsearch almost never covers every single node in the search space, there is mo reason to\nhave this incredible amount of memory dedicated to pathfinding. For example, a\n1,000 * 1,000 tiled world has | million pachiinding nodes just sitting there unused\nmost of the time.\n\nThe solution is to decouple the pathfinding node dara from the search space.\nThis solution reduces the huge memory overhead and could also speed up searches.\nInterestingly, by decoupling the node dara from che search space, you allow for simul-\ntaneous searches, which can now occur because multiple-node data can poine to che\nsame real node in the search space. However, it’s generally not a good idea to allow\nsimultaneous scarches—siill, in certain circumstances, it mighr be useful.\n\nPre-allocating a Minimum Amount of Memory\n\nDecoupling the node data from the search space requires char each search use some\nother chunk of memory. We could simply allocate node data on che fly, bur A* can\nchurn through hundreds of modes each search, so this isn't a reasonable solution. A\nway around this is co pre-allocate a sufficiently lange block of memory that can be\nrecycled for cach A®* search.\n\nWhat is A° storing so much off It's all the data that tracks the progress of the\nsearch. Por every node explored, the algorithm needs to save the following informa-\n\ntion:\n\n. A pointer to the parent node\n\nThe cost to get to this node\n\nThe total cost (eort + Aenoristic estate)\nWhether this node is on the Open list\nWhether this node is on the Closed list\n\nhi\n\nSection 3 Artificial intelligence\n\n‘The idea is ta pre-allocate a ton of these nodes (call it the mode Aané). The actual\nnumber varies depending on the size of your largest search, Now, you done want to\npre-allocate too much memory, so this array should be able to enow if needed—or\nalternatively, force the search to give up.\n\nWhen A* explores 2 new node for the first time, it needs to ask for a frec node\nfrom the node bank When it gers a free node back, it needs te fill out the info in\norder to personalize it for this new node.\n\nStoring Explared Nodes In a Master Node List\n\nOnce a node has been personalized from the node bank, it needs to be put somewhere\nfor fast retrieval, The optimal data structure for this activity is a Aawh table, Hash\ntables allow constant-time storing and looking up of data. Therefore, we store all\nexplored nodes in this: master node lise, This hash table allows us to instantaneously\nfind our if a particular node is on the Closed list or the Open list, Remember, since\nthe node dara memory is already allocated, the hash table contains only pointers ta\nthese nodes.\n\nAr this point you might ask yourself, “Where is che Closed list?” The answer is\nthat it lives inside the master mode list. All explored nodes are stored inside the master\nnods list, and the Closed list just happens to be in the same place. This isn't a prob-\nlem, because each node is clearly marked as whether it's on the Closed or Open liss. So\nwhere does che Open list live? The Open list is maintained separately, dict the master\nnode list also contains pointers te all the same nodes that are on the Cpen list. Why\nthe duplication? Because sometimes it's faster wp find the nade you want using the\nmaster node list, and sometimes it's faster using che Open list. Ir's all about speed.\n\nWhen any given node is explored during the A* algorithm, irs possible thar che\nnode was already explored during this same search. ‘To make things simple, you'll\nwant a function that gives you back a pointer co thar particular node's dasa, whether\nits been searched before or nor.\n\nThis function first checks che master node list to see if the node has been explored\nbefore. If ic has, the function simply returns a pointer co thar existing node. If the\nnode is not in the master node list, a free node is taken from the node bank, it is ini-\ntialized to represent the desired node, and irs pointer is rerurned_ In effect, the func-\ntion completely hides the details of allocating mew modes from the node bank and\ngeting nodes char already exist.\n\nHode* GetNodel WasterWodelist nodelist, ModeLoration node location }\n{\n//GethodeFromlasterNodelist accesses the hash table of nodes\nNode\" node = GetNodeFromWasterNodelisty nodeliet, node location );\nif({ node ) {\nretura( mode )5\n\nelon\n{ /#Mot in the Master Node List — get mew one fron the Node Bank\nNode* nawiede = GetFreeNodeFrondodedank();\n\n35\n\nA* Speed Optimizations 204\n\nnewNode->locatian = mode location;\nnewNode-ronOpen = false;\nnewhods ->orGlosed = false:\n\nffStoreahodelnMasterhadelist places the node inte the hash table\nStoreladelnMastarNodelist( modelist, newNode );\nreturn( newiede };\n\nOptimizing the Open Liat\n\nThe beaury of A* comes from its ability to direct the search toward the most promis-\ning directions. The way it achieves this goal is by putting all nodes it could search next\nimmo the Open lise. It then orders the list from the most Promising to de lease promis-\ning nodes to search. The problem ix that the Open list tends co get big, and each time\nit goes through the A* loop, the most promising node must be extracted from che list.\nThe node to extract is che one with the lowest total cost (cost fo get to the node + Bewris-\nBc entimate of the remaining cost to the goal), As it turns out, the best way to store che\nOpen list is co keep it sorted as a priority queue.\n\nA prtoriry queue can be implemented as a binary heap. A Ainary Aeap is a sorted\ntree thar has che property thar che parent always has a lower value than its children.\nHowever, there is no ordering among siblings, so a heap is nora completely ordered\ntee. Because of this interesting property, insertions and extractions (removing the\nlowest clement) take only Oflog n). Fortunarely, thar’s preery much all At needs to do\nwith the Open list.\n\nImplementing a Priority Queue\n\nIt's out of the scope of this article to implement a priority queue from scracch, but\nthere's an casy way to implement one using STL. Whether you're using STL or nor, be\nsure to check out 2 grear article about priarity queues [Nelson96). Ir describes prior-\nity queues Clearly enough that you could probably construct one withour the help of\nSTL. Otherwise, consult any standard algorithm and dara strucrure hook far more\ninformation.\n\nIn order ro properly use the priority queue, use the following four operations that A*\nneeds ro perform on the Open list:\n\nExtract the node with che minimum total cost (and resort the list): Ofleg 7).\nInsert anew mode on the Open list (and resort the list}: Oflog ni).\n\nUpeate the total cost of a node already on the Open list (and resort the listh:\nOfnedog m),\n\n4. Determine whether the Open list is empry= O(1).\n\nSTL actually implements a priority queue with something called a connainer\nadapter. However, the operations that can be performed on ir are very limiting. In\n\nFoes iP\n\n282 Section 3 Artificial Intelligence\n\nfaet, it has no interface co perform operation #3 (updating a nodes total cost and\nresorting the list). Therefore, we can't use the STL implementation of a priority\nqueue. However, we can use the STL heap operations on an STL vector container co\nmake our own prioriry queue!\n\nLissings 3.5.1, 3.5.2, 3.5.3, and 3.5.4 coneain the four Open list operations along\nwith the node object, the heap object, and the STL comparison object—all imple-\nmented in C++ using STL, In addition, on the CD that accompanies this book, you'll\nfind that Greg Snook’s pathfinding article, “Simplified 3D Movement and Pathfind-\ning Using Navigation Meshes,” contains almost identical code for implementing an\nSTL prioricy queue.\n\nA* Using the Optimized Master Mode List and Open\nList\n\nThere's nothing too tricky about using che ideas presented, bur just in case, the eurs of\nthe A* algorithm are implemented in Listing 3.5.5 using the master node lise and the\nOpen list. Some other small wicks are also included, such as not searching the node\nfrom which the search just came.\n\nConclusion\n\nSince pathfinding is fundamentally a tough computational problem, the besc strate-\ngies have always been to simplify the problem. Before any effort is made to optimize\nthe algorithm, ensure that the world is represented in the simplest reasonable way.\nOnce that’s decided, ir's very importance that some kind of hierarchical scheme is also\nincorporated. Usually this scheme involves some pre-processing that requires level\ndesigners and artists to be very involved in the search space representation. Alchough\ninadds some overhead to the development of assets, there's no better way to speed up\nparthfinding.\n\nOnce the search space is finalized, it’s important to get the pathfinder working\ncorrectly in thar space before any optimizations are atcempred_ A™ is not a trivial alga-\nrithm, and it’s extremely difficult wo debug if many of the optimizations have been\nincorporated. When you are ready to optimize, start by decoupling the node memory\nfrom the search space, The next step is to implement a priority queue for the Open\nlist and a hash table for the master node/Closed list. Finally, when everything works\nlike a charm and the pame is stable, you can play with the heuristic cost. In order go\nget the bese results, you'll wane co rune the heuristic several times during development\nas the game world becomes better defined.\n\nAfter all these techniques have been implemented, che next step is co chear. Some\ntechniques for giving the impression of instantaneous pathfinding can be found in the\n“A® Aesthetic Optimization” article in this book. The trick involves making the player\nthink that a path has been found when in reality you are just stalling. If che player\nfeels chat the game is very responsive, the pathfinder appears to be unobtrusive and\n\n3.6 A\" Speed Optimizations\n\nnransparent, which is the core reason for speeding it up.\n\nListing 3.5.1: Node Object\n\nclasé Hede\n\nq\npublic:\n\nNodelocation location; // lecation of node (some location\nff representation)\n\nNode* parent; ff parent node [zero pointer represants\nff starting node)\n\nfloat cost: ff cost to get to thie node\n\nflnat total; ff tetal cost (cost * hewristica estinate}\n\nbool anOpen; ff on Open list\n\nbool anGliosed: ff on Glosed list\n\nListing 3.5.2: Priority Queue Object\n\nclass PriorityQueue\n\n{\n\npublic:\n‘fHeap inplamentation using an STL vector\nfffiete: tha weetor is an STL container, but the\n‘foperations done on the container cause it ta\n(/D8 a priority queue organized as a heep\nStd: :vector<Node*> heap;\n\nListing 3.5.3: STL Comparison Function\n\n— ——\n\nclass NodeTotalGreater\n\n{\n\npublic:\n/Thia 18 required for STL to sort the prierity quave\nf/(ita entered as an argument in the STL heap functions)\nbool aperater()( Nede * first, Node ~ second ) const {\n\nratural first->total > second->total |;\n\nt\n\nIi\n\nListing 3.5.4; Four Open List Operations\n\nKode\" PopPriorityucuel PriorityQueues poweue }\nq {{Tatal time = Ofleg aj\n\n(fGet the nade at tha front — it has the lowest total cost\nBode * fodé@ = pqougua. heap. tranti ys\n\nSection 3 Artificial Intelligence\n\n=\n\n‘/pap_heap will move the node at the front to the position WN\n‘fand then sort the heap to make positiens 1 through M-1 correct\n(f(5TL makes 0 assumptions about your data and dogsn’t want\n‘ite change the seize of the container.\n\nStd: :pop_heap( poueue.beap.begin(), pqueue.heap.end(},\nNodeTotalGreater() ;\n\nffpop_back() will actually remove the last element from the heap\nifimow the heap is sorted for positions 1 through Ww}\nqueue. heap. pop_back( );\n\nreturn{ mode };\n\n}\n\nvoid PushPriorityQueue( PriorityQuewea pqueve, Node\" node }\n{ J/Total time = O(log nj\n\n//Pushes the node ente the back of the vector (the heap is\n// now unsorted)\nPOvEUE heap. puch back( mode }3\n\n{{Sorte the new elegant into the heap\nSOI: push hesol powgue.heap.bagin(), pqucue.heap.end(),\nNodeTotalGreater() 4:\n}\n\nvold UpdateNadetnPriorityQueue( PriorityQueuek pqueuwe, Nada™ node i\n{ /ffTotal tine = O(mtlog nj)\n\nifleng through the heap and find the node to be updated\nstd: vector<hode*>::iterator i:\nfor{ i=pqueve.heap-begin(); il=pousue.heap.end(j; itt }\nif\nit( (*i)-slacation == node->Location |\n{ /fFound made = resort from this position in the heap\nfi(since its total value was changed before this funetion\nifwags called)\nata: push _heap( pqueve.neap.begin(), i+t,\nHodeTotalGreatar() J:\nreturn;\n\n}\n\nbool IsFriorityQueucEnpty( PriorityGueuek pquewa }\n{\nffempty() 48 an STL function that determines if\nifthe STL vector has no alemente\nreturn( pqveue.heap.enpty() J:",
      "page_number": 266,
      "chapter_number": 29,
      "summary": "This chapter covers segment 29 (pages 266-278). Key topics include node, list, and heap. To find an arbitrary path in that kind of world simply takes a lor of\nwork, no matrer how optimized your code.",
      "keywords": [
        "Open list",
        "Optimizations Steve Rabin",
        "node",
        "search space",
        "Master Node List",
        "list",
        "search",
        "Steve Rabin Traditionally",
        "Node List",
        "che Open list",
        "Open",
        "Steve Rabin",
        "Speed Optimizations Steve",
        "search space representation",
        "Closed list"
      ],
      "concepts": [
        "node",
        "list",
        "heap",
        "search",
        "searches",
        "path",
        "optimizations",
        "optimization",
        "optimized",
        "optimize"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 8",
          "chapter": 34,
          "title": "Segment 34 (pages 317-324)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 37,
          "title": "Segment 37 (pages 1180-1210)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "operating_systems_three_easy_pieces",
          "chapter": 21,
          "title": "Segment 21 (pages 193-203)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 6,
          "title": "Segment 6 (pages 48-56)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 33,
          "title": "Segment 33 (pages 662-682)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 30,
      "title": "Segment 30 (pages 279-290)",
      "start_page": 279,
      "end_page": 290,
      "detection_method": "topic_boundary",
      "content": "3.5 A* Speed Optimizations —\n\nListing 3.5.5: A* Implemented with a Master Node\nList and a Priority Queue Open List\n\nMasterliadeList g nodelist;\n\nbool FindPath( Gasedaject* ganechject, Worldlocation goal 4\nt\nif/Get & path in progress aif it exists for this gene abject with\n// this goal\n(fA Path may have Been started and not finished from Jast game tick\nfiTf 00 path in progress, it raturna an empty path structure\nPath* path = GetPathiInFrogress{ gamecbject, goal }:\n\nif( lpath=>initialized j\n\n{ (ithe InitializePath function fills out the path structure for\nffthis path reguest\nFfTt initializes a clean WasterNodeList and a clean Open list\nInitializePath( path, gamgahject, goal 4;\n\nifCreate the very first mode and put it on the Open list\nWode* startnode = GetNode( g nodelist, GetNodeLocation|\ngameabject-spos ) };\n\nStartnode-+onQpen = true; SiThas node goes on Open List\nStartmode-sonGlesad = falsa; (This node. not on Glosed list\nStartnode->parent = 0; {i This node has no parent\nStarthoade-scost = 03 {/This node has no cast to get to\n\nStartnade->total = GetNomeHeuristie( startnode-=location,\npath. goal js\nFushPriorityOueue( path.open, startmode );\n\n}\n\nwhilet (IsPriorityduaueEnpty( path-sopen } )\n\n|\n/#Gét the best candidate node to search next\nNode\" bestnode = PopPrierityQuewe( path.apen );\n\nif( AtGgal[ bestnode, goal | )\n\n{ ffFound the goal mode — construct a path and exat\nifthe complete path will be stared inside the gane object\nGonstructPathToGesl( ganeobjest, path 4;\nretura{ true Mi hipetirn with success\n\n}\n\nwhile! f*leop through al] connecting nodes of bastnode*/ }\nf\n\nNode newnde;\n\nneamode.location = /*ehatever the new location is*/:\n\n[This avoids searching the node we just came tron\nif( bestnoda-=parant == 0 |!\n\nbastnade->sparant-*Location {= newnode.location |\n{\n\nnewnade.parent = bestnoda;\nhewnnde.cogt = bestnode-scost + GostFromNadeTonode |\n\nSectlon 3 Artificial Intelligence\n\ndnewnods, bastnode 7\nhewniedd.total = ngemode.cast:\n\nffGet the preallocated nada for this location\n\n(Both mewnode and actualnode represent the same node\niflotation, but the search at this point may not want\nifte ¢loabber over the data fram a more promising route —\niithus the duplicate nodes for now\n\nHoge* actualmoda = GetNode( g_nodelist,\nnownode, location );\n\n/iKote: the Tollowing test takes O(1) time (na sé#arching\n/ithrough lists)\nif{ !( actualnode-sandgen £8 noenode.total >\nactualnode-=total ) 4&4\n'( actualnode-sanClosed A newnode.totel >\nactualnade->total | }\n{ JitThis node is very pramising\n(Take it off the Open and Closed lists (in theory)\nFfand push on Open\nactualnode--ontloged = false; /fetteactively removing it\nfitrom Glosed\nactualnode->parent = agwoods. parent;\nactualnode->ceet = nownode.cost:\nactwalnode->tatal = nowneda, total:\n\nif{ actualnade-sonQpen }\n\ni #fSinee this node is already on the Open list,\nffupdate it's position\nUpdatenodadaPriorityQueua, path.apen, actwalnode j:\n\n}\n\nelse\n\n{ ff Put the node on the Opan List\nPUSHPriorityluewe! path.open, actualnede };\nactualnede->ontpen = true:\n\n}\n\n}\n}\n\nifMow that we'ws explored bestnade, put it on the Glosed list\nbestmada-sonClosed = true;\n\nFfUSG 50m methed to determine if we've taken too much time\nFfthis Tick afd should abort the search until next tick\nif({ ShouldAbortSearch() ) {\nreturn( false };\n}\n\n}\n\nHitt wa got here, all nodes have been searched without finding\nfithe goal\nreturn{ talse );\n\n3.5 A* Speed Optimizations 27\n\nReferences\n\nA® Algorithm\n\n[Heyes-Jones98] Heyes-Jones, Justin, “A* Algorithm Tutorial,” available online at\nwww.gamedev.net/ reference! programming/ai/article690,asp, 1998.\n\n[Parel99] Patel, Amic J_, “Amit's Thoughts on Pathfinding,”” available online at\nhtrp.! cheory.stanford.edu/-amitp/GameProgramming/, November 27, 1999.\n\n[Stouts] Srour, Bryan W., “Smart Moves: Intelligent Path-Finding,” Creme Devel:\naper, —October!Nevember 1996, pp. 28-35, also available online ar www, gama-\nsutta.comfeareres! 1021 2/em Obes.\n\nData Structures\n\n[Lewis91] Lewis, Harry Ru, Dine Srrwcrures artel Ther Alport, HarperCollins Pub-\nlishers Inc, 1991.\n\n[Nelson96)] Nelson, Mark, “Priority Queues and the STL.” Or Dabbi fournal, also\navailable online at www.dogma.net/marke/articles/pq_sel/priority htm, January\n1996.\n\n3.6\n\nSimplified 3D Movement and\nPathfinding Using Navigation\nMeshes\n\nGreg Snook\n\nGerting an object to move from Point A to Point B intelligently has always been a\nchallenge for the game programmer. Doing the same for an object in 3D Space is a\ngrearer challenge still. In today’s world of complex 31 environments, the task can\nbecome overwhelming. This article proposes a rather simple method to help over-\ncome these obstacles and get all your objeccs safely to Point B wich the least amount\nof work: Ghear.\n\nYes, chiear. Rarely do real-time games have the time to compute true 3D) objecc-\nto-scene interaction and pathfinding, and the code complexity wo do so is often\nunnecessary for most applications, We are here to find the easier way out. We seek a\nsimple, extendable method to roll our dice and move our mice in a way that looks\nbelievable to the player. Ler’s face it: The easiest ways almost always invalve cheating.\n\nIn a Nutshell\n\nWhat we need is a way to simplify 31D space into more familiar 21D terms. Objects in\n2D space move in a highly predicable fashion and can be controlled very intuitively\nby the player. In addition, there isa myriad of 2D search algorithms at our disposal to\ncreate intelligens parhs for our objects to move on. Whar we will create is a method\nallowing our objects to function in a pseudo-3D environment while providing a full-\n3D presentation for the player. To do this, we employ a mesh of triangular polygons\nto represent our 3D space as a warped 2D playing field,\n\nThe idea stems from the fact thar, for most game environments, you can pretry\neasily predict where objects can and cant move. From thar information, a simple ser\nof geometry can be created to define this area as a “walkable” surface area, One way to\nvisualize this area is to imagine a room within a typical 3D environment. Since your\ncharacters are humanoid and the planet hosting the came has gravity, you can assume\nthe game objects will spend most of their time on the floor of this room. You can also\n\n3.6 Simplified 30 Movement and Pathfinding Using Navigation Meshes 289\n\nFIGURE 3.6.1. A 31 environment with the associated navigation mesh drawn in wireframe.\n\nassume that they wont be walking through the pillars, desks, soda machines, and\nother objects sharing the floor space. We can define che remaining portions of the\nfloor with some simple, coarse geometry that covers the open, walkable surface area.\nThink of this geometry as a sort of polygonal carpet, which we refer to as a navigation\nmea. Tt represents the area around which your objects can meve within the environ-\nment, Figure 3.0.1 shows the 31D environment used in the mertmerh program avail-\nable on the CD thar accompanies this book. The wireframe polygons show the\nfavigation mesh, which defines the area where objects can move.\n\nIn a sense, this navigation mesh object can be treated like the grid systems\nemployed by 2D tile-based games. Each polygon of the mesh can be thought of as a\ngrid cell, except that they artach to adjacent cells on chree sides instead of four, With\na bie of effort, we can even use this mesh for traditional grid-based algorithms such as\nline-of-sight detection and pathfinding, The added bonus is that our replacement for\nthe 21D grid can have cells of irregular shape and size, wind up and down srairs and\nhills, and even overlap irself on things like bridges and carwalks—all while providing\naccess to the same time-tested 2D algorithms we all know and love.\n\nUnlizing a navigation mesh can also reduce the amount of collision testing\nrequired berween an object and its static environment, Since the navigation mesh\nalready represencs an approximation of the open surface area in the environment, our\nobjects need collide with only the mesh edges rather than the true scene geometry. By\nProjecting a control point from the object onto the mesh, we can casily track ebject\nmovement and collisions with 21D line intersection tests rather than full 3D polygon\nintersection, In cases in which higher detail is needed for collision, che mesh cells can\nstill link to sets of rue scene geometry for refined testing. Objects char collide with a\ncell edge would chen be passed onto routines that resolve the collision with the associ-\nated room geometry. Linking process dara with che cells in chis manner serves as a\n\n250 Section 2 Artificial intelligence\n\nquick-and-dirty proximity test for objects in motion, an idea that can be extended to\ntigger traps, doors, or switches whenever an object enters a given cell or collides with\na particular edge.\n\nConstruction\n\nNavigation mesh geomerry needs to adhere to a few simple rules in onder to work cor-\nrectly. First, it needs co be compased completely of wiangles co ensure chat each cell is\ncontained in a single plane. Second, the entire mesh must be contiguous, with all\nadjacent triangles sharing two vertices and a single edge. Finally, no cwo triangles\nshould overlap on the same plane. That is, any piven point within a triangular cell\nshould be exclusive to thar cell. This will aid our algorichms immensely and provide\nbelievable movement for che player.\n\nThe navigation mesh is mor intended to be vistble to che player. We use it only\nbehind the scenes co limic character movement and determine paths. Therefore, it\nneed consist of only the minimal amount of polygons necessary to represent che area\nin which objects can move. Highly detailed navigation meshes might produce che\nmost accurate resules, bur their overhead would be a limiting factor for mast real-time\ngames. The mesh should be one that contains only che cells necessary to facilitate\nbelicvable movement to the player, not one that represents every pebble and twig on\nthe prownd.\n\nRoll the Dice and Move Your Mice\n\nTo begin, we first examine using the navigation mesh to conrol object movement in\na 3D environment. Once we have our objects happily interacting with the mesh, we\ncan extend its use for pathfinding and line of sight. Bur firse chings first: We need to\nget some objects moving around the confines of the mesh geometry.\n\nWeattach objects to the mesh using a. control point that will he locked to the nav-\nigation mesh surlace. This control point may never leave the mesh, but it can move\nabout the surface of the mesh ac will. Using our polygonal carpet example, imagine a\nperson standing in a room. The concrol point can be visualized as a marble sitting\ndirectly below the person, resting between his ar her feet. Wherever the person is\nmoved in the room, the marble rolls along, always maintaining a position on the car-\npet directly under the person.\n\nAll desired object movement is transferred ea this control point, which, in wen,\ngers resolved on the surface of the navigation mesh, The object is then moved relative\nto the new control point location. In our example, kick the marble and let it ricochet\noff the walls, then move the person to the new marble location.\n\nThe basic procedure is as follows, giver that each object maintains a control point\non the mesh and we know which cell of the mesh currently contains the concral\n\nPoint:\n\na6 Simplified 3D Movement and Pathfinding Using Navigation Meshes 254\n\nI. Project the object's desired motion vector onto the plane of its current cell. This\ntranslares the motion into a 2D vector along che plane of the cell. We'll call this\nnew vector a motion path and represent it asa 2D line segment. The endpoints af\nthe segment are the starting location of the control point and the desired ending\nlocation, bork translated to 2D space relative to the plane of the cell,\n\n2. Test the motion path against the cell’s 2D triangle edges. Duc to the nature of rri-\nangles, we know that for our path to exit the cell, ic must intersect with exactly\none side of the triangle. So, we cest the 2D) line segment of the motion path\nagainst the three line segments representing the cell wiangle for any possible inter-\nsections. There can be only one of three possible results to this test:\n\na) Our path intersects with an unshared edge (Le., an edge not connected to an\nadjacenc cell). This means we have hit something solid. Resolve the collision af\nthe motion path vector and the cell wall, adjusting che motion path ro aceount\nfor any change in direction, and repear Step 2.\n\nb) Our path intersects with a shared edge. Mave to the adjacent cell and nepeilt\nthe entire process from Step 1, projecting our current veetor to the plane of che\nnew cell and resting against its walls\n\n¢) The only remaining possibiliry is that our motion path does mot exir the cur-\nrent cell. We have reached the end of our process and found che cell char hosts\nthe object's new resting position. We translate our resulting 2D motion path\nendpoint back into 3D space ta find the ruc 31D location of the control point\nand move the object relacive to it.\n\nObviously, for complex navigation meshes, this can be a very cumbersome process,\nFor each cell encountered, we need to project an arbitrary 3D vector onto a 3D plane.\nFrom there we translate the resulting vector along with the cell edges to 2D space,\nwhere we can perform our line intersection rests, Once finished moving abour the\nmesh, we need to unde the translations and projections to produce our new contol-\npoint position in 3D space.\n\nThat's quite an effort to undertake in real time, especially if you have many\nobjects to test or your objects plan co cravel over many cells in a given frame. For sim-\nple environments, however, this could he plausible and allows for che greatest flexibil-\nity in navigation mesh geometry. For complex environments, we can still speed up the\nprocess considerably with a bir more careful planning (read: cheating) and an addi-\ntional navigation mesh geometry rule: Ja facilinare fas projections. all cell normale mrest\nface in the same direction along a predetermined cardinal axis.\n\nImagine our room again with the navigation mesh carpet on the floor. All cell\nnormals of the floor point up, so they meer this new requirement of our mesh, That\nis to say; all cell normals have a positive y value in our environment, Note that we do\nhot require our new savigation mesh ro be flat, we simply no longer allow cells whose\nnormals are 90 degrees or more away from our chosen axis.\n\nSection 3 Artificial intelligence\n\nWith this new cule, the projections become incredibly simple, We simply throw\nout the dimension along the axis we have chosen. In our carpeted room example, pro-\njecting points onto the floor is now as simple as throwing their y values our the win-\ndow. In addition, when we have finished the Motion Path processing along che\nnavigation mesh cells, we have a new 2D (x, z) location and the cell that contains it.\nUsing the cell's plane equation, we can solve for y using our (x, z} location and trans-\nform ourselves back into 3D) space easily. Qur new motion-tracking process is reduced\nwo the following:\n\n1. Create 2 motion path consisting of the concrol point and the desired location,\nreduced to 2D points by tossing out their common axis values.\n\n2. Test the 2D motion path against the sides of the cell criangle as before until a cell\nis found chac contains the destination endpoint of the motion path.\n\n3. Using our new (x, 2) control point location and che plane equation of the cell it\nresides in, solve for y and reconvert our control point back into 3D space,\n\nThe #tarimiert sample program includes some simple classes thae illustrate chis\nprocess. In the source code, an object called Navigation Cell is used to represent a sin-\ngle triangular cell, and NiwigationsWest represents a collection of chose cells. Ler's first\ncamine MaigetionCell, since ix does most of the work.\n\nNevigetionCel defines a single cell of the mesh with the following members:\n\nPlane m_CellPlane; // A plane containing the cell triangle\nvectors m_Vertex[3]; ff the threes vertices of this cell\nLing2D m Side(a]; // a 20 line rapresenting each call wall\nNavigationGell* m_Link[4]; ij pointers ta celle that attach to\nff this cell on gach of its three\nff sides. A WOLL link danotes a solid\nif edge.\n\nVectors, Plane and Line2D are premy straightforward workhorse classes whose\nsource code is also provided. One point of distinction is that Line2D is really treated\nasa ray passing through wo poincs. Ir hasan implied direction, fram Endpoint A to\nEndpoint B. It also tracks a perpendicular “normal” for che 2D line segment. This\nnormal is used co classify points as being cither on the Lime’s left or right side, These\nnotions of “left” and “right” are defined as though you were standing on Endpoine A\nof the line looking toward Endpoint B, As you see in che source code, the ability to\nclassify points in relation to the line is used quite heavily in our motion processing.\n\nThe main use of NavigatonCell is to perform the seep in our process where we\ndetermine how a path interacts with the walls of a cell. NavigusionCell contains a\nmember function to classify a 21D line segment to its chee cell walls and return a\nresult. This function, ClassifyPathToGell(), is the basic building block of navigation\nmesh use. The return value of this function can be one of the following enumerated\ntypes:\n\nenum PATH_AESULT\n\n2.6 Simplified 3D Movement and Pathfinding Using Navigation Meshes 293\n\n{\nNOLRELATIONSHIP = 6, fy the path does not cress this call\nENDING _CELL, if the path ends in this cell\nEXITING_CELL ff the path exits this cell\n\nbi\n\nTn the case where EXITING_CELL is the result, che cell wall traversed as well as che\n2D point of intersection with the wall are provided to the caller, This allows us to\ncompare any 21D pach w the cell and determine what type of intersection occurs,\nWhen an intersection with a solid edge occurs, we can use the point of intersection to\ncalculate our new direction and retest. Listing 3.6.1 shows the ClassifyPathToCell(}\nfunction in detail.\n\nNavigarion/ew uses this Function as needed to process our movement as defined\nin the preceding steps. The Nevigarion/ feo’ member function ResolvewotaondnWesh{)\nmanages the entire process, testing cach cell encountered using ClassityPathTacell().\nIt takes ina 31 concrol point, a pointer co che cell is is currently occupying, and the\ndesired location for the control point after movement has occurred, Ir returns to the\ncaller the true final location of the control point and the cell the new control poine will\nreside im. Listing 3.6.2 details the use of the Resolveliotiondnvesh() function.\n\nGetting There Is Half the Fun\n\nNow thar we have seen how to use the navigation mesh to control object movement,\nwe can look into other applications for che mesh. The first obvious use is pathfinding,\nKeep in mind that our mesh consists of linked cells, which share common edges, just\nlike a gid or hex map. Any path-finding algorithms traditionally applied to a grid or\nhex map should then reasonably translate co our euesh,\n\nAsa mater of fact, using polygonal meshes for search algorithms is no new feat.\nSince path-finding algorithms were designed to work over databases of linked node\ndata, they work quite nicely across sets of linked vertices. As game programmers, we\nhave become too accustomed to seeing these methods applied co grids and hexes,\nwhich is only a stall subset of the environments within which they can be used_\n\nUsing our navigation meshes, we do add one small wrinkle to the path-finding-\nover-polygons methed: We don't use the mesh vertices. Instead, we use the midpoincs\nof each cell wall. Why? Two reasons come to mind, both of which are arguable\ndepending on your game environment, The first is that we are also using our naviga-\ntion mesh oo limit object movement in the environment. If we generate a path along\nthe cell vertices, we are always traveling on the edges of the cells. This is the most\ncostly movement on a navigation mesh, since moving down che edge of a cell cxactly\nMeans you are constantly colliding with the cell edge, causing a lot of extra, unneces-\nsary IMGEDSOction bests,\n\nThe second reason is purely aestherie. If we assume our mesh was designed to use\nthe minimal number of polygons, ir stands to reason thar there are not many vertices\n\nSection 3 Artificial Intelligence\n\nFIGURE 3.6.2. [wo overhead views ofa sample hallway and navigation mesh showing a\npath a: generated along cell edges and 6: through cell wall midpoint:\n\nor polygon edges in the body of our open space. Have a look at Figures 3.6.24 and\n3.6.2b, which show an overhead view of a hallway, and a reasonable number of paly-\ngons to define the open space within ic. If we generated a pach on the cell edges (Fig-\nure 3.6.2), we would spend mast of our time dragging ourselves against the wall of\nthe hallway. Using the cell wall midpoints (Figure 3.6.2b), we can generate a more\nvisually appealing path down the body of the hallway,\n\nfis [ said, both reasons are arguable. You could simply increase the complexity of\nyour navigation mesh and add code to avoid paths that drag along the solid edges of\nthe mesh, bur | have found it easier (and concepeually more inmicive) co move\nthrough the wall midpeints. In application, it has alse proved to be easier for che level\ndesigners creating the mesh to work withour having to concern themselves with che\nplacement of extra vertices and cell edges for pathfinding, In essence, all we have\nreally done is offset our mesh vertices to create a more believable path.\n\n30 how do we build the path? As in any path-finding situation, you need to\nchoose the best method for your game environment. Best-first searching, Dijkstras\nalgorithm, and the venerable A* can all be applied to the cells of our navigation mesh.\nEbewhere in this boak are some excellent explanations of the various search methods,\n50] will not ga inte detail on them all here. Check our the articles by Steve Rabin and\nBryan Stout in this book for detailed information on A*. You can also check the ref-\nerences at the end of this article for some recommended reading on pachfinding.\n\nFor demonstration, the save) ample code shows how to use A™ on the navi-\ngation mesh. Although it can be the most complex method co employ, A* can achieve\nhighly accurate results and is often more efficient than other methods in terms of\nmemory use and search time. However, its efficiency hinges on the use of a good\nheuristic. ‘The heuristic helps steer the search algorithm toward the goal, preventing it\nfrom fanning out all over che mesh unless necessary.\n\nThe best heuristic to use is purely a game-specific matter. Only you know how\nwell your objects move over your game's rerrain, and you need to tune your heuristic\naccordingly. You might even need to tailor separate heuristics for each object type,\ntaking into account its ability to climb steep grades, corner at high speeds, and so on.\n\n3.6 Simplified 30 Movement and Pathfinding Using Navigation Meshes 285\n\nIn most cases, however, this heuristic is simply the approximate distance from a given\ncell to the goal. For the purpose of our demonstration, this is the heuristic we employ.\n\nTo run the A* algorithm, we maintain a list of cells char need to be processed. In\nthe manimesh sample code, these “Open” cells are held in an ordered list called a Naw\nigationteap. Cells are listed in the order of best ta worst cost in terms of the distance\nrequired to reach the goal. Therefore, each time we pull a cell off the heap, we know\nwe are dealing with the current “best guess\" of the cell thar will provide the best path\nto our goal,\n\nTo begin pathfinding, we need to stoke the heap with the first cell, our destina-\ntion. We then pop and process each cell on the heap until we reach our starting posi-\ntion of man out of heap. [the heap runs dry before we reach the goal, we know there\nis mo path available berween our two locations.\n\nTo process a cell, examine each of its neighbors. We determine the distance rrav-\neled to reach each one by adding the cost associared with our current cell to the dis-\ntance required co cross the cell co cach neighbor. This Arrive! Case for each neighbor\nis then added to the neighbors’ own heuristic values co arrive at a priority score fos\neach of the neighboring cells.\n\nWe now examine the score, or cost, of cach neighboring cell to do one of revo\nthings, If the neighboring cell is not currently in the Open heap, we must sore it by its\nscore value. This essencially purs it off for later processing. If the cell is already in the\nheap, we need to see if our new score is berter than the score by which the cell is cur-\nrently sorted. IF che new score is an improvement, we need co move the cell up within\nthe heap to its new priority position for earlier processing. If the new score is not an\nimprovement, we toss it out, since a more optimal path already passes chrouph this\ncell. In either case, each time a cell is added to che heap or repositioned within che\nheap, we record che identiry of the cell thar has sec the current Aniual Case.\n\nThis is done so thar the cells can keep track of the next closest cell to the destina-\ntion along the generated path. You'll notice that the mepinresh sample runs the A*\nalgorithm in the reverse search direction, starting at the destination cell and searching\nfora path backward te our current location. When the search is complere, each cell\ncontains a link co the next cell closest to the goal along the generated path. We can\nhop through these links in the proper order, from current location to destination, and\nbuild a final waypoint list for our game object.\n\nIn the sample code, the entire process is run by the Bui ldNavigationPath() mem-\nber function of the Mergarionesh class. It uses the NavigationHMeap object to main-\ntain a list of NaeigarionCels to be processed. As each cell is pulled from the heap, its\nProcessCell() function is called, which does the work of testing each neighboring\ncell, as outlined previously, Cells are added or moved within the heap as necessary,\nuntil a pach as found. Ar that point, SuilgNavigationPath() iteraces through the cells\non the path, adding their wall midpoint co the final NawigurionPanh waypoint list.\nSource code for the entire process is shown in Listing 3.6.3.\n\nSection 3 Artificial Intelligence\n\nIt Works, But It Ain't Pretty\n\nAs you can see by the blue lines drawn in the marines’ sample program, building a\npath through polygonal objects yields a very jagged result. Very rarely will you find\nthat your navigation geomienry is set up to produce a straight-line path. The nature of\nthe mesh forces our path to meander from cell to cell, making many abrupt twists and\nturns (see Figure 3.6.34). Any object that uses this path verbatim will look very odd\nindeed to the player. Luckily, we have one final application oo discuss thar can smooth\nthe path our considerably: line-of-sight determination.\n\nBack when we were working out how to move objects around the mesh, we\ndefined a function, ClassifyPathToGeli(), co compare a 2D line of mation to a cell.\nThe result of dhe function told us whether che path ended within the cell, encoun-\ntered a solid edgc, of passed through to an adjacenc cell. We can now use that function\nagain wo perform a line-of-sight test. smoothing our our path by skipping ahead to the\nfurthest visible waypoint.\n\nFach time we arrive ara waypoint in our path, we look ahead to the next few way-\npoines in che list. By creating a line of motion from our current position to each of\nthese waypoines, we can quickly test if the waypoint are “visible.” To do this, we test\nthe path against each cell between our currenc position and the waypoint using the\nClassifyPathTocell() function. If the function rerurns a solid-wall intersection, we\nknow the waypoint is not visible from our current position. Conversely, if we reach\nthe waypoint without such an intersection, we know the point is visible to us. By\nsearching for the furthest visible waypoint up the chain, we can skip over some of the\nmeandering waypoints and smooth out our path. Figure 3.6.3b shows the new\nsmoother path generated by skipping over the redundant visible waypoints.\n\nThis method can be used for all sors of visibilicy testing. Using our Glassity-\nPath Toceli() function, we can test whether any cwo points on the mesh can see each\nother. This has some very useful applications in enemy Al, since you can quickly test\nwhether enemy objects can see the player's position ar any given moment. The Line-\nOfSightTest() member function of che NavigurionMenh class details the process for\ndetermining point visibility.\n\n[ah qb)\n\nFIGURE 3.6.3. a: A sample path generated using A®. & The same path smoothed using line-\nof-sight testing.",
      "page_number": 279,
      "chapter_number": 30,
      "summary": "This chapter covers segment 30 (pages 279-290). Key topics include path, cell, and meshes. cheory.stanford.edu/-amitp/GameProgramming/, November 27, 1999.",
      "keywords": [
        "cell",
        "navigation mesh",
        "path",
        "mesh",
        "Navigation",
        "navigation mesh cells",
        "motion path",
        "point",
        "che",
        "control point",
        "che mesh cells",
        "object",
        "Open List",
        "Navigation Meshes",
        "navigation mesh object"
      ],
      "concepts": [
        "path",
        "cell",
        "meshes",
        "mesh",
        "object",
        "listing",
        "function",
        "locations",
        "edges",
        "point"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 32,
          "title": "Segment 32 (pages 296-313)",
          "relevance_score": 0.73,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "Segment 33 (pages 314-325)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 10,
          "title": "Segment 10 (pages 91-99)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "makinggames",
          "chapter": 32,
          "title": "Segment 32 (pages 282-290)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 31,
      "title": "Segment 31 (pages 291-298)",
      "start_page": 291,
      "end_page": 298,
      "detection_method": "topic_boundary",
      "content": "2.6 Simplified 3D Movement and Pathfinding Using Navigation Meshes 207\n\nConclusion\n\nee\nT hope this article has demonstrated char 31D space need nat be so computationally\ncomplex. My goal was to show thar using familiar 2D methods (and a bit of cheat-\ning), we can greatly simplify the game environment withour impacting the player's\n3D experience. The end result is a very flexible and useful tool for moving objects\naround in 3D space without a boatload of 3D math.\n\nThis method allows you to reduce object/scene collision operations, create com-\n\nplex paths, and test for the visibility between any two paints in the environment space.\nHowever, there is still more that can be done with navigation meshes, They can be con-\nstructed of high-order primitives rather than rigid triangles, ressellated like multireso-\nlution meshes for greater path finding detail near che camera, or even animared to\nrepresent fluid surfaces, For now, I leave the exploration of these ideas to you. Give the\nmeshes a try and sec what new uses you can layer on top of chis foundation.\n\nListing 3.6.1: Intersecting a 2D Line with a Cell of\nthe Navigation Mesh\n\nHawigationGell: |PATH_RESULT MavigationCell: :ClassifyPathToCell [const\nLine2D& MotionPath, NavigatianGell** pNextCell, CELL SIDES Bide,\nvVector2\" pPountOtintersectian) const\n\n{\n\nint Interiorount = Oo;\n\nif Gheck our MotienPath against each of the thraa cell\n\nff walle\nfor (int 1-0: <3: s4i)\n{\n\nff Glassify the WotionPath endpoints as being either\nff QOM_LINE, or to its LEFT_SIDE or RIGHT SIDE,\n\nfi Since our triangle verticas are in elockwise order,\n‘f we Know that points to the right of each ling are\nff inside the sell. Points to the left are outside,\nff We do this test using the ClassifyPoint function of\nff Line2n\n\nff If the destination endpoint of the BotionPath\nff is Not on the right side of this wall...\nif (m_Sidé[i)-ClassifyPoint (MotionPath.EngPointB()} !=\nLine2D; :AIGHT_SIBE)\ni\nPf ..8td the starting endpoint of the iotiLonPath\nff is WOt on the lett side of this wall...\nif\n(f_Side]i] .ClassityPoint(WotionPath-EndPointar)) !=\nLine2t: :LEFT_SIpe)\n\nff Check to see if we intersect the wall\nif using the Intersection function of\nfi Line2o\n\n238 Section 3 Artificial Intelligence\n\nLine2i: :LINE CLASSIFICATION IntersectRhesult =\nWotionPath.Intersactiom(m_Sideliy,\npPointhf Intersection) ;\n\nif (intersecthesult ==\nLine20: ;SEGMENTS_INTERSEGT ||\nIntersecthesult ==\nLine20; :A_BISECTS_B)\n{\nff record the link to the naxt\nfi adjacent cell for NULL 4f ae\nfi attachment exists) and the\nfi enumerated ID of the side we hit.\n\n\"pNextGall = m_Link[iJ;\nSide = (GELL_SIDE)i:\nreturn {EXITING CELL);\n\n}\n}\n}\nelse\n{\nff The destination andpeint of the MotionPath\nff is on tha right sid#. Inerement our\nff InteriorGount #9 we'll know how many walls we\nf/f were to the right of.\nInteriorfount+;\n}\n\n}\n\nff An interiarGount of 9 means the destination andpoint of\nff the MotionPath was on the right side of all walls im the\nff ooll. That meane it is located within this triangle,\n\nff and this is cur ending cell.\n\nif (IinteriorCount == 3)\n\n{\n}\n\nreturn (ENDING CELL};\n\nif We reach here only af the MotionPath dees not\nif intersect the cell at all,\nreturn (NO_AELATIONSHEP) -\n\nListing 3.6.2: Resolving Motion on a Navigation\nMesh\n\nwold NavigatLonilesh::ResolveMotiondeMesh(const vectora& StartPos,\nNavigationCell* StartCell, vectord& EnoFos,\n\nHavigationCell** Endtell)\n\nt\n\nff create a 20 motion path from our Start and End\n\n2.6 Simplified 30 Movement and Pathfinding Using Navigation Meshes 258)\n\nff positions, tossing aut thair ¥ values to project them\nff dow to the Zz plane.\n\nLinezD MationPath(vectore (Starthos.*,StartPos.z),\nveetor2(EndPos.«,EndPos.z});\n\nff these three will hold the results of our tests against\nff the cé#1l walls\n\nNawigationGell::PATH RESULT Result =\n\nNavigationCell : :Mo RELATIONSHIP:\n\nNavigationGell::GELL SIDE Wal lhuaber;\n\nvector2 Polntotintersection:\n\nNavigationGell\" MextCell;\n\nff TestOell ds the cell we are currently examining.\nNavigationGell* TestCell = Starttell;\n\nif\nif Keep testing until we find our ending cell or stop\nI @oving due to triction\nil\nwhile ((Result I= MavigationGell:: ENDING CELL}\n£4 (MotLonPath.EndPaiatat) =\nUotionFath.EndPointe( )})}\n\nifouse NavigeationCell to determine how our path and\n\nff call interact\n\nResult = Test0ell->ClassityPathTotell(MotionPath,\nSNextCell, WallMunber, &PointOf Intersection) ;\n\nff aif exiting the ¢ell...\nif (Result == NavigationGell::EXITING CELL)\n{\nff Set if we are moving to an adjacent ¢e11 or\nff we have hit @ solid (unlinked) edge\nit (MextCell)\n{\nff moving on. Set our motion origin to the\nff point of intersection with this cell\nff and continue, wsing the new cell as our\nff test cell,\nMetigarath, SatEndPointal PointOfintersaction}:\nTestCell = MaxtCell;\n}\nelse\n{\ni} we haye hit a solid wall.\nfi) Resolve the collision and cerrect our\nit path,\nMationPath. SetEndPointa(Pointlfintersection):\nTestCell-s?rojectPathinCell Wall (WallNunber,\nMationPath) ;\n\nff add same friction ta the new MotionPath\nfi sintea we are scraping against a wall,\nif we dg this by reducing the magnitude of\n\nSectlon 3 Artificial Intelligence\n\nfd our motion 10%\nweotor2 Direction =\n\nMotionPath. EndPointe() =\n\nBotionPath. EnOPointAl } ;\nDirection \"= 0.9T;\nMotionPath.SetEndPointh(letionPath.EndPodntaAl) +\nDirection);\n\n}\n\ni\nelse if (Result == NavigationCell: :MO RELATIONSHIP}\ni\n\nff Although theoretically we should never\n\nff encounter this case, we do sometimes find\n\nff qureelvas directly on a vertex of the cell.\n\nff This can be viewed by some routines as being\nif outside the call. To accommodate this rare\nif case, we force our starting point into the\n// current cell by nudging it back so we may\n\nif continue.\n\nWeoters Newlrigin = MotionPath,EndPointAl):\nTesteel1->ForcePointTocellCollumn(Newrigin) ;\nMotionPath  SetEndPointa(Newtrigin) :\n\n}\n\ni/o we now have our new host cell\n\"EndGell = Testte11:\n\ni! Update the new contral point position,\n\nfi solving Tor ¥ using the Plane member of the\nif Mavigationtell\n\nEndPos.«x = MotionPath.EndPoint®().x;\n\nEndPos.z = MotionPath.EndPoint8().¥;\n\nTestCell -sWapVectorHeight Tetell (Endres);\n\nListing 3.6.3: Building a Navigation Path on the\nMesh Using A*\n\nbool NavigationMesh: :-BuildNavigationFath(NavigationPath&’ NavPath,\nHavigationGell* StartCell, const vector3& StartPos,\nNavigationCell* EndCell, const wactors& EndPos)\n\nbool FoundPath = false;\n\nff Incramant our path finding session ID\n\nff This identifies each path finding session\nif $0 we do mot need to clear out old data\nff in the cells from previous sessions.\nt++m_Pathdession;\n\nif load our data inte the NavigationHeap object\n\n2.6 Simplified 3D Movement and Pathfinding Using Navigation Meshes 307\n\nii to prepare it for use.\nA_Naviitap.Setup(m PathSession, StartPa) ;\n\n7 Wa are doing & reverse search, Trom Endtell to\nff StartCell. Push our Endtall onte the Heap as the first\nj/ cell to be processed.\n\nEndtell->QueryForPath(in NavHaap, 0, 0):\n\nfi} process the heap until empty, or a path is found\nwhile (n_Navigap.NotEmoty() && 1FoundPath)\n{\n\nNivigationNode ThisMode;\n\n/? Pop the top cell (the open cell with the lowest\n‘f east) off the Heap\nfh_MavHeap. GetTop(ThiaNode}:\n\nff if this cell is our Starttell, we are dona\nif(Thisheda.cell == StartCell}\n{\n\n}\nelse\n\n{\n\nFoundPath = true;\n\nif Process the Cell, Adding its neighbors te the\nii Open Heap as needed\nTHishode.cell->ProcessCell( dm Mavieap) +\n\n}\n\nfi If we found a path, build a waypoint list\n// gut of the cells on the path\nif (FoundPath)\n{\nNavigationGell* TestCell = StarttCell;\nVECtOrS NewiayPoine:\n\n// Setup the Path object, clearing out any old data\nNavPath.Setup(this, StartPos, StartCell, EndiPas,\nEnigtel1):\n\nff Step thraugh each cell linked by aur A* algorithm\nff trom Starttell ta Engtell\nwhile (TestCell £8 TostGell f= Endtell)\n{\nff add the link point of the cell as 4 way point\nff [the exit wall's canter)\nint LinkWall = Test€ell-=ArrivalWall|);\n\nMawayPoint =~ TestGell->Wal Midpoint (LinkWall) ;\nNawayPoint - GnapPointTotell(Testtel1,\nMawWayPoint ) :\n\nff just te be sure\n\nSection 3 Artificial Intelligence\n\nNavPath AddWayPoint (NowvayPoint, TestCell) ;\n\niif and of to the next cell\nTeetGell = TestCell->Link(LainkWall):\n\n}\n\n‘i! cap the end of the path.\nNavPath.EndPath( ):\nreturn( true};\n\nI\n\nff no path exists between the two points provided.\nff d.@. \"you can*t get there from here\"\n\nff This will never happen on a contiguous mesh.\nreturn(false);\n\nbool Mavigationtell: :ProcesstelliMavigationHeap* pHeap)\n\n{\nif (m_S69si0n1D-\"pHeap->SessionID{))\n{\nff ance wet have boan processed, we are closed\nm Open = false:\nff query all our maighbore to see if they need to be\n‘f added to Open haap\nfor (amt 1=0;1<35++1)\nif (m_Link[i])\n{\niy The Distances between the wall midpoints\nfy oof this opll are held if th® order\ni) ABtOBG, BOTOOA end CAtoAB.\nfy abs(i-n_Arrivalwall) 44 a farnula to\nff determine which distance measurement\nff to use. We add this distance to known\nff marrivalCest to campute the total cost\nif to reach the next adjacent call.\n@_Link[i]->OueryForPath(pdeap, this,\nB_Arrivaltast+m Walllistance| abs (\ni-m_ArrivalwWall)j}:\nI\n}\nreturn(true);\n}\nrequrn(false) ;\n}\n\nbool NayvigationGall: :QueryForPath(NavigationHeap* pHaap,\nNavigationGell* Caller, flaat arrivalcost)\n{\n\nif (m_SeseionID!=pheap->Sessionio ))\n\na6 Simplified 30 Movement and Pathfinding Using Navigation Meshes\n\nI\n\nfi this is a naw session, reset our internal data\nH_SessioniO = pHeap->SeasionID( |:\n\naf {Galler}\ni\n\nn_Open = true;\nConputeHeuristic(pHeap->Goal());\nn_ArrivalGost = arrivaleast:\n\nii Remember the triangle wall this caller is\ni} oenta ring Tron\nif (Caller == s_Link[O))\n\n{\nn_ArrivalWall = 0;\nI\nelse if (Caller <= m Link[1]}\nt\nn_ArrivalWall = 1:\nI\nelee if (Caller == m Link[2)}\n{\nn_ArrivalWall = 2:\nIr\nI\nelse\n{\n\ni} We are the cell that contains the starting\nii Iaeation of the A*®* search.\n\nm Open = false:\nM_ArrivalGest = oO;\nmn Heuristic = O;\nm_ArrivalWall = 0;\n\nI\n\nff add this cell ta the Open heap\nPHeap ->AddCell (this) 5\n\nreturn( true);\n\nelee if (m_ Open)\n\nf\n\nfi] A true m_Open means we are already in the Open\n\nfi Heap. If this naw caller provides a better path,\nff adjust our data. Then tell the Heap te reasert our\n{i} position in the list.\n\nif ((arrivalcost + m_Heuristic) =< (m_aArrivalCast + m Heuristic) }\n{\n\nf_Arrival€est = arrivalcost;\n\n!! Renember the triangle wall this caller is\n!! entering fron\nif (Caller = n_Link[d])\n{\nm_ArrivwalWall = 0;\n\nk:\n\nSectlon 3 Artificial Intelligence\n\n}\nolse if (Caller == m_Link[1})\n\n{\nn_ArrivalWall = 1j\n\n}\nelse if (Caller == m_Link[2])\n{\n\nmn ArrivalWall = 2:\nij\nIi @8k the heap to resort our position in the\nii priority heap\npHeag->Adfuetlell (this);\nreturn (true);\n}\n\n}\n\nfi this cell is closed\n\nreturn(falsep ;\n\nwoid NavigationGell::ComputeHeuristic(canst vectar3& Goal)\n\nff qur hauristic is the estimated distance (using the\nff Longast axie delta) between our cell canter point\nff and the goal lecation\n\nTioat KDelta = fabs(Goal.x - o_GanterPoint.™);\nTloat YWelta = fabs(Goal.y - m_CanterPoint.y):\nTloat 2De1ta = fabs(Goal.z - m_CanterPoint.?):\n\nM_Heuristic = _ max(_ mix(XOelta, Delta), 7Delta):\n\nReferences\n\n[Patel99] Patel, Amit J., “Amits Thoughts on Pathfinding,” available online at hup:/f\n\ntheory.stantord edu/—amitp/GamePmgramming!, November 27, 1059,\n\n[Heyes-Jones99] Heyes-Jones, Justin, “A* Algoricam Turorial,” available online at\n\nwww. gamedev.net/reterence/programming/aifarticleG90.asp, November 27, 1999.\n\n[Stouc?6] Sout, Bryan W., “Smart Moves: Incelligent Path-Finding,” Game Devel-\n\noper, alto available online at www-gamasurra.com/fearures!19990212/sm_01\nhom, Oetober 1996.",
      "page_number": 291,
      "chapter_number": 31,
      "summary": "This chapter covers segment 31 (pages 291-298). Key topics include cell, paths, and line. My goal was to show thar using familiar 2D methods (and a bit of cheat-\ning), we can greatly simplify the game environment withour impacting the player's\n3D experience.",
      "keywords": [
        "Cell",
        "Navigation Meshes",
        "path",
        "link",
        "SIDE",
        "ending cell",
        "open",
        "CELL SIDES Bide",
        "Caller",
        "Navigation",
        "wall",
        "Artificial Intelligence",
        "Heap",
        "result",
        "Movement and Pathfinding"
      ],
      "concepts": [
        "cell",
        "paths",
        "line",
        "wall",
        "endpoints",
        "meshes",
        "mesh",
        "listing",
        "points",
        "goal"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 32,
          "title": "Segment 32 (pages 296-313)",
          "relevance_score": 0.67,
          "method": "sentence_transformers"
        },
        {
          "book": "makinggames",
          "chapter": 30,
          "title": "Segment 30 (pages 266-273)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "Segment 33 (pages 314-325)",
          "relevance_score": 0.61,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "Segment 34 (pages 326-336)",
          "relevance_score": 0.61,
          "method": "sentence_transformers"
        },
        {
          "book": "makinggames",
          "chapter": 32,
          "title": "Segment 32 (pages 282-290)",
          "relevance_score": 0.61,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 32,
      "title": "Segment 32 (pages 299-307)",
      "start_page": 299,
      "end_page": 307,
      "detection_method": "topic_boundary",
      "content": "Flocking: A Simple Technique\nfor Simulating Group Behavior\n\nSteven Woodcock\n\nFlocking (sometimes called soaring or bending) is a wechnique first put forth by Craig\nReynolds in a 1987 paper he did for SIGGRAPH, “Flocks, Herds, and Schools A\nDistributed Behavieral Model.” In that paper, Reynolds proposed a series of three\nsimple mules, which, when taken together, gave groups of autonomous agents (also\ncalled Soids) 2 realistic form of group behavior similar to flocks of birds, schools of\nfish, or swarms of bees, (See Figure 3.7.1 for an example of this behavior in action.)\n‘These rules, which Reynolds refers to as steering behaciors, are:\n\n* Separation. Steer to avoid crowding local flockomates.\n* Alignment. Steer toward the average heading of local flockmares.\n* Cohesion. Steer to move toward the average position of local flockmates.\n\nFIGURE 3.7.1. An cxample image of the flocking demo in action.\n\nSection 3 Artificial intelligence\n\nSeparation gives an agent the ability co ory to maintain a cercain separation dis-\ntance from other agents in the immediate viciniry. This helps prevenc agen from\ncrowding together while ensuring a “natural-looking” closeness that emulates groups\nin the real world, The code presented in this article accomplishes this goal by having\ncach member of a flock rest how close it is to its nearby flockmates and then adjust its\nheading (steering) to obtain a desired distance.\n\nAlignment provides an agent that has the abiliny co align itself with (Le., head in\nthe same direction and/or speed as) other agents in its immediate viciniry. As with\nseparation, this article accounts for alignment through each member of a flack look-\ning at nearby Hockmaces and then adjusting its heading and speed to match the aver-\nage heading and speed af its neighbors.\n\nCofeston gives an agent the ability co “group” with other nearby agenn, thus emu-\nlating similar behavior seen in nature. Again, chis article accomplishes this goal by\nhaving each agent examine nearby agents, averaging their positions and then adjust ing\nbeading to match.\n\nThe Fourth Rule\n\nIn later implementations and papers, Reynolds added what has sometimes been\nreferred to as the “fourth rule” of flocking:\n\n* Avoidance. Steer to avoid running into local obstacles or enemies.\n\nApeidance provides an agent with the ability to steer away from obstacles and\navoid collisions. This behavior is accomplished by giving each agent the ability to\n“look forward” some distance and determine whether a collision with some object is\nlikely, then to adjust its heading to prevent ir. Similarly, it might be desirable co avoid\ncertain other types of agents (such as rabbits avoiding foxes or doves avoiding hawks),\nand again this principle would come into play.\n\nHo Memory\n\nNote that che steering behaviors say norhing about state information er about a given\nagent maintaining knowledge of the flock, its environment, where it's headed, or the\nlike. Flocking is a sratefer algorithm in chat no information is maintained from update\nto updare; each boid reevaluates ite environment at every update cyele, Not only does\nthis reduce memory requirements that might otherwise be needed to provide a simi-\nlar behavior using approaches besides flocking, burt it also allows che flock to react in\nreal time to changing environmental conditions. As a result, flacks exhibit dements of\ncmengent behavior Noa one member of the flock knows anything abour where the flock\nis going, bur the flock moves as one mass, avoids obstackes and enemies, and keeps\npace with one another in a fluid, dynamic fashion,\n\nHow Is This Concept Useful for Computer Games?\n\nFlocking provides a powerful cool for unit motion and making more realistic environ-\nmens the player can explore; it has been wed with erear success in a variery of com-\n\n4.7 Flocking: A Simple Technique for Simulating Group Behavior 207\n\nmercial tithes. For example, both Lmreal (Epic) and Half-Life (Sierra) used flocking\nalgorithms for many of cheir monsters as well as less life-threatening creatures such as\nbinds and fish. Enemy Nations (Windward Studios) used a modified flocking algo-\nnthm to control unit formations and movement across a 3D) environment. Groups of\nanimals can be made to wander the terrain in real-time strategy games or RPGs more\nrealistically than can be done with simple scripting. Groups of archers or swordsmen\nean be made to move realistically across bridges or around boulders and other obsta-\ncles. Monsters in a first-person shoorer can wander the dungeon halls in a more\nbelievable fashion, avoiding players where possible but perhaps launching an arrack\nwhen the flock prows large enough. The possibilities are practically endless.\n\nimplementation\n\nVectors and Motion\n\nA quick overview of the mechanics of morian for the members of a flock helps in\nunderstanding how the code does whar it does.\n\nFigure 3.7.2 demonstrares the concepre of doeal spare (space relative vo the boid\nitself). “Forward” is coward che positive #-axis, “left” is toward the positive X-axis,\nand “up” ts vertical toward the top of the boid. Our boid in this article is che classic\ndelta-wing shape often used by Reynolds, but of course it can be any shape desired.\n\nFigure 3.7.3 demonscrates another important principle, ortewtation. Referred to\nas mali pitch, and yaw, orientation is simply an indication of how a given object is ari-\nented in the local space, shown in Figure 3.7.2. Roll is rotation around the local 7-\naxis (the one facing forward and backward), Pitch is rotation around the local X-axis\n(the one running left and right). Yaw is roration around the Yaucis (the one running\ndirectly up and down through the boid). Understanding orientation is important\nbecause we use it when making decisions about our boid's orientation during move-\nment. The idea presented in this article works by building a velocity vector during each\n\nLavcal ¥\nLocal 2%\n\nLocal X\n\nFIGURE 3.7.2. Local space is defined for each boid.\n\nrer Sent ih\nsie aT te\n\nFIGURE 3.7.3. The three axis rotations are defined as roll, pitch, and yaw.\n\nupdate cycle that will adjust the boid's local X, ¥, and Z orientations to match the\nneeds of che four steering behaviors.\n\nAnother important aspect of how this idea operates is the manner in which it\narbitrates conflicting desires on the part of a boid. Looking at the four stecring behay=\niors for a moment, one can sce that there is no guidance on how to prioritize these\nbehaviors—all are considered of equal importance. This loosely matches most normal\nbehavior in the real world: A dove might want co both keep up with its fellows and\navoid cutting through a flock of hawks while doing so; however, this concept doesn't\ntake into account life-and-death situations.\n\nOne can solve this problems in several ways—automatically giving higher priority\nto avoidance, for example—but this article uses a vector accumulation approach. The\norentation changes that a given boid wanes to make to satisfy each of the four steer-\ning behaviors are summed in a changer verter before being applied to the boid’s\nmotion. This change vector, by convention, is held to a unit vector so that the accu-\nmulated changes are kept in proper proportion. This method allows each steering\nbehavior to have a proportional influence on the boid’s final motion changes while\nenabling the boid to satisfy (at least partially) the needs af hwo or more conflicting\n\ndirectives. Qver time I've found thar this approach is generally more satisfactory than\nothers.\n\nConstraints\n\nSeveral constraints on our boids restrict how they can move and react, Possibly che\nmost influential in this implementation is each boid’s perception nange, which restricts\nhow far a flockmate can “look” around its environment to detect other flockmates,\npotential obstacles, or enemies. The larger this range, the more organized and coher-\nent the flocks and the better they are at avoiding enemies and obstacles. Making this\nrange smaller results in more erratic flocks, groups of boids splitting off more often\nwhen confronted by obstacles or enemies, and so on.\n\nAnother constraint on how car agents can move is their relocity and maximamn\nvelocity change. In the real world, animals in flocks are restricted in their ability to keep\nup with their flockmares by how fast chey can move, how fast chey can tum, and the\n\n2.7 Flecking: A Simple Technique for Simulating Group Behavior 209\n\nlike. ‘This article simplifies the problem of morion in a 3D environment somewhat by\nignoring acceleration and focusing entirely on velociry; changes mo velocity are\nrestricted ta same proportion of overall maximum velocity. This helps prevent the\nagents in our deme from turning on a dime or putting on ridiculous bursts of speed\nwhen trying to catch up with their flockmates. It also provides a governing restraint on\nhow quickly they can slow down or alter course to avoid an obstacle. If allowed “infi-\nnite response,” they might fly directly up co the surface of an obstacle before tuming\nwith infinite agility and speed to move around it—not a very realistic behavior.\n\nA final constraint for the purposes of our demo is the world in which our boids\nflock. For the purposes of this article, I've arbinarily created a Box class that defines\nthe warld in which our boids can move. Any boid thar strays beyand the boundaries\nof the Box is magically transported to the opposite side, keeping the same motion\ncharacteristics it had before. The effect is char flocks that stray too clase to the edge of\nthe Box can lose members to the “other side of the world.” where they can lose mack\nofthe main flock and form a mew flock of their own.\n\nVirtually all these parameters are adjustable so char ome can see the potential\nimpact of fiddling with them.\n\nThe Code\n\nThree classes make up the heare of this article: Car, CFlock, and CBoid. Organiza-\ntionally, these classes can be viewed as described in Figure 3.7.4.\n\nFach flock is represented by an instantiation of a CAlock object. There can be\nmultiple Fleck objects residence within Cfox, and they can be created or destroyed ar\nany point (although this article creates chem only ar inisialization). Clack objects\nserve to organize and simplify access co the members of the flock.\n\nSimilarly, a CBefa object represents cach member of a flock. There can, of course,\nbe multiple CBerd objects associated with each CAloct (if there werent, it would be a\n\n(Flock Flock f through 7...\n\nEee re)\n\nFIGURE 3.7.4. The Box dass defines the basic world in which our flocks will fly.\n\n310\n\nSection 3 Artificial Intelligence\n\nprety small flock), and, like CAteck objects, they can be created or destroyed at any\npoinc, Although this article creates flack members only at inicializarion, ic wouldnt he\nhard co all co build in some “lifetimes” for individual members (sec che “Limitations\nand Potential Improvements” section) so thar individuals might age and die.\n\nThe CBox Class\n(Bex is a rather simple class, as one might expect:\n\n¢lass Gaox\n{\n\npublic:\n\neee ee ee ee\nij constructors and destructors\neee eee ee ee\n\ni} Constructor #1.\n\nff Greates a Box with default values of 50 waters\nff on any side not specified.\n\nBox (float lv=50.0, float w=50.0, Tloat nv-40.0);\n\nff Destructar\nvirtual -Chax();\n\neee eee ee\nff miscellanéous functions\nCOLAC RN ARSE?\n\nff Gethoslength.\nif Returns the length of the Box, in meters.\nfloat GetBoxLength (void);\n\nit Gethoetidth. .\nii Returns the width of the Box, in meters.\nTlost GetBoxWidth (void);\n\ni} Gathoxkheight.\nIi Returas the height of the Box, in meters.\nFloat GetBoxbsight (void);\n\nThis class provides us with a simple way ro parameterize and retrieve che bound-\nanes of our world.\n\nThe CFlock Clase.\nThe CAlock class represents a basic flock of boids and serves mostly as an organiza-\n\ntional tool rather than a strict representation of each flock per se. Its various functions\nare fairly simple and deal primarily with the “bookkeeping” that one might desire\nwhen handling flocks, The class definition for CFisek can be found in Listing 3.7.1.\n\n3.7 Flocking: A Simple Technique for Simulating Group Behavior a4\n\n<=\n\nProcedurally, flocks are first created and then have one or more boids added to\nthem. The class is built to allow for real-time creation and deletion of flocks, although\nthe demo itself does not do this. A list of all CAlck objects is maintained in the simple\nstatic array CFlock::List0fFlocks|] (again, simplified for che purposes of this article).\nAr each update cycle, the flocks’ cFlock: :Update() method is called to updace all the\nmembers of that flock, New boids can be added at any time using GFlock::AddTo(},\nand members can be removed, if desired, via GFlock::femoveFrom(). CFlock: :Get-\nCount () and CFlock:i:GetFirstMember(} provide methods co obrain spechc Statls:\ninformation about a given flock, whereas the debugging method CFlock::PrintData()\nprovides more exhaustive information.\n\nFlocks can be created at any rime, although the demo provided creates them only\nat initialization. Each flock can have any number of Cid objects as members. Note\nthar members of a flock have no idea what flock they're a member of. but the Jock\nitself does know who its members are. For the purposes of this article, a CBoia object\nremains a member of whatever CFfock it is initially assigned wo, bur it wouldn't be\nhard ar all to add code that would allow boids te change their loyalties if so desired\n(see the “Limitations and Potential Improvements” section).\n\nThe CBoid Class\n\nThe CBorf class implements the true “meat” of the flocking algorithms and, as such,\nis fairly beefy. Ic is contained in Listing 3.7.2. This class handles all aspects of a spe-\ncific agent's motion and existence: how it moves, how it senses its environment, how\nit POritines Is actions.\n\nFach C#oid object represents a single individual agent. Much as with CAlack\nobjects, CBotd objects can be created or deleted at will. Once created, they are indi-\nrectly managed through the GFlock::AddTo(), CFlock::Removerrom(}), and\nCFlock::Update() methods, as described previously.\n\nFach CBoid object is updated via its Flock: :FlockIt() method, which begins by\nbuilding a list of these flockmates that a given boid can see (based on its\nperceptten_naonge valuc)_ A list of enemies (members of ocher flocks) is also built if char\nOption is active.\n\nThe method then begins to implement the steering behaviors as described previ-\nously, summing an accumulating series of velocity vector changes to accommodate\nthe wishes of che agent. The methods CBoid: :Keepbistance!) (separation behavior),\nCBoid::MatchHeading() (alignment behavior), and CSoid: :SteerToCenter (cohesion\nbehavior) are called to determine what the boid would like to do. If the option is\nactive, avoidance behavior of members of other flocks is modeled through a call co\nCBold: :FleeEnemiesi }.\n\nOne additional method implemented here is Choid::¢ruising(). This method\nattempts to model a boid's “desired cruising speed,\" if everything were up wo it and it\nwasnt under any other influences. The primary reason for chis method was to give\n\n412 Section 3 Artificial Intelligence\n\nany boids wandering on their own (our of sight of their flockeaartes) some “purpose”\nto their motion.\n\nAt each stage of the update process, we accumulate all desired velocity vector\nchanges proportionally into an accumularion vector, A check at the end of the\nCBoid::Flockit() method ensures thar an individual mever exceeds ite maximum\nallowed speed or velocity change.\n\nTwe final methods serve as “cleanup” ro ensure that everything looks correct.\nCHoid::Computenry(} males calculations necessary to orient our boid properly as a\nresult of its final velocity vector changes. CBoid: ;WorldBound() does some sanity test-\ning to determine whether any agent has strayed outside the bounds of the CRox world\nobject in which ir resides and, if it has, places it back in irs bow.\n\nVarious private methods handle visibility and linked-lisr Management; there's\nnothing particularly special abour chem, sor are they flocking related per se. A debug\nmethod, CBoid: :FrintData(), provides cchaustive information on a even boid on an\n\nupdate-by-update basis.\nLimitations and Potential Improvements\n\nHard reality dictates char any demonstration of flocking behavior has some limirations.\nThis article docs not implement obstacle avoidance ar all, although it does allow for\navoidance in the form of “enemy flocks.” Boids remain assigned to the flocks they start\nwith, but one could easily envision code that reassigns a boid dynamically to a new\nflock should ir lose sight of ixs old onc. Similarly, beids in this implementation are\nblessed with an amazing, 360-degree, full-spherical field of views there are no restric:\nWiens such that they can see only objects or flockumares directly in front of them. A\nmore realistic field of view would probably be desired for any game implementation,\n\nA list of other possible improvements is fairly easy to come up with. Many people\nwhe have used flocking behavior and its variations have implemented “life clocks” on\nindividual agents, making boids thar die if they stray too far from cheir mares but that\ncan “breed” new flock members if they remain with their brothers long enough, One\ncould also examine predator and prey behavior, modifying the base code to allow one\ntype of flock ro “feed” on another.\n\nListing 3.7.1: The CFlock Class Definition\n\nclass Grlock\n{\n\npublic:\n\nPOPP PPPOE ELS\nfi stetic variablas\nreese ee\n\n3.7 Flocking: A Simple Technique for Simulating Group Behavior 313\n\nff number of flocks\nStatic int FlockCoaunt;\n\nff list of flocks\nStatic CFlock * ListO?Flocks [WAX FLOCKS);\n\nA0RCAAA ARLE\nfi constructors and destructors\nA000 UU ALAO SEE\n\nff Cometractor.\nit Greates & new fleck.\nOFlock (void):\n\nIf Destructor.\n-OFlock (wodd);\n\nARCOLA RODGERS\nIf Plocking functions\nTerre eerie |\n\ni Update.\nIf Updates all members of a flock.\nvoid Update (void):\n\neee ee\nff migeellaneaus functions\n\nJACAOLALE LEER BEOGGE\n\ni] Addo.\nff Adds the inditated boid to the flock.\nWold AddTo (GHoid * boid);\n\nff GetCount.\nif Returns the # of boids in @ given flock.\nant GetCount [vwoid);\n\n{) GetPirestiember .\n\n// Returns & pointer to the first boid in a\n// given fleck (if any).\n\nCBoid * GetFirstienber (void);\n\ni) PrintData,\ni/ Dunps all data deseribing a given flock.\nwoid PrintData (void);\n\nfy Remver ren.\n(J Removes the indicated boid fram the flock.\nvoid RemoveFrom (CBodd * boid);\n\nprivate:\nint m_iel; if id of this flock\nint fh_fhian_menbers; // cumber of bodds in this flock\n\nCBoid = *m_first_oonmber; ii pointer to first member",
      "page_number": 299,
      "chapter_number": 32,
      "summary": "Alignment provides an agent that has the abiliny co align itself with (Le., head in\nthe same direction and/or speed as) other agents in its immediate viciniry Key topics include flocking, behavior, and avoid.",
      "keywords": [
        "Behavior Steven Woodcock",
        "Steven Woodcock Flocking",
        "Steven Woodcock",
        "Group Behavior Steven",
        "Simulating Group Behavior",
        "flock",
        "boid",
        "Behavior",
        "Group Behavior",
        "Simulating Group",
        "Behavior Steven",
        "Woodcock Flocking",
        "Simple Technique",
        "members",
        "Technique for Simulating"
      ],
      "concepts": [
        "flocking",
        "behavior",
        "avoid",
        "avoidance",
        "object",
        "method",
        "classes",
        "changing",
        "changes",
        "article"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 25,
          "title": "Segment 25 (pages 240-248)",
          "relevance_score": 0.43,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 33,
          "title": "Segment 33 (pages 319-337)",
          "relevance_score": 0.42,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 25,
          "title": "Segment 25 (pages 238-245)",
          "relevance_score": 0.41,
          "method": "sentence_transformers"
        },
        {
          "book": "Generative AI with LangChain_2e",
          "chapter": 40,
          "title": "Segment 40 (pages 336-343)",
          "relevance_score": 0.41,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 4",
          "chapter": 16,
          "title": "Segment 16 (pages 271-288)",
          "relevance_score": 0.38,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 33,
      "title": "Segment 33 (pages 308-321)",
      "start_page": 308,
      "end_page": 321,
      "detection_method": "topic_boundary",
      "content": "a14 Séction 3 Artificial Intelligence\n\nListing 3.7.2: The CBoid Class Definition\nclass Choid {\npublic:\n\nJC0UACOROOSR EGG\nff static wariables\nACCUUASDEEE EEL\n\nHf visible friends list (work space reused by each bodd)\nStatic Choid * VisibleFriendsList|MAx FRIENDS VISIBLE];\n\neee ee eee ee\nf/ constructors and destructors\nA220 KOR DELOREELOODOEEES\n\nif Constructor #1.\n\nff Greates an individual bold with randomized pasition,\nif velocity, and orientation,\n\nC8oid (short id _v};\n\nfi Gonstructor #2,\nI! Creates an individual baid with specific position,\nfi velocity, and ardentatian.\nCSoid (short idg_v,\nweetor “ pos_¥, vector = vel_v, weetar * ang_vj;\n\nff Dastructer\n-CHoid (void) ;\n\nTerre eee eee |\nff public flocking methods\neee eee eee ee\n\nfi Floekit.\n\nffi Used for frama-by-frane updates: no time\n\nif deltas on positions.\n\nwold Flockit (int flock_id, CBoid *first _boid};\n\nCUE\nif miscellancows. tunctians\nieee eee eee ee\n\nff AddToVisibletist.,\n\nff This visibility list is regenerated for cach menber each\nfF update cycle, and acts auch like a push-down queue: the\n\nff) latest menber added to the list becomes the first one\n\nff when the List is sequentially accessed. Mastly I did\n\nff this for speed reasons, as this allows for toast inserts\n\ni? (and we don't delete fron this list, wm just rebuild it\n\n4.7 Flocking: A Simple Technique for Simulating Group Behavier 3415\n\nfy each update cycle}.\nWOiG AddToVisibleList (CSoid *ptr);\n\ni) GlearVisiblelist—\ni] Cleare the visibility list.\nwoLd ClaarVisibleList (void):\n\nfy Gethaxt.\n\nij Returns the \"next\" pointer of the invoking member.\nCBoid * GetNext();\n\nff LinkOut.\nif Remves a menber from a last.\nwoid LinkOut [()};\n\nij PrintQata.\nfi Dumps all data describing a given merbor.\nvoid PrintData (void);\n\nfy Setvexwt.\nfi) Set the “next” pointer of an individual menber.\nvoid SetNext (CBoeid ptr};\n\nfj SetPrev.\nfy Set the “prev* pointer of an individual member.\nwoid SetPrev (Cfodid \"ptr};\nprivate:\nPOPPER EES\ni} data members\neee eee ee ey\n\nfy supplied with constructor (s)\n\nshort m_id; if menbar individual ©D\nfloat m_perception range; i) how far genber ean sec\nvector m_pos; if position of meaber\niflin meters)\nvector m_vel; if veletity of menber\nif (meters/sech\nvector m_ang; fi orientation of member\nfi computed\nfloat m_speed; if averall speed of member\nu_short m_nun_ftlockmates_seen; il # of flocknates this\nfi tember sees\nu_short m_nun_enamies seen; i) # of enemies this\nff tesber sees\nG8oid “nm nearest _Tlocknate; if pointer to nearest\nif flockmate (if any)\nCaoid “n nearest _eneny; if pointer to nearest\n\nff enemy (i? any)\nfloat B_dist_to_nearest_flockmate; // distance to\n\nif nearest ftlocknata\n\n316 Section 3 Artificial Intalligence\n\nor\nfi (iF anyp, in\nff meters\n\nfloat m_Giet_to_nearest_anemy; if distance ta\n\nff nearest eneny\nff (if any), in\n\ni) meters\nvector m_oldpos; if last position\nvector m_oldvel; if last velocity\nCaoid *m_hext; ff pointer to next\nff flockmate\nCeoid ‘Em prev: iJ pointer to\n\nff previows\nif flockmate\n\nFRAO EEE\nff Tlocking methods\nPEPPERS EEE\n\nff Gruising.\n\ni) Generates a vactor indicating how a fleck boid would\n\nfi like to move, if it were all up to hia and he was under\nii no other influences of any kind.\n\nvector CBoid::Cruising (void);\n\ni} FleeEnemies.\nI} Generates a veeter for a flock bodd te avodd the\nif] nearest enesy (boid of a different flock) it sees,\n\nWector CBoid: !FlaaEnemies (void);\n\nii KeepDistance.\n\nfi Generates a vector for a fleck bedid to maintain his\n\nif dge6ired separation distance from the mearest flockmate\nffs te sees.\n\nwector CBoid: :KeepDistance (void);\n\nff MatchHeading.\nI} Generates a vactor for a flock bodd to try\nfi to match the heading of its nearest flockmate.\n\nwettor CHoid: :MatchHeading {void};\n\ni} Segknemies.\n\nff Determines which enemy flock boids a given flock boid\nif can 866.\n\nint Cioid: :SeeEnenies (int flock_id);\n\niy! SeeFriends.\n\nff Determines which flocknates a given flock boid can see.\nint Gioid: :SeeFriends (CBoid \"first boid):\n\n3.7 Flocking: A Simple Technique for Simulating Group Behavior aif\n\nfi StearTotenter.\ni} Generates & vweeter to guide a fleck boid towards\nif the \"center of mass\" of the Tlockmates he can sen,\n\nweetor GHoid: :SteerTatenter (woaid):\n\nfy WorldBownd.,\n\nff! Implenents a world boundary so that flecks don\"t fly\n\nff infinitely far away from the camera, instead remaining\nff ina nite viewable area. It does this by wrapping flock\nff boids around to the other side of the world, so {for\n\nMY example) they move out tha right and return on the left.\n\nwold Cioid::WorldBound (woid);\n\nCOBO ORE LEER\nff giscellanesus functions\nAGERE ERR\n\nJ} AccumulatecChanges.\n\ni) Adds vector values in changes inte the accumumlator\nff vector. Returns magnitude of accumulator vector atter\nif ating changes.\n\nTloat Choad: :AccunulataGhanges (veeter Zaccunylator,\nvector changes);\n\nff CantSee.\nff Deterning whether a given invoking boid can see the boid\nff if question. Returns the distance to the boid.\n\nTloat Ciioid:-:CanISee (Choid “ptr};\n\niY Computenpy\nFi Computes the rall/piteh/yaw of the flock boid basad on\nff ite latest velocity vector changes. Aoll/pitch/yaw are\nfi etored in the ‘ang\" data member as follows:\n\nff piteh is about the x axis\n\nii yaw is about the y axis\n\n/} roll is about the z awdgs\n\nFf} All calculations assum a right-handed coordinste\n\nfi 4ysten:\n\ni +m = through the left sido of the object\nif; +y = up\n\nfj 42 = throwgh the nese of the model\n\nwiid CBoid::GomputeRPyY (void):\n\nResources and Acknowledgments\n\nI's virnually impossible to study this particular field without quickly discovering that\nnearly every flocking/swarming/herding application on the Web is somehow related\n\n318\n\nSection 3 Artificial Intelligence\n\n10, derived from, or inspired by some other flocking/swarming/herding application.\nThe implementation described in this article is no exception, Many thanks to\nChristopher Kline (Mitre Corporation) for his original method for computing\nroll/pitch/yaw (liberally adapted here), originally published in his C++ Bosds imple-\nmentation (available on his Website). Also thanks to Mile Louic (Bocing) for helping\nwith the transformation math (7 hate matrices).\n\nBesides Christopher's Web page, which includes many excellent demos and am-\nple code (at weew.media.mitedu!-ckline/boids/), there are a number of other excel-\nlent references on this subject on the Web and in bookstores. Probably the best single\nplace to start seeking more information is with the “father of flocking” himself, Craig\nReynolds, Craig's Websire can be found ar ww red. comicwr, Also see Reynolds, ©\nWe, “Flocks, Herds, and Schools: A Distributed Behavioral Model,” in Computer\nGraphic, 21(4), SIGGRAPH “87 Conference Proceedings, pages 25-34, 1987.\n\nThe JMicroroft DirectX SDK also comes with two fairly simple-ro-follow imple-\nmentatons included on the source CD. On the OrecXN 7a CD, they are locaned ar\nLOAF sornples \\iultineceta ld 3adim\\orc\\boids and VON FP amples\\multimedialdmusicurc\\\ndmboids. Both versions fearure obstacle avoidance using a “force-field” approach that\nis fairly natural looking.\n\nFinally, an excellent book char addresses the topic of artificial life in general, in\naddition to discussing both flocking and boids, is Steven Levy's Artificial Life, Vintage\nBooks.\n\n3.8\n\nFuzzy Logic for Video Games\n\nMason McCuskey\n\nThis article is an introduction eo an artificial intelligence technique called fizey logic.\n\nThe best way to define furzy logic is co explain how it differs from craditional\nlogic, Traditional logic works on the idea of “true” and “false”—something’s either on\nor off, Zero OF One, yes OF NO, positive or negative.\n\nFuzzy logic allows us to work with concepts chat aren't “crisp\"—in other words,\nthings that require an adjective specifying “to what degree” or “how much.” For\nexample, fuzzy logic allows us to mathematically model size concepts such as “pretty\nbig,” “awfully small,” “medium,” “gigantic,” and so on.\n\nFuzzy logic has mysiad uses in game Al. For example, we can use fuzy logic vo\nsimulate emotions of computer-concrolled characters: “irritated” vs. “incredibly\nangry, “a bit nervous” vs. “terrified,” “happy” vs, “ecstatic,” and so on. This in wun\nallows us to create an Al that's more human or deep than one built using traditional\n(“black or white”) logic could ever be.\n\nHow Fuzzy Logic Works\n\n‘To define how fuzzy logic works, let's first take a step back and review how traditional\nlogic works. Traditional logic manipulates “crisp sets.” A crisp set is a set for which a\ngiven element either belongs to the set or doesn't. For example, ler’s define a crisp set\ncalled M, which consists of all real numbers between $ and 10:\n\nff = (5, 10]\n\nThe characteristic function for sec M looks like che one shawn in Figure 3.8.1\n(for the sake of chis example, let's assume our universe of discourse is the set of all real\nnumbers berween 0 and 20, as shown in Figure 3.8.1).\n\nThis is a crisp set because any given number in our universe is cither in sec M or\nnot in set Ad—thar is, either the number is berween $ and 10, in which case our func-\ntian retums ome, of it isn't, in which case it returns zero.\n\nA crisp Ser works reat For black-and-white SCCMAarLOS, bute it Falls apart under cer-\ntain situations. Say we want co make a set of all call people. We decide thar 7 fer is\n\n318\n\nSséction 3 Artificial Intalligence\n\nTu\nt a\na 5 iD =a\n\nFIGURE 3.8.1. Representation of seq AY,\n\ntall, so we declare our set of tall people as “all people who are at least 7 feet tall.” We\nmake a function thar returns one if the given height is greater than 7 feet, zero if it\nisnt. The problem with this is that people who are 6 feet, 11.5 inches aren't in our tall\nsct, even though very few people would dispune the fact thar chey're tall. So, to cry and\nfix the problem, we drop our minimum height requirement down to G fer, bur irs\njust as silly to put two people, one $ feet 11 inches and one G feet, next to each other\nand say that one of them is “tall” and ome isn't. The rigidiry of the crisp set works\nAgainst us.\n\nIn other words, whar crisp sets don't give us is the abiliry ro specify bow much (or\nto whet degree) something is in a set. Fuzzy sets, however, give us that abilicy, Using\nfurzy sets, we can “flex” the separation berween “in the set” and “nor in the set” co\ninclude things like “just a litde bie in the set” or “almost entirely in the set.”\n\nWe do this by having our characteristic function return not only zero and one,\nbur also values bereere zero and one thar indicare to wvrat degree the given number is\nin the set. Going back to our previous example, if zero means “not call” and one\nmeans “tall,” then 0.5 cam mean “sorr of rall” (or, “halfway in the set of tall people\"),\nand 0.01 can mean “a little tall” (or, “just barely in the tall set”).\n\nFigure 3.8.2 shows our fuzzy set of all call peaple.\n\nCompare the graph in Figure 3.8.2 to the graph of the crisp set in Figure 3.8.1,\nThe fuzzy set in Figure 3.8,2 has slopes—5—someone who's five feet is nor tall, bur\nstarting at 5 feet 3 inches, the heights gradually start belonging to the tall set, until\nfinally, at 7 feet, they belong entirely co the call set.\n\nThar's a firzy oct,\n\n3.8 Furry Logic for Video Gamez 321\n\n& Aiba 6 feat 7 Freed:\n\nFIGURE 3.8.2. Representation of set “tall people,”\n\nFuzzy Logic Operations\n\nNow that we understand what a fuzzy set is, let's do some operarions an it,\n\nFigure 3.8.3 defines another fuzzy set: a set of people “sbour 6 feet tall.”\n\nHere's an example of the fuzzy see AND operation, Figure 3.8.4 shows the graph\nof the fuzzy set \"people who are tall AND are about 6 feet.”\n\nContinuing with that same idea, Figure 3.8.5 shows the graph of the fuszy sec\n“people who are tall OR 6 fees.”\n\nSteet Bi foot F bead\nhit\n\nFIGURE 3.8.3, Representation of set “abour six feet tall,”\n\n322 Section 3 Artificial intelligence\n\n5 feed: 6 fest ? feet\nHeigne\n\nFIGURE 3.8.4. Representation of sec “people who are all tall AND alsouc six feet”\n\nFinally, Figure 3.8.6 shows an example of the NEGATION operator: the set\n“people who are NOT ull.”\n\nI Brake for Fuzzy Control\n\nNew we know how ro create and operate on fuzzy secs. The next step is using furzy\nsets to accomplish something. This is called fixzy contrel\n\nLet's say, for the sake of example, that we want to model trafic, Maybe we're\nmaking a ciry simulation game, and we want the linle cars in our city to behave real-\ntically. We have a line of cars, and we want cach car in that line to speed up or slow\ndown as though it were driven by a real person. This means that no cars can bump\n\nSfoat 6 foot 7 fone\nHesyght\n\nFIGURE 3.6.5. Representation of set “people whe are tall OB sre fee”\n\n3.8 Fuszy Logic for Video Games 323\n\nFIGURE 3.8.6. Representation of set “people who are NOT rll.”\n\ninto the backs of other cars and that inside each car is a safe driver who tries to main-\ntain a reasonable distance (two car lengths) berween his or her car and the car in front.\n\nThis situation is easy to model with fuzzy logic, because for cach car, there are\nonly owo variables we need to worry about (in fuzzy logic, these are called Enreraistic\n\nlL. The distance between this car and the one in frone of it. (We'll call this linguistic\nvariable dimncuee)\n\n2. The distance dele between this car and the one in front of i IF the apace berween\nthe owo cars is growing, we have a positive distance delca; if the space is shrinking,\nwe have a negative distance delta. If the space is neither growing nor shrinking,\nthe distance delea is zero.\n\nAfter spending hours carefully studying real cars on real highways, we come up\nsome rules, For each car:\n\n* Waistance deles is zero and distance is about two car lengths, maintain your cur-\nrent speed.\n\n* Lf distance defta is negative and ditence is less than two car lengths, slow down.\n\n= Uf divance dele is peosicive and distance is greater than two car lengths, speed up,\n\nThere are many mare rules, which all follow the same pattern and are summed up\nin Table 3.8.1.\n\nNow that we've got our cules, we need co mail down all che cecrns we've used to\ndeserihe dittance and alissence delta with furzy sere, This means thar we need to define\n15 furzy sets: five cach for distance, distance dele, and the action of the car (which\nwe'll call action). These sets are summarized by Tables 3.8.2, 3.8.3, and 3.8.4 and the\ngraphs in Figures 3.8.7, 3.8.8, and 3.8.9,\n\n324 _ Sections Artificial Intelligence\n\nTablé 3.4.1. Rules for Our Car Al\n\nMaintain\nSlow down spood Seeerd up\n\nd\n\n| seca\n— Brake | heard! | Brake hard! Slow dawn Slow dean\n\nDistance Label Gormesponding Furry Set\n\nWery small Les than one car h\n\nSmall About one car lenpth\n\nPerfect About two cer lengths\n\nBie About three cr lengths spe oe\n\nWery bic More than three car lengths —=\n\nTable 3.8.3. Distance Delta Fuzzy Set Definition\n\nDistance Delta Label Comesponding Furry Sal\n\nShrinkine Fast Ra y equal co negative (half the car's presence ]\nShrinking Lest than vere =\n\nSable About zero (the nwo cars are moving at roughly the same speed)\nGrow (Greaner than zero\n\n(Growing fast Roughly equal co half the car's present speed\n\nTable 3.6.4, Action Furry Set Definition\n\nBrake Harel Half your speed (speed fa 2)\nSlow down Decrease your speed by half your present speed (speed —= speed / 2)\nMaintam speed Dn nothin\n\ndw Increase your speed by half your present speed {5 += speed / 2)\n\nFlaar it Double your speed (spocd *= 2)\n\n3.8 Fuzzy Logic for Video Games 325\n\nPorto\nLees than 1 car length 1 car eregth (@Car Lorghs} Searkngta ere than d cor lengths\n\nFIGURE 3.8.7. Representation of Dusrrmce defininion.\n\n‘ary srrmall oral Bag ery Bag\n\nPartect\nLees than 1 car henge Vicar length @CarLergral doriengts Mom than dow lenge\n\nFIGURE 3.8.8. Represcotation of Diraece Delos definition.\n\nNew lets take a concrete example and lear how the numbers flow through the\nfuzzy control system we've just created. Figure 3.8.10 shows an actual value we've\npicked for afsance; Figure 3.8.11 shows an actual value for distance delta,\n\nAs you can see, we've picked 1.3 as the distance variable and 0.25 as the aismance\ndelta. Que fuzzy sets tell us thata alimance delta of 0.25 is “slightly growing” (it belongs\nto the “growing” set to a degree of about 0,3), and that a distance of 1.3 is “mostly\nsmall” (it belangs to the “small” ser roa degree of about 0.75). Note that we could alo\nsay distance ts “barely perfect” (ic belongs to the “perfect” set co a degree of about 0.1),\nand thar dinenee delta is “mostly stable\" (it belongs vo che “stable* set to a degree of\nabou (5).\n\nSection 3 Artiticial Intelligence\n\nHail spect Seed (Ceastain epee\n\nFIGURE 3.6.8. Representation of Acciow definition.\n\n‘Vary smal Vory Ekg\n\nPoet\n(ues Pea 7 ear kenga T car length (Cor Lengths) Zen logis Moco than 2 cor lengths\n\nFIGURE 3.6.10. The Dérnnce value we've chosen for this example.\n\nThis means that we're dealing with four of our sets: che cwo sets to which alisance\nbelongs (“sraall” and “perfect\") and the two sets to which distance deltas belongs\n(\"growing and “stable\"). Given the combination of these sets, we know whatever we\ndecide will be based on one of these four rules:\n\n* Tf distance is small and distance dlefra is growing, Maintain current speed.\n© Tf @tnance is small and dimace defes is stable, slow down.\n\n* [fF distance is perfect and distance alcita is growing, speed up.\n\n* If distance is perfect and distance delta is stable, maintain speed.\n\nThe next step is to evaluate the degree to which each of these rules is “true.”\n\n| Fuzzy Logic for Video Games 327\n\n0\nhegre [halt of car's poset space) jtabiiod Hatof cars present see!\n\nFIBURE 3.8.11. The Ditence Delta value we've chosen for this example.\n\nLets look at the first rule. The degree to which we should maintain our current\nspeed depends on “how true” che statement “distance is small and distance delta is\ngrowing” is. ‘We know that dimznce belongs to the “small” sec wo a degree of 0.75, and\nwe know thar désene dele belongs to the “growing” set to a degree of 0.3. Sa, we\nknow the result of the fuzzy statement “wires is small and aisnaee deles is growing”\nis 0.3. This is because 01.3 is che largest degree vo which don statements will still hold\ntruc.\n\nWe can evaluate the degree of “trueness” of the other three rules the same way,\ngiving us the following:\n\n* distance is small and distance delte is growing: 0.3 degree of “trueness”\n\n* distance is small and alistence celts is stable: 0.6 degree of “trueness”\n\n* distance is perbect and aictance defts is growing: 0.1 degree of “trueness”\n* distance is perfect and distance delta is stable: 0.1 depree of “trueness”\n\n‘This means that of our possible actions, “maintain speed” gets a score of 0.3 and\n0.1, “slow down\" gets a score of 0.6, and “speed up” gets a seore of 0.1.\n\nThe exact way we get from where we are now to a final value is called a deficcziif-\ncation method. There are many available defuzzification methods; you need to pick\none that suits your application. Most of the time, however, it’s good enough to per-\nform a simple center-of-mass calculation on the “true” area of the action graph (sec\nFigure 3.8.12).\n\nThis caleulation gives us our final course of action, namely, “sow down” to a\ndegree of about 0.25, Now it's simply a matter of applying 25% of the slow-down mule\nto the car's present speed. Since “slow down\" to a degree of 1.0 is 0.75 of the car's\nspeed, 2596 of the slow-down rule means we should multiply the car's speed by about\nO81.",
      "page_number": 308,
      "chapter_number": 33,
      "summary": "This chapter covers segment 33 (pages 308-321). Key topics include distance, vector, and sets. CSoid (short idg_v,\nweetor “ pos_¥, vector = vel_v, weetar * ang_vj;\n\nff Dastructer\n-CHoid (void) ;\n\nTerre eee eee |\nff public flocking methods\neee eee eee ee\n\nfi Floekit.",
      "keywords": [
        "Fuzzy Logic",
        "distance",
        "fuzzy set",
        "car",
        "Artificial Intelligence Listing",
        "Fuzzy",
        "speed",
        "Logic",
        "distance delta",
        "Definition class Choid",
        "sets",
        "tall",
        "Fuzzy Logic Works",
        "degree",
        "crisp set"
      ],
      "concepts": [
        "distance",
        "vector",
        "sets",
        "figures",
        "speed",
        "cars",
        "car",
        "lengths",
        "void",
        "logic"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "Segment 63 (pages 609-616)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 24,
          "title": "Segment 24 (pages 222-231)",
          "relevance_score": 0.49,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 33,
          "title": "Segment 33 (pages 319-337)",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 23,
          "title": "Segment 23 (pages 220-230)",
          "relevance_score": 0.46,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "Segment 33 (pages 314-325)",
          "relevance_score": 0.46,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 34,
      "title": "Segment 34 (pages 322-330)",
      "start_page": 322,
      "end_page": 330,
      "detection_method": "topic_boundary",
      "content": "328 Section 3 Artificial Intelligence\n\nIY \\,\n\nFIGURE 3.6.12. Using che defurzification method.\n\nSo the car slows down slightly which makes sense given the inpur crireria (aii\nnance is small, bur diseence dele is growing),\n\nOF course, the entire process we just wene through is performed by the computer\nhundreds of times a second, simulating the expert control of a safe driver.\n\nOther Applications of Fuzzy Logic\n\nFuzzy logic and fuzzy control can be used in a variety of game situations. The general\nidea is that furzy logic can be used anywhere you're wrying co emulate a human expert.\nOther good places for fuzzy logic include Al for enemies (the ogres in battle against\nthe playet’s paladins are scared te what degree’), non-player characters (few much does\nthe shopkeeper trust the player?), flocking algorithms (Sew far away am I from the\nrest of the pack?), and myriad other places.\n\nFuzzy logic can also be used to represent inorganic evenes, such as how clouds\nmove, given wind speed and direction.\n\nConclusion\n\nFuzzy logic is a powerful tool with many uses. With any luck, this article has\nexplained fuzzy logic and how the processes of fuery logic and fuzzy control work, as\nwell as giving you a few ideas on where to use fuzzy logic in your games,\n\nIf you have questions or comments, please contact me or visit my Website. See\nthe author's section for my conract informacion.\n\n3.8 Furry Logic for Video Games a28\n\nResources\n\n[Bauter00) Bauer, Peter, Nouak, Stephan, and Winkler, Roman, available online ar\nwww. fl 1 1 suni-linz.ac.av/pdw-furzy/index.html, March 21, 2000.1 based chis arti-\nele on their excellent online lecture,\n\n[Nguyen99] Neuyen, Hung T., and Walker, Elbert A., A Fist Course In Fuuczy Logic,\nCRC Pres, 1999. This is an excellent book that explains mathematically the\nbasic ideas of fuzzy logic.\nfog, 1GD Books Worldwide, 1995. Another great book, this one with an\nemphasis on creating C++ classes and code for both fuzzy logic and neural-net Al\ntechniques.\n\n[Woodoock00) Woodenck, Steven M., “Game Al,” available online ar We frames\ncom, March. 21, 2000. This is a great place for information on all sors of Game\nProgramming Al topics, including fuzzy logic.\n\nAnd, in general, www.gamedev.net/ is a great site for game development.\n\n3.9\n\nA Neural-Net Primer\n\nAndré LaMothe\n\nIn many ways, the computational limies of digital computers have been realized. Sure,\nwe will keep making them faster, smaller, and cheaper, but digital compurers will\nalways process digital information because they are based on deterministic binary\nmodels of computation. Mewnal nets, on the other hand, are based on different models\nof computation, They are based on highly parallel, distributed, probabilistic models\nthat dont necessarily model a solution to a problem the way a compurer program\ndoes. Instead, they model a network of cells that can find, ascerrain, or correlate pos-\nsible solutions co a problem in a more biological way by solving che problem in little\npisces and pucting the result copecher, ‘This article is a whirlwind tour of neural nets\nand how they work.\n\nBiological Analogs\n\nNeural nets were inspired by our own brains. Literally, some brain in someone's head\nsaid, “T wonder how T work?” and then proceeded to create a simple model of itself.\nWeird, huh? The model of the stanland sewroe'r is based on a simplified model,\ninvented over 50 years ago, of a human neuron. As shown in Figure 3.9.1, there are\nthree main parts to a biological neuron:\n\n* Dendrites. Responsible for collecting incoming signals.\n* Soma. Responsible for the main processing and summation of signals.\n* Axon. Responsible for cransmiteing signals to other dendrites.\n\nThe average human brain has abour 100,000,000,000, or 10\", neurons, and\neach neuron has up co 10,000 connections via the dendrite. The signals are passed via\nelectrochemical processes based on sodium, potassium, and chloride ions, Signals are\ntransferred by accumulation and potential differences caused by these ions. The\nchemistry is unimportane, but the signals can be thought of as simple electrical\nimpulses thar cravel from aor to dendrite. The connections from one dendrite to an\naxon are called sapies, ancl these are the basic signal transfer points,\n\n2.9 A Neural-Net Primer L 331\n\nh F Synaptic\n. gaps i Dendrites from\ni ai\n\n| i J\ngam [Soma\n\n1 al\n\nFIGURE 3.9.1. A basic biological neuron.\n\nSo how does a neuron work? Well, chat question docsn't have a simple answer, but\nfor our purposes, the following explanation suffices. The dendrites collect the signals\nreceived From. other neurons; then the soma performs a summation of sorts and, based\non the result, causes the axon to fire and transmit the signal. The firing is contingent\nupon a number af Getors, but we can model it asa cransfer function that processes the\nsummed inputs and then creates an ourput if the properties of the transfer function\nare met. Im addition, the ourput is non-linear in real neurons—thart is, signals aren't\ndigital, they are analog. In fact, neurons are constantly receiving and sending signals,\nand the real model of them is frequency dependent and aust be analyzed in the S-\ndorait: (the frequency domain). The real transfer function of a simple biological neu-\nron has. in fact, been derived, and it fills 2 number of chalkhoards.\n\nNow that we have some idea of what neurons are and what we are Irving to\nmodel, lees talk fora moment about what we can use neural nets for in video games.\n\nApplications to Games\n\nNeural nets seem to be the answer for which we all are looking. If we could just give\nthe characters in our game a litele brains, imagine how cool a game it would be! Well,\nthis is possible, in a sense. Neural nets model the structure of neurons in a crude way,\nbut not the high level functionality of reason and deduction—ar least, nor in the clas-\nsical sense of the words. It takes a bit of thought to come up with ways to apply\nneural-net technology to game Al, but once you get the hang of it, you can use it in\nconjunction with deterministic algorithms, fuzzy logic, and genetic algorithmy to cre-\nate very robust thinking models for your games. Without a doubr, it will be better\nthan anything you can do with hundreds of iFthen statemencs or scripted logic.\nNeural nets can be used for such things as:\n\n* Environmental scanning and classification. A neural net can be fed with infor-\nmation that could be interpreted as vision or audicory information. This infor-\nmation can then be used co select an ourput response or teach the nee. These\nresponses can be learned in real time and updated to optimize the response.\n\nS32 Section 3 Artificial Intelligence\n\n* Memory. A neural net can be used by game creatures as a form of memory. The\nneural net can learn through experience a set of responses; then when a new expe-\nrence occurs, the met can respond with something char is the best guess at what\nshould be done.\n\n* Behavioral control. The output of a neural netcan be used to control the actions\nof a game creature. The inputs can be various variables in the game engine. The\nnet can then control che behavior of the creature.\n\n* Response mapping. Neural nets are really pood ar “association,” which is the\nmapping of one space to another. Association comes in two flavors: aufoauecia-\nfen, which is the mapping of an input with itself, and Aeteroasociation, which is\nthe mapping of an input with something else. Response mapping uses a neural\nnet at the back end of output to create another layer of indirection in the control\nor behavior of an object. Basically, we might have a number of control variables,\nbur we have crisp responses for only a number of certain combinations wich\nwhich we can teach the net. However, using a neural net on the output, we can\nobtain other responses thar are in the same ballpark as our well-defined ones.\n\n‘The preceding examples might seem a lirtle fuzzy, and they are. The point is that\nneural nets are tools that we can use in whatever way we like. The key is to use them\nin cool ways that make our Al programming simpler and make game creatures\nrespond more intelligently.\n\nNeural Nets 104\n\nIn this section, we cover the basic ccrminology and concepts used in neural-ner dis-\ncussions. This isn't easy, since neural nets are really the work of a number of different\ndisciplines, and therefore, each discipline creates its own vocabulary. The vocabulary\nthat we deseribe here is a good intersection of the well-known vocabularies, In addi-\ntion, neural-network theory is replece with research char is redundant, meaning thar\nmany peaple reinvent the wheel. This has had che effect of creating a number of\nneural-net architectures thar have different names. I try to keep things as generic as\npossible in this article so thar we don't get caught up in naming conventions. Laver in\nthe antiele we cover some ners that are distinct enough that we refer to them by their\nproper names. As you read, don't be too alarmed if you don't make the “connections”\nwith all che concepts. Just read them for now; most of the concepts are covered again\nin full context in the remainder of the article. Let’s begin.\n\nNow that we have seen the wetware version of a neuron, let's take a look ar che\nbasic artificial neuron on which to base our discussions, Figure 3.9.2 is a graphic of a\nsandard neurede, or arificial neuron, As you can sec, it has a number of inpurs\nlabeled X; —X, and B. These inputs each have an associated weight w, —w,, and b\namached to them. In addition, there is a summing junction Y and a single ourpur y.\nThe output y of the neurode is based on a transfer or “activation” function, which is a\nfunction of the net input to the neurode. The inputs come from the Ms and from B,\nwhich is a bias node. ‘Think of B as a past history, memory, or inclination.\n\n4.9 A Meural-Net Primer 333\n\nsingle neurodes\n\nTotal input ¥j,=8-b+ Ex: wy)\n\nFIGURE 3.9.2. Asingle neurodes with = inpurs.\n\nThe basic operation of the neurode is as follows: The inputs X, are each multi-\nplied by their associated weights and summed. The output of the summing is referred\nto as the inpar actination Y,. The activation is then fed to the activation function f(x),\nand the final output is y. The equation for this operation is:\n\nY,=Btb+ EX\" w, (3.9.1)\n\nand y = £(Y,). The various forms of F(x) are covered in a moment.\n\nBefore we move on, we need to talk about the inputs X., che weights w;, and their\nrespective domains. In most cases, inputs consist of the positive and negative integers\nin the set (—, +6), However, many neural nets use simpler éfnadent values (meaning\nthat they have only two values). The reason for using such a simple inpur scheme is\nthar ultimately all inputs are dinary or bipolar, and complex inputs are converted to\npure binary or bipolar represencacions anyway. In addition, Tay times we ane trying\nro solve computer problems such as image or voice recognition, which fend them-\nselves to bivalent represencations, Nevertheless, chis rule is not etched in stone. The\nvalues used in bivalent systems are primarily 0 and 1 in a binary system or—1 and 1 in\na bipolar system. The twe systems are similar excepe thar bipolar representations rurn\neut to be mathematically better than binary ones. The weights w, on each input are\ntypically in the range (—e, +e) and are referred to as excisarory and inmbibitery for pos-\nitive and negative values, respectively. The extra inpuc & (the bias) is always 1.0 and is\nscaled or multiplied by b—thar is, bis its weight, in a sense. This concept is illustrated\nin Equation 3.9.1 by the leading term.\n\nContinuing with our analysis, once the activation Y, is found for a neurode, ir is\napplied to the activation function and the output y can be computed. There are a\nnumber of activation functions, which have different uses. The basic activation func-\ntions £,(x) are shown in Table 3.9.1.\n\nBes | Section 3 Artificial intelligence\n\nTable 3.9.1. Tho Activation Functions f, [x]\n\nEquation 3.9.2 Equation 3.9.3 Equation 3.9.4\nFix) =1,ifx2@ Fix} = x, forallx F(x} = 1/(l+e*)\n0, ifx<@\n\nThe equations for cach function are fairly simple, bur each is derived to model or\nfit various propertics.\n\nThe sep function is used in a number of neural nets and models as a meuron fir-\ning when a cricical input signal is reached. This is the purpose of the factor @, which\nmodels the critical input level or threshold ac which the scurode should fire. The Jin-\near activation function is used when we wane che output of the neurode vo more\ndosely follow the input activation. This kind of activation function is used in model-\ning Jinear systems such as basic motion with constant velocity, Finally, che expomential\nactuation function is used to create a won-dinear response, which is the only possible\nway to create neural nets that have non-linear responses and model non-linear\nprocesses. The eqpenentia! ecteation function is key in advanced meural mets because\nthe composition af linear and step activation functions is always linear or step; we will\nnever be able to create a net that has non-linear response, ‘Therefore, we need the\nexponential activation function to address che non-linear problems that we wane to\nsolve with neural nets, However, we are noc locked into using the exponential fune-\ntion. Ayperbolic, dogarithmic, and manscendental fenetions can be used as well, depend-\ning on the desired properties of the ner. Finally, we can scale and chift all these\nfunctions if we need to.\n\nAs you can imagine, a single neurode isn't going to do a lot for us, so we need to\ntake a group of them and creare a layer of neurodes, as shown in Figure 3.9.3. This\nfigure illustrates a single-layer ncural nerwork The neural net in Figure 3.9.3 has a\nnumber of inputs and a number of output nodes, By convention, this is a single-layer\nnet because the input layer is not counted ules it is che only layer in che nerwark. In\nthis case, the input layer is also the ourput layer; hence, there is onc layer. Figure 3.9.4\nshows a two-layer neural net. The input layer is still not counted, and che internal\nlayer is referred to.as “hidden.” The output layer is referred to as che ourpur or regparne\nLeper, Theoretically, chere is no limit to the number of layers a neural net can have:\n\n3.9 A Neural-Net Primer a5.\n\nMietes welt (Aa aren ace are equal in 0.0\n\nFIGURE 3.9.3. A four-input, chree-newrode, single-Layer neural net.\n\nhowever, it might be difficult to derive the relationship of the various layers and came\nup with tractable training methods. The best way to create multilayer neural nets is to\nmake each network one or two layers and then connect them as components or func\ntional blocks.\n\nAll right. now let’s talk abour remponz or time-relared topics, We all knerw that\nour brains are fairly slow compared to a digital computer. In fact, our brains have\neyele times in the millisecond range, whereas digital computers have oycle times in the\n\nHIDDEN LAYER OUTPUT LAYER\nBigs Blas\n\nMoin: waelghis ig 1nd Wie are dittererct\n\nFIGURE 3.9.4. A two-layer neural network.\n\nSection 3 Artificial Intelligence\n\nnanosscond and, soon, sub-nanosecond range. This means that signals take time ro\ntravel from neuron to neuron. This fact is also modeled by artificial neurons in the\nsense that we perform the computations layer by layer and transmit the results\nsequentially, This model helps co better model the time lag involved in the signal\ntransmission in biological systems such as humans.\n\nWe are almost done with the preliminaries. Lers talk about some high-level con-\ncepts and then finish up with 2 couple more terms. The question thar you should be\nasking is, “What the heck do neural nets do?” This is a good question, and it’s a hard\none to answer definitively. The question should be, “What do you want to ley to\nmake neural nets do?\" Neural nets are basically mapping devices that help map one\nspace to another space, In essence, they are a type of memory. Like any memory, we\ncan use some familiar terms co describe them. Neural nets have both short-term\nmemory (STM) and long-term memory (LTM). STM is the abiliry for a meural net to\nremember something it just learned, whereas LTM is the ability of a neural net to\nremember something it learned some time ago amid its new learning.\n\nThis leads us no dhe concept of plaricty or, in other words, how a neural pet deals\nwith new information or training. Can a neural net learn more information and still\nreeall previously stored information correctly? If so, does the neural net become\nunstable because it is holding so much information that the dara starts to overlap of\nhas common intersections? This area is referred ta as stability. The bottom line is, we\nwant a neural net to have a good LTM, a good STM, be plastic (in most cases), and\nexhibit stability. OF course, some neural ners have no analog 1 memory. They are\nmore for functional mapping, so these concepts don't apply aa is.\n\nNow thar we know about these memory concepts, let's talk about some mathe-\nmatical fectors char help measure and understand these properties.\n\nOne of the main uses for neural nets is as memories, which can produce a\nresponse by processing inpuc that is incomplete or “noisy.” The response might be che\ninput itself (auteaseciation) or another output thar is totally different from the input\n(Aeteroanociarion). Furthermore, the mapping may be from an n-dimensional space wo\nan m-dimensional space and non-linear to boot. The bottom line is that we want to\nsomehow store information in the neural net so that inputs (perfect inputs as well as\nnoisy ones) can be processed in parallel. This means char a neural net is a kind of\nhyperdimensional memory unit because it can associate an input n-tuple with an out\nput m-tuple, where m cam equal n, but it docsn't have co.\n\nWhat neural nets do in essence is partition an n-dimensional space Into regions\nthat uniquely map the input co the outpur or classify the input inte distincr classes,\nlike a funnel of sorts. Now, as the number of input values (vectors) in the inpuc data\nset (which we eall 5) increase, it logically follows that the neural ner will have a harder\ntime separating the information, As a neural net is filled wich information, the input\nvalues that are to be recalled overlap, since the input space can no longer keep every-\nthing partitioned in a finite number of dimensions. This overlap results in crovseadh,\nmeaning that some inputs are not as distinet as they could be. Crosstalk might or",
      "page_number": 322,
      "chapter_number": 34,
      "summary": "This is an excellent book that explains mathematically the\nbasic ideas of fuzzy logic Key topics include inputs, neural, and models. Another great book, this one with an\nemphasis on creating C++ classes and code for both fuzzy logic and neural-net Al\ntechniques.",
      "keywords": [
        "neural nets",
        "neural",
        "Fuzzy Logic",
        "nets",
        "Games Neural nets",
        "Logic",
        "input",
        "Neural nets model",
        "Fuzzy",
        "model",
        "function",
        "create neural nets",
        "layer",
        "game",
        "number"
      ],
      "concepts": [
        "inputs",
        "neural",
        "models",
        "signals",
        "layer",
        "times",
        "logic",
        "nets",
        "game",
        "basic"
      ],
      "similar_chapters": [
        {
          "book": "Machine Learning Engineering",
          "chapter": 1,
          "title": "Segment 1 (pages 2-11)",
          "relevance_score": 0.45,
          "method": "sentence_transformers"
        },
        {
          "book": "Machine Learning Design Patterns",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 0.44,
          "method": "sentence_transformers"
        },
        {
          "book": "Designing Machine Learning Systems An Iterative Process for Production-Ready Applications",
          "chapter": 1,
          "title": "Segment 1 (pages 2-9)",
          "relevance_score": 0.43,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "Segment 63 (pages 609-616)",
          "relevance_score": 0.43,
          "method": "sentence_transformers"
        },
        {
          "book": "Generative AI with LangChain_2e",
          "chapter": 27,
          "title": "Segment 27 (pages 222-231)",
          "relevance_score": 0.43,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 35,
      "title": "Segment 35 (pages 331-343)",
      "start_page": 331,
      "end_page": 343,
      "detection_method": "topic_boundary",
      "content": "3.9 A eural-Net Primer 347\n\n= --\n\nmight not be desired. Although this problem isn't a concem in all cases, itis a concern\nin associative memory mcural nets, so to illustrare the concept, let's assume thar we are\nOrFing to associate n-tuple input vectors with some output set. The output set isn't as\nmuch of a concern to proper functioning as che input set is.\n\nIf a set of inputs 5 is binary, we are looking at sequences in the form\n11O1010,..10110. Let's say chat our inpur bit vectors are only 3 bits each; therefore,\nthe entire input space consist of these eighe vectors:\n\n¥, = (0,0,0), v. » (0,0,1), v. = (0.1.0), v, = (0.1.1), vs = (1,0,0), v= (10,1), ¥. =\n(1,1,0), v,= (11,1)\n\nTo be more precise, the basis for this set of vectors is:\nv= (1,0,0) “bb. + (0,1,0) * b, + (0,0,1) * b,.\n\nwhere b, can take on che values 0 or 1.\nPor example, if we lec bj=1, b,=0, and by=1, then we get the vector:\n\nv= (1,0,0) * 1 + (0,1,0) * 0 + (0,0,1) * 1 = (1,0,0) + (0,0,0) + (0,0,1) = (1,0,1)\n\nwhich is ¥, in our possible inpur set.\n\nA. basis is 2 special vector summation that describes a set of vectors in a space. So\nv describes all the vectors in our space. To make a long story short, the more orthege-\nmal the veccors in the input set. the better they distribure in a neural net and the bet-\nter they can be recalled. Oreboganality refers to the independence of the vectors or, in\nother words, if nwo vectors are orthogonal, their dot product is 0, their projection\nonto ome another is 0, and chey cant be written in terms of one another. In the set v\nare a lot of orthogonal vectors, but they come in small groups—for example, ¥, is\northogonal to all the vectors, so we can always include it. But if we include v, in our\nset 5, the only other vectors char will fit and maintain orthogonaliry are v, and ¥, or\nthe sec:\n\n¥, = (0,10.0), = (0,0, 1 he ¥ = (0,1 iO}, y= (1,0,0)\n\nWhy? Because vy; - vy; for all ij from 0..3 is equal co 0. In other words, che dot\nproduct of all che pairs of vectors is 0, so they must all be orthogonal. Therefore, this\n\nset will do very well in a neural net as input vectors. However, the set:\n\nwill potentially do poorly as inputs because v, - ¥; is non-zero of, in a binary system,\nitis L. The next question is, “Can we measure this orchogonaliry?” The answer is yes,\nIn the binary vector system, there is a measure called Aanmring distance. It is used to\nmeasure the n-dimensional distance between binary bit vectors. The hamming dis-\ntance is simply the number of bits that are different beoween nwo vectors. For exam-\nple, the vectors:\n\n¥o = (0,0,0), ¥, = (0,0,1)\n\n338 Section 3 Artificial Intelligence\n\nhave a hamming distance of 1, whereas the vectors:\n¥2 = (0,1,0), vy = (1,0,0)\n\nhave a hamming distance of 2.\n\nWe can use hamming distance as the measure of orthogonality in binary bir ver-\ntor systems, which can help us determine whether our input vectors will have a lot of\noverlap. Determining orthogonality with general vector inputs is harder, bur the con-\ncept is the same.\n\nThat's all the time we have for concepts and terminolagy, so let's jump right in\nand sec some actual neural nets chat you will be able to use in your game's Al. We\ncover neural nets used to perform logic functions, classify inputs, and associace inputs\nwith outputs.\n\nPure Logic, Mr. Spock\n\nThe first artificial neural networks were created by McCulloch and Pitts in 1943.\nThese neural networks were composed of a number of neurodes and were Typically\nused to compute simple logic functions such 2s AND, OR, XOR, and combinations\nof them. Figure 3.9.5 is a represencation of a basic McCulloch-Pitts neurode with own\ninputs. IF you are an electrical engineer, you will immediately see a dose resemblance\nbetween MoCulloch-Pitts neurodes and transistors or MOSFETs. In any case,\nMcCulloch-Pitts neurodes do mor have biases and have the simple activation function\nf(x), which is equal to Equation 3.9.5.\n\nf(x) = 1, ifx=0 (3.9.5)\n0. ifx<6\n\nThe MP (McCulloch-Pitts) neurode functions by summing the product of che\ninputs X, and weights w, and applying the result Y, co the activation function fo(x).\nThe early research of MeCulloch-Pitrs focused on creating complex logical circuitry\nwith the neurode models. In addition, ane of the rules of the meurode model is that it\ntakes one time step for a signal to travel fom neurode to neurode, This helps model\nthe biological nature of neurons more closely,\n\nLet's take a look at some examples of MP neural nets that implement basic logic\nfunctions. ‘The logical ANT? function has the following truth rable:\n\nMI X22 © ©6(Qurpur\n( 0 0\no I 0\nI 0 0\nL 1 1\n\nWe can model this table with a two-input MP neural net with weights w,=1,\nw =I, and 8=2, This neural net is shown in Figure 3.9.6a. As you can see, all input\n\n3.8 A Neural-Net Primer 39\n\nOx.\n\nInputs ¥ Output\nWl, y\nMy Wig = By, #0,\ny=1,if¥,,>8\n0,7 ¥),,= 4\n\nFIGURE 3.9.5. The MeCulloch-Pitts neurodes.\n\ncombinations work correctly. For ceample, if we ory inputs X,=0, ¥,=1. the activation\n\nwill be:\nyw, + Xp\" wy = (1\"(1) + (OND) =\n\nIf we input 1 to the activation function Fag) the resule is 0, which is correct. As\nanother example, if we ory inputs X,=1, X)=1, the activation will be:\n\nX,tw, + X%w, = (1)\"(1) + (LY) = 2\n\nIf we input 2 to the activation function Fox), the result is 1, which is comect.\nThe other cases work aloo. The function of the OR ts similar, but the threshold of 6 is\nchanged to 1 instead of 2, as it is in the ANID. You can try running through the euch\ntable yourself to see the resules.\n\nThe XOR network is a little different because it really has two layers, in a sense,\nbecause the results of the pre-processing are further processed in the output neuron.\nThis isa good example of che reason a neural net needs more than one layer to solve\ncertain problems. The XOR isa common problem in neural nets, used to test a neural\nnet's performance. In any case, KOR is not linearly separable in a single layer; it must\nbe broken down into smaller problems and then the results added together. Let's rake\na look at MOR as che final example of MP neural networks, The truth table for KOR\n\nis a5 follows:\nXI M2 Output\n0 0 0\n0 l I\n1 it 1\n1 I 0\n\nXOR is cue only when che inputs are different. This is a problem because both\ninpucs map co the same output. KOR is not linearly separable, as shown in Figure\n3.9.7. As you can see, there is na way to separate the proper responses with a straight\nline. The pains is that we can separate the proper responses with two lines, which is\njose what two layers do. The first layer pre-processes or solves part of che problem, and\n\nSection Artificial Intelligence\n\nInputs\n\nB\nHIDDEN LAYER\nH=1\nInputs\nCc\n\nFIGURE 3.9.6. Basic logic functions implemented with MeCulloch-Pirts new.\n\nthe remaining layer finishes up. Referring to Figure 3.9.6c, we see that che weights are\nwy=l, w=—l, wy=1, wy=—-l, wy-1, w=]. The network works as follows: Layer One\ncomputes whether X, and X, are opposites in parallel, he results of either case (0,1)\nor (1,0) are fed to Layer Two, which sums these up and fires if either is true. In\nessence, We have created che logic function:\n\nz = ((X, AND NOT X,) OR (NOT X, AND X,))\n\nIfyou would like to experiment with the basic McCulloch-Pitts neurode. Listing\n3.9.1 on the CD is a complete two-inpur, single-neurode simulator with which you\nCal experiment,\n\n29 A Meural-Net Primer BPG |\n\na. The best & single layer\n\nnetwork cen do %\nA. single lina cant\nportion the +'s\nfrom the —'s\na |\nb, With two layers Layer 2\nthe sor can be Ky |\n+ =\nsolved ee *1,1)\n=——= Layer\n7 = A ih + -\n0,0) (7,0) my\n\nFIGURE 3.9.7. Using the XOR function vo ilbuscrace linear separabiliry.\n\nThat finishes up our discussion of che basic building block invented by McCaul-\nloch and Pits. Now ler’s move on to more contemporary neural nets such as those\nused to classify inpur vectors.\n\nClassification and “Image” Recognition\n\nAr this point, we are ready to start looking at real neural mets thar have some girth to\nthem! To segue into the following discussions on Hrbbien and Hopfield neural nets,\nwe analyze a generic neural net structure thar illustrates a number of concepts such as\nlinear separabiliry, bipolar representations, and the analog that neural mets have with\nmemories.\n\nLet's begin by making a look at Figure 3.9.9, which shows the basic neural net\nmodel we use. As you can sec, it is a single-node net with three inputs, including the\nbias, and a single ourpur. ‘We will see whether we can use this network to solve the\nlogical AND function that we solved se easily with McCulloch-Pits neurodes.\n\nSection 3 Artificial Intelligence\n\nFIGURE 3.9.8. The basic neural-net model used for discussion.\n\nLer's start by first using bipolar representations, All Os are replaced with —1s, and\nIs are left alone. The truth table for logical AND using bipolar inputs and ourpuss is\n\nas follows:\n\nbt et Output\n-l =|] -l\n-] i -]\n\n] =| —]\n\n] | ]\n\nEquation 3.9.6 shows the activation function £.(x) char we will use.\n\nf(x) =1,ifx>68 (3.9.6)\n—l,ifx<6\n\nNotice thar the function is step with bipolar outputs. Before we continue, let me\nplace a seed im your mind: The bias and chreshold end up doing the same thing, giv-\ning us another degree of freedom in our neurons that make che neurons respond in\nways that cant be achieved without them. You will see this concept illustrated shortly,\n\nThe single-neurode net in Figure 3.9.8 will perform a classification for us, In-will\ntell us wheeher our input is in one class or another. For example, is this image a (ree or\nnora tree? Or in our case, is this inpur (which just happens to be the logic for an\nAND) in the +1 class or the <1 class? This is the basis of most neural nets and the rea-\nson I was belaboring linear separabilicy, We need to come up with a linear partiion-\ning of space that maps our inputs and outputs soa solid delineation of space separates\nthem. Thus, we need to come up with che comect weights and a bias thar will do this\nfor us. Bur how do we achieve this goal? Do we merely use trial and error, of is there a\nmethodology? The answer is that there are a number of ining methods to teach a\nneural met, These maining methods work on various mathematical premises and can\nbe proven, but for now, we simply pull some values thar work out ofa har. These cxer-\ncises lead us into the learning algorithms and more complex nets thar follow.\n\nAll right, we are trying to find weights w; and bias b thar give use the correct\nresult when the various inputs are fed to our nerwork with the given activation func-\n\n3.8 AWNeural-Net Primer 343\n\ntion F(x), Let's wrote down the activacion summation of our neurode and see whether\nwe can infer any relationship berween the weights and the inputs thar might help us.\nGiven the inputs X, and X, with weight: w, and w, along with Bel and bias b, we\nhave the following formula:\n\nK,\"w, + x, + B\"b=8 (3.9.7)\nSince B is always equal to 1.0, che equation simplifies to:\nKy\"w, + X,\"*w, + bef\n\nWhar is this entiry? Ir's a line! Ane ifthe left side is greater than or equal ro 8, that\nis, (M,°w, + X,*w, + b), che meurode will fire and ourput 1; otherwise, che newrode\nwill output -1. Therefore, the line is a decision boundary. Figure 3.9.92 illustrates this\neencept. In the figure, You can see chat the slope of the line is -w,/w,, and the X,\nintercept is (0-b)/w;. Now can you see why we can gee nid of 6? It is part of a con-\nstant, and we can always scale b to take up any loss, so we assume that @ = 0. The\nresulting equation is:\n\nX= —X,°w, fr, — bier\n\nAy = XW, fw, + (G—-b)/w, (solving in terms of X,)\n\nWhar we want co find are weights w, and w, and bias b so thar ir separates our\nourpucs or classifies chem inte singular partitions withour overlap. ‘This is the key to\nlinear separabiliry. Figure 3.9.9b shows a number of decision boundaries that suffice,\nso we can pick any of them. Let's pick the simplest values, which are:\n\nWw, =w, = |\n\nb=—l\nWith these values, our decision boundary becomes:\nmg = =A)\" w/w — biw, — My = —-1\"X, +]\n\nThe slope is =1 and the X, intercept is 1. Ifwe plug che inpue vectors for the log-\nical AND into this equation and use the £{x) activation function, we will ger the cor-\nfect ouipucts. For example, if X, + Xy—1> 0, chen fire the neurode; else output —1.\nLet's try it with our AND inputs and see what we come up with:\n\nInput X]1 x2 Output (X2+X1-1)\n| -l (-I}+(-1})-l=3<0 = dont fire, output —1\n—1 I (-I)+(1)-l=-1<0 = don't fire, output -1\n\nl 1 (1)+Cl)-l=-2<0 dont fire, outpur —1\n\nI 1 (+-l=1.0 fire, outpure 1\n\na44 Section3 Artificial Intelligence\n\nFIGURE 3.9.8. Mathematical decsston boundaries generated by weights, bias, and 8.\n\n2.9 A Newral-Net Primer 245\n\nAs you can ses, the neural neowork with the proper weights and bias salves the\nproblem perfectly. Moreover, there is a whole family of weights thar will do just as\nwell (sliding the decision boundary in a direction perpendicular to itself}. However,\nthere is an important poinc here. Withour the bias or threshold, only lines chrough\nthe origin are possible, since the X, intercept has to be zero. This is very important\nand the basis for using a bias or threshold, so this example has proven an important\none, since it has flushed out this fact.\n\nSo, are we closer co seeing how to algorithmically find weighes? Yes, we now have\na geometrical analogy, which is the beginning of finding an algorithm.\n\nThe Ebb of Hebbian\n\nNow we are ready co see the first learning algorithm and its application to a neural\nnet. One of the simples: leaming algorithms was invented by Donald Hebb and is\nbased on using the input vectors co modify the weights in a way so thar the weights\nereate the best possible linear separation of the inputs and ourpurs. Alas, the alga-\nrithm works merely okay. Actually, for inputs that are orthogonal, it is perfece, bur far\nnen-orthoponal inpurs, the algorithm falls apart. Even though the algorithm doesn't\nresult in correct weights for all inputs, however, it is the basis of most learning algo-\nrithms, so we start here.\n\nBefore we see the algorithm, remember thar it is for a single-neurode, single-layer\nneural net. You can, of course, place a number of neurodes in the layer, but they all\nwork in parallel and can be taught im parallel. Are you starting to see the massive par-\nallelization char newral mers exhibie? Instead of using a single weight vector, a multi-\nnheurode net uses. a weight manrix. The algorithm is simple; it goes like his:\n\nGipen:\n\n* Input vectors are in bipolar form I = (=1,1,..-1,1) and contain k elements.\n\n* There are nm inpur vectors, and we refer to the secas I and the jch element as I.\n* Ourputs are referred to as y,, and there are k of them, one for each input I,\n\n* The weighs w,—w, are contained in a single vector w = (w,, We, -.- W,)-\n\n1. Initialize al your weights to 0, and let them be contained in a vector w that has n\nenuies. Also initialize che bias b to 0.\n\n2. For j= 1 ton, do:\nbebey, (where ¥ is the desired output)\nwewel)*y (remember, ds is a vector operation)\nend do\n\n‘The algorithm is nothing more than an “accumulator of sorts, shifting the deci-\nsion boundary based on the changes in the input and output. The only problem is\n\n346 section 3 Artificial intelligence\n\nthat it sometimes can't move the boundary fast enough (or at all), and so “learning”\ndoesnt take place.\n\nSo how do we use Hebbian learning? The answer is, the same way as the previous\nnetwork except that now we have an algorithmic method with which to teach the net,\nso we refer to the net asa ebb or Hebbian net,\n\nAs an example, let's take our rusty logical AND function and see whether the\nalgorithm can find the proper weights and bias to solve the problem. The following\nsummation is equivalent to running the algorithm:\n\nwe [Lyi] + (h\"y2) + [Ey\"y5] + [\"ya) = -1, -1)\"(-1)] + [(-1, 1)*t-1)] +\n(C1,—-1)\"-1)] + (C1, 1)%{1)] = @,2)\n\nb=y) ty. t+yst yy = (1) + (-1) + (-1) +0) =2\n\nTherefore, w)=2, w;=2, and b=—2. These are simply scaled versions of the values\nwy=l, wy-1, b=—1 thar we derived geometrically in the previous section. Killer, huh!\nWith this simple learning algorithm, we can tain a neural net (consisting of a single\nneurode) to respond ro a set of inputs and cither classify che inpurtas true or false, 1 or\n—1. Now if we were to array these neurodes together to create a nenwark of neurodes,\ninstead of simply classifying the inputs as on or off, we can associate patterns with the\ninputs. This is one of the foundations for the next neural-net structure, the Hopfield\nnet. One more thing: The activation function used for a Hebb net is a sep with a\nthreshold of O and bipolar outputs 1 and -1,\n\nTo get a feel for Hebbian learning and how to implement an actual Hebb ner,\nListing 3.9.2 on the CD contains a complete Hebbian Neural Net Simulator. You can\ncreate networks with up to 16 inputs and 16 neurodes (ourpues). The program is self-\nexplanatory, buc there are a couple of interesting properties: You can select one of\nthree activation functions, and you can input any kind of dara. Normally, we would\nstick to the step activation function, and inputs/outputs would be binary or bipolar.\nHowever, in the light of discovery, maybe you will find something interesting with\nthese added degrees of freedom. I suggest that you begin with the step function and\nall bipolar inputs and outputs, though.\n\nPlaying the Hopfield\n\nJohn Hopfield is a physicist who likes to play with neural nets (which is good for us),\nHe came up with a simple (in structure at least) bur effective neural merwork called\nthe Hopfield net, which is used for autoassociation. You input a vector x and you pet x\nback (hopefully!) A Hopfield net is shown in Figure 3.9.10, It is a single-layer net-\nwork with a number of neurodes equal to the number of inputs KM. The merwork is\nfully connected, meaning that every neurode is connected to every other neurode and\nthe inputs are also the outputs. This structure should strike you as weird, since there\nis feedback. Feedback is one of the key features of the Hopfield net and che basis for\n\nthe convergence to the correct result.\n\n3.9 A Neural-Net Primer 47\n\nw=[4m 4]\n\nInputs ( Wag Outputs\n\nx, ¥ -—s J\natl Ye\n\n* Single Layer\n\n* Inputs x, act as outputs y,\n\nBidirectional arrows\n\nmean thal 4 Wo A =\n\n———_\n\nOutput becomes input\nalter Tet cycle\n\nFIGURE 3.9.10. A four-node Hopfield auroasociative neural nes.\n\nThe Hopfield network is am frerative autoaueciative memory. This means chat it\ncan take ane or more cycles to retum the correct result (if at all). Let me clarify: The\nHopfield network takes an input and then feeds it back, and the resuling ourput\nmight or might not be the desired inpur. This feedback cycle can occur a number of\ntimes before the inpuc vector is returned. Hence, a Hopfield network functional\nsequence is as follows: First, we determine the weights based on our input vectors that\nWe WANT to autoassociare, then we input a vector and see what comes out of the acti-\nvations, [F the resulr is the same as our original input, we ane done; if ner, we take the\nresult vector and feed it back chrough the network,\n\nNow let's take a look at the weight matrix and learning algorithm used for Hop-\nfield nets.\n\nThe learning algorithm for Hopfield nets is based on the Hebbian rule and is\nsimply a summation of products. However, since the Hopfield network has a number\nof input neurons, the weights are no longer a single array or vector bur a collection of\nvectors that are most compactly contained in a single matrix. Thus the weight matrix\nW fora Hopiield net is created based on this equation:\n\nSection 3 Artificial Intelligence\n\nrrrwrs:\n* Input vectors are in bipolar form I = (-1,1,,..-1,1) and conrain k elements.\n* There are m input vectors, and we refer to the set as T and the je element as I...\n* Outputs are referred to as y, and there are k of them, one for each input 1.\n* The weighe macrix W is square and has dimension kx k, since dhere are k inputs.\n\nk\nWray = 51x], (3.9.8)\n\nb= 1\n\nNote: Each outer product has dimension k x k, since we are multiplying a column\nvector and a row vector\n\nWi = 0, for alll i,\n\nNotice that there are no bias terms and the main diagonal of W must be all\nzerocs. The weight macrix is simply the sum of matrices generated by multiplying the\ntranspose I) * I, for all i from 1 ton, This is almose identical to the Hebbian algo-\nrithm for a single neurode except that instead of multiplying the input by the output,\nthe input is multiplied by isself, which is equivalent to the ourpur in the case of\nautoassociation. Finally, che activation function f(x) is as follows.\n\n0, ifx<0\n\nf,(=) is a step function with a binary ourpur. This means thar the inputs must be\nbinary, but didn't we already say that che inputs are bipolar? Well, they are, and they\naren't. When the weight matrix is generated, we convert all input vectors to bipolar,\nbut for normal operation we use the binary version of the inputs, and the output of\nthe Hopfield net will also be binary. This convention is not necessary, but it makes the\nnetwork discussion a litle simpler.\n\nAnyway, let's move en to an example. Say we want to create a four-node Hopfield\nnet and we want it co recall these vectors:\n\nT,=(0,0,1,0), T,=(1,0,0,0), 1,=(0,1,0,1) Note: these are orthogonal.\nConverting to bipolar (*), we have:\n\nI) = C1,-1,1,-1) , I, = (1,-1,-1,-1), I; = (-1,1,-1,1)\n\nNow we need to compute W), W, Ws, where W is the product of the transpose\nof each inpur with itself\n\nWy=(1,'x 0, J = (-1,-1,1,-1} x (=1,=1,1,-1) =\n1 1 =] 1\n1 L = 1\n4 hi oot ee cal\n1 1 -l 1\n\n3.9 A Meural-Net Primer 249\nel!\n\nWy, = [1,*x Ly ] = (1,-1.-1,-1} x (1,-1,-1,-1) =\n\n] -l -l1 -l\n-l 1 1 ]\n—l 1 1 I\n—l 1 1 |\n\nWy; = (1,*x I, ] =(€1,1=-1,1) x (-1,1,-1,]) =\nLe teed od ay\n=| i -l I\n eloeclel a]\nelite alee nol\n\nThen we add W, + W, + W,, resulting in:\n\nWo e2aa) =\n\n3 -1 -l =\n—) 3 =I 3\n—l -l 3 —l\n-l || 5\n\nZeroing out the main diagonal gives us che final weipht maqix:\n\nWs\n\n0 -l =-1 -1\n—| 0 =! 3\n= ee)\n-l 3 =! )\n\nThat's it, now we are ready to rock. Let's inpur our original vectors and see the\nresults, To do this, we simply multiply the input by the matrix and chen process each\noutput value with our activation function f(x). Here are the results:\n\nI, x W = (-1,-1,0,-1) and f{(-1,-1,0,-1)) = (0,0,1,0)\n1, * W = (-2,3,-2,3) and &((-2,3,-2,5)) = (0,1,0,1)\n\nThe inpurs were perfectly recalled, and they should be, since they were all orthog-\nonal, As a final example, let's assume thar our input (visual, auditory, ete.) is a litle\nnoisy and the inpur has a single error in it. Let's take I, = (0,1,0,1) and add some noise\nto T,, resulting in 1° ~ (0,1,1,1). Now let's see what happens if we input this noisy\nvector to che Hopfield net:\n\ni x OW = (3, 2-3, 2) and f ((—3.2,-2, 2)) has (0,1,0,1)",
      "page_number": 331,
      "chapter_number": 35,
      "summary": "This chapter covers segment 35 (pages 331-343). Key topics include vector, inputs, and nets. Covers function. The output set isn't as\nmuch of a concern to proper functioning as che input set is.",
      "keywords": [
        "inputs",
        "input vectors",
        "neural net",
        "vectors",
        "Hopfield net",
        "neural",
        "Hopfield",
        "che",
        "output",
        "function",
        "activation function",
        "Hopfield neural nets",
        "weights",
        "nets",
        "che inputs"
      ],
      "concepts": [
        "vector",
        "inputs",
        "nets",
        "functioning",
        "functional",
        "output",
        "weights",
        "single",
        "logic",
        "logical"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 34,
          "title": "Segment 34 (pages 338-346)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 20,
          "title": "Segment 20 (pages 395-412)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "Segment 63 (pages 609-616)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "More Effective C++",
          "chapter": 14,
          "title": "Segment 14 (pages 133-140)",
          "relevance_score": 0.49,
          "method": "sentence_transformers"
        },
        {
          "book": "Fluent Python 2nd",
          "chapter": 49,
          "title": "Segment 49 (pages 993-1010)",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 36,
      "title": "Segment 36 (pages 344-351)",
      "start_page": 344,
      "end_page": 351,
      "detection_method": "topic_boundary",
      "content": "350 Section 3 Artificial intelligence\n\nAmazingly cnough, the original vector is recalled. ‘This is very cool. So we might\nhave a memory that is filled with bit patterns char look like trees (oaks, weeping wil-\nlow, spruce, redwood, etc.}. MPwe input another tree thar is similar to, say, a weeping\nwillow bur hasn't been entered inco the net, our net will (hopefully) output a weeping\nwillow, indicating that this is whar ir “thinks” it looks like.\n\nThis is one of the strengths of associative memories: We don't have to teach the\nnetwork every possible input. We just have to teach ir enough to give it a good idea.\nThett inputs thar are “close” will usually converge to at actual trained input. ‘This is\nthe basis for image and voice recognition systems.\n\n‘To complete our study of neural nets, I have included a Hopfield auvoassociative\nsimulator that allows you to create nets with up to 1G neurodes. It is similar no che\nHebb net, but you must use a step activation function and your input exemplars must\nbe in bipolar while training and binary while associating {running}. Listing 3-9-3 on\nthe CD contains the code for the simulator.\n\nConclusion\n\nI hope that this article has given you an idea of whar neural nets are and how to create\nsome working computer programs to model them. We covered basic terminology and\nconcepts, some mathematical foundations, and finished up with some of che more\nprevalent newral-net structures.\n\nHowever, there ts still so much more to learn about neural nets: Perceptrons,\nfuzzy ASOCTVEe MeMeries (FAs), bidirectional associative memories (BANMs),\nKohonen maps, Adalines, Madalines, back-propagation networks, adaptive resonance\ntheory networks, “brain state in a box,” and a loc more, Well, that's it, my neural net\nwants to play PlayScarion 2!\n\n4.0\n\nOptimizing Vertex Submission\nfor OpenGL\n\nHerbert Marselas\n\nThere are a number of functions available for submining and rendering vertices in\nOpenGL, which range from the simple immediate mode functions to more compli-\ncated multiple vertex functions and vendor-specific extensions. However, the pertor-\nmance can vary greatly depending on the fanctionaliry used.\n\nImmediate Mode\n\nOften, immediare mode functions (e.g., giVertex*, glColor*, giNormal*) are used to\nget up and rendering quickly, These are easy to use since cach function is geared\ntoward submitting a different component of the vertex: position, color, normal, tex-\nture coomdinates, etc. However, what makes che immediate mode functions so easy to\nuse (submitting a vertex component by component) also makes them the lowest per-\nforming.\n\nThis is due to two factors. First, several function calls are required to render a sin-\ngle vertex. Second, each function must be entered, where it then performs a small\namount of work, and then exited, The time required to enter and leave a function is\ncalled the irmenan everfesd. This overhead occurs regardless of the amount of work\nthe function does, and represents a fixed amount of time required to use the function.\nIf the function does a lot of work, chen the overhead will be low compared co the\nwork being accomplished, If the function doesn’t do a lot of work, or if the function\nis called a large number of times, the overhead can quickly add up.\n\nFigure 4.0.1 shows the amount of time in CPU cycles required co submit 300 col-\nored, textured, and transformed vertices using the immediate mode functions\nglTextured?, glCelerdf, and givertexat. The 300 vertices comprise 100, three-pixel,\ndiscrete, uniform, right triangles. These timings were taken under Microsoft Win-\ndows 98 on a 450MHz Pentium II using a popular consumer OpenGL graphics card.\nThe source code used to generate this dara can be found as a Microsoft Visual C++ 6\nproject on the accompanying CD.\n\n354 Section4 Polygonal Techniques\n\ninmediate Mode Viertex Submission\nTune to Submit Each Verte\n\nFIGURE 4.0.1 CPU cyeles to submit 300 vertices (100 discrete triangles} using immediate mode,\n\nUsing small transformed triangles removes the time spent in transform (they are\nalready transformed), lighting (hey are pre-lit), and rasterizarion (they are very\nsmall). This guarantees that we are effectively measuring che rime required to enter\neach function, store the data, and return. In total, it required -163,154 CPU cycles to\nsubmit and render all 300 vertices.\n\nOn average, it took -544 CPU eycles to submit the position, color, and texture\ncoordinate of a single vertex. However, there were spikes in performance. This can be\nseen in the glVertex function char rook -38238 CPU cycles the first time it was called\nduring a frame, probably co allocare data, although more detailed analysis of the dri-\nver would be required 00 verify this. It then averaged -308 CPU eyeles per call with\nspikes up to ~1500+ CPU cycles per call. The full analysis is contained in a Microsoft\nExcel 97 spreadsheet on the accompanying (CD),\n\nThe simplest way of improving performance would be to remove the function\noverhead by reducing the number of functions called 09 submit and render che 300\nvertices. Calling one or two functions to submit and render all 300 vertices could be\nmuch higher performing than calling 900 functions as we have just done.\n\nInterleaved Data\n\nIf your vertex data is already contained ina single straccure, glinterleavedarrays can\nbe used to submit all the components of the vertex in a single finction call. gliInter-\nJeavedArrays is capable of submitting a number of standard interleaved vertex suruc-\ntures ranging from a lightweight position-only vertex, to a heavyweight vertex with\nposition, normal, diffuse color, and texture coordinates.\n\n: 4.0 Optimizing Vertex Submission for OpenGL 355:\n\nQlinterleavedarrays only submits a pointer to the vertices to be rendered.\nAnother function such as giDrawArrays, glDrzwElenents, or glArrayélenent must be\ncalled to actually render the dara.\n\nApplying the use of glinterleavedarrays to the previous immediate mode exam-\nple. a single function call could be used to submit all of the dara for a single vertex.\nHowever, as its name implics, glinterleavedArrays can accept an array of vertices ro\nsubmit for rendering, This allows us to make a single function call to submit all 300\nvertices, rather than three calls per vertex (00 coral) in immediate mode.\n\nIn the case of the test dara, an array of 300 vertices is generated using the glIn-\nterleavedrrays (GL_T2F (3R_V36F vertex structure formac. This effectively dupli-\ncates the data that was submitted and rendered by the immediate mode functions.\n\nFigure 4.0.2 The amount of time required ro submit and render the vertex work-\nload using glinterlaavedArrays and gitrawarrays. The average time to submis che\n300 triangle workload is -72,821 CPU cycles. This is less than half the time (44%)\nthar was required by the immediate mode functions co submit and render che same\nworkload.\n\nglinterleavedArrays Vertex Submission\n\n200000\n100)\nno\n140000 fe\n20000 oe\nqooo00 £\nagooo\n60000\n‘0000\n20000 fe\n\nin\n\n=\nfT\n7\na\n=]\nX\n1 ]\n\ngintarhgawedss rays gDraw Arniys Total Submission\nTena\n\nFIGURE 4.0.2 Submitting vertices with gilnrerlcaved/Arrays.\n\nStrided and Streamed Data\n———————————COOCO ees\n\nAnother altemarive vertex submission interface is the gl*Pointer functions. Similar to\nglinterleavedArrays, pointers to the vertex data are submited using che gl*Pointer\n\no56 Section 4 Polygonal Techniques\n\nIndependent Date Streams\nVaCa |...) TxGn\n\nInterleaved Data\n\nVeron | Gator Fetes] v2 [6 | Teo2| va] es] Taca |. [va [Gn [Thom\n\nFIGURE 4.0.3 Streamed vs. interleaved dara.\n\nfunctions (e.g. g1VertexPointer, giColorPointer). The submitted vertex dara is then\nrendered using the glOrawArrays, glArrayElesent, or glOrawElenents functions.\n\nThe 91*Pointer functions also have a uniform stride parameter, similar to glIn-\nterleavedtrrays. The stride specifies the number of bytes from the beginning of one\nvettex component to the next. When che stride is greater than zero, the operation of\nthe gl*Pointer functions is essenially the same as making a single call to glInter-\nJeavedarrays, When the stride is zero (the data is tightly packed together), rhe data is\nreferred ta as stream data (Figure 4.0.5).\n\nStream data is very important when using SIMD (Single Instruction Multiple\nData} instruction segs like Intel's SSE (Streaming SIMD Instructions) or AMD\":\nSD Now! instructions to transform, light, and/or clip vertices. If the data was in an\ninterleaved vertex format, the dara must be moved piecemeal into and our of the\nCPU's SIMD registers, With the dara in stream formar, the CPU can quickly and eas-\nily move large chunks of the dara into the SIMD registers for processing.\n\nEven without taking advantage of the CPU's SIMD instructions for geometry\nand lighting, a performance boost can be had just by using che g1*Pointer functions.\n\nTt takes on average -51,212 CPU cycles to submit and render the 300 vertex\nworkload using the g1*Pointer functions with glDrawarrays (Figure 4.0.4) as com-\npared to -72,821 CPU opcles using gl Interleavedarrays and g1Dramirrays (Figure\n4.0.3). This is -30% reduction in time. Again, the performance increase would be\neven larger if we were relying on SIMD CPU instructions to perform geometry and\nlighting operations.\n\nComplled Vertex Arrays\n\nThe compiled vertex arrays extension (EXT_compiled_vertex_array) builds upon the\nfunctionaliry of glinterleavedArrays and the gl*Pointer functions. The compiled\n\n4.0 Optimizing Vertex Submission for OpenGL 357\na a a ene ee Ee ee ee eet ae\n\n220000\nTen\n1E0000\nlh ae\n120000\n\n1Tno000 - - ~ - BpiOrawarrays\nBOo00 = i BCVA sOrawsrrigs\n\nooo\n\nFIGURE 4.0.4 Vertex submission time for glDrawArrays with and without Compiled Vertex\nAIrays,\n\nvertex array (CVA) function allows the application to specify a range of data in the\narrays supplied by glInterleavedArrays of gl*Pointer chat wont be changed by the\napplication. These allow the driver to optimize the data range once, and re-use the\noptimized version wneil the application unlocks che data.\n\nThis can result in significant speed increases by allowing the CPU's transform and\nlighting implementation to re-arrange the data for aptimal access. It can also allow the\nrendering hardware to modify the data for faster performance, or even make a local\ncopy of it on the graphics adapter for faster access,\n\nThe performance difference berween using CVA and not using CVA is not very\nlarge in our test workload (Figure 4.0.4), bur this is only because we are attempting to\nquantify the overhead of the function, The performance differential would be sub-\nstantially greater if the vertices were being transformed, lit, and clipped, or if there\nwere more of chem.\n\n(CWA is very useful for data char is static, or that can be used multiple times before\nbeing modified. If the data is only used once, then the overhead of using CVA may\nourweigh the benefit. To improve the performance of dynamic data, the only current\nalternative is to use a vendor-specific extension.\n\nEliminating Data Copy—Vendor Extensions\n\n‘With both the immediate mode functions and the array functions when not using\nCVA, the dara submitted for rendezing must be copied from application-allocared\n\n358 Sectlon 4 Polygonal Techniques\n\nmemory te driver-allocated memory. As any data copy cakes time, eliminating the\ncopy is an easy performance win,\n\nCVA reduces this copy to a single time when the vertex array is locked. However,\nCVA assumes thar che dora is static or will be used repeatedly before being modified.\nThe problem of copying daca from application memory to driver memory srill exists\nfor dynamic arrays of dara thar are frequently updated or changed.\n\nThe only way to remove this copy would be for che application to store vertices\ndirectly in driver-allocated memory, and some vendors support chis as an extension,\nThe nVidia extension wglAllocateMenoryNv is one such vendor-specific extension. It\nallocates memory direcely accessible to the graphics card where the application can\nstore vertex data. This eliminates the need for any driver copying of data, and im-\nproves the performance when a vertex array is submiteed and then immediately ren-\ndered since the data is ready to go.\n\nCheck with your vendor for their specific OpenGL extensions.\n\nData Format\n\nA second area of consideration is the formar thar vertices are submitted in for render-\ning triangles. Vertex lists, Like those used in the test workload, are the most common\nformat. In a vertex list, chree vertices define each riangle (Figure 4.0.5a). However,\nwhen triangles share vertices, there's offen no reason to repeatedly include the same\nvertex. One alternative is to use triangle scrips of fans (Figure 4.0. 5b).\n\nDiscrete, stip, or fan triangles are identified by the mode parameters of\nglOram4rrays and g“l0rawElements. These are GL_TRLANGLES, GL_TRIANGLE_\nSTRIP and GL_TRIANGLE_PAN, respectively.\n\nUtilizing a separate array of vertex indices to build fees from the vertex array is\nanother way to reduce the number of vertices required to draw a number of triangles\n(Figure 4.0.$¢). glOrawElements is similar co g1Orawirrays, but it adds a new pare-\nmeter that accepts the face vertex index liss.\n\nUsing both triangle strips and face vertex indexing, it's posible to lower the ver-\ntex per triangle ratio to almost 1:1 for some complex triangle meshes. On many oypes\n\nindeed Veotions\nWerlex List rene : 2 Vortices: Por First\n\n3 \\Veetoos Per Trangia 1 Vera Por Ackettignnl Tei od 6 f Wertex Per Additional\nB Vertices to Grew 2 Tranghas 9 5 Vordicaa bo Dea 3 Tearngiee 8 Wortions to Draw &\nA B C\n\nFIGURE 4.0.5 A,B, G. Vertices for a: three discrete triangles, é chree strip riangles, and\nsix indexed triangles.\n\n4.0 Optimizing Vertex Submission for OpenGL 359\n\nof dara, however, triangle fics combined with face wertex indexing are nearly as fase,\nand require less: pre-processing to create.\n\nGeneral Recommendations\n\nThere are also a number of general recommendations for increasing vertex submission\nand rendering performance.\n\n1. When using indexed data, care should be taken to co-locate all the vertices for a\nsingle triangle as near to each other as possible, [fF the vertices required for a trian-\ngle are too far apart in the array, it may cause the graphics adapter ta continually\nre-process sub-parts of the array as it jumps around.\n\n2. Pre-sorting vertex data by material, shader, and texture settings can help increase\nthe number of vertices that can be submitted and/or rendered in a single function\ncall.\n\n3. Keep the amount of information submitted per vertex as lean as possible, Don't\ninclude extra information that's only used occasionally. This must be balanced\nwith continually changing vertex formats. For example, don't submit a vertex\nwith additional color information if that information is rarely used.\n\n4. There is a balance between submitting too little data and woo much data, Most\narray functions require at least 10-50 vertices no be submitted to overcome the\nfunction overhead. On the upper end of the scale, no more than 32k—64k of dara\nof vertex data should be submitted, These amounts vary by graphics adapter.\n\n3. Spending too much time getting a lot of vertex data together into a single buffer\n(if it's not a driver-allocared buffer) can present more problems than ir solves on\nthe CPU. These include cache issucs, letting che graphics card stall, and over-\nwhelming the function with too much clata.\n\nConclusions\n\n1. Immediate mode functions may be easy to use when getting started, bur they are\nthe lowest performing functions for submitting vertices for rendering (Figure\n4.0.6).\n\n2. Submit and/or render as many vertices as ts feasible in a single function call.\n\n3. Use Compiled Vertex Arrays (CVA) for static dara, or for data that doesn't change\nvery often.\n\n4. For the best CPU transform and lighting performance, use streamed dara formats\nwith CVA.\n\n3. Some vendors will provide specific vertex submission extensions for even higher\nperformance.\n\n6. Use indexed vertex data with discrete or strip triangles to increase the number of\ntriangles that can be drawn with the smallest number of vertices.",
      "page_number": 344,
      "chapter_number": 36,
      "summary": "This chapter covers segment 36 (pages 344-351). Key topics include vertex, function, and functions. Covers function. It is similar no che\nHebb net, but you must use a step activation function and your input exemplars must\nbe in bipolar while training and binary while associating {running}.",
      "keywords": [
        "Artificial intelligence Amazingly",
        "Vertex",
        "Optimizing Vertex Submission",
        "Vertex Submission",
        "data",
        "vertex data",
        "functions",
        "function",
        "mode functions",
        "CPU",
        "intelligence Amazingly cnough",
        "vertices",
        "Pointer functions",
        "single function call",
        "vertex array"
      ],
      "concepts": [
        "vertex",
        "function",
        "functions",
        "triangles",
        "data",
        "performs",
        "performance",
        "cpu",
        "extensions",
        "extension"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "Segment 63 (pages 609-616)",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 18,
          "title": "Segment 18 (pages 352-373)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Computer Systems A Programmer’s Perspective",
          "chapter": 27,
          "title": "Segment 27 (pages 537-558)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 36,
          "title": "Segment 36 (pages 347-355)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 53,
          "title": "Segment 53 (pages 511-519)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 37,
      "title": "Segment 37 (pages 352-362)",
      "start_page": 352,
      "end_page": 362,
      "detection_method": "topic_boundary",
      "content": "360 Section4 Polygonal Techniques\n\nSummary Vertex Submission Time\n\nBm mediate Mode\nBginieteaveda nays\nGHgt@Psémiat Sbaam\n\nGEVA gFFointer Stream\n\nFIGURE 4.0.6 Summary comparison of verrex submission and rendezing time by function.\n\nReferences\n\n[ARB] OpenGL Extensions. OpenGL ARB. Available wow.opengl_org.\n\n[Kempf?7] Kempf, BL, ancl Frazier, C., Open Reference Manual 2™ Edition, Addi-\nson-Wesley Developers Press, 1997.\n\n[Spitzer] Spitzer, John E, Maximizing Open(sL Performance for GPUs. Online. 08\nMarch 2000. Available www.nwidia.com.\n\n4.1\n\nTweaking a Vertex’s Projected\nDepth Value\n\nEric Lengye!l\n\nMany games need to render special effects such as scorch marks on a wall or foorprints\non the ground that are not an original part of a scene, bur are created during gamie-\nplay. These types of decorarive additions are usually decaled ante an existing surface,\nand thus consist of polygons that are coplanar with other polygons in a scene. The\nproblem is that pixels rendered as part of one polygon rarely have exacdly the same\ndepth value as pixels rendered as part of a coplanar polygon, The result is an unde-\nsired pattern in which parts of the original surface show through the decaled poly-\nPons.\n\nThe goal is co find a way to offset a polygon’s depth in a scene without changing\nis projected screen coordinates or altering its texcure mapping perspective. Most 3D\ngraphics libraries contain some kind of polygon offser function to help achieve this\ngoal. However, these solutions generally lack fine control and usually incur a per-ver-\ntex performance cost. This article presents an alternative method that modifies the\nProjection matrix wo achieve the depth offser effect,\n\nExamining the Projection Matrix\n\nLet us first examine the effect of the standard OpenGL perspective projection matrix\non an eye space point P= (PL 2, F, 1). To simplify our matrix, we assume thar the\nview fruscum ts centered about the z-axis in eye space (i.c., che rectangle on the near\nclipping plane carved out by che four side planes has the property thar lef? = —nighrand\nbottom = —rap)). Calling the distance to the near clipping plane m and the distance to\nthe far clipping plane £ we have:\n\nBC) i Sectlan4 Palygonal Techniques\n\nmn 0 i o Fa ne.\nO it] i] = nb,\nva | Fi=\noO ayifoct yeaa P apa aja. . (4.1.1)\nfo—m j-a . f—nS 1x\n\noo =] i) —P\n\n=\n\n‘To finish the projection, we need to divide this result by its w-coordinate, which\nhas the value =?,. This division gives us the following projected 3D point, which we\n\nwill call P\"\n_ ak\nPe\nTi\nP= = + (41.2)\n\nFae aa\n\nfon Plf-n\n\nRecall that the near clipping plane lies at z =—m, and the far clipping plane lies at\n== —f since the camera points in the negative z direction. Thus, plugging — and —f\ninto Equation 4.1.2 for P, gives us the expected = valucs of =I and I bounding the\nnormalized clipping volume. Also recall that this mapping from [—s.—/] to -1..1] is\na function of inverse « This is necessary So thar linear interpolation by the 3D herd-\nware of values in the depth buffer remain perspective correct.\n\nTweaking the Depth Value\n\nTt is clear from Equation 4.1.2 that preserving the value of —P, for the ncoordinate\nwill guarantee the preservation of the projected x- and y-coordinates as well. From this\npoint forward, we shall only concern ourselves with the lower-right 22 portion of\nthe projection matrix, since this is the only part that affects the z and wcoordimates.\nThe projected s-coordinate may be altered without disturbing the x coordinate by\ninwoducing a factor of 1 + €, for some small ¢, as follows.\n\noT fpr aa || fia eels\na eee for [?|- AF f-n| (413)\n-I i) sali\n\nAfter division by w, we arrive at the following value for che projected z-coordi-\nnate.\n\n4.1 Tweaking a Vertex's Projected Depth Value 363\n\n— ftn if\nBARA sey ay\n\n: |\nSet) 9 Sern\n\nf-n Plf-n) f=\nComparing this to the z-coordinate in Equation 4.1.2, we see thar we have found\n\nFew\n\nfa”\n\n(4.1.4)\n\naway to offset projected deprh values by a constant €\n\nChoosing an Appropriate Epsilon\n\nDue to the nonlinear narure of the z-buffer, the constant offset given in Equation\n4.1.4 corresponds to a larger eye space difference far from the camera than it does near\nthe camera. While this constanc offset may work well for some applications, there is\nno single solution that works for every application at all depths. The best we can do is\nchoose an appropriate € given an eye space offset 6and a depth value P, which collec-\ntively represents the object thar we are offsetting. To determine a formula for &, ler us\nexamine the result of applying the standard projection matrix from Equation 4.1.1 ra\na point whose z-coordinare has been offset by some small 6,\n\nfat fon (4.1.5)\n\n-(P. +6)\n\nDividing by m, we have the following value for the projected 2-coordinate.\n\nfon f-# ,\n\nell 0\n\nga a et, ee\nHe foe (F+8\\f—m)\n\nfr-r Pf x) fon Pid Be\n\nEquaring this result to Equation 4.1.4 and simplifying a bit, we end up with:\n\n(4.1.6)\n\n_2h | 2 ; (4.7)\nf+n\\ P(r +d)\n\nA good value of é for a particular application can be found with a little experi-\nmentation. In showld be kept in mind char dis an eye space offset, and thus becomes\n\n364. Section 4 Pohrgenal Techniques\n\nless effective as J, gets larger. For an m-bir integer depth buffer, we want co make sure\nthat:\n\n2s mbes (4.1.8)\n\nsince smaller values of € will noc yield an offset significant enough to alter the integer\ndepth value. Substituting the right side of Equation 4.1.7 for £.and solving for d gives\n\nLs=\n\nkp\n\nj= —— ole\n1 &P (4.1.9)\n\nkp?\n=\n\n= 4.1.10\n1+ EP :\n\nwhere the constant & is given by:\n\nepee At Ds\n2 fil 2\" ~ |\nEquation 4.1.9 gives us the minimum effective valuc for éwhen offsetting a paly-\n\ngon toward the camera (the usual case), and Equation 4.1.10 gives us the maximum\neffective value for 6 when offsetting a polygon away from the camera.\n\n(4.1.11)\n\nImplementation\n\nThe following sample code demonstrates how the projection matrix shown in Equa-\ntion 4.1.3 may be implemented under OpenGL. The function Load0ffsetmatrix\ntakes the same six values that are passed ro the OpenGL function glFrustun. It also\ntakes values for Gand P, that are used co calculare £\n\nSource Code\n\ninclude <g1.h»\n\nVOLO Load fsetWatrix(Gldouble 1, Gldouble r,\nGidouble ob, GLdowble ¢t,\n\nGidoubla n, GLoouble #,\n\nGLfloat dalta, Glfloat pr)\n\nGLfloaat matrix] 16];\n\nra | Tweaking a Vertex's Projected Depth Value 365\n\nff Set up standard perspective projection\nglllatriniode (GL_PAOJECTION) :\ngiFrustun(1], r, b, t, m, fT):\n\nif Retrieve the projection matrix\nglGetFloaty(GL_PAQJECTION_WATRIX, matrix);\n\nif Galculate apsilon with equation (4.1.7)\nGLiloat epsilon = -2.0F * # * mn * delta ;\n((t +n) * pe * (pz * delta};\n\nff Modify entry (3,3) of the projection matrix\nHatrixfio] *= 1.0F + epsilon:\n\n/? Sand the projection matrix back to OpenGL\ngiloadMatrixf (matrix |;\n\n4.2\n\nThe Vector Camera\n\nDavid Paull\n\nThe vector camera is a generalized form of the matrix-based camera found in many\nmaditonal graphics engines. Macrices are often difGeult to read due to che face chat\nthey typically hold several operations concatenated together, The vector camera uses\nonly simple vectors to describe its orientation, position, field of view, and aspect ratio.\nThis formar allows for some interesting optimizations to the overall graphics pipeline.\nThe vector camera uses the same information found in matrix-based cameras. The\nworld-te-camera matrix (view matrix) is broken down into four vectors. As you can\nsee in Figure 4.2.1, a view matrix is really four vectors,\n\nThree vectors represent the three axes that define the camera's orientation, and\none vector represents the camera's position in the world coordinare space. In total, his\nprovides six degrees of freedom. In some graphics engines, you may need to invert the\nview matrix to be compatible wich the vector camera. Figure 4.2.2 shows a scene with\nthe vector camera and a cube model. Ir also shows the viewing pyramid that defines\nthe limies of the camera's view.\n\nThe main advantage to the vector camera is that it can operate in both local and\nworld coordinate space. The camera's orientation and position vectors are stored in\nworld space; however, they can be inverse transformed into local space using the\ninverse of the model’s local-to-world matrix. The camera and dhe object wan't move\nin relation to each other; rather, the camera's new orientation and position are relative\nto the local space object. These are the only cransformations required to render che\n\n2, 0.707 0.000 0.707 §0.000 :\n=, 0.000 1.000 0.000 80.000\n0.000 ae\n\n0.000 0.000 0.000\n\nFIGURE 4.2.1. The view matrix is composed of four vectors.\n\n42 The Vector Camera i687\n\nFIGURE 4.2.2. Ulusiration of che vector camera.\n\nobject. Now that the vector camera is in local space, it can project the local space\ncoordinates, and no further transformations are required. After doing almost no\nwork, the vector camera can now cycle through each of the local space vertices in the\nmodel, and project them into 2D sereen coordinates, If the model is static, like a\nmountain, the model data can be stored in world space. This allows for an even faster\neode path, With both the object and the camera in world Space, no inverse matrix\nheeds to be calculated, and no wansformations are required at all.\n\nThese diagrams use a left-handed coordinate system with the ¥-axis pointing up.\nThe vector cameras position is (0), 2,—2), and has a small rorarion about the L/-axis to\ntilt the camera down. The bor's position is (0, 0, 2), and has a rotation of 45 degrees\nabout the Y-axis. The smaller arrows show world (x, y, 2]-axis vectors to help illustrate\nrotations.\n\nIntroduction to the Vector Camera\n\n‘The vector camera uses three vectors to represent its orientation. The tf, Vo and\nvectors are parallel to the A, ¥, and 2 origin vectors, respectively, if the camera has no\nrotation and is positioned ar (0,0,0). The C! vector pains co the right, the vector\npoints up, and the N vector points in the direction thac the camera is facing, Figure\n4.2.3 shows the vecuor camera with its 3D screen. This 3D screen is created using the\n\n368 Section 4 Polygenal Techniques\n\ncameras Of, Vand NV vectors, and cwo field of view parameters. The field of view\nparameters ate calculated using a user-defined field of view that is then scaled by the\naspect ratio. There are many ways to calculate the field of view parameters. For these\nexamples, I used the following code:\n\nTloat Aspecthatio = Screenteight/ScreenWidth;\nTloat FOV = pase;\n\nfloat hFrac = tan(Fove'o,5):\n\nfloat wFrac = tan{FOV\"O. S*Aspecthatio) 5\n\n[f the camera had no rotations or translations, the vectors would be defined as fol-\n\nlovers:\n\nO vector = -U vertar * hFras 4 V vector = vFrac\nS wactor = WU vector * hFrac * 2\nT vector = -¥ vector “* vFrac * 2\n\nThe 3D screen is created by adding these vectors, For this example, the distance\nto the near plane is 1.0; thus, starting at che camera's position, add 1.0 * N vector.\nThen add the © vector, This defines the point in 310 that will be called the screen ori-\ngin, The Sand 7 vectors originare from this poinc. The Sand Tvecrors define lines of\nconstant screen A and screen F, respectively. It is analogous to adding a screen-sized\ntexture to the quad defined by the Sand J vectors, Using the world space position of\nthe camera and the world space Sand vectors, any point in wodld space can be pro-\njected into screen coordinates using the following method. A veceor is created starting\nat the world space position of the camera, which ends at che world space position of\nthe vertex to be projected. If the vertex is in view of the camera, we can calculate the\n3D point where the ray intersects the 3D sereen of the vector camera. This intersec-\ntion point is shown in Figure 4.2.3 and Figure 4.2.4 as the ? vector. Then using the\nvector det product, the distance along beth the Sand T vectors can be fownd, which\nessentially converts che values into 21D. ‘These 2D valwes are rescaled based on che cure\nrent display resolution, and the resule is 2D screen coordinares ready for display.\n\nLocal Space Optimization\n\nThe camera vector are stored in world space; however models are typically stored in\nlocal space, sometimes called model space. The model is centered around (0,0,0) and\nis accompanied by a local-to-world matrix, This local-to-world matrix defines how\nthe object will rotane and cranslate in order to end up in its final world space orienta-\ntion and position. Since the model data is stored in local space, it would be adwanta-\ngeous to be able to work in local space, In order to accomplish this, the camera must\nbe moved from world space into local space. The camera must be rotated and trans-\nlatecl about the object, such that the camera's new orientation and position retains che\nsame spatial relationship as if the object was transformed bocal-vo-world, and viewed\nby the camera in world space. The solucion is che inverse of the model's local-to-world\n\n42 The Vector Camera 269\n\n, al\n\nFIGURE 4.2.3. Using the P vector.\n\nmatrix. The inverse of a rotation matrix is calculated in two parts, ‘The first part per-\nforms @ transpose of the upper 3x3 rotation matrix. The second part uses three dot\nproducts to calculate the new position, This inverse matrix can perform the opposite\noperation of world-to-leeal.\n\nPlease mote thar there are really two local-to-world wansformations that need to\nbe preserved. The camera has an assumed local-to-world already applied to che cam-\ncras orientation and position; thus, we only need to worry abour che ebject’s local-to-\nworld macrix. The newly created world-to-local matrix defines how the camera's\norientation and position will rotate and translate in order to preserve the spatial rela-\ndonship between the object and the camera. As you can see in Figure 4.2.3, the cube\nhas undergene the lorcal-to-world transformation, which is a slow per-vertex process.\nAlso in Figure 4.2.3, nove the camera's world position and orientation for comparison\nwith Figure 4.2.4. You can sec in Figure 4.2.4 thar the cube is in its local coordinare\nspace without any rotation or translation. The camera, however, has been rotated and\ntranslaned such thar the camera generates the same image found in Figure 4.2.3. Mov-\ning the camera into local space is computationally faster than moving the local data\ninto world space. Only four transforms are required to move the camera into local\nspace, while it takes NV transforms to move a shape with NV vertices from local-to-\nworld. Once the model data and the camera data are in the same coordinate space,\nprojection of the model data requires little computation.\n\nNow thar the camera is in local space, some additional optimizations are possible.\nIf you store the plane normal for cach triangle with your model, back facing can be\n\naro\n\nSectlon4 Polygonal Techniques\n\nFIGURE 4.2.4. The cube resides in a local coordinate space,\n\nperformed using a single dot product. If the triangle faces the camera, all of its vertices\nare flagged as visible. When the entire object has been back-face culled, only the visi-\nble vertices will need to be projected.\n\nConclusion\n\nThe vector camera is a handy way of representing the camera math for use in software\nor hardware 31D rendering engines. Its simplicity allows the freedom ta intuitively\nplace and manipulate the camera, The camera's abiliey to work in che local coordinate\nspace allows for several well-known optimizations to have a larger impact on render-\ning speed than they do on traditional matrix-based cameras. The vector camera pro-\nvides a consistent 25% increase in frame race. It accomplishes this by reducing the\nnumber of required transforms, computing small final packets for display, and using a\nlow amount of memory overall, The projection math is flexible enough that ir can\nalso be applied ro any focus-based frustum like shadow volumes. Sometimes, the best\noptimization is to redesign the method, rather than squeeze performance out of che\nexisting method!.\n\nThe OpenGL source code to the vector camera is included with this book. For\nthe latest version of the source code, please visit the Tanzanite Software Website ar\nwww. tanzanite.to. All diagrams used in this article were rendered using the TechNa-\nture engine.",
      "page_number": 352,
      "chapter_number": 37,
      "summary": "This article presents an alternative method that modifies the\nProjection matrix wo achieve the depth offser effect,\n\nExamining the Projection Matrix\n\nLet us first examine the effect of the standard OpenGL perspective projection matrix\non an eye space point P= (PL 2, F, 1) Key topics include vector, cameras, and projected.",
      "keywords": [
        "Vector Camera",
        "camera",
        "Vector",
        "space",
        "local space",
        "world space",
        "matrix",
        "Projection matrix",
        "vector cameras position",
        "world space position",
        "space Sand vectors",
        "Vector Camera David",
        "local",
        "world",
        "Summary Vertex Submission"
      ],
      "concepts": [
        "vector",
        "cameras",
        "projected",
        "value",
        "world",
        "coordinate",
        "position",
        "positioned",
        "effects",
        "techniques"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 8",
          "chapter": 3,
          "title": "Segment 3 (pages 23-30)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 39,
          "title": "Segment 39 (pages 386-393)",
          "relevance_score": 0.42,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 40,
          "title": "Segment 40 (pages 394-404)",
          "relevance_score": 0.42,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 35,
          "title": "Segment 35 (pages 337-346)",
          "relevance_score": 0.41,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 4,
          "title": "Segment 4 (pages 31-40)",
          "relevance_score": 0.4,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 38,
      "title": "Segment 38 (pages 363-370)",
      "start_page": 363,
      "end_page": 370,
      "detection_method": "topic_boundary",
      "content": "4.3\n\nCamera Control Techniques\n\nDante Treglia II\n\nThe interactive nature of games is the key element in what attracts and enthralls che\nPlayer. The fact chat one can become so many differenc characters, from a Sexy, Scant=\nily clad warrior to an Italian plumber with the charm to arerace a princess, is what\nentices so many people ro purchase games. But in order to allow the player to see che\nworld through a differenc set of eyes, the game needs to have a solid camera model.\nThis is where camera control encers the picture. This article will outline a few basic\n\ntechniques thar can be used co develop the proper camera model for your game.\n\nA Basic First-Person Camera\n\nLook-At\n\nBaste first-person carnera moxdels rely on “look-at\" uriliries such as OpenGLs glu-\nLookAt(Q). Given a camera position, view direction, and up veetor, this function\nTetuIns an ofentation view martrix. The view macrix is then placed on the OpenGL.\nMODELVIEW matrix stack and concatenated with orientation macnices far each object in\nthe scene as they are rendered. This camera model is very easy ro implement, and\nquite useful. An implementation of this function can be found in the Ces matrix\n\nlibrary.\n\nEuler Angles\n\nOrientation in three-dimensional space can be represented with three Euler angles:\nyaw, pitch, and roll (also known as azimuth, elevation, and roll). Yaw, pitch, and roll\naccount for the rotation in the F-axis, A-axis, Z-axis, respectively as illustrated in Fig-\nure 4.3.1.\n\nOne method for calculating the orientation matrix is to concatenate the three\naxcs rotation matrices, However, for control purposes, it is necessary to maintain the\ncurrent position as well as information abour che cameras X (side), F (up), and -#\n(forwand) directions. The forward, side, and UP VEChors are weed ta calculate the cam-\neras forward movement, strafe, and jump, respectively. The following code gives a\nfunction that calculates these vectors, which can be used as parameters to che glu-\nLookAt() function to produce the cameras view matrix.\n\na72 Section 4 Polygonal Techniques\n\nFIGURE 4.3.1. An image of a plane with the yaw, pitch, and roll angles described.\n\nvoid FlyCam::CosauteInfo() {\nfloat cosY, cos, cosh;\nfloat sini, sinP, sink;\n\nii Only Want ta Cale these once\ncosy = cost (v)}\ncos? = cost(F);\ncos = cost (Al;\n\nsin¥Y = sint(¥);\nsinP = sinf(P);\nsink = sint(A):\n\nii Fad Vector\ntwd.s = ain¥ * cosh;\ntwd.y = sink;\ntwd.z = cosh * -cosy:\n\nff Look At Point\nat = fwd + eye;\n\nif Up Vector\n\nUp-« = -cosY ~ Sink - sinY * sinP * cosh;\nUp-¥ = cosP * cash:\n\nUp.z = -sinY * si8h = sinP * cosh * -cos¥;\n\ni! Side Vector (right)\nside = CrossProduct(fwd, up);\n\n4.3 Camera Control Techniques afa\nia aE aa ee eee ee\n\nControls\n\nMethods for moving the camera's orientation and position through the scene are very\ngame-dependenc. For example, the camera position of a first-person shooter will most\nlikely follow the contours of the environment. A very accurate Hight simulator will\nrely on other environmental factors such as engine thrust, altitude, air conditions, cur-\nbulence, etc. I'm only going to cover the necessary components to get you off the\nground. Let's assume that the user's input device is a keyboard and a mouse. bur keep\nin mind that these techniques can be casily applied wo almost any inpur device,\nincluding joysticks, console controllers, and even VR devices.\n\nThe most intuitive control using Euler angles is to map the yeu to the mouse's\n(screen-relative) X position, and the pitch co the ¥ position. This mapping will mimic\nthe camera control found in Quake, which allows the user to change their view\nrapidly with two degrees of freedom. This cechnique can be used in conjunction with\nother camera models, For example, Super Aferiodd¢ was mostly a third-person game,\nbur also included the abilicy to examine the world through Mario's eyes. Since rofl is\nnota common human experience, it is usually disregarded.\n\n‘The cameras interaction with the environment is a very Fame-specific topic. As I\nmentioned earlier, the forward, side, and up vectors are used for contralling the posi-\nion of the camera, and should tie directly into your game engine. However you\nchoose to incorporate these vecrors, I strongly recommend thar you use time-based\nphysics. This will ensure thar your controls are frame-rate independent and give the\ngame a more realistic feel. Aca bare minimum, you should interpret che user's input as\na velocity in the desired direction. Since you have the camera's orthogonal orientation\nbasis vectors (forward, side, up), the implementation is a simple one-dimensional\nphysics problem:\n\nPosition += deltaTime * inputSpeed \" forward\n\nAAccelerations can also be applied co achieve damping effects. In the sample code,\n[have consolidated these control rechniques into a flying cameza that allows you to\nmove the view in any direction.\n\nScripted Camera\n\nSeripted cameras are a crucial part of many games, from cinematic scenes in role-play-\ning games to helicopter fly-throughs of a golf course. Most games that use this camera\ntechnique use an animation package to script the camera, then import the animation\ninto their game engines. This is an excellent solution for a static path, but what abour\ndynamic paths? Say, for example, you want the player ro have an out-of-body experi-\nence and fly through the scene while targeting on enemies, allics, the gates of heaven,\nor the gares of hell.\n\na74 Section4 Polygonal Techniques\n\nB-Spline Curves\n\nSpline curves are a flexible, easy, and efficient solution to generating a smooth curve\ngiven a set of control points, There are several ocher curve-peneraring algorithms and\nmodifications that offer more flexibiliry and power that I encourage you to explore,\nbut B-Splines are a great place to start. The cubic implementation I will discuss is\nbased on a basis function in the form of the matrix shown in Equation 4.3.1, Givena\nset of four contrel points and a parameter, wu, that uniformly progresses from 0 co 1\nthrough a set number of subdivisions, this matrix will produce a smooth curve sec-\nvon. For each element (x, y, 2) of the control points, the Build() function is applied.\n\n-| 3 31\n3-6 0 4/1\n\nB- Spline = =\nSlibetenaes: in le\n\n\\1 0 0-0\n\nEQUATION 4.3.1. The cubic §-Spline basis function.\n\nvoid Spline::Guild[) {\nfloat u, w_2, u_3;\nint 4, 4, &:\nint index;\n\nindex = 0;\nfi For each control Point (Minus the last three)\nFor {i = 0; a < controltnt = a: ite) 4\n\n/i Far each subdivision\nTor] = 0; j = curvesubD; j++) {\nuo = (float)] / curvedubb:\nweer\" uo:\na= wz\" u:\nfor(k = 0; kK <3; kee} {\nJi Position\ncurvebata[ index].pos[k} =\n{\n(-1*u_3 * G*u 2 = 3*y + 1)\ncontralDatali ].pos[k]\n{ 3°03 - Gu 2 + O*y + 4)\ncontrallatalito] .pos[k]\n(-3*u_3 # 37u 2 + 3*u + 1]\ncontrolpatali+1].pos[k]\n{ 13 * Ofu 2 4+ 0% + 0)\ncontrolData[i+2] .pos[k]\n} / BOF;\n\nchk t+ te fe\n\nindex ++;\n\n43 Camera Control Techniques 375\n\nWote thar che paramerer # is squared and cubed; hence, we have a codic splinc.\nAlso note thar the last three control pointes are nor weed, since this algorithm utilizes\nfour continuous control poincs ara cime. | leave dhese extra components in my algo-\nnthm so chat] can preserve the continuity of che curves. For ceample, the following\ncontrol points will create a very close approximation of a cirele.\n\nCG: 46.000000 2.00RRO 46.000000 // Not drawn\n\n2\nC: 48.000000 2.0000 -46.000000\nC: -48.000000 2.000000 -48.000000\nC: -48.000000 2.000000 46.000000\nC: 48.000000 2.000000 46.0eh000\nC: 48.000000 2.000000 -48.0KM00 // Mot drawn\nCz -d8. 000000 2.000000 -48.000000 // Mot drawn\n\nUnilizing B-Splincs for our purpose requires a little work. The curve provides che\nposition of the camera, but we also need a target and an up vector. For multiple\ncurves, cach control point should be associated with a target position. Hence, the\ncamera will continue to focus on the target as it moves along the curve. Once it\neRCOLNEers a new Larger position, the camera control logic can simply interpolate\nberveen che points to get the desired effect. A more complex but flexible solution\nwould be ta use ewo B-Spline curves, one for camera position and the other for target\nposition.\n\nTricks\n\nGiven a set of control points, the game engine can either compuce the entire curve\nduring one frame, or calculate only the needed portions of the curve. This reduces the\namount of computations per frame, and also reduces the amount of memory needed\nto store curve data. B-Splines only require four control points for any subsection of a\ncurve, So, by continuously cycling in a new control point, whether it is a random\npoint ora carefully calculated one, a smooth curve of infinite length can be created.\nThe demo software for this article demonstrates such a solurion.\n\nAlthough the curve is guaranteed to be continuous, the distance berween subdivi-\nsions is mot. Hence, moving the camera across the curve incrementally is noc a suffi-\ncent solution. The camera would visibly change velocicy between conerol points, and\nit would be subject to changing frame races. The best method for moving the curve\nacross the screen is co use distance and speed calculations. For accurate distance calew-\nlation, you need co calculate the distance between cach subdivision at dhe curve level.\nThis method requires a lot of calculation, bur it is worth ic. Use chis function to cal-\nculate an appropriate index for a piven distance:\n\nint Spline::GetindeaxAtDistance(tloat distance) {\nint imdex = 0;\n\n1f (agLstenca «< 0.0) raturn -71;\nff Forward Push\nwhile (indax < curvetnt 4&\n\na76\n\nSection4 Polygonal Techniques\n\ndistance > curveDatalindex].distance}\n\n{\nindex++>\n\nif (index >= curvetnt) return -1;\nreturn index:\n}\n\nAnother useful trick for using B-Splincs is to utilize the tangents of the curve to\nforce the orientation of the camera to the curve. This would be particularly useful if\nyou wanted to implement a roller coaster. A close approximation can be calculated by\nswberacting each curve point from the one preceding it. However, a more accuraic\nsolution is to calculate the derivative of the B-Spline basis function. This derivative is\ngiven in Equation 2. These calculations are performed in the sample code.\n\n(ie © Spake sy\n,_|0 3 -4 of1\ney lo 3 2 41 4|2\nO10 0\n\nEQUATION 4.3.2. First derivative of the B-Spline basis.\n\nOne pitfall | should mention is normal calculations, Finding a normal co a curve\nisa simple problem. One solution is to take che tangent of the current concrol peint\nand cross it with the tangent of the next concrol point. Finding the appropriate nor-\nmal, on the other hand, is a difficule problem. There are an infinite number of pare\nmals at any given point of a curve, and the problem is to find the one thar produces\nthe result you wane. I found thar using the narural normal, by crossing tangents, usu-\nally gave me the resule I wanted. However, since | was using the cross product, che\ntight-hand rule would occasionally flip my normal when the curve switched diree-\ntions. | compensated for this by checking the doc product of the current normal and\nthe previous one to sce if the difference was -180°, Ifso, I would set a flag to flip the\nnormals back. In some instances, I simply provided the normal that I wanted with the\ncontrol point, and interpolated to the next natural (or specified) normal as | subdi-\nvided the curve.\n\nCatmnull-Rem\n\nSince I'm on the topic of B-Splines, I should mention a variation of curve gcnicration\nfunctions called Carmull-Rom curves. The biggest difference between these ewo\ncurves is thar Catmull-Rom curves go through the control points, whereas B-Splines\ndo not. However, I must warn you that the “curviness” of this variation is not as pleas-\ning to the eye as B-Splines. Nonetheless, you may find it useful or necessary to have\nthe curve pass through the control points. The basis functions are listed in Equation\n4.4.3.\n\n4.3 Camera Control Techniques STT\n\n-—| fF =] O\nCarmull — Rem = Sell, =|\n—3 4 Ll OF2\n1 —l .0..0\n—i -] 4 -1]\n\nCarrill — Form’ = EAR SE Bra eel st\n— 3 & 1 }2\n\nSoe he\nEQUATION 4.4.3. The Carmuull-Riom basis functions.\n\nCamera Tricks\n\nZoom\n\nSay you want co have a high-powered sniper rifle with a long range scope in your\ngame, and you want the player to be able to look around through the seope. One\nquick and dirty method for accomplishing this in OpenGL is wo use the FOV para-\nmeter of che gluPerspective() function. This snippet of code will cause the camera\nto zoom in and out with the cosine function:\n\nQlvatrinvode (GL_PARIECTION):\nglLoadidentity();\n\n@luPerspective(cos(teapAng += 0.03F)\"10 4 34,\nB40.0F /480.0F, 1.0, 2000.0);\nglMatrinMode (GL_MOOELVIEN) ;\n\nDamping\n\nDamping is the key to making camera controls look and feel right. The following\nfunction will return a vector that approaches the target vector such that as it reaches\nthe target, it begins to slow down. However, there is 2 major problem with this solu-\ntion: It is frame rate dependent. As che frame-rare increases, the damping effect\ndecreases.\n\nVectors dampTypel(vectors currx, vectors targeex) {\nreturn currex + ( (targets - currk) | i6.0F);\n}\n\nUsing physics is one possible solution for damping. Applying accelerations and\nfriction to the camera's position will produce the desired result, and physics equations\nare frame-rate independent. But, physics is more appropriate for an interactive solu-\n\na78 Section 4 Polygonal Techniques\n\ntion. They don't easily offer a current and target position interface, which would be\nmore useful in situations where the camera is scripted or affected by fixed animations.\nSprings are the perfect solurion.\n\nFa ma= hx — bop\nEQUATION 4.3.4, The spring equation.\n\nLet's break the spring cquation up into usable pieces and ger a function, First, ler's\nassume that our mass is 1. a represents the displacement from the nesting (target) scare\nof the spring to the current position, The nwo constants & and é, represent Hooke’:\nspring constant and the damping constant, respectively. p is the velocity of the target\nposition. The function char implements this damping is shown here. Whar a perfecs\n\nopportunity for C++!\nweetera Springdenp(\nVectors currPos, Ji Current Position\nWECtOrS trgPes, fi Target Position\n\nWectord previrgPos, // Previous Target Position\nfleat deltaTine, i? Change in Tine\nfloat springtenst, // Hooke's Constant\n\nfloat dampCenst, ff Dap Canstant\nfloat epringlen} i\n\nvectors disp; ff Displacement\nvectors velocity; if Velocity\nfisat forceWag; if Foreé Magnitude\n\nff Galeulate Spring Force\ngisp = currPas - trgPas:\nvelocity = (prevTrgPos - trgPos) * eltaTime:\nforcellag = springtenst * (apringlen - disp. lengthi)) +\ndampConst * (DotProduct(disp, velocity) |\ndisp. Llenmgenh());\n\nff Apply Spring Force\n\ndisp normalize | |;\n\ndisp *= forceMag * deltaTime;\nreturn currPas += disp:\n\n}\n\nThird-Person Camera\n\nOn the topic of cameras, | also need to mention the valuable third-person camera, As\nan example, I have added a spring-based third-person camera model co my sample\ncode. The actor im the scene is regulated by a spline. This is only to mimic random\norentations that an actor could possibly undertake. In an interactive game, the orien-\ntation of the actual actor can be controlled by game logic, canned animations, or even\nthe first-person camera model described earlier. Regardless, the camera tracks a pasi-\nHon that is a given distance behind the actor I use the spring damping function to\ngive the camera a realistic feel,",
      "page_number": 363,
      "chapter_number": 38,
      "summary": "This chapter covers segment 38 (pages 363-370). Key topics include curves, camera, and control. Given a camera position, view direction, and up veetor, this function\nTetuIns an ofentation view martrix.",
      "keywords": [
        "Techniques Dante Treglia",
        "Camera Control Techniques",
        "Control Techniques Dante",
        "Camera",
        "Camera Control",
        "Dante Treglia",
        "Control",
        "control points",
        "camera position",
        "curve",
        "position",
        "Control Techniques",
        "target position",
        "Camera Seripted cameras",
        "camera model"
      ],
      "concepts": [
        "curves",
        "camera",
        "control",
        "controllers",
        "function",
        "functions",
        "vectors",
        "techniques",
        "float",
        "point"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 46,
          "title": "Segment 46 (pages 443-452)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 27,
          "title": "Segment 27 (pages 526-548)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 7,
          "title": "Segment 7 (pages 57-65)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 11,
          "title": "Segment 11 (pages 100-107)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "Segment 63 (pages 609-616)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 39,
      "title": "Segment 39 (pages 371-380)",
      "start_page": 371,
      "end_page": 380,
      "detection_method": "topic_boundary",
      "content": "43 Camera Contral Techniques a70\n\nQuatemlons\n\nAsa final note, quaternions have become an integral part of game programming, and\nplay an important role in camera orientation techniques. There are many benefits ro\nusing quaternions to internally represent orientations. The three-parameter represen-\ntation of Euler angles requires crigonometry and nine-parameter orthogonal matrices.\nQuaternions, on the other hand, only require four parameters and are less computa-\ntionally expensive.\n\nWhen it comes to view interpolation, the Fuler angle implementation is inher-\nently buggy. Say you wish to rotate the object 90° in the F-axis (yaw = m2). Because\neach rozation is computed separately, this operation rotates the X-axis onto the nega-\ntive “axis. Hence, the result of a rotation in the X-axis by an angle @ is the same as\nrotating -8 in the #-axis. In other words, the camera will roll when you apply a change\nin the yaw. This parametric singularity is called gimbal ck. Because of this lock,\ninterpolating through these singularities produces strange and most likely unwanced\nresults. Quaremions, on the other hand, do nor have this problem, and can be inter-\npolated quite easily. By representing camera orientation with quaternions, we can per-\nform smooth interpolations between two viewpoints.\n\nMore sophisticated implementations of orientation controls such as those found\nin commercial flighe simulators apply angular velocities via quaternions. However, for\nour purposes, it is sufficient and more ineuitive to increment rotation around an angle\nusing the Euler angles, than to directly recalculare a quaternion. Hence, it is useful co\nhave a function that produces a quaternion given the three Euler angles.\n\nquatertiion Aquaternion: :Seteuler(float yaw, float pitch,\nfloat relly {\nTloat cos = cost(yaw / 2.0F}:\nfloat sin’ = sinf(yaw / 2.0F):\nT1loat cosP = Gesf (pitch | 2.0F}:\nTioat sinF = sinf(pitch | 2.0F):\nfloat cosh = cosf(roll / 2.0F);\nFloat sink = sinf({roll | 2.0F):\nsetValues[\ncosh * sinF * qosY + eink * eosP * sin,\ncosh * cosP * sinY - gin * sinP * cosy,\nSank * cosF * cogY - cosh * sinP * sin,\ncosh * cosP * cosY # sinh * sinP * sin¥\n\nF\nF\n\nNe\nreturn \"this;\n\nA Fast Cylinder-Frustum\nIntersection Test\n\nEric Lengyel!l\n\nBefore attempting to render a complex object, many games first determine whether a\ngeometrically simple volume bounding that object is visible. Due co cheir computa=\ntonal efficiency, spheres and boxes are commonly used as bounding volumes, bur it i\nsometimes the case thar objects are naturally suited to be bounded by a cylinder,\nAlthough we will mot be able to achieve the speed at which a sphere or box could be\ntested, this article presents a quick algorithm for determining whether an arbitrary\ncylinder potentially intersects the view frustum (and thus whether the objece is visible),\n\n‘The efficiency of the algorithm relies on the fact that we can reduce the problem\nto that of determining whether a line segment innersects a properly neodified view\nfrustum. Given a cylinder described by a radius and two point in space representing\nthe centers of the end faces, we individually move each of che six planes af the view\nfrustum outward by the cylinder's effective radius with respect to that plane. The effec-\ntive radius depends on the cylinder'’s orientation, and ranges from zero (when the\ncylinder is perpendicular to the plane) to the actual radius (when the cylinder is par-\nallel to che plane).\n\nThe cylinder test has advantages over the sphere and box tests when an object's\nbounding cylinder has a large height-to-radius ratio. Such a case arises, for instance,\nwhen rendering shadow volumes for infinire light sources, since a shadow volume\ntypically needs to be long relative to the size of the object casting it. A shadow volume\nas completely contained inside the extrusion of the object's bounding sphere along the\nlight direction, making it a natural candidate for a cylindrical bounding volume.\nUsing a bounding sphere for such a volume would contain a grear deal of empty\nspace, Ciusing a sphere visibiliry test eo return positive in many cases when the volume\nis not really visible. Although a bounding box would generally contain an acceptably\nsmall amount of empry space, box visibility tests are not well suited for boxes having\none dimension that is much larger than the other two. This is due to the face that box\ntests only detect that a box is invisible by determining that the bax lies completely on\nthe negative side of any one of the six planes bounding the view frustum. A lang rec-\ntangular bounding box could easily straddle one of the view frustum planes far out-\nside the view frustum, but the box tests would rerurn positive.\n\n44 A Fast Cylinder-Frustum Intersection Test 381\n\nThe View Frustum\n\nQur view frastum shall be completely described by four quantities. The first is the\nfocal length 4 which determines the field of view. Fora desired horizoncal field of view\nangle @, the focal length is given by the formula:\n\nwe ala .\nran(@ / 2)\n\nThe second quantity is the aspect ratio 2, which is simply the viewport's height\ndivided by its width. At a distance / from the camera, a plane perpendicular to the\ncameras viewing direction carves a rectangle out of the view fruscum whose left and\nright edges reside at x = 21, and whose top and bottom edges reside at y = +2.\n\nThe remaining ovo quantities thar describe our view frustum are the minimum\nand maximum depths that define the near plane distance » and the far plane distance\nJ Aca distance # from the camera, the viewport rectangle is bounded by x = 2n//and\ny= tral These values are passed to the OpenGL function g1Frustum.\n\nUsing the values of f and a, the inward-pointing unitlength normals of the six\nfrustum planes are given, in eye space coordinates, by the following formulas:\n\n(44.1)\n\nTable 44,1. View Fruatum Plane Normals\n\nPlane Normal\nNear (0, 0,-1)\nFar (0,0, 1)\n\ni 1\nBagh — 0-74]\n| Je +1 wi 41\nTap [o.- z= nant = |\nPage {f° +a\"\n\nRie Pada Vi + a?\n\n382 Section 4 Polygonal Techniques\n\nThe cylinder intersection test will take place in eye space so that we can ake\nadvantage of the symmetry of these normals, as well as the murmerous zeros that appear\nin the table.\n\nCalculating Effective Radi\n\nLet us call the two endpoints of the cylinder's axis P, and P., and the cylinder's radius\nr (see Figure 4.4.1). Now we select one of the six view frustum planes, label irs normal\nN, and call the angle between the normal and the cylinders axis of. The effective\nradius r’of the cylinder with respect to this plane is given by the simple formula\n\nr= 7rsin (4.4.2)\n\nThe most immediate method for determining the value of sin of would be to cal-\nculate the magnitude of a cross product, bur we can calculate the same value using sip-\nnificantly fewer operations through a bit of rigonometric manipulation. Recall che\n\nidentity:\n\nsin? + cos? = 1. (4.4.4)\n‘This gives us the alternative form for Equation 4.4.2:\n\nr= ryl — cos’ a, (4.4.4)\nThe value of cos ais given by\n\nRB -PI-N\ncos of = (\":-®) (4.4.5)\n2B\n\nThe normalized vector representing the axis of the cylinder only needs to be caleu-\nlated once. For cach view frustum plane, Equation 4.4.5 can then be evaluated through\nasimple dot product with a normal having at most owo non-zero components.\n\nIt is not absolutely necessary ro calculate the effective radii, simee the actual radius\ncould be used in its place, saving up to five possible square root calculations. Using\nthe actual radius may be desirable in the case when many cylinder visibility tests are co\nbe performed, and the square root operation is slow on the target machine. The dis-\nadvantage of using the actual radius is that it increases the number of visible cylinders,\nperhaps significantly if the actual radius is large. If speed is am issue, the decision co\nuse effective radii or the actual radius should be determined chrough experimentation.\n\nThe Algorithm\nes\n\nThe intersection test executes by visiting each of the six view fruscum planes individ-\nwally, We consider the near and far planes first since they are parallel and chus produce\n\n44 A Fast Cylinder-Frustum Intersection Test amd\naad\n\nFIGURE 4.4.1. Calculating an effective taclins.\n\nthe same effective radii. Quee we have discovered char at least part of the cylinder lies\nbetween these planes, we proceed to the four side planes. For each plane, we first cal-\nculare the effective radius r'of the cylinder and move the plane outward by char dis-\ntance, at illustrated in Figure 4.4.2. This has the effect of reducing the cylinder to a\nline segenent, but it carries the slight cost of including a few more cylinders in aur vis-\nible set that do not actually intersect the view frustum.\n\nAfter adjusting a plane, we next test the ewo endpoints P, and P, to determine on\nwhich side of the plane they lie. This is done by plugging each endpoint’s coordinates\ninto the plane equarion\n\nF-N-d=( (4.4.6)\n\nwhere d=” —r'for the near plane, d = —f— 7\" for the far plane, and d= <r'for any of\nthe four side planes. The sign of the left side of Equation 4.4.6 indicates on which\nside of the plane the point F lies. Since the plane's normal points toward the interior\nof the view frustum, any point lying on the negative side of the plane lies outside the\nview frustum. Thus, if both P, and P, lie on the negative side of the plane, then we\nimmediately kaow that the cylinder is not visible, and the algorithm exits, Any point\ninterior to the view frustum must lie on the positive side of all six planes, so whenever\nboth P; and P, lic on the positive side of a single plane, we cannot draw any conclu-\nsions and just continue to the next plane.\n\nSection4 Polygonal Techniques\n\nFIGURE 4.4.2. The shaded region represents the volume added to the view frustum after\neach plane has been expanded by che associared effective radius.\n\nIn the remaining case thar one endpoint lies on the positive side and the other lies\non the negative side, we calculate the point where the line segmene intersects the\nplane and replace the exterior endpoint with it. This effectively chops off the part of\nthe cylinder thar we know to lie outside the view frustum. To find the point of inter-\nsection, we use the parametric equation for a line\n\nP-P,+x#P,—- P)) (4.4.7)\n\nwhere 05 ¢S 1. Substiuucing the right side of this equation for P in Equation 4.4.6\ndlows ws to solve for che value of rae the point of intersection:\n\nd-B-N\n\njp -P)-N (4.4.8)\n\nPlugging this back into Equation 4.4.7 gives us our new endpoint. After replac-\ning the exterior endpoint with it, we continue to the next plane.\n\nIf we visit all six planes of the view frustum and never encounter the case that\nboth endpoinrs lie on the negative side of a plane, then the cylinder is ar least partially\nvisible. Of course, this means that we do not have to replace any endpoints for the last\nplane that we visit. As soon as we know thar at least one of the endpoints lies on the\n\npositive side of the final plane, we know thar part of the cylinder intersects the view\nfrustum.\n\n44 A Fast Cylinder-Frustum Intersection Test 365\n\nimplementation\n\nThe sample code in Listing 4.4.1 implements the cylinder visibility test. The Frustun\nclass encapsulates the view frustum and is constructed by specifying the focal length,\naspect ratio, near plane distance, and far plane distance, The components of the nor-\nmals listed in Table 4.4.1 are precalculated inside che constructor, The member fune-\ntion CylinderVisible determines whether a cylinder specified by two points and a\nradius intersects the view frustum and returns true or false.\n\nListing 4.4.4\n\n#include “mtxlib.h\"\n\n6lass Frustum\n\n{\n\nPrivate:\n\nff Near and far plane distances\nfloat nearbistance;\nfloat farbistance:\n\nff Preceléulated normal components\nfloat leftRights;\nfloat Jefthightz:\nfloat topBattony;\nfloat tophottenz:\n\npublic:\n\nf/f Constructor defines the frustun\nFrustun(float 1, float a, float nm, float fj;\n\nff Intersection test returns trué or false\nbool CylinderVisible{vector3 pi, woctors pz,\nTlost radius) comet:\n\ni\n\nFrustum::Frustua(tloat 1, float a, float n, float f)\n{\nif Save off naar plane and far plane distances\nnearbistanee = nm:\nTarDistance = f;\n\ni! Précaleulate side plane normal components\nTloat d= 1.0F # sqrtqi * 1 4 4_0F);\nLeftAightx = 1 * d:\n\nLeftAight2 = d:\n\nd= 1.0F / sqrtt(l * 1+ a8 * a};\ntopfottomY = Ll * @\ntopBottemz = a * d\n\nSection 4 Polygonal Techniques\n\nbool Frustum; iCylindervisible(vectora pl, vectord p2, float radius) const\n\nf\n\nff Calculate unit vector representing cylinder's axis\nvector’ dp = pe - pi;\nop.normalize();\n\nif Visit near plane Tirat, NH = (0,0,-1}\nfloat dat) = -pl.z}\nfloat dot2 = -p2.z;\n\nif Galculate affective radius for near and far planes\nfloat effectiveRadius = radius * sqrt(1.0F - dp.2z * dp.z);\n\nif Test endpoints against adjusted near plane\nTloat d = nearbistance - effectivenadius:\nbool interior! = (doti >= dj;\n\nbool interiora = (dots > dj;\n\naf {linteriord)\n\n{\nff If neither andpoint is interior,\ni! cylinder is mot visible\nif (linterior2) return (false):\n\nii 1 Was outside, 50 move it to the mear plane\nfloat t = (d + pi.z}) / dp.z;\n\npi.x -= t * dp.x;\n\npi.y -= t * dp.y;\n\nPI-2 = =]\n\nelse if (linterior2)\n\n{\nff $2 was gutside, so move it to the near plang\nTloat t = {di + pi.z) f dp.zz\npe.x = pi.x = t+ = dpix:\np2.y ~ pl.y - t * dp.y;\np2.2 = od;\n}\n\ni! Test endpoints against adjusted far plane\nd= farfistance + effectiveRadius;\n\ninterior? = (doti < oj};\n\ninterior2 = (dot? < a):\n\nif (linterior1)\n\n{\nff Of neither andpoint 18 interior,\nff cylinder is not visible\naif (linterdor2) return (falze);\n\nii pl was outside, so move it to the far plane\nfloat t = (d + pi.z) J (pa.z = pi.z);\n\npl-x == tf * (p2.e - pi.x);\n\npl.y -= t * (p2.y - ply);\n\npl.z = -d;\n\n44° A Fast Cylinder-Frustum Intersection Test\n\n}\nelse if (linteriera)\n{\nff p2 was outside, so move it to the far plane\nfloat t = (d + pi-z) / (p2.z - pi.z);\np2- = pi.m - t * (pl.a - pi.xys\nPe.Ww = play - t* (p2.y = pl.yh;\npz.z = -d;\n}\n\ni] Misit Left side plane next\n\nff The pornal components hava been preaalculated\nfloat n= = lefthightx;\n\nfloat nz = leftRightZ;\n\nfy Compute pl * No and pe * w\ndott = ne * pl. = nz * piizs\ndot2 = 9k * Pe.k = nz * pez:\n\nff Galculate effective radius for this plane\nfloat 6 = nx * dp.m - nz * dpvz:\neifectivenadius = «radius * sqrt(1.0F - § * sj;\n\ni! Test endpoints against adjusted plane\ninteriari = (dati = effectiveRadius);\ninterisre = (date = effectivenadius);\n\nif (Jinteriort)\n\n{\nfi Tf neither andpolnt is interior,\nif cylinder is not visible\nif (!interior2) return (false);\nff fl was owtside, sa move it to the plane\nFloat t = (attectivenadius - dott) ¢ [(dot® - dott);\nPl.w += t ™ (pe.u - pi-x);\nPl.y += t \" (pe.y - ply);\npl.2 += t \" (pe.z - plz);\n}\n\nelse if (lintariore)\ni\nif Pe was outside, so move it to the plane\nfloat t = (effectiveRadius - doti) | (det? - dott);\npe-x = pi.w * t * (pe.a - pix):\nPe-y = pi.y tf * (peey - pt.y)}\npe-= > pi.z + € * (plz = pi.z:\n}\n\nff Wisit right sida plane next\ndati = -nx * pi.x - mz * pliz:\ndat] = -nx * pe.x - nz * pez:\n\n5 = «na * dp.x - nz * dp.z;\notfectivenadius = -radius * sqrt(1.0F - ¢ ™ s};\n\nSection4 Polygonal Techniques\n\ninterior] = (detl > effectiveRadius):\ninterior? = (dota > effectiveRadius):\n\nif (linterior)\n\n{\nif (linterior2)}) return (false);\nTicat t= (effectiveRadius - doti) f# (dot? - deti);\npi.w t= t * (pox + pi.x):\nPi.y + £ * (pe.y + pl-y}i\nfl.2 += £ * (pe.z = pl.z)i\n}\nelse if (linteriore)\n{\nfleat + = (effectiveRadiue - doti) # (det? - doti);\np2.% = pix + t * (pZ.m - pl.x};\np2.y = pl-y + t * (pz.y - pi.yt;\np2.z = pl.t + t * (pe.z - pl.zy}:\n}\n\nif Visit top side plane next\n\nff The nomial components have been pracalculated\nfloat ny = topBottom;\n\nnz = tepbotton?;\n\nmoti = -ny * pi.y - az * pi.z:\ngot2 = -iy * pe@.y = oz * pe.z:\n\nSo -fy * dp.y - nz * op.z\neffectivenadius = -radiue * aqrt(i.dF - 5 * 5);\n\ninteriort = (dot? > effectivernadiue):\ninteriar2 = [(dot2 > eftectiveRadius);\n\naf [linteriori}\n\n{\nif (linterior2) return (false);\n\nfloat t = (ettectivenadius - deti) / (dete - dott};\nPi-x += { \" (pe.m - pi.x};\nPi-y += £ * (p2.y - pi.y};\npl.z += t * (po.z - pi.z):\n\nelse if (linterior?)\n\n{\nfinat t= (ettectiveRadius - dotij f (dotz - dott);\nPe-x = pl.x + t * (p2.x - pix};\nPe-Y = ply +t * (p2.y - pl.yh;\npe-2 = plz +t * (pR.z - pl ep\n}\n\nif Finally, visit bottom side plane\ndot) = ny * pi.y - mz * pl.z;\ncote = my * pay - ne * Azz;",
      "page_number": 371,
      "chapter_number": 39,
      "summary": "This chapter covers segment 39 (pages 371-380). Key topics include float, planes. Say you wish to rotate the object 90° in the F-axis (yaw = m2).",
      "keywords": [
        "view frustum",
        "plane",
        "Quatemlons Asa final",
        "Quatemlons Asa",
        "view frustum planes",
        "float",
        "view",
        "cylinder",
        "frustum",
        "plane float",
        "Intersection Test",
        "Camera Contral Techniques",
        "side plane",
        "frustum planes",
        "radius"
      ],
      "concepts": [
        "float",
        "planes",
        "dot",
        "dots",
        "view",
        "radius",
        "cylinder",
        "frustum",
        "tested",
        "returns"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 22,
          "title": "Segment 22 (pages 207-219)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 10,
          "title": "Segment 10 (pages 182-202)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "makinggames",
          "chapter": 19,
          "title": "Segment 19 (pages 161-168)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 12,
          "title": "Segment 12 (pages 108-115)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 6,
          "title": "Segment 6 (pages 103-120)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 40,
      "title": "Segment 40 (pages 381-388)",
      "start_page": 381,
      "end_page": 388,
      "detection_method": "topic_boundary",
      "content": "44 A Fast Gylinder-Frustum Intersection Test 386\n\n$= ony * dp.y - me * dp.z;\neffectiveRadius = -radiys * agrt(i.OF - 5 = 3);\n\ninterior! = (doti > effectivenadius);\ninterdor2 = (dot® > effectivenadius);\n\nff At least one endpoint must be interior\nff oor cylinder is net visible\nreturn (interiert | intarior2}:\n\n4.5\n\n3D Collision Detection\n\nKevin Kaiser\n\nA real-time physics engine is central to creating a 31D gaming environmenc where the\nplayer can easily suspend their dishelief; instead of just realistic pictures, the physics\nengine provides realistic interactions between objects in the pictures. These ineerac-\ntions provide the player with a basis for reality; in other words, the player can beter\nunderstand and navigare in a world where things act as they do in real life. The firse,\nand arguably most important step in setting up a real-time physics simulation is har-\ning accurare collision detection; ance collisions are detected, the simulation can react\naccordingly. This article will help lay the groundwork for building an accurate physics\nsimularion by starting with one of the most crucial parts of a real-time physics engine:\n3D collision detection.\n\nOverview of the Algorithms\n\nThe two basic collision algorithms this artick covers are:\n\n* Bounding Sphere Collision Detection—For the sake of clean code and an easy-\nto-understand explanation, we'll be using bounding spheres. The bulk of chis\ncode checks the radius of a bounding sphere against the radius of another bound-\ning sphere co determine possible collisions.\n\n* Triangle-to-Triangle Collision Detection—It might be wise ro brush up on\nyour calculus before amemping to understand this algorithm; it uses parametric\nequations to determine collision points between one criangle and che plane of the\nother mangle, then determines whether those collision points lic inside che oppo-\nsite triangle.\n\nBounding Sphere Collision Detection\nCollision detection is best performed in hierarchical steps: Object Bounding Sphere\n\nto Object Bounding Sphere, Polygon Bounding Sphere to Polygon Bounding Sphere,\nthen Triangle to Triangle. We will begin by generating bounding spheres. Calculating\n\n4.5 3D Collision Detection 361\n\nbouncing spheres is very simple; all you need is to find che center of the object, chen\ncompute the maximum distance between the center and a vertex in the object. By\nstoring the radius of each bounding sphere, you can perform bounding sphere colli-\nsion detection by adding the radii of the nwo objects, then taking the distance\nbetween the two center vertices. If the distance is greater than the sum of the radii, che\nspheres are certainly not colliding.\n\nLer's go through this step by step. First, you'll need to determine the center point\nof the mesh. One way to do this is to create a bounding box and find the midpoine\nbetween diagonally opposite vertices (see Figure 4.5.1), To compute the bounding\nbox. you need to find the minimum and maximum x, y, and z values for the entire\nobject, This can be accomplished by iterating through the vertices and maintaining a\n“current” minimum and maximum. After checking all vertices, you'll have the maxi-\nmum extents of the bounding box, The minimum and maximum values will be wsed\nto create the bor,\n\nGiven a bounding box with eight maximal paints (ABCDEPGH, see Figure\n4.5.2}, let's call the vertex assignments:\n\n(minx, miny, minz)\n(minx, Maxy, mainz)\n(Maxx, RAY, mainz}\n(Maxx, miny, minz)\n(minx, miny, maxz)}\n(Minx, RAxy, maxz)\n(ize, Haxy, maxz)\n(iixx, miny, maxz)\n\nTaAaAmMooagds\n\nhobo wt\n\nNow find the center point, given by averaging the minimum and maximum\npoints on the bounding box (these are indicated by paints A and G}.\n\nFIGURE 4.5.1 Finclinge the midpoine.\n\nSection 4 Polygonal Techniques\n\nFIGURE 4.5.2 (Creating a bounding box.\n\nI? Widpeint formula; Given A{xi,yi,21) and B(x2,y2,22),\n\nif the midpoint of the line the passes through A and & is\nif [(xiteay/2, (yityeps2, [ztez2}/2]\n\nif\n\ncéenter.x = (A.x + G.xjs2\n\ncenter.y = (A.y + G.yp/e:\n\ncenter.z = (A.2 + G.zj/2y\n\nThe radius of the bounding sphere is easily computed by looping through the\nobject's vertices and finding the distance berween the center point and the cument\nwertex. If the distance is greater than the current maximum distance, replace the max-\nimum distance with the mew distance. After the loop, the maximum distance is the\nradius of the bounding sphere. (Of course, an casy optimization here is co only do the\nsquare root at the very end.)\n\nff Distance formula:\nff gist = soqrtl ((e2-xip°2)4((y2-y1)c2p+( (z2-z1)\"2) ]\nHi didatag = ( (2x1) 024 (Cy 2 yi Be ize-21 0-2)\nif\nforeach vertex v in object {\nEurrent_distante_sq = distsq(ebject.center, vj:\nif (current_distance aq > max_distance_ sq)\nmax_distance sq = current_distance sq;\n\nobject.os_radius = asqrt(max_ distance 44);\n\nThis will next be repeated on the polygonal level; bounding sphere checks are\nquick and simple, which is why when you have co check many polygons against cach\nother, it’s advantageous co begin with this test. After you have generated the necessary\nbounding boxes, bounding spheres, and center points for each object and polygon,\n\n45 3D Collizion Detection 303\n\nyou will be ready to get into the real meat of this article: riangle-to-triangle intersec-\ntion tests! Get out the calculus book—you might need ir.\n\nTriangle-to-Triangle Collision Detection\n\nThis method of triangle-ro-triangle collision detection relies directly on some easy-\nto-understand but slightly ticky mathematics. Imagine chat we are given two triangles\nin 31D space (see Figure 4.5.3). We'll need to collect a lor of information from the nwo\ntriangles. We need to begin by finding the plane equation of one of the triangles. IFyou\nremember correctly, the plane equation is.Av+By+Cz+D=0. We determine A, 8, Cand\nby taking cross products of vertices:\n\n‘if given a triangle trit with vertices a, b and ¢,\nff wectord a, b, ©;\nWeotors v1, v2, cross_vixve;\n\nff create vectors vi, v2 (tril.b = trii.a,\nif tril.c - trit,a)\nwio= trii.b — trit.a:\nva = tril.c — tril.a;\n\ni] HOTE: You may be able te skip this step and substitute your\nff OWN SUPTfete normals if you already have then stored somewhere,\nfi Take cross product of vi and w2 (this is the normal\n\nfi vector of the cross product of vi and w2)\n\nCross Wixv2 = GrossProduct(vi, v2}¢\n\nFIGURE 4.5.3. Two intersecting trianeles.\n\nSection 4 Polygonal Techniques\n\nif Then we plug these values back into Ax#By4Cz+b-0\ntril.pA = cross vixve.x«;\nTPLil.pa = eross vixve.y:\nTrill. pl = cross vixve.z:\n\nii Following this rule; Ax+By+Gz+0-0\n\nff if point P(xd,y0,20) is a point on the polygen\nif A = cross vinv2.x\n\nif B= 6ros4 yvinvily\n\nff, c= Gross vinvw2.z\n\nff O = (-A\"ed-B yo-Gez0)\n\nteil.pO = -DetProduct(cross vixw2, P);\n\nLine-Plane Intersection\n\nWe now have the plane equation of rriangle? and can move on to step two: sccing if\nsrianigle? collides with szangéel’s planc. This is done in multiple steps. The main idea\nis thar given owo vertices of miange2, we take the line defined by these vertices and\ndetermine at what point that line collides with sriangfeJ's plane. If the collision point\nis berween the two vertices, sriangle2 is colliding with rriangiel’s plane; if ix isn't\nbetween che two vertices, we iterate through the other two lines of sriaaghe2 te see if\nthere are collision points berween chose points.\n\nWe solve this line-plane intersection using parametric equations from caleulus\nGiven wo vertices, alxyG20) and bixlyplcd), we set alayO20i\"r -\nbic! yizly(1-2). cis an interpolation fetor that ranges from 0 ro 1. When =i) you\nare at point b, and when f=] you are at poine a. If we plug in paramenric equations for\neach component of the plane equation, we can then solve for r\n\nA(x + sD fI—) + Bt op ll) + C0 + cl Yl) 4 Da 0\nThis reduces down to:\n\np=—(A*el + BYyl + Cel + D)/(A(xO-x1) + BYyO-pl) + C'(e0-21))\nThe following code solves for 5\n\nff dO = (A*sD}) * (B*yO) + (o™z0)\nif = (tri1->pA*a->x) + (tril-+pe\"a->y) + (trii->plra->z);\n\nff 11 = (Atxi} * (Bt yt) + (6*z1)\n17 = (tril->pA‘b->x) + (trit-spa“b->y) + (trii->pt*b->z);\n\niY Be wary of possible divide-by-zeres here (i.e. if 20 == if}\nfinal_t = -(11 * trii->pO) / (id-11);\n\nff Then plug final_t back inte the functiona x(), yt} and zi)\nff to get the point of intersection from line to plane\nfinal_x = ({{a-*xj*(final_t)j+((b->x)*(1-Tinal_t1)});\n\nfinal_y = (((a->y)*(final_t))+((b->y)*(1-Tinal_t)));\n\nTinal_z = {{{h-*2)*(final_t}}+((b->z)*(1-final_t1}};\n\n4.5 3D Collision Detection 305\na eS He at\n\n‘This will give you the final point where the line intersects the plane (see Figure\n4.5.4). OF course, the t value we've computed must be berween zero and one or che\nIntersection ts not between our two vertices! A special case char you also need to look\nfor at this step ix the presence of vertical line segments. The quickest way to determine\nthe intersection point is to plug x and z of either point a or b inco the plane equation\nfor the triangle and solve for ». The intersection point would then be (a.x, solved.y,\n\na2).\n\nTriangle “Flattening™\n\nWe're going to assume a right-handed coordinate system now. Imagine flattening a\ntriangle against one of the coordinate planes, depending upon triangle orientation. It\nmight lose the y coordinate and keep the x and 2 coordinates. The concepr here\ndoesn't specifically call for losing the y coordinate; it just requires losing the appropri-\nate coordinate $0 that it will flatten. A good way co decide which coordinate to drop\nis by looking at the normal of the plane; if you determine which component's absoluce\nvalue is the greatest, you can then find a plane to flarcen against where the triangle will\nnot be a “straight line” (such as a vertical triangle losing the y coordinate). For exam-\nple, if the x component is greatest, you would project to the yz plane. Regardless of\norientation, the tangle produced by chis will be flat (as if it were lying flat on a table,\nsee Figure 4.5.5). This ts very advantageous because now we can use basic algebra to\ncheck and see if the final intersection point, when flattened in a similar manner, lies\ninside the flartened triangle. The code in Listing 4.5.1 effectively flamens the polygon\napainst one of the coordinate planes.\n\nFIGURE 4.5.4 Determining collision points.\n\nSection 4 Polygonal Techniques\n\npate =\n\n: Flattened Triangle :\n\nFIGURE 4.5.5 Verex projection.\n\nPoint-in-Triangle Test\n\nNow that we have flattened the coordinates, we need to do some algebra co determine\nwhether the flattened intersection point lies inside the flawened rriangle or not. There\nare several popular ways of doing this; we're going to make use che equation for each\nline of the flattened criangle. Take noge that regardless of which plane you project to,\nin this discussion we will seill refer wo the x and y coordinates of the flattened points.\nThis is because by projecting the vertices, we have effectively reduced the problem to\n2D; hence, the + and y. First, we need to find a point that is definitely inside the trian-\ngle. The easiest point to find char fits this description is the center of the triangle,\ncomputed as the average of irs vertices: ((xexl+x2)/2, (y0+-yI+72)/2)), Now thar we\nknow what direction the inside of the triangle is, we need to see if our point is on the\n“inside” side of the lines thar are made by each pair of vertices (see Figure 4.5.6).\n(siven two vertices, WO and v1, first find the equation of the line that goes through\nthem in the form y=nx+4. Remember thar the formula for slape (1) is (yf (lt),\nand you can find # by using the computed slope and 3 known point on the line. Now\nthat we have the equatian of the line in slope-intercep: form, we can determine\nwhether che factened intersection point lies on the side of the line that is the inside of\nthe triangle. We do this by comparing y values. If you plug the x coordinate of che flar-\ntened intersection poin into the line yen, you will ger che y value of the line ar x.\nNext, you determine whether the center point we computed earlier is “above” or\n“below\" the line by checking y values. We know thar ir is inside the triangle, 50 our\nintersection point has to have a» value that is in che same “direction” from the line as\nthe center point. If it docs, the intersection point is “inside” the triangle with respect to\nthe line ab. Repeat this for lines be and ca. If the point is on the inside after each vest,\nthe point is certainly inside the triangle. There is a special case to take into considera-",
      "page_number": 381,
      "chapter_number": 40,
      "summary": "Overview of the Algorithms\n\nThe two basic collision algorithms this artick covers are:\n\n* Bounding Sphere Collision Detection—For the sake of clean code and an easy-\nto-understand explanation, we'll be using bounding spheres Key topics include triangle, points, and line.",
      "keywords": [
        "Collision Detection",
        "Sphere Collision Detection",
        "Bounding Sphere",
        "Bounding Sphere Collision",
        "Object Bounding Sphere",
        "Collision Detection Kevin",
        "Bounding",
        "Polygon Bounding Sphere",
        "Detection Kevin Kaiser",
        "point",
        "Fast Gylinder-Frustum Intersection",
        "Collision",
        "collision points",
        "intersection point",
        "Detection"
      ],
      "concepts": [
        "triangle",
        "points",
        "line",
        "intersection",
        "intersecting",
        "collision",
        "collisions",
        "bounding",
        "planes",
        "vertices"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 32,
          "title": "Segment 32 (pages 632-651)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 19,
          "title": "Segment 19 (pages 173-181)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 24,
          "title": "Segment 24 (pages 222-231)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 55,
          "title": "Segment 55 (pages 529-536)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 32,
          "title": "Segment 32 (pages 306-318)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 41,
      "title": "Segment 41 (pages 389-403)",
      "start_page": 389,
      "end_page": 403,
      "detection_method": "topic_boundary",
      "content": "4.5 3D Collision Detection 397\n\nOutside\n\nFIGURE 4.5.6 Determining the boundaries of a wiangle.\n\ntion: a projected vertical line segment. You cannot graph vertical lines using y=nexed. If\nthis is encountered, you instead check x coordinates instead of y coordinates; char is,\nfirst determine on which side of the vertical line the inside poine is, Then, check the x\nvalue of the projected intersection pointe. If it is on the “inside” side of the vertical line,\nitis inside with respect to thar line. See Listing 4.5.2 for this procedure.\n\nCheck All the Lines, in Both Triangles!\n\nOF course, if one line of our triangle does not intersect, we still need to check the\nother lines, One line/triangle collision is all thar is needed to show thar both criangles\nare colliding. See Lasting 4.5.3 for the rest of this sample ende,\n\nAfter all of this has finished, if no collision has occurred, you need to reverse the\n\nprocedure, starting with triangle? as the source. This ensures a perfect collision detec-\nton.\n\nListing 4.5.1\n\nif [xX=\"FALSE) { // dropping x coordinate\nal = tri->a.y7\nbl = tri-2a.z7\n\na2 > tri-2o.y;\nba = tri->b.z7\na4 = tri-sc.y:\nba = tri-2¢.z;\n\nad = wert->y;\nBa = wart->z:\ninside = Oo;\n}\nalse if (y==FALSE) 4 // drapping y coordinate\nAl = tfi->a.e:\nbl = tri->a.z7\nao = tfl->b.x:\nba tri-sb.7:\na3 = tri->c.%j\n\n298 Section 4 Polygonal Techniques\n\nba = tri->o.2;\na4 = vert->x;\nb4 = vert->2;\ninside = oO;\n\n}\n\nelse if (Z==FALSE) { // dropping z coordinate\nai = tri-Fa.e;\nbl = tri-za.y;\naf = tri->b.x:\nb? = tri->b.y:\nBe © tri-*c.x;\n\nbd = tri->s.y;\nad = Wart->K;\n\nbl = vart->y;\n\ninside © 0;\n\nListing 4.5.2\n——————$——————————\n\nHf TWGSe are used to check Tor vertical line segments in the\n\nff flattened triangle; you cannot graph vertical lines in 20\n\ni? using yenr+h, so we have to instead check if the flattened\nff intersection polnt lies batween the x coordinates af any\n\nHf vertical Line and the canter point of the triangle to see if\nff the flattened intersection point lias on the inside of the\nff triangle with respect ta the vertical Line segment,\n\nAR_vert = BG yoert = GA vert = FALSE:\n\nif yeme+h for outer 3 Lines\nif [{a2-aiji=oy q\nAi = (b2-bi)/(az-gi); ss a>\nboi = (bij«(mi*at}; if yi(ax) using vertex a\n} elae if ((a2-at}==9) ¢\nAB vert = TAUE;\n}\n\nAf [(@3-a2)i=0) {\n\nm2 = (bo-b2p/(ad-a2jp: ff b-ec\n\nbbe = (h2)-(mz*a2) ; if yim} using vertex b\n} @lse if ((ad-B2)=-o) (\n\nBC vert = TRUE:\n}\n\nif ({{at-aapl=0) {\n\n83 = (b1-bS) /(ai-agj; fy o-pa\n\nBS = (b3)-(ma*as); fi vitae) using vertex ¢\n} @1se if ((ail-asj==-0) [\n\nCA_vert = TRUE;\n\n}\nff find average point of triangle (point is guarantesd\ncenter_x = (altaztad)/4a; if ta lie ingide the triangle)\n\neenter_y = (bi+b2eba)/a:\n\n4.5 30D Collision Detection Hi ei lt]\n\nff See whether (center_x,center_y} is above or below the line,\nff then set direction to UP if the point is above or DOWH if the\nff point is below the Line\n\nff @->b\nit (((mi*center_x)jibbt) == center _y)\nDIRECTION(direction,UP);\nplse\nDIRECTION( direction, DOWN) :\nif (AB_vert==TRUE) {\nif ((a1<a4)éh(al<gonter_x)) // vert projected Line\ninside+:\nelse if ((ai>a4)4h(alscenter_x}} // vert projected line\ninside++;\n} else {\nif (direction=syF) i\naif (ba <- ((ml\"a4j+bhb1)) // b4 lesa than y to be inside\ningicde++: fi (Ling i6 above point)\n} else if (direction==poAWM) {\naf (ba >= ((m@i\"a4a)+bb1)) fy) b4 greater than y to be ineide\ningide++: ff (ling is below point)\n}\n\n}\n\nff bec\nif ((ime\"center_x)+bo2) += canter_y)\nDEREGTION (direction UP}:\nelse\nDIRECTION (direction , DOWN) ;\nif (BG_vart==TRUE) {\nif ¢ (az < a4phh{a2 =< centers) ) // vert projected line\ningida++;\nelse if [ (a2 > a4djBR(a? > cemter_x) ) ff! vert projected ling\ninside++;\n} else {\nif (direction==UF) {\nif (b4 <= ((a2*a4)eboe)) f/ Ba less than y to be inside\ninside++; ff (line a8 above point)\n} else if (direction--DOWN) {\naf (D4 == ((m2*a4)+bb2)) ff Ba greater than y to be insida\ninsiders; fi (ling is below point)\nHi\n}\n\nfi c->a\nif (((ma*center_x)4683) >= center_y)\nDIRECTION (direction ,UP};\nalse\nDIRECTION( direction , DOW) ;\nif (CA_vart==TRUE) {\naT { (a3 = adjeh(ad =< center_x) } fs vert projected line\ninsidet+:\nelse if ( (aa > a4jee(aa > center_x) } // vert projected Lina\ninsides:\n} else {\n\n400 Section 4 Polygonal Techniques\n\nif (direction==UP) {\nif (b4 <= ((m3*a4)4bb3)} // ba less than y to be inside\ningide++: ff (1in@ is above point}\n} #lse if (direction=-Dow) {\nif (ba == ((m3*a4)+bb3)) // b4 greater than y to be inside\ninsicde++: ff (Line 48 below point)\n\n}\nif (inside==3) {\nPéiturn TRUE;\n} @lse {\nraturn FALSE;\n}\n\nListing 4.5.3\n———\n\nff Sorell thru 3 line segments of the other triangle\n\nff First iteration (a,b)\n\np=Line_plane_collision((vertex_ptr)&tri2.a, (vertex_ptrjatriz.b,\n(triangle ptrjstrii};\n\nif Determine which axis to project to\ni] X is greatest\nif ((abs(trii.pAj>=abs(trit.p8) )S4(abs(trit.pAj>~abs(trit.pc)})\ntop = Point_inside_triangle((triangle_ptr)&tri1, (vertex _ptr)ép,\nTRUE, TRUE FALSE} ;\nfi ¥ ds greatest\nelse if ({abs(trit -PR)> abe (trait. pA) )ealabs (tris -RE)>=abs(trit.poj)}\ntemp = point_inside_triangle((triangle_ptr)&tril, (vartex_ptrjdp,\nif 2 as greatest asad ioe\nelse if ((abs(trit.pC)>=abs(trit. pA) )Sh(abs( tril. pC)>=abs(trit.po}))\nteap = point_inside triangle((triangle_ptrjatril, (vertex_ptrjap,\nFALSE, TRUE, TRUE) ;\n\nif (temp==TRUE} {\n\nff Point seeds to be checked to see if it lies between the two\nff wartices.\nff First check for tha special case of vertical lina SeQnents\nif ((tri2.a.x = tri2.b.x)Ab(triz.a.z <= tri2.b.z)) {\n\nif (((tri2.a.y <= p.y)SA(p.y <= tri2.b.y))]|\n\n((tra2.b.y <= p.y)SA(p.y <= tri2.a_y)))\nreturn TAUE;\n\n}\niy End vertical ling segment check\n\nff Now check for point on line segment\nif [point_inbetwgen_vertices ( (vertex_ptr)&triz.a,\n(vertéx_ptr)Stri2.b, (triangle ptr)atril)==TRUE}\nreturn TALE;\nelaa\nraturn FALSE;\n\n4.5 30 Collision Detection 407\n\nif Sé@cond iteration (b,c)\npeline_plane_collision( (vertex ptr) btri2.b,(vertex_ptrjatriz.c,\n{triangle _ptrjStrit);\n\nif Determine which axis to project to\ni] X 4 greatest\nif ((abs(tril.pAjs=abs(tril. pe) jeh( abel tril. pAj>-abs(trit.pop))\ntemp = point_inside triangla((triangla ptr)strii, (vertex _ptridp,\nTAWE , TRUE, FALSE);\ni] ¥ ais greatest\nelse af ((abs(trid,pa)>sabs{trit. pA) jaa abs(tril .pb)==abs(tril.pc)})\ntenp = point_inside triangle( (triangle_ptr)&trii,(vartex_ptr)ap,\nTAWE , FALSE, TRUE):\nif £ 45 greatest\nelse df ((aba(tril.po)>-abs(trii.pA))&A(abs(trit.pG)>=abs(trit.pB)}}\ntenp = point_inside triangla((triangle_ptr) Streit, (vertex_ptr)ap,\nFALSE, TRUE, TAUE} ;\n\nif (temp==TRUE) {\nii Point needs to be checked to see if it lies betwoen the two warticeas\ni} First check for the spacial case of vertical ling segnents\nif ((triz.b.% == tri2z.c.ujah(tri2.b.% == triz.c.zj) {\nif (({triz.b.y == p.y)aalp.y c= triz.c.y))]\n(ltriz.c.y == p.y}Sa(p.y c= trie boy) ))\nraturn TRUE:\n}\n\nji Now check for paint on line segnent\nif (point_inbetween vertices ((vertex_ptr)&triz.b,\n(vertex _Pirjatriz.c, (trianglée_ptr)&triij==TAVE)\nreturn TRUE:\nelse\nreturn FALSE;\n}\n\nff Third iteration (c,a}\np=Line_plane_collision((vertex_ptr)Strit.c,(vertex_ptr)&triz.a,\n{triangle _ptr)strii);\n\nff Ootermineg which axis to project to\nfi X is greatest\nAf ((abs( tril, pAj=\"abs (tril. ph) SS (abs(trit.pAjr=abs( tris, pop)\ntemp = point_inside_triangle( (triangle ptr)strii, (vertex _ptrjap,\nTRUE, TAVE, FALSE} ;\nfj ¥ ais greatest\nelse if ((abs(trii.pB)j>=abs(tril.pA))&4(abs {tril .ps)>-abs(trit.pc}))\nTEP = pPoOlnt_inside triangle((triangle ptrjatrii ,(vertex_pirjap,\nTRUE FALSE, TRUE) ;\nfi 2 is greatest\nelse if ((abs(tril.pC)>-abs(tril.pA))S&(abs(trit .pG)>sabs(trit.pB}))\ntemp = point_inside_triangle( (triangle _ptr)a&tril, (vertex_ptrjép,\nFALSE, TRUE, TRUE);\n\nif (tenp==TRUE} {\nfy Point needs to be checked to see if it lies between the two wertices\n\nE\n\nSection4 Polygonal Techniquer\n\nff First check for the special case of vertical line segments\nLf ((triz.c.x == triz.a.x}eh(tri2.c.7 = triz.a.zj} {\nif (((trig.e.y <= p.y)Ss(p.y <= triz.a.¥))]|\n((tri2.a.y <= p.y)S8(p.y <= triz.c.y¥}))\nreturn TRUE;\n}\n\nji Now check for point on line segnent\nif (point_inbetween_verticas((vertex_ptrj]&tri2.c,\n(Vertex ptr }Striz.a, (triangle_ptr)&tril)==TRUE}\nreturn TRUE; /! Intersection point is inside the triangle and an\nalee if the line segeant\nreturn FALSE:\n}\n\nreturn FALSE; // Ostawlt value/na collision\n\n4.6\n\nMulti-Resolution Maps for\nInteraction Detection\n\nJan Svarovsky\n\nThis article describes a method for reclucing the number of proximity tests that must\nbe performed for games with large numbers of game objects of varying sizes. The cost\nof simply testing cvery abject against every other object goes up with the square of the\nnumber of objects. which can ger very large! This is particularly bad if the proximicy\ntest is expensive.\n\nUsing a Grid\n\nThe simple solution ts to cut up the world with a grid-based map. Esch grid square\nhas a linked list af the objects whose centers are locared above i. Because the objects\narc of non-zero size, they may overlap into adjacent map squares. When che time\ncomes to search for all possible collisions benween objects, cach object only has to test\nfor others after it in the linked list associated with its own map square, and also map\nsquares 0 the east, southeast, and south. Any collisions co che north and west and\nwith objects earlier in the list are detected when other objects do meir check. This\nenables you to avoid checking for the same collision rwice.\n\nProblems with Varying Object Size\n\nThis approach has problems when the game objeces vary widely in size. You are only\nguaranteed to find all the collisions in chis way if your game objects are smaller than\nyour map squares. IF you have large game objects, you could make the map squares\nlarger. However, this would mean chat smaller ebjeces would test against each other\nwhen they are in fact far apart, when a finer grid system would have avoided them\neven considering each other, Sec Figure 4.6.1.\n\nIf you make the map squares smaller than some game objects, then there is a dan-\nger that objects’ interactions are not detected because they are far enough apart in\nmap squares to never check each other, though physically they do touch.\n\n403\n\n| 3\n\nSection4 Polygonal Techniques\n\nFIGURE 4.6.1 Object 2 checks against Object 3 and map squares A, B, and C.\n\nYou can solve this by giving cach object “feet.” Here, objects do nor sie in the map\ndirectly (unless they are small enough); instead, rarher small helper objects sit in the\nmap squares that the object touches. Management of these fect is simple, thoweh a lic-\nthe clumsy (Figure 4.6.2).\n\nFIGURE 4.6.2. Lareer Object 2 now has feet!\n\n4.6 Multi-Resolution Mape for Interaction Detection 405\n\nMulti-Resolution Maps\n\nThe alternative suggested here is to have several resolutions of map. The map square\nsites go up in powers of owo to make conversion herween the different coordinate sys-\ntems simple. Each object resides in the map where the squares are the smmallest possi-\nble while actually being larger than the object. When doing the collision detection,\nyou not only check against your own map square but also che map squares in the\nlower-resolution maps (larger map squares) chat you touch. Much like only checking\nin the linked list after yourself, you don't bother checking in higher-resalution maps,\nThe smaller objects will find you when they do their own checking, so you don't have\nto search for chem (Figure 4.6.3).\n\nIt is simplest to have all resolutions of map squares, down to one map square cov-\nering the whole world. Each lower-resolution map is four times less data, so the mem-\nory fequirements ate vanishingly small. In my experience, if you cut off the map\nresolutions at some level, you may every now and then dunng game development dis-\neower a game object (such as an explosion’ effect sphere) will be just a little too large\nand crash your game. The only cxura cost for not cutting off che map resolutions is\nthar the searching goes all the way to the lowest-resolution map.\n\nYou can add a lower bound for the resolution simply, with a decision—do you\ndisallow larger objects, or do you just put them in the lowest-resolution map squares,\naccepting thar sometimes they won't be collided with correctly? recommend allew-\ning them to reside in the lowest-resolution map, assuming that the objects are only\ntoo large during development of the game, and by the time of release you will need ro\ntune the map square size co suit the largest object available in the game.\n\nri\n\nFIGURE 4.6.3 Multiple simple maps; cach object resides im che finest resolution map\npossible.\n\n406 Section 4 Polygonal Techniques\n\nSource Code\n\nhh ee a\n#include <stdio.h>\nFincludé <a6¢ert.h>\n#include ‘mtxlib.h*\n\nff This ie your gane object base class\nClass Gamedhject:\n\neee eee ee eee eee eee ee eee CEE REALE E SOAP EATS\ni\nff External definitions\n\nfy) Tf the sap decides two objects are close enough together, it will\nff call this function, which you have to prowide\nextern void process collisian(Gamp0bjact “a, Gametbject \"bj;\n\nA00U0ASRUOAAG CUO R UGC OGG LEBEAU OO EEE EEE\nii\n\nif A gana object. Derive your ow objects off this\nclass Gasedbject\n\npublic:\nGaneObjact | }\n{\n\nNextInWap = MULL;\nMapSquare = NULL;\n\nNaphies = Os\nI\n\nif The object if in a singly linkad list hanging off one of\nJf the map squares\nGaneQoject *MaxtInMap;\n\nff And this is the map square that this abject is hanping off,\nff ile the start of that list\nGaneObjact *\"Mapequare;:\n\nff The reselution of the map the object is sitting in\nint Mapes:\n\nff Take the object aut of the map's linked list\nWold RénoveFromlapt):\n\nif calls \"process collision® om all the relevant other objects in\nif the ap, a4 per the article\nwold Process¢ollisions(class Map *my_nap);\n\nprivate:\n\nff 00 on€ resolution of map, used by ProcessCollisions( }\nVOid ProtessOnelevel(Map ‘my_map, Gamedbjact **map_=ho,\nGanedhject \"walker, int eurrent_rasj;\n\n4.8 Multi-Resolution Maps for Interaction Detection 40T\n\nJCUUBDBE A OODLEUEEECUOUBDBEEL OCHO LOE EU SEEDER BBE UE E EEE\nif\njj The map.\n\nff for efficiency’s sake, the map dimensions etc are constants, you\nif could sinply turn them into variables if you so wished\n\nff (1 << this) is number of aap squares at highest ras\nfidefine MAP_HE RES SHIFT iB}\n\nfo and the mumber of map squares at tha lowest ras\nfdefing M4P_LO_RES_SHIFT Ct)\n\nif snallest size of a map square\n\nfdefine MAP SMALLEST SQUARE SIZE_SHIFT (a)\n\nPietine MAP SMALLEST SQUARE SIZE {1 oc |\nMAP_SMALLEST_BOUARE SIZE SHIFT)\n\nfi? largest\nfdefine MAP_BEGGEST SQUARE SIZE_SHIFT (WAP SMALLEST SQUARE SIZE SHIFT +\nMAP HI RES SHEFT \\\n- MAP_LO AES SHIFT)\ndefine MAP_BIGQGEST SMARE SIZE qi <<}\nWAP BIGGEST SQUARE SIZE SHIFT)\n\nif The Length of one Bdge of the nap if, aétual game coordinates\nfdetine MAP_SIZE (1 << \\\n(MAP_SWALLEST SQUARE SIZE SHIFT + MAP_HI_RES SHIFT) )\n\nif The map,\nclass Wap\n\n{\n\npublic:\n\niia array of pointers th the differeat resalutions of Tap.\nGamaGbject **Who[MAP_HI_RES SHIFT - MAP_LO AES SHIFT + 1];\n\nMap);\nWap (hi\n\nff Fills in the who array and clears it\nbool Init();\n\nff deallocate\nVoid Reseti);\n\nff fills in the object's map-related information given its\nff position and radius\n\nvoid Placateject(Ganeteject Bob], const vectora &pos,\nfloat radius);\n\n{/ Q@iven 4&4 map square at a certain resolution, returns the\n\nff one at the next lower resolution, or NULL if that was the\nff Lowest res\n\nGaneObject \"\"GetLowarWapSquare (Gamedbject **current, int res};\n\n};\n\nsection 4 Folygonal Techniques\n\nAA CRUAAUROROLAL ALOU SDA GAEEOUOEG LUPE LEEEELE LED EELE EEL\n\ni\n\nfi implementation\n\nvoid\nif\n\nwoid\n\nGama0bject::ProcessCollisions(Map *my_map)\n\nff We loop through several resolutions of map, starting with\niy the current.\n\nff First start with the objects in my aap square\n\nGameObject “walker = Nextinwap;\n\nint current_ras = Maphes:\n\nGameQhject **map who = MapSquere;\n\noo\n\n{\n// 00 ong resolution's worth of eellisign\nPracessOngLevel(my_map, naplwho, walker, CUrrenk_res);\n\nff Move to the next lower resolution\nmap who = my_Map->GetLowsrWapSquare (map who, curréent_ras);\ncurrent_ras—;\n\n}\n\nwhile (map_who); // until we're at the lowest resolution.\n\nGaneObject::ProcessOneLovel(Map \"my map, GameDoject **map sq,\nGareGbject “walker, int CuUrrent_res_ shift)\n\nint turrent_res_ Size = | =< curhant_res_shitt;\n\nff 06 all tha objects in the first list presented\nTor {; walker; walker = walker->MextInMap)\n\n{\n}\n\nff Work gut if you can go to the adjacent map #quaras\nint current_offset = map eg - hy_map-Anolcurrént_ras_ shift —\nWAP_LO_RES_SHIFT];\n\nprocess_collision(this, walker);\n\nff Than do fap squares to the east, southeast and south\nif ((current_offset & (current_oros size - 1) t=\nturrant_reg size = 1)\n{\n\nfi} Square te the east\n\nfor (walker = map_sqli); walker;\n\nWalker = walker->WextInWap)\n\n{\n\n}\n\nprocess collision(this, walker);\n\n4.6 WMulti-Resolution Maps for Interaction Detection\n\nif (curment_offset + current_res_size <\n{i << (curremt_res_shitt * 2)))\n\n{\ni} Square te the south\nfor (walker = nap_sq[curront_ros_ size]; walker:\nwalker = walker->NextInilap}\n{\nprocess eollisian(this, walker);\n}\nffi and lastly, southoast.\nif ((ourrent_offset & (current_res size - aj) !=\ncurrent_res_size - 1)\n{\nfor (walker = map_sq[current_ras_size + 1]; walker;\nwalker = walker-=HaxtIoMap)\n{\nprocess _collision(this, walker);\n}\n}\n}\n}\nvoid GaneQbject: :AemoveFromapt}\n{\nff Search for nyself.\nfor (GameObject **pointer_to_me = Mapaquare;\n“painter_to_mea |= this;\npointer to me = &(*pointer_to_mé)->NextInidap)\n{\nassert (\"polinter_to_ma 43\n\"Gane object couldn't find itself in map\");\n}\nff Aénovwe myself.\n\"pointer_to_me = fextinMap:\nif and tor satoty's sake, lat's clear my pointers.\nNextinWap = MULL;\nMapSquare = MULL;\n}\npat\nfor (int res = WAP LO RES SHIFT; res <= WAP_HI RES SHIFT: res++)\n{\nWhojres - MAP_LORES SHIFT] = MULL;\n}\n}\nMap: : lap i }\n\nReset;\n\n410 section4 Polygonal Techniques\n\nvoid Map: iReset()\n{\nHf You'd better have cleared all the objects out by now.\nff IT won't check.\nfor (int ras = MAP_LOORES SHIFT; res <= MAP_HT_RES SHIFT; res++}\n|\ndelete.] Wholres - WAP LO RES_SHIFT);\nWoe[res - MAP LO RES SHIFT] = NULL;\n\n}\n\nbool Map:sImit (}\n\n{\nHeset(); #/ just in case\nff allecate and claar everything.\nTor (ant res = MAP LO AES SHIFT; res <= MAP _HI RES SHIFT; res++}\n1\nWhol Pes - MAP LO RES SHIFT) = new GameQbject*\n[1 << (res * 2);\nif (IWhe[res - MAP_LO_RES SHIFT))\nreturn falge; sf alloc failed\nfor (int sq = 0; sq < (1 << (res = 2)); sq++)\nWholres - MAP_LO RES SHIFTJ[eq] - NULL:\n}\n}\nreturn true;\n}\n\nff fills in the object's map-related information piven its\n\nii position and radius\n\nVoid Map: :PlaceObject(Game0bject obj, const vectors Epos,\nTlaat radius)\n\n{\n\nff input value cheeking.\nassert(radius == 0.f &4 radius < MAP STZE);\n\nff Tf you want ta allow positions «aff the Nap, change\ndf these asserts inte assignments\n\naSsert(pos. 2 = O.f BE pos.e = MAP SIZE):\nASsertipos.y >3 0.7 £8 pos.y < MAP SIZE};\n\n‘i Conversion inte integer coordinate systam needed far\n\nff shitting/array maths later on. Note that these conversions\nff are often slow and may have to be replaced with faster\n\nff versions in some compilers. If you do replace then,\n\nff preserve their rounding-down nature\n\nint iradius = int(radius);\n\nint ix int(pos.x 4;\n\nint iy int(pos.y 1;\n\n4.6 Multi-Resolution Maps for Interaction Detection 411\n\nft Find which resolution level of the map the object showld\nif go in.\n\nobj .Maphes = MAP_HI RES SHIFT;\n\nfor (int map size = MAP SMALLEST SQUARE SIZE; map size <=\nWAP_BIGGEST SQUARE SIZE;\n\nHap siza <<= i}\n\n{\n{f Does the object fit?\nif (iradius <= map size} goto it_tits;\nfy step on...\nobj -Mapies=;\n}\n\nassert(! \"object too large for map - soné collisions nay not be\ndetected\");\n\nit fits:\n\nI\n\niy Put it an the nap.\nint which_level = obj.Mapaes - MAP_LO_ RES SHIFT;\nGamedbject **which who = Who[which level];\n\niy Then add on the position\n\nwhich why += ix >> (MAP_BIGGEST_SQUARE SIZE SHIFT - which level):\nwhich_wha += {iy >> (MAP_BIGGEST_SQUARE_SIZE_SHIFT — 5\nehi¢h_level)) == obj.Maphes;\n\nif Insert tha object inte the map square\nobj .MextinWap = “which wha;\n\"which who = hobj;\n\nob). MapSquare = which who;\n\nGaneObject **Map:;GetLowerWapSquare(Gamedbject **current, int who res)\n\n{\n\nff Top of map?\nif (who res == MAP_LO_AES SHIFT) return MULL;\n\nif Gunning bit-shifting -\nint current_otfset = ¢urrent = Wholwho_res - MAP_LO RES SHIFT];\n\nff Extract tha y part af the current offset.\nint ¥_Maek = Oxttttttt? << who res;\n\nif The new offset is this:\nint newloffset = ((current_offset & -y_mask } == ij #\n({current_offset & [y_mask <= 1)) => 2);\n\nreturn Wholwho_res - MAP_LO RES SHIFT - 1] + new offset;",
      "page_number": 389,
      "chapter_number": 41,
      "summary": "This chapter covers segment 41 (pages 389-403). Key topics include maps, object.",
      "keywords": [
        "map",
        "RES SHIFT",
        "SQUARE SIZE SHIFT",
        "map squares",
        "RES",
        "SHIFT",
        "MAP SMALLEST SQUARE",
        "square size",
        "SMALLEST SQUARE SIZE",
        "size",
        "MAP SIZE",
        "SIZE SHIFT",
        "line",
        "map square size",
        "square"
      ],
      "concepts": [
        "maps",
        "map",
        "object",
        "sizes",
        "shift",
        "square",
        "res",
        "walker",
        "abs",
        "collision"
      ],
      "similar_chapters": [
        {
          "book": "makinggames",
          "chapter": 32,
          "title": "Segment 32 (pages 282-290)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "Segment 33 (pages 314-325)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "makinggames",
          "chapter": 30,
          "title": "Segment 30 (pages 266-273)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 32,
          "title": "Segment 32 (pages 632-651)",
          "relevance_score": 0.61,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 26,
          "title": "Segment 26 (pages 243-252)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 42,
      "title": "Segment 42 (pages 404-412)",
      "start_page": 404,
      "end_page": 412,
      "detection_method": "topic_boundary",
      "content": "4.7\n\nComputing the Distance into a\nsector\n\nSteven Ranck\n\nThis article describes 2 simple and fast algorithm for decermining where a point is\nberween the edges of a 2D quad (or sector). The result is a unir floating point num-\nber, where O indicares that the point lies on the leading edge, and where 1 indicates\nthat the point lies on the opposite edge. The sector may be any four-sided, 2D convex\nshape,\n\n‘This article is useful for any game that may require knowledge of how far “into” a\n20) sector an object or point is. For example, a 3D racing game might use a cop-down\n2D sectorization of its track no describe to the AI driving system how to navigate the\ntrack, Using the sector data and a vehicle's AZ position within a sector, the Al system\ncould use chis algorithm to determine hew far into the current sector the vehicle is, or\nwhere laterally it is. The algorithm is very fast, and in most cases can easily be com-\nputed for every vehicle each fame, if heocssary.\n\nThe Problem\nee ee eee eT\n\n412\n\nFigure 4.7.1 shows a four-sided, 2D sector in XZ world space. The object's posi-\ntien on the AZ planc is shown as point P. We would like to find a continuous fune-\ntion that acceprs Pas a parameter and produces a value of O if P lies on the leading\nedge, 1 if Plies anywhere on the trailing edge, and a value between O and 1 if the\npoint lies berween the leading and trailing edges. Figure 4.7.2 shows the desired sealar\nvalues for several points within a sector.\n\nAs Figure 4.7_2 shows, all points lying on the leading edge produce a value of 0,\nand all points lying on the trailing edge produce a value of 1. Points beeween the evo\nedges produce values that increase from 0 to 1 as the poine is swept across the secrar\nfrom the leading edge to the trailing edge. Because we're interested in an algorithm\nthat's computationally inexpensive, we will not require thar the interpolation be lin-\ncar. However, it must be a smooth interpolation, and the function must work far all\nconvex sector shapes. A few examples are shown in Figure 4.7.3.\n\n4.7 Computing the Distance inte a Sector 4413\n\nHe\n\nie\n\nLeaclirny\nEdge\n\nFIGWAE 4.7.2 Dresired scalar valuss for various Poln Within a sector.\n\nFigure 4.7.3 shows that, regardless of the sector's shape, the value\nreturned from our desired function is always 0 on che leading edge and 1\non the railing edge, and it is interpolated when our paint lies between the\n\nTaro eckpes.\n\n0.0 1.0\n0.0\n0.0 0.0\n1.0\n0.0\" 1.0\n\n0.0 1.0\nFIGURE 4.7.3 Example convex sector shapes showing comesponding scalar values.\n\n414 Séction4 Polygonal Techniques\n\nDescription of the Algorithm\n\nA fast and simple solution to the problem in the previous section is given by the equa-\nLi:\n\nT= (Vip #¥,)\nVip @ Ny + Vp oN,\nEQUATION 4.7.1 Equation for computing a distance value across a sector,\n\nWhere\need adie\nV>y- PP,\nAnd:\n\nPis the point of interest within the sector.\n\n* is any point on the Leading Edge.\nPyis any point on the Trailing Edge.\n\nis the inward-pointing unit normal of the Leading Edge.\nNris the inward-pointing unit normal of the Trailing Edge.\nDis our result: a floating point number from 0 to 1,\n\nFigure 4.7.4 shows the variables involved in Equation 4.7.1 and their relationship\nto the problem. Note thar ?, may lie anywhere along the leading edge, and F; may lie\nanywhere along the trailing edge. However, using opposite corners of the sector offers\nseveral advantages. First, sino the sector is most likely defined by its four vertices, it\nmakes sense to use the corners far aur purposes. Second, by choosing opposite cor-\nners, Equation 4.7.1 can be used to compute both the distance from leading edge to\ntrailing edge, as well as the distance laterally, This is because #, lies on both the lead-\ning edge and one of the lareral edges, and > lies on both the trailing edge and the\nother lateral edge.\n\nEquation 4.7.1 has several fearures:\n\n- It produces a scalar from 0 to 1.\n\n- It produces 0 if P lies on che leading edge.\n\n~ It produces 1 if Plies on che crailing edpe.\n\n- Although not lincarly, it docs produce a smooth, interpolared value from 0 to 1,\ndepending on how far into the sector P lies.\n\n. It's fast, requiring only two 2D vector subtractions, nwo 21D det products, one\nsealar addition, and one scalar divide to compute.\n\n6. The raw, world-space point P can be directly plugged inte the equation. No\n\ntransformation into warped sector space is required.\n\nee a fc) me\n\nNoah\n\n4.7 Computing the Distance inte a Sector 415\nee\n\nFIGURE 4.7.4 Parameters used in the algorithm.\n\ni\n\n- [f the sector is a staric shape, then P;, Py, N;, and M>may all be pre-determined\n\nand stored in the sector definition data stracture.\n\n8. Ifthe sector dynamically changes shape, P; and Pare still available from the sec-\ntors vertices, and N, and My can easily be computed from che sector's vertices\n(although this is slower because it involves a square root per normal).\n\n9. Tt may be used to compute the distance larerally, moo, provided thar the nwo\n\ninward-pointing unit normals for the lateral edges are available,\n\nThe equation has several requirements;\n\n- The sector must be convex and have four sides, each of non-zero length.\n\n. The sector must have non-zero area.\n\n- must lie within the sector, or along any of its perimeter line segments. If che\npoint lies outside of the sector, the result might not be a value between 0 and 1,\nas expected,\n\nee\n\nApplications\n\nDistance Down a Track\n\nEquation 4.7.1 has many applications in game development, One example is in the\ndetermination of how far down the track a vehicle is. Figure 4.7.5 shows a top-down\nview of a road track overlaid with a chain of sectors.\n\nWhat wei like co know is how far down the track each vehicle is. When the vehi-\ncle is at the starting line, it should be a value of 0. When che vehicle is at the finish\nline, wee like a value of 1. And, weld like reasonable interpolation in between.\n\nThe sectors are constructed to completely contain the crack so that the vehicle\nposition, P, will always be within a sector, This also means thar adjacent sectors use\nthe same vertex points. Ar game initialization time, each sector's inward-pointing unit\nnormal for both irs leading edge and trailing edge is computed. Note char a sector's\n\n416 Section 4 Polygonal Techniques\n\nFIGURE 4.7.5 Secrorization of a track.\n\ntrailing edge normal is equal to its neighboring sector's negated leading edge normal.\nBut if the memory is available, it’s fastest co store the evo normals with cach sector.\n\nAnother piece of information we'll need is the approximate world-space distance\nberween cach sector's leading and railing edges. A sloppy bur decent metric for this is\nto use the magnitude of the vector extending between the midpoints of the leading\nand trailing edges as shown in Figure 4.7.6,\n\nAs with the other sector data, we pre-compute sfor each sector and store it in the\nsectors data structure. Ac chis point, we might have a sector dara structure that boolss\nlike this:\n\ntypede? struct {\nFloat f%, fz; // 20 X2 worldspace coordinate\n} Weck? +;\n\ntwpede? struct {\n‘i Glockwise, where [0] = left side of Leading Edge\nVookZ_t aVertices[4];\n{i Clockwise, where [0] = Leading Edge\nWack? _t aUnitNormals[4]:\nif Distance from Leading Edge's midpoint to\nif Trailing Edge's midpoint\nTloat feactorDist;\n\nif = previews sector's fTotalPriorbist + fSectarDist\ntloat fTetalPriorbist;\n} Sector_t;\n\nNote the tTotalPriorDist field, which is simply che sum of the previous sector's\nfTotalFriorfist and tSecterDist fields (fTotalFriorDist is 0 for che first sector).\nWe'll discover why we need this below, The final piece of information we will need is\nthe sum of all iy adding together #SectorQdst for all sectors. We'll pre-compute and\nstore the inverse of this and call it fOneQverTotalSactorDist. We store the inverse\nbecause, as we'll see, we actually need to divide by the sum of all s, and multiplying by\n\n47 Computing the Distance Inte a Sector 417\n\n5 = |S!\n\nFIGURE 4.7.6 Approximating the world-space distance berween sector edpcs.\n\nthe inverse is faster on mest CPUs than dividing. Since we have the luxury of pre-\ncomputing this information, we won't pass up the opporeunity to do the division (rec-\niprocal) ar that time and score an inexpensive multiplication at run-time,\n\nArmed with the preceding information, we're now able to determine how far\ndown a track a vehicle is. For each vehicle, we need the following information:\n\nfinclude \"ntxlib.h®\n\ntypedet struct {\nvectors WorldPossD;  // Vehicle's origin in 3D worldspace\nSector_t \"pSector; fi Points to the sector the\nff vehicle origin is currently in\n} Vehicle t;:\n\nAt the start of the race, the vehicle structure is initialized for cach vehicle, and\npSecter is pointed to the sector containing its origin. This initial sector may be four\nby either scanning the entire list of sectors for the one sector containing the vehicle\norigin point, or by storing the initial sectors as part of the starting line data.\n\nOnce the race begins, we need to track which sectors the vehicles are in, since\nEquation 4.7.1 requires that che point lic within a sector. To do this, each time we\nmove the vehicle, we use a simple point-in-sector test to see if the vehicle is still within\nsector. If nor, then the vehicle is either im the next sector or the Previous sector, and\nWe agilin use the point-in-secvor test, Most of che time, only one test is required; occa-\nsionally, two tests are required. If the vehicle is moving backward, three tests will be\nneeded. [fit is possible that the vehicle's speed is fast enough that the vehicle skips an\nentire sector from one frame to the next, a more sophiscicared sector-tracking algo-\nrithm will be needed. One such solution would be to check, in order, the nar N for-\nward sectors first. Ifthe vehicle is not found in any of those, the algorithm would next\ncheck the previous W sectors. If the sector is still not found, this could be considered\nAn uncommon condition, and the algorithms would resort ro scanning the entire sec-\nbor list,\n\n418\n\nSection4 Polygonal Techniques\n\nNow thar we have a valid secoor for cach vehicle, we can write a function for\nEquation 4.7.1 te determine how far ine its sector each vehicle is:\n\nTloat CaléUmitDistIntosector( float fPointx, float fPaintzZ, const\nSector_t *pSector j {\n\n}\n\nVeex2_t VLF, VIP:\nfloat flotL, fOotT:\n\nff Compute vector from point on Leading Edge to P:\nVLP.fX = fPointX - pSecter-saverticas[0O] .tX:\nVLP.fd = fPointZ - pSector-saverticas[0] tz;\n\nif Compute vector from point on Trailing Edge to FP:\nVIF.TX = TPointk - pSector--avertices[2].7x;\nVIF.?Z = TPointZ - pSector-savertices[2].#2Z;\n\nji Gampute (WLP dot Leading Edge Normal):\nfDoth = VLP.fX*pSector->alinitNornals[0] x +\nWLP. f2*pSector-sallnithernals(o].Tz:\n\nJi Gonpute (VIP dot Trailing Edge Normal):\nFDotT = VIF. tx*pSecter->alinitNormals[2] fx +\nVIP. TE\" pSactor-*alinithornals[2].tz;\n\n/f Conpute unit distance into sector and return it:\nreturn { fDotl / (fOo0th + tOotT) }:\n\nFinally, we can compute the distance down the track like this:\n\nif Pre-computed to be tha inverse sum of Seoter_ti:tSectarbist\n\nIf\n\nTor all s#eters.\n\nfloat TOnefverToatalSectorbist;\n\nfloat CalclnitbistbownTrack({ const Vehicle t “pYehicle } {\n\nfloat TUnitDistintesector, tOistDoenTrack;\n\nff Campute how far vehicle is inte its sector:\nTUNLEDstlateSecter = CalclUnithistintegector [\npP¥venicle-“WorldPoasso. x,\npYehicle->WorldPosso.z,\npWehicle->pSector\nNM\n\nfi The distance down the track is the full distance\n\nff across all previous sectars, plus the partial\n\nff distance into our current sector:\n\nfOistlewmiTrack = p¥ehicle->pSecter->fTotelPriorbist\n+ p¥ehicle->pSector:>*SoctorDist *\nFUnLtDistIintesector ;\n\nff Finally, our unit distasice dom the track is our\nif distance sa tar divided by the track's total distance:\nreturn fOistBownTrack * fOnelverTotalsectarDist;\n\n4.7 Computing the Distance Inte a Sector 4419\n\nThe function CaleUnitbistbownTrack() returns a value of O if the vehicle is on\nthe leading edge of the firsc sector of the crack, returns a value of | if the vehicle is on\nthe trailing edge of the lasr sector of the crack, and returns an interpolared value\nbeeween 0 and | based on how far down the mack the vehicle is,\n\nSmooth Light Changes\n\nAnother practical application of Equation 4.7.1 is the smooth interpolation af light-\ning on objects moving through sectors. If we associate ambient and directional lights\nwith leading/trailing sector edges, we can interpolate the lighting parameters as the\nabjects to be lit move from sector to sector.\n\nConsider a sector enclosing a section of a track that begins in che sum at the sec-\ntors leading edge, and ends in a dark cave at the sector's trailing edge as in Figure\n477.\n\nWe can store the ambient RGB light color at each adjoining sector edge lile so:\n\ntypedef struct {\nfloat fA, 76, TB; // ROB ambient light\n} Anbient_t;\n\ntypedef struct {\nff Clockwise, where [0] = left side of Leading Edge\nVeex? t aVertices|4];\n{f Clockwise, where [0] = Leading Edge\nVeex? t allnmitNormals[ 4);\nff Oistance trom Leading Edge's midpoint to Trailing\nfi Edge\"\nFleat fSectordist:\nif = previous sector's fTotalPriorfist + TSecterDist\nFloat fTotalPriorDist;\ni} Ambient light at Leading Edge\nAbient_t LradingAmbient ;\nff Ambient light at Trailing Edge\nAnbient_t Tradlingémbient:\n} Sector_t;\n\nThe ambient value of adjacent sectors must be the same to avoid a visual pop of\nthe light level when the vehicle crosses into a different sector. In the preceding imple-\n\nBrigh sunlight\nambient light sii Feito\nipaaecedl ® ambiant light\nwe FP on Trailing Edge\n\nFIGURE 4.7.7 Ambient lighr pradient ZTOSs @ POCO.\n\nSection4 Polygonal Techniques\n\nmentation, we simply store both leading and wailing ambient values with each sector,\nbut a more memory-conscious implementation might share ambient dara through\npointers. In any case, the preceding is all we need to smoothly animate the ambient\nlight level from sunlight to cave light as the object progresses through the sector. The\nfollowing funcoon dees the trick:\n\nSdeTine LEAP( fUnit, fVO, f¥1 ) ( (1.0f-(fUnitpp\"fvo + 4\n(flnitprsv1 )\n\nAabient_t CalcAmbientlightLevel( const Vehicle t *pvahicle }) {\nfloat funitDistintasector;\nAmbignt_t “pleadAnbiant, *plrailambient, RatAmbient;\n\n‘i Conpute how Tar vehicle is inte its sector:\nFUnitDistintesector = Calclitbistintesector|\npiehicle->WorldPos30.x,\npVenicle->WorldPos30.z,\np¥enicle->pSecter\nla\n\npleadanbient = &pvehicla->pSecter->Leadingénbient:\npTrailAnbient = &pvehicla->pSector=>TrailingAmbient:\n\nRetAmbient th = LERP( flnithistintosecter,\nPleadémbient->fA, plrailambient->fA 4};\nRetAmbient. 7G = LERP( fUnitDistintoSector,\npleadAmbient->9G, pTrailAmbient->f0 };\nRetAnoient. Th = LERP( fUnitDistintosector,\nPLEAOUAMOLENT-=Th, PrrailaAmbient-+fh jp;\n\nreturn AetAmbient;\n}\n\nThe preceding function computes the ambient light level at the world pasition of\nthe vehicle, A graphics engine could use the resulting ambient RGB ta provide the\noverall ambient light with which ro light the vehicle, combining it with other, more\nsophisticated lighting if desired. As the vehicle drives through the sector, the ambient\nlight is smoothly interpolated, regardless of the shape of the secter.\n\nFunctions similar to CaleAmbientLightLevel(} can be written to smoothly incer-\npolate any parameter that's assoctated with a sector edge. Examples are directional\nlight (interpolating the direction and color), sector heighs, water flow rate and direc-\ntion, foe characteristics, sky appearance, Al dificuley. etc.",
      "page_number": 404,
      "chapter_number": 42,
      "summary": "Because we're interested in an algorithm\nthat's computationally inexpensive, we will not require thar the interpolation be lin-\ncar Key topics include sector, edges, and floating.",
      "keywords": [
        "sector Steven Ranck",
        "leading edge",
        "trailing edge",
        "sector",
        "edge",
        "Steven Ranck",
        "vehicle",
        "leading",
        "leading edge normal",
        "trailing sector edges",
        "che leading edge",
        "trailing edge normal",
        "Trailing Edge FIGURE",
        "trailing",
        "Distance"
      ],
      "concepts": [
        "sector",
        "edges",
        "floating",
        "light",
        "point",
        "vehicle",
        "ambient",
        "distance",
        "computing",
        "computationally"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "Segment 48 (pages 456-465)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "Segment 34 (pages 326-336)",
          "relevance_score": 0.49,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 37,
          "title": "Segment 37 (pages 356-366)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 5,
          "title": "Segment 5 (pages 41-49)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 18,
          "title": "Segment 18 (pages 162-170)",
          "relevance_score": 0.46,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 43,
      "title": "Segment 43 (pages 413-421)",
      "start_page": 413,
      "end_page": 421,
      "detection_method": "topic_boundary",
      "content": "4.8\n\nObject Occlusion Culling\n\nTim Round\n\nOcclusion culling is a technique for culling unwanted geometry from the field of\nview, This is an extension of field of view culling, in that it helps reduce unnecessary\nprocessing time associated with rendering a mesh (Le., transformation, lighting, and\nrasterization). The occlusion provides a culling method that will work on arbitrary\nand dynamic geometry data. This means the mesh data doesn't have to contain any\ninformation about the potentially visible data set. Occlusion culling also isn’t limited\nto indoor scenes, and can be used to mark ampwhere in the mesh data that could be\nblocked from your field of view (see Figure 4.8.1 for an example).\n\nUsing a 2-buffer makes it easier to display a scene correctly, but you still need to\ntransform, light, and draw che polygons, while resting cach pixel’s depth. This imple-\nmentation of occlusion culling simplifies the process of building the occlusion dara by\nusing simple pre-defined occlusion shapes, namely rectangles. ‘These occlusion rectan-\ngles could easily be added into the original geometry as wo co-planar triangles, and\neither named or colored in such a way that che exporter or the loader could separate\nthem our from the original mesh dara.\n\nFIGURE 4.8.1 A typical occlusion.\n\n422 Section 4 Polygonal Techniques\n\nFrustum Culling\n\nTo help explain the process of occlusion culling, it’s worth describing a technique for\nfield of view culling. The field of view is the area in 3D) space visible from the current\npoint of view of the camera. This area is typically described using front and back clip\nplanes and the viewing angle (see Figure 4.9.2).\n\nThe culling process uses the bounding sphere (in world space) of each objects\nmesh, and wests if ir falls inside che field of view. To perform this test, you transform\nthe bounding sphere coneer point into view space (relacive to the camera) and check\nthe new 2 value against the near and far clip planes. You can chen cest the cenecr point\nagainst the left, righe, top, and bottom clip planes. The clip planes for the field of view\nean be pre-calculated ar the stare of the render loop. Because these clip planes are in\nview space, we can simplify the clipping test. The frome anc back clip planes will be\nperpendicular two the 2-axis, so a simple compare against the 2 value can quickly\ndecide if the mesh is in front or behind the camera. The coefficients 4 and 2 in the\nequation of the plane for che left and right planes are zero (because they are vertical),\nand the planes pass through the origin (0,0,0). This means co test a poine agains the\nleft or right plane, you can use the following equation:\n\nDistanceFromGlipPlane = (x \" Plane.a) + (z \" Plane.c);\n\n‘This also applies to the top and bettem clip planes, except the coefficients 4 and\nDare now zero, and this produces the following equation:\n\nDistancarronGliprlane = (y * Plane.b) + (z * Flane.c};\n\nBack, cp plane\n\nFronl cip plane\n\nFIGUAE 4.8.2 Field of view of viewing frusnim,\n\n48 Object Occlusion Culling 433\npS el toate rable tt eS ee\n\nH the distance of the poine from the plane is greater than the bounding sphere\nradius, then the bounding sphere is outside the area. By testing ehe bounding sphere\nagainst all the clip planes, we can find out if the mesh lies within the field of view: this\nhelps us remove all meshes that are not visible. The order we test the center point\nagainst the clip planes can be changed to mach the geomerric data; for example, a\nlandscape expands more along the Xand Z axes chan the Faxis, so we test the left and\nnght clip planes before the top and bottom clip planes. The front and back planes are\ntested first because they require less computation and can typically remove a large\nproportion of the geomenry. See Listing 4.8.1 for sample code thar implements field\nof view culling.\n\n‘As you see, we can use the plane equation to describe the boundaries of the view\ning frustum, and by first transforming the bounding sphere center point into view\nspace we can simplify che point-to-plane test. So, using this same principal, we can\ndescribe the boundaries of an ocelusion.\n\nOcclusion Culling\n\nOcclusions described in this article are four-sided flar or planar polygons, but they can\neasily use more or less sides, providing che polygon is planar. We can pre-calculate che\nocclusions clip planes in the same way as for field of view culling, except this time we\nonly need a frent plane and four edge planes (sce Figure 4.8.3).\n\nThe ocelusion area differs from the viewing fruscum in that it deseribes.a hole. If\nany mesh lies inside this hole, it won't be rendered (see Figure 4.8.4).\n\nThe front plane of the occlusion won't always be perpendicular with the front clip\nplane, so we will have co use all four coefficients of the plane equation. We also can't\nsimplify the edge planes because they too can be at any angle, The front plane is cal-\n\n-\n\nFae\nFIGURE 4.8.3 A four-sided occlusion is described with four planes, front, left, tight, top and\nbottom,\n\nSection 4 Polygonal Techniques\n\nViewing\naction\ni This obeet\nFront ip im wigiie\nelon\n\nFIGURE 4.8.4 Objects that are behind che occlusion are invisible,\n\nculated by using three poines from the oeclusion polygon after they have been trans-\nformed into view space. The edge planes are calculated by using the camera position\n(remember in view space this is 0.0.0) and cwo points along the edge of the occlusion\npolygon (see the SetupQeelusion() function in Listing 4.6.2). Qoclusions can be\nmade two-sided by testing which way the frone plane faces and reversing the order of\nthe points used to generate the planes.\n\nWe will need to test if an object's mesh falls inside the field of view before testing\nit against the occlusions, so we have already transformed the bounding sphere center\ninto view space. To help speed up the occlusion test, we can pre-calculace a minimum\n# value (the value closest to the front clip plane) in view space for each occlusion, and\nwe can test the transformed bounding sphere center against it to quickly test if the\nmesh isin front of the occlusion (see Figure 4.8.5.)\n\nIf the bounding sphere of the mesh overlaps the edge of an occlusion, we could\ntest alll che poincs of an axis-aligned bounding box for extra precision. [fan object is\nmuch bigger along one axis (c.g., very tall), then a bounding sphere can be very waste-\nful in describing its area, bux che bounding sphere can be tested againsc a plane much\nfaster than a bounding box. So we use the bounding sphere first to quickly reject any\nmeshes char are tocally outside or inside of an occlusion.\n\nWhen building up a list of occlusions that are visible, you can also test che ocelu-\nsions against each other co remove any occluded occlusion. If an occlusion covers the\nencire viewing frustum, we can move the back clip plane closer. Ocelusions can also\n\nFIGURE 4.6.5 A minimum 2 value can be used to speed up the test,\n\nhave their own bounding sphere, which can be used to remove any occlusions char are\nnot visible in the viewing frusum.\n\nSummary\n\nAs you can see, occlusion culling of this nature is fairly easy co implement, but it\ndoesn't have to be limited to mesh culling—ie can also be used for culling sounds.\nOcclusions can also help to prevenc time-consuming effects like skinned animarion\nfrom being applied to objects thar aren't visible.\n\nOeclusions can be made more efficient by joining several together to form com-\nplex occlusion zones, bur this is beyond this discussion.\n\nThe example code is writen with DirectX in mind (ie., it’s left-handed), but it\ncan easily be changed to suit any coordinate system. The code is designed ro illustrare\nthe algorithm, and can easily be adapeed to suit any target platform or application.\n\nListing 4.8.1: Field of View Culling Code\n\ntypedef struct VECTOR\n{\n\nTloaat x;\nTlaat y;\nfleat z:\n\nSection 4 Polygonal Techniques\n\n}VECTOR:\ntypedef struct _ PLANE\n{\nTloat a;\nTloat 6B;\nfloat ¢;\nfloat d;\n}PLANE;\ntypedet struct MATHIX\n{\nfloat 11:\nfloat _ 12:\nfloat _ 13;\nfloat 14;\nfloat 21:\nfloat 22:\nfloat 25:\nfloat 24:\nfloat 31:\nfloat 32:\nfloat 3a:\nfloat 44:\nfloat 41;\nflaat 42;\nfloat _ 43;\nfloat — 44;\nMATRIX:\n\nPLANE g FOVLeftPlane;\nPLANE 9 FOVRightPlane;\nPLANE 9 FOVTopPlane;\nPLANE g FOVEot tom? lane;\nfloat g FOVFrantclip;\nflaat g FOVBackClip;\nMATAIN g ViewTransforn;\n\nvoid Normalize (VECTOR *pi')\nff\nfloat Length , Invlength;\n\nLangth = (float) sqrtt ( pY->x \" pW-=x J +\n{ p¥->y * pi->y J + ( pW-sz * pi-ez ) 5\n\ninviength = 1.0% | Length;\n\np¥=>x j= Invlength;\n\np¥asy j= Invlength;\n\np¥=>z /= Invlength;\n\nwold GrossProduct (VECTOR \"pio , VECTOR \"pv1 ,\nVECTOR “pGrassProduct}\n{\n\n4.8 Object Occlusion Culling 427\n\nPCPOSSProduet->x = pWO-sy \" p¥i->z - pV0->z * ply;\nPCMOESPPoduct->y = pWO-s2 \" pVi-=_ - pV0->e © pi-z:\nPEPGSSProduct->2= pvO->x \" pyi-sy - pVO->y * pid->x;\n\nvoid PlaneFronPoints(VECTOR *pPO , VECTOR “pri,\nVECTOR *pP2 , PLANE \"pP lane}\n\n{\nVECTOA VO,¥1,W2;\nVO.% = APIs - pPp->x;\nWOiy © pPis>y = pPO->y;\nWO.2= pPi->z- pPO->z:\nVi.¥ = pPS->x - pPp->x:\nVicy = pP2->y = pPO->y;\nVi.z= pP2->2- pPj->z:\nGroseProdiet( avo, a, BYE):\nHornalize( av2)5\npPlané-2a = V2.2\";\npPlane->b = V2.¥;\npPPlané-»t = V2 Lz;\npPlane->d = -( VW2.x * pPO->x + V2.y \" pPO->y + ve.z #\npPO-2z jj\n}\n\nf/This function calculates the planes for describing the view\ni/frustun using 3 points. Because we are in viaw space the\nifcameras position is at 0,0,0. We use the back clip position\nf/and the viewing angle to work out a point on the edge of\nifthe frustum. The view angle is the angle between the top\nHfand Botten of the view frustum in radians.\n\nWid SetupFOVGlipPlanes( float Angle , float Aspect ,\nfloat FrantGlip , float BackClip ]\n{\n\nWECTOR PO , Fl, Pas\n\nif) Galevlate left plane using 3 points\n\nPO.x = O.0f;\n\nPO.y = O.0f;\n\nPO.z = O.0f;\n\nPt.x = -BackOlip * ( (float)tan{ Angle * O.5T ) / Aspect };\nPl.y = -BackClip * ( (flost)tan( Angle * O.5f ) 1;\n\nPl.z = BackGlip;\n\nP2.% = Plex:\n\nP2.y = -Pi.yi\n\nP2.z = Pl.z;\n\nPlaneFronPoints{ SPO, &Pi , &P2 , &p_FOVLeTtPlane };\n\nff Galewlate right plane using 3 points\nPO.x = O.0T;\nPO.y = 0.0f:\nPO.2 = 0.0?!\n\niy\n\nil\n\nBOO.\n\niif\n\nif\n\nif\n\nif\n\nSection 4 Poblgonal Techniques\n\nPi.x = BackClip = ({ (floatj)tan( Angle * O.5T }) | Aspect):\nPi.y = Backlip = { (float)tan{ Angle * O.5T ) 1;\n\nFl.z = BackClip:\n\nP2.4 = Pi.x;\n\nP2.y = -Pi.y;\n\nP2.z = Piz:\n\nPlaneFromPoints( &PO, 4P1 , @P2 , 49 POVRightPlane }:\n\nCalculate top plane using 3 points\n\nPO.x = O.0F;\n\nPO.y = O.0F;\n\nPO.2 = 0.0F:\n\nPi.x = -BackOlip \" [ (float)tani Angla * O.5f j / Aspect):\nPi.y = BackOlip = ( (Tloat}tan( Angle * O.5f } 4;\nPi.Z = Back€lip;\n\nP2.z = -Fi.x;\n\nP2.y = Pl.y;\n\nP2.z = P1.z;\n\nPlaneFramPaints( SPO, Fi , aP2 , £9 FOVTopP lane ‘i\n\nCalculate bottom plane using 3 paints\n\nPO.x = O.0f:\nPO.y = O.0f;\nPO.z = O.0f;\n\nPi.x = BackClip * { (float}tan( Angle * O.5f } / Aspect};\nPisy = -BackGlip * { (floatjtan{ Angla * O.5f ) };\n\nPi.z = Backtlip;\n\nPo.\" = -Pi.z;\n\nP2.y = Pliy;\n\nP2.2 = Pliz;\n\nPlaneFramPoints( &P0, &P1 , aP2 , Sg FOVBottemPlane };\n\nWesnFOVCheck(VECTOR “paaphereros ,\nTloat BSphereRadius, VECTOA \"pViewPos)\n\nfloat Dist;\n\nTransform 2 inta view space\n\npviewPos->z = g ViewTransform, 13 * pagpherePos->x +\ng_ViowTranstorn. 23 * paspherePos->y +\ng_ViewTranstorn. 33 * paSpherePos->z +\ng_ViewTransforn. 43;\n\nBehind front clip plane?\nAf{ ( pWiewPos->z + BSphereRadius ) < 9 FOvFrontGlip }\nréturn FALSE:\n\nBeyand the back clip plane?\nif( { pWiewPos-*z - Bopherefadivs } * 9 FOVBack¢lip }\nreturn FALSE;\n\nTransform X into wlew space\nPViewPos->x = g ViewTransform._11 * poSpherePos->x ¢\ngViewlrangforn. 21 * paspheraPas->y +\n\n4.2 Object Occlusion Culling\n\nQg _ViewTranstorn. 3) \" paopherePos->z +\ngq ViewTransfarn. 41;\n\nfi Test against Left clip plane\nDist = ( pliewPos->2 \" 9g FOVLeftPlane.a } +\n{ P¥iewPas->:z \" g FOWLeftPlane.c };\nif[ Dist > BSphereRadius }\nreturn FALSE:\n\nff Test against right clip plane\nDist = ( pWiewPos->~ * g FOVAignhtPlane.a ) +\n{ pViewPos->2 \" g FOWAignhtPlane.a };\nif{ Bist >= BSpheareRadius }\nreturn FALSE;\n\nff Transform ¥ into view space\nPViewFos->y = 9 ViewTransform. 12 \" p&SpherePos->x +\nB_ViewTranstorm, 22 * poSpherePos->y +\ng_ViewTranstorm, 32 * paSpherePos->z +\no_ViewTransform, 42;\n\nff Test against top clip plane\nDist = ( p¥iewPos->y * g FOVTopPlane.b ) +\n{ pPViewPos->7 * g FOWToapPlane.¢ };\nif Dist > Bapherefadius }\nreturn FALSE;\n\nfi Test against bottem plane\nDist = [ p¥iewPos->y * g_FOVeottemPlane.b | +\n{ pWiewPoe->2z * g FOWBottosPlane.c};\nif{ Dist > BSpherafadius }\nreturn FALSE;\n\ni} Mesh as inside the field of view\nreturn TAWE;\n\nListing 4.5.2: Occlusion Culling Code\n\ntypede? struct OCCLUSION\n{\nVECTOR PO;\nVECTOR Pi;\nVECTOR P2;\nVECTOR PS;\nfloat Minz\nPLANE FrantPlane;\nPLANE FirstPlane;\nPLAME S2condP lane;\nPLANE ThirdPlane;\nPLANE FourthPlane;\n}OOCLUSION;",
      "page_number": 413,
      "chapter_number": 43,
      "summary": "The occlusion provides a culling method that will work on arbitrary\nand dynamic geometry data Key topics include plane, occlusion, and occlusions. This means the mesh data doesn't have to contain any\ninformation about the potentially visible data set.",
      "keywords": [
        "Culling Tim Round",
        "Tim Round Occlusion",
        "Occlusion Culling Tim",
        "Round Occlusion culling",
        "Occlusion Culling",
        "clip planes",
        "Object Occlusion Culling",
        "plane",
        "Tim Round",
        "Occlusion",
        "view",
        "Culling",
        "field of view",
        "front clip plane",
        "view culling"
      ],
      "concepts": [
        "plane",
        "occlusion",
        "occlusions",
        "vector",
        "view",
        "culling",
        "mesh",
        "meshes",
        "tested",
        "space"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 8",
          "chapter": 5,
          "title": "Segment 5 (pages 41-49)",
          "relevance_score": 0.49,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 40,
          "title": "Segment 40 (pages 394-404)",
          "relevance_score": 0.45,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "Segment 34 (pages 326-336)",
          "relevance_score": 0.45,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 3,
          "title": "Segment 3 (pages 23-30)",
          "relevance_score": 0.45,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 35,
          "title": "Segment 35 (pages 337-346)",
          "relevance_score": 0.44,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 44,
      "title": "Segment 44 (pages 422-430)",
      "start_page": 422,
      "end_page": 430,
      "detection_method": "topic_boundary",
      "content": "| 2\n\nSection 4 Polygonal Techniques\n\nwold VectorMatrixMultiplygx4 (VECTOR “pNewvector ,\n\nf\n}\n\nWECTOR *pve@ator , MATAIN “pltatrix)\n\nvead SetupOcclusian (OCCLUSION *pOcclusion ,\n\n{\n\nif\n\nfi\n\niif\n\nif\n\nMATRIX *o¥ieeTransform}\nWECTOA PO , Pi , P2 , Po , Camera:\n\nTranéferm points form world space to view Spice\n\nVectoriatrixMultiplydad( &°0 , SpOcclusion->Po ,\npViewTranstorm) ;\n\nVectoriatrisMultiplyaz4( 41 . ApOcclusien->P4\nPViewTranstorn):\n\nVectorMatrimMultiplyaa4( &P2 , spocclusion->P2\npP¥ieeTranstforn} :\n\nVectorlatrixMultiplyge4{ £P3 , Spd0celusion->P2 ,\npViewTransforn} :\n\nr\n\nPoot lusion-=Ming = Po.zs\n\nif{ P1.2 = pOeclusiLon->Winr)\npoeclusion--Winzd = Pi.z;\n\nif( P2.2 = pOcolusion->Minz)\nPOcclusdon-*WinZ = P2,z;\n\nfi PS.z = pOcelusion->Minz)\nPOcclusion-sWin? = PS.z;\n\nThe camera position in view space is 0,0,0\nCamera. x =O. Ot:\nCamera.y=0.01:\nCanara. 2-60.00;\n\nGreate front plane fron first three points\nPlaneFromPoints(&P0 , &P1 , &Fz , &plcclusion-2FrontP Lane);\n\nTest the 0 co-effecient to find which way the\nocclusion Taces\nif(p0celusion->FrantPlane.d > 0.0f}\n\n{\nPlaneFromPoints( &Ganera , SFO , ai ,\nSpdeclusion-=FirstPlane} ;\nPlaneFromPoints{ SGamera , &P1 , ap? ,\nhp0ce lusion->SacondPlane) ;\nPlaneFromPoints( &tanera , &P2 , &Pa ,\nSpec liéioan->ThirdPlane) :\nPlaneFromPoints| ACamera , &F3 , &Po ,\niphoclusion->FourthPlane) ;\n}\nelse\n{\n\nPlaneFromPoints( &P2 , APi , 4Pd\nEplcclusion->FrontPlane) :\nPlaneFronPoints{ &Gamera , &P1 , aro ,\n\n4.8 Object Occhusion Culling\n\n}\n\n&pOcclusion->FirstPlane) ;\nPlaneFronPoints( Gamera , SP? , &Pi ,\n&pOcelusion->SecondFlane) ;\nPlanaFronPoints( EGamera , SFG , &P2\n&p0celusion:>ThirdPlana) ;\nFlaneFromPoints( &Camera , SFO , GPS\nSpOcelusion->FourthP lang) ;\n\nBOOL TestifOceludad (OCCLUSION *pOeclusion ,\n\n{\n\nVECTOR \"p¥ilewFos , Tloat BSphereAadius)\nfloat wind:\n\nMing = pViewPos-=z - Bapherefadiue:\n\nif{ pOcelusion->Wing = Winz j\nreturn FALSE;\n\na7{ ¢ | p¥iewPos->x * pOcclusion-*FrontPlane.aj 4\n(pViewPos->y \" pOcclusion-=FrontPlane.b) 4\n(pViewPos-z \" pOcclusion-=FrontPlane.c) 4\npocclusion-=FrantPlane.d) > BSphereAedius |\nreturn FALSE:\n\naft { ( pviewPos->x * pOcelusion->FirstPlane.aj +\n(pViewPos-sy * pOtelueion->FirstPlane.b) +\n(pviewPos->z * pOeelusian->FirstPlane.c) +\npOcelusion-*FirstPlane.d) > BSphereRadius |\nreturn FALSE;\n\nitt [ ( pViewPas->x * pdcelusion->SecondFlane.a) +\n(pviewPos->y * pOeclusion->SecondPlane.b}) +\n(p¥viewPos-*2 * picelusion->SecondPlane.c} +\nptcclusion-*FirstPlane.d) = BSphereAadius |\nreturn FALSE;\n\nif, { ( p¥iewPos->x * pdcelusion->ThirdPlang.a) +\n(pviewPos-2y * pOeelusion->ThirdPlane.b) +\n(p¥iewPos-2z * pOcelusion->ThirdPlane.c} +\npOcclusion-*FirstPlanée.d) > BSpheraAadius }\nreturn FALSE:\n\nif{ [ { p¥iewPos->” * pdeclusion=>+FourthPlane.a) +\n(p¥iewPos->y * pOtcelusion->FourthPlane.b} +\n(p¥viewPos->2 \" pOcelusion-+FourthPlane.c} +\npOtelusian-=FirstPlanc.d) = BSphereAadiue |\nreturn FALSE;\n\nreturn TRUE;\n\n4.9\n\nNever Let ‘Em See You Pop—\nIssues in Geometric Level of\nDetail Selection\n\nYossarian King\n\nObjects and characters are represented in computer graphics as geometric models.\nModels can be created ar different levels of detail (LODs), with more polygons and\nanger textures for the more detailed models, and fewer polygons and smaller textures\nfor the less detailed models. Why would you want to do this? To improve rendering\nperformance and visual quality, Drawing fewer polygons when objects are far away\nfrom the camera reduces the palygon count of the scene, and so speeds up rendering.\nHaving a more detailed model for use when an object is close to the camera improves\nvisual quality. If only a single model is used, then there is always a tradeoff between\nperformance and quality—multiple levels of detail help to achieve both.\n\n‘To implement LOD rendering, multiple models are created at different levels of\nderail, and the model to be rendered is chosen, each frame based on distance from he\ncamera. As a rough rule of thumb, each level of detail should have about twice che\nnumber of polygons as the preceding level, The models are created to reduce “pop:\nping” as much as possible—when the character or object switches from one level of\ndetail to another, the visible change in geometry (especially at the silhouette edge) and\ntexturing must be minimized. The artist's job is to create models thar are as similar as\npossible when rendered at the scale where the transition will occur. The programmer's\njob is to determine when to change LODs to achieve the desired performance and\nquality while minimising the number of LOD transitions. This article explains how.\n\nNote thar for objects or characters that stay a relatively constant distance from the\ncamera (such as the hero character in a thircl-person game), level of derail selection is\nnot necessary. Also note thar this article docs not address level of detail issues for ter-\nrain rendering.\n\n4.9 Wever Let ‘Em See You Pop 433\n\nLOD Selection\n\nThe simplest way to select which level of detail to render is to apply a threshold to the\ndistance of the object from the camera. For example, use the high detail model when\nthe objece is closer than 500 units, the medium derail model for distances of\n300-1500 unis, and the low detail model when the object is further than 1500 units\nfrom the camera. Ac first glance this seems reasonable—when the object is closer, use\nmore detail; when it is farther away, use less derail—however, there are two problems\nwith this method.\n\nFirst, it doesn’t account for che field of view of the camera. If the object is a long\nway from the camera, but the field of view is very narrow (e-¢., 2 zoom lens) then the\nobject may appear large on screen, and a derailed model may be appropriate. Simi-\nlarly, an object may be relarively close co che camera, bur if the field of view is very\nwide (a macro lens), then the object may appear small on screen and a low detail\nmodel should be used. Figure 4.9.1 shows thar the same object at the same distance\nfrom the camera does not always appear the same size on screen. Rather than distance\nfrom the camera, we really want to use the projected size of the object on the screen as\na basis for choosing the detail level. Size on screen is obviously related to distance\nfrom the camera, but che field of view must also be accounted for.\n\nThe second problem with the simple distance threshold approach is that if the\nobject remains close co the threshold distance, then there may be rapid toggling back\n\n————\n—— ——— =e\n——\na\n——\noe\npels\na\na\neal bite\nHe oS\nSs &\na a\nSha ~\na\n=\nFee ee\nary\n\nFIGURE 4.9.1 Varying the field of view changes the projected size of objects om the screen.\nTep: A narrow field of view produces a larger image on screen. Barter: A wider field of view\nproduces a amaller image. In both cases, the size of the mee and the distance from the tree to\nthe camera are the same, demonstrating thar camera distance is not sufficient for choosing\nhewel of detail.\n\n434 section4 Polygonal Techniques\n\nand forth benween levels of detail. This can happen when a character is running across\nthe field of view close to the threshold distance. Popping once from one level of derail\nto another might be noticeable, but rapid cycling back and forth berween levels will\nbe very distracting and undesirable.\n\nFortunately, both of these problems are easily solved. A better aluernative to cam-\nera distance is a “magnification factor,” which is the screen size of the object relative ro\nits physical size, As chis ratio increases (i.e., as the object grows larger on screen), we\nchoose higher levels af detail. Screen size accouncs for both camera distance and ficld\nof view, so the firer problem is climinated. The magnification factor is cacy to calcu-\nlate, as explained in the next section.\n\nThe problem of rapid popping back and fordh is solved by using hysteresis thresh-\nolding. Normal thresholding selects an ourput based on applying a single chreshold to\nan input valuc. Hysteresis thresholding uses an upper and a lower threshold, and\ndecides which to apply based on the previous output value. As long as the input value\nremains between the upper and lower threshold, che output value doesn't change, thus\nstabilizing the thresholded ourput and, in our case, maintaining stabiliry of LOD\nselection. Details are described later.\n\nMagnification Factor\n\nThe screen size of an object could be determined by transforming and projecting the\nhighest and lowest point on the object and subtracting the screen position of cach\ncoordinate to get the screen height. This method depends on the orientation of the\nobject, and requires processing two points. The magnification factor is simpler to\ncompute and is independent of orientation. It can be computed by transforming the\nobject position into view space and then calculating:\n\nff = erealel crete\nwhere ascefr is the sealing parameter used in the projection equation:\nsconce = (spew “seule ) fevtew + center\n\nSince view coordinates are just a rocation and translation of the world coord|-\nnates, zview is measured in world unies. xeele, which relates to the camera field of\nview, has pixel units; hence, the magnificarion factor Af measures pixels per world\nunit. As Mf increases, there are more pixels per world unitz—the object is relatively\nlarger on screen and therefore should use a higher level of detail, Nore chat JM is simi-\nlar to the level of detail used for interpolating mipmapped textures, bur in the case of\nmipmapping, pixels-per-texel are che measure of interest.\n\n‘7 accounts for both camera <listance (via sede) and field of view (via xwezle), and\nmakes a much better choice for determining level of detail selection chan simple cam-\nera distance. However, applying a simple threshold to Af will have the same popping\nproblems described previously, Hysteresis thresholding is the solution.\n\n49 Never Let ‘Em See You Pop 435\n\nHysteresis Thresholding\n\nHysteresis thresholding is a fancy term for thresholding against a range of values,\nrather than a single value. A simple threshold Tis applied as:\n\nantput =f) ifiepur > = T\n{0 inpet < “h\n\nHysteresis thresholding uses an upper and a lower threshold and remembers the\nprevious ourput value, The output doesn't change if the input is berween the upper\nand lower thresholds:\n\n{2 ifiuput >= Tiga\nantpuit) = {OsF input < I.\nfontpra(t—l) otherwite\n\nTf the inpuc is increasing, then the output wall be 0 until the input reaches Ties if\nthe input is decreasing, then the output will remain | until the input falls below Ty,\nRegardless of whether the value is increasing or decreasing, the output doesn't change\nwhen the input is berween the upper and lower thresholds. Using chis approach for\nlevel of deeail selection means there is no single point at which che object will toggle\nback and forth between levels of detail—the hysteresis cheesholding ensures thar all\nwe get is a single pop, never a toggling behavior. A visual comparison of simple\nthresholding and hysteresis thresholding is shown in Figure 4,9_2_\n\nImplementation\n\nWith the magnification faecter and hysteresis thresholding we can create a level of\ndetail selection algorithm that accounts for camera field of view and avoids rapid pop-\nping problems. Assume we have models for three levels of detail: high, medium, and\nlow. The hysteresis thresholds for moving between high and medium detail are ff aoe\nand Titer Phe thresholds for moving berween medium and low detail are Txygyper atid\nF eiue- In pseudocode, the level of detail selection algorithm looks like this:\n\nint computelod:\n\nworldpes world position of the abject\n\nlodprey devel of detail chosen in previews frame\n\nviempos = transfore{ worldpos }\nM= xscale / viewpos.z\n\nif { W< T_mlower j\n\nlod = low\nelse if ([ M = T_muppar }\nlod = lodprev hysteresis range for sediuo/low\n\nglee if ( M = T hlowar }\nlod = medium\naloe if ( M = T_hupper }\n\n436 section 4 Polygonal Techniques\n\ncotput Simple Threshold cat put Hysteresis Threshold\n\na\nIngs Tow Thgs 9 =F\n\nFIGURE 4.9.2 Cefi: An input value is thresholded agains: a single threshold 7, Right: An input value is\nthresholded against hysteresis thresholds T),..and 7j,,, with the appropriate threshold chosen based on\nthe preceding output valuc. As long as the input remains beoween T),,, and Tyas Ubere is no change in the\noutput.\n\nled = lodprev hysteresis range for high/sedion\nelse\n\nlod = high Wo>= T_hwpper\nreturn lad\n\n}\n\nNote thar if Mis berween Tj. and T).20 then chis will always recurn che pre-\nvious level of derail, even if it was low detail. IF you expect your object to be magnify.\ning this quickly, then the algorithm is easily adapted.\n\nThe equivalent algorithm using a simple distance threshold would just use onc\nthreshold berween each level of detail, and would look like this\n\nint computelotwithpopping:\nwarldpos\nq\n\nViewpos = transfora( worldpos }\n\nif { viewpos.z = Tm }\nlad = Low\n\nGlee if ( viewpos.z =< Th }\nlod = mediun\n\nelse vieKpos.7 = Toh\nTod = high\n\nreturn lod\n\n4.9 Never Let ‘Em See You Pop 437\n\nee\n\nAs can be seen, solving the field of view dependence and popping problems does\nnot add significantly co the complexicy of the level of detail selection.\n\nOther Issues\n\nThreshold Selection\n\nFor any thresholding method, hysteresis or otherwise, you meed to choose your\nthresholds. For level of detail selection, choasing the thresholds is a tradeoff berween\nperformance and visual quality. [f the thresholds are set too low, then the higher levels\nof detail will be drawn more often, and you will have to render more polygons per\nframe, which will slow down the rendering. If the thresholds are too high, then che\nlower quality models will be drawn more olten, and popping between levels will be\nmore mociccable.\n\n‘To reduce popping, you can implement the selection algorithm, then move che\nobject toward and away from the camera, moving the thresholds until che popping is\nacceptable. Keep in mind tharin a game-play situation with a moving object, moving\ncamera, and distracted user, the popping will be less noticeable than in a testbed envi-\nronment. Achieving performance targets is a combined effort by che artist and pro-\ngrammer to reduce the polygon counts and adjust the thresholds to achieve a suitable\nbalanoe\n\nUser Alfention\n\nSo far, we have only considered rhe size of an object an screen to determine which\nfewel of detail to render. Another factor to consider is where the user is looking. In\ngeneral, we expect the user to be paying artention ro things that are close to the cam-\nera, but we may have additional knowledge abour the particular game situation to\nhelp us know where the user is probably looking. For example, in a sports game, a\nplayer character controlled by the user will probably be che focus of attention, as will\na player character wich the ball, or one involved in the current play. This “expected\nfocus of attention” can be used in the level of detail selection algorithm by biasing the\nmagnification factor when che user is likely to be watching an object or character. In\nthe sports game example, we can multiply the magnification factor by a scaling para-\nmeter (e.g., 1.1) when the character is under user control.\n\nBiasing the Magnification Factor\n\nThe idea of biasing the magnification factor can be used in other ways as well. If there\nis a game situation in which rendering quality is more importance than performance\n(such as a non-interactive rendered cue scene), the magnification faceor for all objects\ncan be biased higher in order to render objects at higher detail. Or the magnification\nfactor can be biased dynamically depending on frame rate—when frame rate drops,\nbias the magnification lower to select more lower polygon models and improve che\n\nframe rate,\n\nSection4 Polygonal Techniques\n\nLimiting Number of Modals or Polygons\n\nIfa scene has multiple instances of the same object, chen there may be limits on che\nnumber of objects that can be rendered at each level of detail. Such constraints may be\nimposed in order to conserve memory in the object representation, or you may sim-\nply wish co limit the maximum number of high polygon models in order to improve\nperformance. Limits on che number of models at cach level of detail can easily be\nbuilt inte the selection algorithm—sort the objects by magnification factor, and then\ntake the M largest objects ar each level of detail, demoting any remaining object wo the\nnext lower level of detail. With a little moze work, the selection algorithm can be\nmedified to select objects sa the total polygon count for all objects falls below some\n\nGurger.\n\nProgressive Meshes\n\nA final issue worth mentioning is the use of progressive meshes, or other dynamic\nlevel of detail methods. Increasing processor performance and increasing polygon\ncounts in game models are starting to make these techniques feasible, With these\ntechniques, the polygon count of objects can be varied on the fly across a continuous\nrange. A suitable polygon count still needs to be chosen for each frame, and so the\nmagnification factor is still useful. If polygon counr varies continuously, then hystere-\nsis thresholding is mo longer needed. However, this may cause distracting popping\neffects as polygons are continuously dropped from or added ro the model, so it may\nstill be desirable to use hysteresis thresholds ro decide when to change the polygon\n\nOOUNnNT.",
      "page_number": 422,
      "chapter_number": 44,
      "summary": "This chapter covers segment 44 (pages 422-430). Key topics include threshold, object, and camera. To improve rendering\nperformance and visual quality, Drawing fewer polygons when objects are far away\nfrom the camera reduces the palygon count of the scene, and so speeds up rendering.",
      "keywords": [
        "level of detail",
        "Detail",
        "Object",
        "Level",
        "Camera",
        "Detail Selection",
        "magnification factor",
        "threshold",
        "hysteresis",
        "detail selection algorithm",
        "field of view",
        "Hysteresis thresholding",
        "view",
        "Selection",
        "low detail model"
      ],
      "concepts": [
        "threshold",
        "object",
        "camera",
        "level",
        "polygonal",
        "polygons",
        "pop",
        "popping",
        "selection",
        "select"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "Segment 48 (pages 456-465)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 48,
          "title": "Segment 48 (pages 469-476)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 32,
          "title": "Segment 32 (pages 306-318)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 47,
          "title": "Segment 47 (pages 453-467)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 45,
      "title": "Segment 45 (pages 431-441)",
      "start_page": 431,
      "end_page": 441,
      "detection_method": "topic_boundary",
      "content": "4.10\n\nOctree Construction\n\nDan Ginsburg\n\nCulling geometry for visibilicy deterrnination and collision detection is a problem\nthat must be tackled in the development of nearly every 3D engine. There are nurmer-\nous data structures and approaches to the problem. Most solutions pur constraints on\nthe geometry and often require the 3D artises to explicitly provide information such\nas portal locations to the engine. However, an octree is a simple dasa structure that\nean be used to spatially subdivide geomenry of any form.\n\nThis article deals with the specific steps required co take an input set of polygons\nand construct an octree that spatially partitions the geomeny. The octree is best suited\nto static terrain, bur can also be usec to store attachment lists for objects that move\ndynamically in a scene. An octree can be used as a complere solurion for visibility\nculling, collision detection culling, and object management.\n\nOctree Overview\n\nAt the highest level, an octree is simply a tree (an acyclic directed graph) with a maxi-\nmum. of cipht children ar every node. It turns out chat this is an ideal structure for rep-\nresenting a three-dimensional world enclosed by cubes. The rooe node of an octree\ncontains a cube har encloses all the geometry in the world. The children at each node\nare the eight cubes of equal size that subdivide the parene into octanes (see Figure\n4.10.1). Subdivision stops when some user-defined heuristic is met: qypically, either\nthe bounding cubes are of a certain size, or some minimum number of polygons are\ncontained within each mode,\n\nThe bouncing cubes at cach node are the key to using an octree for spatial subdi-\nvision. Fach node contains pointers to all of the polygons that lie within ics volume.\nGiven this information, one can begin to see the power of the data structure. For vis-\nibility determination, the axis-aligned bounding cube of the root node of the tree will\nbe tested againse the view frustum. If it is fully visible, all of its geometry will be ren-\ndered. If partially visible, traversal will continue down te the children, If it is com-\npletely ourside the view frustum, traversal can stop: it and all of its children are not\nvisible. Further examples of using octrees will be presented later. However, first in is\nnecessary tO examine the specific steps required ta construct an octres.\n\n430\n\n440 Section4 Polygonal Techniques\n\nFIGURE 4.10.1 Subdivision of a cube into oceans.\n\nOctree Data\n\nPartitioning the geometry using an octree is a step that is cypically performed ar the\npre-processing stage. Some tool will take the input set of geometry and produce occree\ndata as output thar can be used at run-time by the application.\n\nAta minimum, each node in the octree must contain the following data:\n\n* Bounding Cube—This is the cube in space thar the node of the occree encloses.\n\n* Geometry List—Each node encloses a number of polygons; these must be stored\nin some way at each node.\n\n* Children—Each node can have up co eight children; pointers to cach of these\nmust be stored at every node,\n\n* Neighbors—Each nede can have up to six neighbors (one for each of the cube\nfaces), Tree craversal for collision detection requires that each node have pointers to\nall of its neighbors. The scighbors allow the collision algorithm to quickly “step”\nthrough the tree along a collision ray. This will be discussed in more desail later.\n\nBullding the Tree\n\nThe first step to building the octree is eo get a list of all che polygons in the world.\nOnce this list has been created, the root node of the octree can be constructed. The\nlargest absolute value Vfor any component X, Y, or Zin the vertex list is determined,\n\n4.10 Octree Construction 444\n\nThis value is used no create the bounding cube for the world (it spans from [-V, -¥, -\nVj two [V, MV). By definition, the geometry list for che root node will conrain all the\npolygons in the world. Starting with this root node, the world can now be subdivided\nrecursively using am octtee. Here is preudecode for the building algorithm:\n\nBuildgctree (Mode Ny)\n{\n\nif (iumPolys (Nj) > POLY THRESHOLD)\nfor(int i = 0; i =< 8; ite)\n\nBuildhede(M-=Child[i], £, WM);\nBuilddetree(N-=Child[ ij};\ni\nI\n\nBuiledetree() creates all cight children for any node that contains more than the\nminimum threshold number of polygons. Creating all eight children simplifies the\nrun-time code by allowing it eo always assume chat if any children exist for a node, all\neight do. If this assumption was not made, there could be nodes without neighbors,\nwhich would make traversal for collision detecsion difficult.\n\nThe heart of Builddetree() is Builoxede(), which creates the node dara. This\nperforms we steps:\n\n1. Creates the bounding cube far the node,\n2. Determines which polygons lic within che node's cube.\n\nCreating the bounding cube for the node is trivial. The index é can be used to\nspecify which octane the node lies in. The box will then he fully determined by taking\nthe parent's box and pantitioning it appropriately. ‘The box will have half che width,\nheight, and depth of the parent's box, and will be centered at one of eight positions,\ndepending on i.\n\nDetermining which polygons lie within che bounding cube is slighrly more emt:\nplicated. Before addressing this, it is worth addressing how to store the polygen list at\neach node. Obviously, it would be hugely memory inefficient vo store copies of the\npolygon ar every node in the tee. A polygon can exist within several nodes: a parent\nwill always contain a superset of the polygons in its children. Additionally, polygons\nmight span across node boundaries. One solution to this problem would be to split\nthe polygons along the boundaries. However, this generates additional polygen daca,\nwhich could adversely affect run-time performance. Instead, the polygons will have a\n“frame count” value, and the run-time render code will be responsible for making sure\nthat each polygon is rendered only once per frame.\n\nOne possible approach to storing the geometry for each node is no store a list of\narea IDs. Then, elsewhere in the builder, for each area ID a list of indices into a shared\npolygon rable will be stored, This requires very little data at each node and ensures\nthat polygons will not be duplicated when they span multiple nodes.\n\n442 Section 4 Polygonal Techniques\n\nPolygon Overlap\n\nGiven the solution for storing polygon lists at each node, the mext step is to create an\nalgorithm for determining whether a polygon lies within a cube. A fast method for\ntesting whether a triangle intersects a voxel is presented in [Moller?9] (Section 10,9).\nA voxel is a cube centered ar the origin, with cach edge having a length of one. It turns\nour thar this algorithm can casily be expanded for resting whether a triangle intersects\na world-aligned cube of any size, The crick is to determine whar cranslation and scale\nwill eransform the cube into a voxel. Then, chat transform is performed on each wi-\nangle, Each transformed triangle is chen tested for intersection with a voxel. Here is an\n\noutline of that alporichm:\nTrilmGuba(Tri T, Cube ¢)\n|\n\nVector Trané= ¢.fenter;\nVector Scale= 1.0 / G.5ize;\n\nfor (int i= O; 4 = 3: d++)\nTiWert[ij= (T.Ver¢[i] — Trans) | Scale;\n\nif (TrilnVoxel (Th)\nreturn true;\n\nreturn false;\n\nNeighbors\n\n— EE EES EE EEE EE ES a\nThe primary components of each octree node are now filled in: the bou nding cube,\nthe geometry list, and the children. This is all the information needed for visibility\nculling. However, in order to use the octree for collision detection, the neighbors co\neach of the six cube faces must be determined. A neighbor for a given cube face is\ndefined to be the node of equal size or grearet that touches it. A neighbor can never be\nsealler, and the algorithm will search for the best-fit neighbor (e.¢,, the smallest pas-\nsible that is no smaller than the node).\n\nThis step needs to be performed after the tree has been fully constructed once all\nof the nodes have been created. The algorithm works by wking each cube face of each\nnode and comparing it against the cube faces of the other modes in the tree ar the same\nlevel or higher. Several conditions must be met in onder for po cube feces po be con-\nsidered neighbors:\n\n* The normals of the faces must be in opposite directions.\n* All the vertices in the source face lic on or inside the destination face.\n* The size of the source face is Jess than or equal to the size of the destination face.\n\nThe cube that meets all three conditions and has the smallest size is considered lc\nbe the neighbor.\n\n4.10 Octree Construction 443\n\nApplications\n\nAs discussed previously, one application of the constructed octree is for visibiliry\ndetermination of static geometry. However, the octtee can also be used for managing\nthe visibiliry of dynamic objects in the world. Each ectree node in the run-time code\ncould store a list of attachment objects, and cach objece in the world could store a list\nof nodes it is attached to, Then, to render che scene, the terrain polygons in each vis-\nible node are rendered, as well as all objects attached to the mode. When an object\nmoves, it detaches itself from all che nodes it is attached to, and re-artaches ro whar-\never new nodes it now lies within. The only trick is to again store a “frame counter\"\npet abject to make sure ic only gets rendered once per frame (since an object could\neasily span multiple nodes).\n\nThe octree can now also be used for culling in collision detection. Consider the\nsimple case of a ray collision test. Two points define a collision ray: a start and an end\npoinc. The collision test begins by finding che leaf node of the actree thar the scart\npoint lics within, The segment is broken into a subsegment at each abe face it inter-\nsects. The mew subsepment is tested againse all the geometry and objects within its\nnode, ‘The next subsegment starts ar the end poine of the previous subsepment, in che\nnode that neighbors the cube face thar it intersected. This traversal through neighbors\ncontinues, colliding with the geomerry and objects at every node until the original end\npoint is reached, Several other collision tests such as axcis-aligned box and sphere cests\nalso work very well when using che oceree.\n\nConclusion\n\nThe octree is a usctul data structure in building a simple geometry culling syscem.\nThis article ts meant as a simple introduction in how 19 build an octree. There are fur-\nther optimizations and enhancements that can be made to the seructure in order to\nimprove its run-time performance as well as usefulness (c.g., adding occlusion culling\nand depth sorting). Please see che references for pointers to further informacion on\noctres and their applications in 31D graphics.\n\nReferences\n\n[Foley87] Foley, van Dam, Feiner, and Hughes, “Computer (sraphics: Principles and\nPractice 2™ Edition”, 1987, p 350-555,\n\n[Hoff] Hoff, Kenny, “Gov ABBR View-Frestiam Opetap Ter\" wwe.cs.uncedu!-holf!\nreearch/vtculler!/boxvdie/boxyfe html\n\n[Moller?9] Moller and Haines, “Real-Time Rendering”, 1999, p. 206-211, 310-312,\n\n[Suter?9] Suter, Japp “Introduction to Octrees” April 13, 1999, wweeflipcode.com/\ntutorials!tut_ocorees shel\n\n4.11\n\nLoose Octrees\n\nThatcher Ulrich\n\nThe octree is a classic anc effective data structure for partitioning 3D darasets into\nhierarchies of bounding volumes. For datasecs with a lot of objects, octrees can greatly\naccelerate frustum culling, ray casting, proximity queries, and just abour any other\nspatial operation.\n\nHowever, ordinary octrees do have a few disadvantages. In this arricle, I will focus\non one disadvantage in particular, which is char a small object, depending on tts loca-\ntion, may be stored in an octree node with a very large bounding volume. This hap-\npens when an object straddles the boundary plane berween owo Large nodes. This\ncreates “sticky” areas in the partitioning hierarchy, keeping small objects high in the\nwee hierarchy and reducing the effectiveness of the partitioning.\n\nThere are various methods of adjusting the basic octree data structure and algo-\nnithms to mitigate or avoid this problem, and cach method has its unique tradeoffs. In\nthis amticle, I present one such alternative, the “loose octree.” Its primary advantage\nover an ordinary octree is that it avoids stickiness in the object partitioning, resulting\nin more precise spacial database queries. For certain applications, such a5 murual col-\nlision detection between numerous moving objects, the efficiency gain can be sienifi-\ncant, There is an additional minor side berscfit, in that computing a given object's\ndesired node in the tree is a simple O/) operation. A similar trick can be done using\nordinary octrees, but it’s not as straightforward,\n\nIts main weakness is that it tends to use more partitioning nodes for a given\ndataset than an ordinary octree. Limiting the depth of the cree can mitigate this, bur\nirs something to be aware of\n\nQuadtrees\n\nThe octree ts a 31D data structure. The analogous 21D data structure is the quaderee,\nwhich shares the same basic properties. This remains true of loose quaderees; they are\njust a 2D version of loose octrees. Loose quadetrees have the same cradeofls as loose\noctrecs, with respect to their conventional counterparts, 50 they can be useful in appli-\ncations thar only require hierarchical partitioning in owo dimensions.\n\n4.11 Loose Octrees 445\n\nSince irs much easier to visualize these data structures in 2D, in this artide I'm\ngoing to use 2D) diagrams based on quaderees, However, the octree principles are\nexactly the same, and the extension to 3D is straightforward.\n\nBounding Volumes\n\nIna conventional octree, the basic node bounding volume is a cube. All objects asso-\nciated with a node must be contained completely within the node's bounding cube.\nFach nede may also have up te eight child nodes, whose bounding cubes are formed\nby slicing the parent cube into eight equal sub-cubes. The quadtree version is illus-\ntrated in Figure 4.11.1.\n\nThe bounding volumes of the child nodes nest perfectly within the bounding vol-\nume of the parent node, filling the entire space with no overlap. The child nodes can\nbe further subdivided the same way. If you examine the sizes and spacing of the\nbounding velumes, you can see thar they follow a regular pattern, Consider the edge\nlength of the bounding cubes: ar the root of the tree, che cube edge length is equal to\nthe world dimensions. Ar each level deeper into the tree, the cube edge length is half\nthe size of the previous level's cube edge length. Thus, che formula for bounding cube\nedge length is:\n\nLfdepth) = Wi (2 * depeh)\n\nwhere Wis the world size, and depth is the number of levels by which a node is sepa-\nrated from the root. The root node has depth 0.\n\ni\ni\ni\ni\n1\nue\ni\ni\ni\nLy\n1\n1\ni\n\nFIGURE 4.11.1 A quadtree node, shown with bounding square in bold, subdivided along\ndotted lines. Fach quadrant becomes a child node, The child nodes can also be subdivided as\nchown in the upper-neht quadranc.\n\n446 Section4 Polygonal Techniques\n\nThe spacing of the bounding cubes’ centers ara given depth follows the same pat-\ntern, Ar the reor there's only one mode, so node spacing doesn't really have any mean-\ning, but starting at depth 1, the centers of the reor's child nodes are spaced W#2 units\napart from their neighboring nodes. Each subsequent level curs the node spacing in\nhalf, The formula for node spacing is:\n\nStdepeh) = W's (2 * depah)\n\nSo, for a given depth, che cube edge size and the node spacing are identical. This\nmakes sense because at a given tree level, the bounding cubes are perfectly packed into\nthe world volume with no gaps and no overlap.\n\nPartitioning Objects\n\nGiven a set of objects in a virtual world, each object having some finite bounding vol-\nume, an octrec can be used to partition the objects within the world space, to acceler-\nate various spatial operations such a¢ frustum culling, ray casting, proximity tests, etc.\nDifferent criteria can be used for partitioning, but the classic octree partitioning\nscheme is to associate a given object with the mode in the octree whose bounding cube\nmost tightly contains the entire object volume. This node can easily be found by a\nfecursive craversal of the tree. Here is some pseudocode:\n\nstruct node {\nVectora CubeCenter;\nnede* Child[ey(z)(2);\nObjectlList Objects;\n\nint Classify(plane p, volume v])\n\nif [v 2s completely brhind p) {\nreturn O\n}) else if (v is completely in front of p) {\nPeturn 15\n} else {\n{i wo atraddlas p.\nreturn 2;\n\nvoid InsertObjectintotres(node* n, Object* o}\n\nint xe = Classity(plana(1,0,0,Cubeatenter. x),\n0. Bounding¥olume) ;\n\nint yo = Glassify(plane(0,1,0,Cubatenter.y),\no.Bounding¥olume) ;\n\nint z¢ = Glassity(plane(0,0,1,CubeaCenter.z),\no,.BoundingVolume) ;\n\n4.11 Loose Octhrees 447\nI\n\nif (xe = 2 || yoe= 2 |] ze == 2) {\n{\n\njf Object straddles one or mora of the ehild\n‘if partition planes, and so won't fit in any\ni} child mode, so store it in this node.\nObjects. Insertia);:\n} else {\nfi Object Tits in one of the child nodes. Recurse to\n!! find the correct descendant.\nInsertobjectInteTres(Ghild[ze][yoj[xe], of;\n\n}\n\nThis is a nice, straightforward hierarchical partitioning scheme that handles\nwhatever you throw at it and generally comes up with a decent partitioning. However,\nithas one disturbing oddity. Nocice that if an object straddles any one of a mode's par-\ntitoning planes, then the object is stored in char node. This happens even if the object\nis tiny and the node is huge; see Figure 4.11.2 for an example, In practice, if you have\nlors of small objects, the ones located along the roor node partitioning planes can\n“clog up® the root mode by filling it with small, poorly partitioned objects, and reduc-\ning the efficiency of spatial operations (c.g., Figure 4.11.3).\n\nPll call this problem the “sticky planes” problem, the idea being thar partitioning\nplanes high in the cee hierarchy attract excess ebjects to their associated nodes, and\nare thus “sticky.” There are various ways to solve this problem. One method is to split\nobjects on partitioning planes and then classify the pieces individually. Another\nmethod is to allow an object to be referenced by more than one node, so an object can\n\nFIGURE 4.11.2 Even though the circle is very small compared to the root node (bold\nsquare), it can't be placed ina child node because it straddles onc of the (domed) parnicioning\nlimes,\n\n443 Section 4 Polygonal Techniques\n\nFIGURE 4.11.3 All of the objects are small, but the shaded ones are suck to higher nodes in\nthe quadtree, duc to straddling the partitioning line.\n\nbe shared by child nodes on cither side of a sticky plane, rather than being stored in\nthe parent node. For static objects, those approaches are effective, but they'te not so\ngood for handling dynamic objects.\n\nMaking It Loose\n\nThe “loose” octree method takes a differenc tack: it solves che sticky planes problem\nby adjusting the node bounding volumes. Specifically, by “loosening” che bounding\ncubes, but leaving the node hierarchy and the node centers as is. The bounding vol-\nume of a node is still a cube, but where in the conventional ocwee the cube edpe may\nhave had length J, in che loose octree the cube edge would be £0, where & > J. Thus,\nthe formula for bounding cube edge length is modified to be:\n\nLidepth) = k* Wi (2 * depth)\n\nHowever, che node spacing remains the same as in the conventional ocoree. Whar\nthis means is that a node's bounding cube now overlaps with the bounding cubes of\nits neighbors. Figure 4.11.4 shows this overlap for a loose quadtree.\n\nThis loosening of dhe bounding cubes increases che minimum size of objects\namracted by a sticky plane. Where previously an object with any size ar all chac crossed\na sticky plane would be stored in char plane's node, with looser bounding cubes,\nsmaller objects will fir within one of the child nodes (Figure 4.11.5). How small must\nan object be to avoid being caughr by a sticky plane? It depends on the tree depth of\nthe plane's node, and on the value we choose for k For a node at a given depth, no\nobject with a bounding radius smaller than (k — J) *£/2 can be stuck oo chat node\ndue to straddling a partitioning plane, Instead, since the child nodes’ bounding vol-\numes have been enlarged, such objects can fic in one of the child nodes.\n\n441 Loose Octress 445\n\nee eee eee\n\nee ee | aS\n\nFIGURE 4.71.4 Pour nodes. The conventional bounding squares are chown with dashed\nlines. The same four nodes in a loose quadtree have bounding squares shown in black. The\nsquares have been offset so that chey can be distinguished from cach other,\n\nSo, whar’s.a good value for 4? Without fully exploring all the tradeoffs in this arti-\ncle, | propose £-2 as a useful all-around value. A wee with £ much less than 2 starts to\nsuffer from the sticky planes problem, and a wee with & too much grearer than 2\nresults in excessively loose bounding volumes.\n\nFIGURE 4.115 The crcle won't fir in any of the conventional child node bounding squares,\nbur ix will fit in the loose bounding square of the lower-right child.",
      "page_number": 431,
      "chapter_number": 45,
      "summary": "This chapter covers segment 45 (pages 431-441). Key topics include node, objects, and cubes. There are nurmer-\nous data structures and approaches to the problem.",
      "keywords": [
        "node",
        "Construction Dan Ginsburg",
        "Dan Ginsburg Culling",
        "node bounding cube",
        "bounding cube",
        "cube",
        "Dan Ginsburg",
        "Octree",
        "bounding",
        "child nodes",
        "Octree Construction Dan",
        "node bounding",
        "objects",
        "che node cube",
        "root node"
      ],
      "concepts": [
        "node",
        "objects",
        "cubes",
        "bounding",
        "partitions",
        "partition",
        "plane",
        "loose",
        "polygons",
        "polygonal"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 37,
          "title": "Segment 37 (pages 368-376)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 18,
          "title": "Segment 18 (pages 162-170)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 34,
          "title": "Segment 34 (pages 317-324)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 38,
          "title": "Segment 38 (pages 377-385)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 35,
          "title": "Segment 35 (pages 347-359)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 46,
      "title": "Segment 46 (pages 442-449)",
      "start_page": 442,
      "end_page": 449,
      "detection_method": "topic_boundary",
      "content": "Section4 Polygonal Techniques\n\nAssuming a loose octree with b=2, we can write an extremely simple object inser-\ntion procedure, The basic principle is that for a given object, che depth of the con-\ntaining node can be calculated solely based on the object's size, and chen the choice of\nthe particular node at thar depch in the tree is based solely on the object's center loca-\ntion. To get che formula for depth, note that a given lewel in che loose octree can\naccommodate any object whose radius is less than or equal to 1/4 of the bounding\ncube edge length, regardless of ins position. Any object with a radius <= L/8 of the\nbounding cube edge length should go in the next deeper level in the tree. For exam-\nple, in Figure 4.11.5, notice that no matter where the object is placed, ic will fit within\nene of the nodes” bounding squares.\n\nHere's the derivation of the level-selection formula:\n\nLidepeh) = 2° Wi (2 * depth)\n\nLet Armaxfdepth) = maximum object radius thar can be accommodated at depth.\nAmax(aepit) = 144 * Cfelepeh) = 112 * Ws (2% dene)\n\nLet depeh(R} = the first cree depth that can accommodate an object of radius R\n\nRe= Rimaexfelepeh(R))\n\nRea VWs depo Rl)\ndepil(R) >= log2{Ws R}— 1\ndepth(R) =~ floor(log2(W s R))\n\nOnce the depils is known, choosing the particular node ata piven depth is sim-\nple—just find the closest node to the object’s center. Assu ming the world is centered\nat the coordinate system origin, the formula to compute the node indices ix:\n\nfndex{x.pe! = floorifobpect. (x, pr) + WI2) / Sfalepth))\n\nNote that chis procedure is not quite ideal: ir does not actually find che tightest\npossible containing node for all cases (see Figure 4.11.6). To get the last bit of tight-\nness, first find che candidate node using the above formulas, and chen cheek the child\nnode nearest to the object to see if the object firs inside it.\n\nPerforming spatial operations on loose octrees is very similar wo conventional\nocturets. For example, this is the pseudocode for rendering with frustum eulling:\n\nenum Visibility { MOTWISIBLE, PARTLY_VISIALE, FULLY_VISIBLE };\n\nvoid Kode: [Render (Frustum f, Visibility wi\n{\nif (v t= FULLY_VISIBLE) {\nv = ComputeVisibility(this,Boundinghox, Th:\nif (v == MOT_VISIBLE) return;\n}\n\nthis .bjectList.fender(#, ¥)z\n\nfor (children) {\n\nos |\n\nLeone Octrees 451\n\nFIGURE 4.11.6 The simple placement formula would put the circle in the node bounded by\nUbe large black square, but duc vo its particular position, the circle has a bemer fir in the\nupperdctt child node, bounded by the small black square.\n\nchild Alender(?, vii\n\n}\n\nThe exact same algorithm works with conventional octrees; the only difference is\nthar this .Boundingaox would be smaller.\n\nComparison\n\nTo help in comparing loose octrees with regular octrees, | wrote a test program based\non loose quadtrees and ordinary quadtrees, The program posiss a 21) square virtual\nworld, 1000 units on a side. Some number of circular objects are generated to popu-\nlate the world. Each abject has a position and a bounding radius, which are chosen\nrandomly to fit within the world boundaries. Then a cerrain number of 7D frusta\n(Le, wedges) are generared, with a fixed field-of-view angle, and a random position\nand direction. The objects are first partitioned using a conventional quaderee, and\nthen for each frustum, the daraset is queried for visible objects. Stacistics are gathered\non the number of objects char are potentially within che frustum, and che number of\nobjects that are actually within che frustum. Then, the objects are re-classified using a\nloose quadtree, and che same frustum tests are run and che same staristies are col-\n\nlected.\n\nResults of some sample runs are summarized in Table 4.11.1.\n\n452 Section 4 Polgenal Techniques\n\nTable 4.11.1 Results of Same Sample Runs\n\nTest Parameters ee OS USES Se Lease Quadtres\n\nfree max depth o 5 Objects Objects Objects Objects\n\n100 frusta possibly acheally Nodes possibly achuoally Hodes\nFOY = 45\" visible visible checked visible wisibbe\n\nchecked\n\n$00 objeccs\n\nobj min radius=30\n\nobj max radius=30 1ees9 ESS 276 442 6533 fied\nLOM) objects\n\nobj min radiue=15\n\nobj max radiuz=15 31133 15173 7265 22457 15173 BBS\n20h) objects\n\noby min racliges=5\n\nobj max radius] (M0 SoS) 29955 9102 4520) 29935 bs\nee a\n\nNore char the frustum queries on the loose quaderee generally renurn fewer “pos-\nsibly visible” objeers than the same queries on the ordinary quadtree. On che other\nhand, the loose quadtree queries usually have to check more modes. So, for frustum\nculling, the differences between che ovo are noticeable, bur nor terribly dramatic.\n\nThings get more interesting when looking at inter-object queries, such as colli-\nsion detection. In my test program, I added a test in which each object is checked for\ncontact with all the other objects in the dataset, and collected statistics om the checks.\nThe results for che same datasets used previously are listed in Table 4.11.2.\n\nTable 4.11.2 Test Results\n\nOO EEE\nOrdinary Quadtres Loose Quactres\n\nTest Parameters Inter-object Object-te- Object-te- Inter-pbject Objeci-tlo- Object-to-\n\ntetmaxdepth=5 contacts objecttests Node tests contacts objacttests Mode tests\n\na a ee\n\n500 objects\n\nobj min radiue=30\n\nobj max ridius=30 3034 33469 ra51 3034 91235 24859\n\n1000 objects\n\nobj min radius=15\n\nobj max radius=15 2730 115989 LB00 2730 24609 45658\n\n2000 objects\n\nobj min radius=5\n\nobj max radiue=100 FOR4 Sai F S8107 7od4 av276 BOR2\n—_—ererererov—X—X\n\n4.11 Loose Octress $55\n\nAs you can see, for these datasets, the loose quadtree needs two do far fewer object\nto-object tests for the same query. The loose quadtree docs require many more object-\nto-nede tests, bur in aggregate, the loose quaderee is significantly more efficient for\nthis type of query.\n\nConclusion\n\nThe octree is an extremely powerful tool, However, in certain cIPCUMstances, YOU may\nwant to modify the classic octree approach to beteer fit your problem. The loose\noctet is one such variation, which avoids the sticky planes problem of rhe classic\noctree. In situations where you have a large number of interacting, dynamic objects\n(such asa particle system with ineez-particle collisions), the loose octree is a particu\nlarly good cheice over the ordinary octree. The loose octree also performs well for\ngeneral spatial partitioning casks such as fruscum culling.\n\n4.12\n\nView-Independent Progressive\nMeshing\n\nJan Svarovsky\n\nA progressive mesh (PM) is a criangle-based mesh that is able to vary its level of detail\nin real-time, at the resolucion of gaining or losing a couple of triangles at a time, while\npreserving its original shape as much as possible. Ir can be drawn at any detail level\nbetween che conventional mesh from which ic was created and a lowest detail “base\nmesh’ as defined by the detail reduction heuristic, which may be as small as no poly-\ngons ar all.\n\nTypically, chese meshes are rendered at lower detail in the distance, so that more\nsystem resources are available to draw higher-resolution meshes in the foreground.\nThe global detail level of the graphics engine can also be based on the power of the\nCOMputer it is hunning on,\n\nFirst, 1 will introduce progressive meshing, working through some of the arpu-\nments for and against different variations on the theme. Based on this discussion, I\nwill describe an algorithm to convert conventional mesh data into progressive meshes,\nand some efficient and simple code to render these.\n\nFIGURE 4.92.1. A progressive mesh varying in detail,\n\n45.)\n\n4.12 View-Independent Progressive Meshing 455\n\nProgressive Mesh Overview\n\nThe basic principle can be simply described as taking a mesh, repeatedly deciding\nwhich is its least significant edge, and removing this edge by making the ewo vertex\npositions ac its ends equal. This edge collapse operation typically makes rwo triangles\nsharing the edge redundant. Detail is pur back into the mesh by reversing these cal-\n\nMuch work has done by people and documented in che public domain, particu-\nlarly [Hoppe96, Hoppe97, Hoppe98). Figure 4.12.2 summarizes the unit-reversible\noperation and the common terminolopy.\n\nEdge collapse (eco)\nSE\n\nVertex split (vomit)\n\nFIGURE 4.12.2 A single step of mesh refinement (vertex split) or reduction (edge collapse).\n\nVariations on the Theme\n\nGiven this basic premise, there are various decisions thar can be made abour the finer\nimplementation details. I will briefly towch on them here; see [Svaravsky99] for a\nmore leisurely discussion.\n\nWhen Vertices Collapse, Where Do They\nCollapse Ta?\n\nWhen two vertices collapse into one, there isa choice for where to put the vernex. It\ncan be calculated to lie on the imaginary smooth surface that the polygon mesh is try-\ning to represent. Alternatively, you can put the poine just halfway in between the ovo\nit replaces, which you would think was cheaper, perhaps because you wouldn't have co\nstore a pre-calculated new poinc. Last, you can just choose te preserve one or the other\nof the original vertices that are being collapsed (Figure 4.12.3).\n\nThe midpoint system has the disadvantage thar convex objects become smaller as\nthey lose derail. The clever preealculated point system takes up twice as much memory,\nor takes up extra CPU time calculating the new point online. Preserving one point or\nthe other is the simplest, takes the least memory, and objects do nor lose apparent vol-\n\nSection4 Polygonal Techniques\n\nVOrAK\n\nFIGURE 4.12.3 Choices for position of vertices produced by edge collapses. a: Higher detail\nmesh. é: New point on hypocherical surface. ¢- Midpoint- mesh changes volume. a: Pick one\nof the points—simple.\n\nume as drastically. It is often a good representation of the original shape, particularly\nwhen, for example, collapsing the corner of a cube-like object and a vertex somewhere\nalong one of the faces of the cube shape. Though it lacks the fHlexibilicy of calculating a\nnew point, its strong advantage is thar it docs not require real-time changes 00 the ver-\ntex dara or the creation of new vertices. This is the system | will use here.\n\nView-Independent vs. View-Dependent Rendering\n\nEach sequence of vertex splits, starting with a vertex im the base mesh, can be visual-\nized as a binary tree, each vertex splitting into two new ones (though, of course, in\nthis system I just add one new vertex to an original onc). The splits can either be left\nin their tree form or can be given some fixed onder (Figure 4.124).\n\nView-independent meshes use one fixed onder for the edge collapses, which can\ntherefore be calculated offline, and this tree representation can be thrown away. IF you\nkeep the tree form in some way, you can vary which nodes you expand. This effec-\ndependent PM can be used to give more derail on parts of the mesh that are closer to\nthe viewer, or on silhouetee edges.\n\nView-dependent PM (VDPM) is able to use triangle counts more effectively,\nbecause it has more fexibiliry in the choice of edge collapse order. In my opinion,\nhowever, this is mever justified in modern systems because of the large gap in efh-\n\n4.12 View-Independent Progressive Meshing 457\n\nFIGURE 4.12.4 A forest of vertex split trees. The dashed line represents the vertices that will\nbe wed when rendering a mesh at deaail level 5.\n\nciency between the nwo types of renderers. A VDPM renderer uses fewer triangles for\na more visually pleasing scene, bur this thriftiness is drowned our by dhe increased\nprocessor time that must be put into making more level of detail choices, and the data\nhandling involved.\n\nA view-independent PM's (VIPM) triangles and vertices in the meth can be\nordered such that the ones char disappear first are further coward the end of the list,\namd therefore are not traversed or “in the way” when che lower levels of detail are\nbeing used. This can also lead to interesting progressive file formats where the more\nyou read, the higher detail mesh you get [Hoppe8].\n\nBecause there is only one collapse order, there is only one level of detail for the\nwhole mesh, H-you are close to one part of the mesh, and therefore want that part co\nbe rendered at high detail, all che rest will have to be rendered ar high detail, too. In\npractical game situations, however, a Large object can be subdivided into independent\n(bur possibly mutually intersecting) parts that can be rendered view-independently.\nNow that you have che pieces separate, you can assign some game code to them, so\nthey become a bit more interactive, such as windows, antennac, radar dishes on a\nSpace station or individual huts, trees, and so on in a landscape.",
      "page_number": 442,
      "chapter_number": 46,
      "summary": "This chapter covers segment 46 (pages 442-449). Key topics include objects, meshing, and meshes. To get che formula for depth, note that a given lewel in che loose octree can\naccommodate any object whose radius is less than or equal to 1/4 of the bounding\ncube edge length, regardless of ins position.",
      "keywords": [
        "objects",
        "objects obj min",
        "Polygonal Techniques Assuming",
        "loose",
        "che",
        "objects obj",
        "mesh",
        "loose octree",
        "node",
        "detail",
        "obj max radius",
        "che loose octree",
        "obj min radius",
        "Techniques Assuming",
        "obj max"
      ],
      "concepts": [
        "objects",
        "meshing",
        "meshes",
        "node",
        "edge",
        "collapse",
        "collapsed",
        "radius",
        "visibility",
        "visible"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 38,
          "title": "Segment 38 (pages 377-385)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 21,
          "title": "Segment 21 (pages 194-209)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 3,
          "title": "Segment 3 (pages 23-30)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "Segment 34 (pages 326-336)",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 35,
          "title": "Segment 35 (pages 347-359)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 47,
      "title": "Segment 47 (pages 450-461)",
      "start_page": 450,
      "end_page": 461,
      "detection_method": "topic_boundary",
      "content": "458 Section4 Polygonal Techniques\n\nLarge sections of continuous mesh like rolling hills can be built using a custom\nrenderer thar uses fewer polygons in che distance in another way, such as the\n“ROAM? algorithm [Duechaineau97], Discussion of these other view-dependent sys-\ntems that work on specific mesh topographies is our of scope of this article, which\nconcerns itself with the progressive meshing of general criangle meshes.\n\nEdge Choice Functions\n\nI believe that once you have an edge choice system that gives fairly acceprable results,\nthere is little to be gained in trying complex evaluation functions. I leave implemen-\ntation of some of the many methods discussed in the literature as an exercise wo che\ninterested reader. 1 have included some references to different works, particularly\n[Lind=tram9] for an overview, The best thing is to build an editor chat allows artist\nintervention in your automared generation of the collapse sequence. In my experi-\nence, after having spent days building the mecsh, artists are quite willing two spend\nsome time tweaking how it looks at lower levels of detail, particularly at the very low\ndetail levels where there are only a few polygons to adjust. It is at these low levels thar\nautomated systems have the most wrouble anyway,\n\nHere I have described a very simple function that is implemented in the example\ncode on the CD. Itis based roughly on the amount of movement of the surrounding\n\nDifficult Edges\n\nlt simplifies the algorithm to ban some special ease edges. These cases stem from tri-\nangles sharing the same point in 31D space, but not sharing some other vertex data,\nsuch as vertex normals, texture type, or texture coordinates. It is an extra complication\nto have triangles pointing to shure texture coordinates and pointing to shared vertex\npositions. To avoid this, and co be friendlier toward current graphics hardware, our\nvertices contain all texture coordinates, normal and position information. This way;\nthe meth will contain multiple vertices in the same Position bur with different mater-\ntal information.\n\nIfan edge being removed contains these duplicate vertices, and therefore the tri-\nangles along the edge do not share vertices, it is handled as ewe edee collapses thar\nhappen simultaneously. The problem arises when a nearby rriangle only refers to one\nof the ends of a collapsed edge, and this is the one thar is ro disappear (Figure 4.12.5).\n\nAn extra vertex could be created for this material, which would remain redundant\nuntil needed for lower levels of detail. This inefficiency is only slight because these\nvertices are created very infrequently, You can avoid this case by just banning these\ncollapses. This will restrict the lowest polygon count that meshes will reduce to. Typ-\nically, when these edges are a significant percentage of the remaining edpes, the poly-\ngon counts will be so low that the renderer call overhead means further detail loss\n\n4.12 View-Independent Progressive Meshing fs 455\n\n=\n\na\n\noe\n\n——$——\n—————\na\n\nFIGURE 4.12.5 ‘When an extra vertex must be generated. a: Original chape. 6: Trivial\ncollapse. Different, complicated collapse.\n\nwould noc really speed up rendering. The objects will also probably be so insignificant\n{as determined by the decision function that made them low detail anyway) thar you\ncould just noc draw them ar all! Ar che time of writing this article, most commercial\nPM systems disallow these types of enllapses.\n\nFor the sake of conciseness, the system is simplified further here. The program\ngiven contains no workarounds for multiple edges that share the same position. This\nway, we can remove all the code that checks for coincident edges, that bans certain\ncollapses, and thar makes some edge collapses happen simultaneously: This implics\nthar all meshes must be smooth and continuously tectured, bur, as can be seen in the\nexamples on the enclosed CD, careful construction of che meshes means many more\ngeneral shapes are still possible.\n\nImplementation\n\nThe Renderer\n\nFor the majority of frames, a mesh will nor change in derail, so it is essential thar the\ndata structure being used to render from is as efficient as possible for the graphics sys-\ntem. Here we can arrange the data much like we would for a standard mesh renderer:\n\nstruct FMMesh\nint NumWaterials;\nStruct Pililaterial *Materials:\n1;\nThe mesh is made of an array of matezials-:\nstruct PMMaterial\nf\nPuTexturé *Texture;\n\nstruct PiVertex *Vertices;\nint “Indices;\n\nSection4 Poblgonal Techniques\n\naint AumVaertices, NunIndi¢ws ;\n};\n\nFach material has a texture (or peshaps several textures in a multi-pass sysem,\nsuch as a hump map, a gloss map, and the actual base texture), and an array of ver-\ntices. Ir alsa owns some triangles, which simply index into che vertex array. Note thar\ninstead of having an array of PMTriangle’s, there is an array of chree times as many\nindices into the vertex array. This is done for efficiency in the Edge(7ollapse seructure\nlater, and is trivial to change back into an array of triangles if you wish to record more\ninformation with cach wiangle.\n\nstruct PaVertex\n\ni\nVECTORS Position, Normal;\nfloat U, ¥:\n\nhi\n\nEach vertex contains position, lighting, and texcure information. In this way, the\nmaterials are quite independent of each other, and the mech looks like one continuous\nobject because the positions of same of the vertices in different materials are the same.\n\nMorph the Verticeas or Pop?\n\nNo vertex morphing will be done in this implementation—vertices pop in and our of\nexistence. [his is cheaper and, in my experience with game teams, actually looks bet-\nier than morphing. This surprising result is because, for a given polygon count, the\nmesh is as close as i can be to its proper shape, rather than being blended somewhere\nbetween the current shape and the next lower detail level. The pops in practice are less\ning to edit vertex dara).\n\nProgressive Mesh Rendering Only Affects the\nTriangle Lists\n\nBecause an edge collapse preserves one our of the two vertices involved, this renderer\nmodifies the triangle lists only, with no effect on the vertex dara. This means thar the\nvertex arrays can be left alone (and in some modern hardware, pre-processed into\nsome more efficient format), and can also be shared berween multiple instances of the\nsame mesh. The triangle lists will be modified over time, and must be duplicated once\nfor each active instance of each mesh.\n\nThis also means thar vertex position modifiers, such as animation, can happen\nfairly independently of the progressive meshing, as long as you dont mind that the\ncollapse order wont change even as the vertices move about against each other. The\nanimation system only has to handle the far chat vertices can come and go, rather\nthan be used continucusly,\n\n4.412 View-Independent Progressive Meshing et\n\nLower Detall Triangles and Vertices First\n\nA point of note for che renderer is thac the vertices and triangles have been ordered\noffline so thar it is always the triangles and the vertices at the end of a list thar are\nmade redundant by a collapse. The renderer will always be submitting triangle and\nvertex lists starting in the same place, just of varying lengths. Discussion of che dara\nstructure generarion will show how this is possible.\n\nThis does mean that unless you create strips and fans of criangles in some other\nway, you will be always presenting the graphics hardware with an indexed list of trian-\ngies. Interesting|y, adjacent triangles in che list often share vertices, which in many sys-\ntems is as good as having triangle strips and fans. This is because ar least pairs of\n\ntriangles on either side of an edge collapse will be next co each other in the triangle list.\n\nThe Reversible Edge Collapse List\n\nThe other renderer data structure describes the reversible sequence of edge exllapses\nthar changes the level of detail of che mesh. Fach edge collapse loses ome Vertex, one or\nmore triangles, and changes which vertices some of the remaining triangles use. There\nis one edge collapse list for the whole object, though different individual collapses\naifect different materials. Alternatively, there could be a collapse list per material, but\nthese would have to be tied together somehow so that the seams of the object don't\ncome apart.\n\nStruct PMEGpecollapse\n{\n\nfloat Value;\nPiWaterdial “Material;\nint HunIndicesToLosa, MunVertigesToLose,\nHunindicasTochange:\nint *Indew¢hanges:\nint CollapseTa:\nhs\n\nThe Gollapseto member says which vertex should replace all references to the\nvertex that is being lost off the end of the list. All these changes are stored in the\nIndexChanges array. This operation is simple to reverse for vertex splitting when the\nlevel of detail is being increased apain.\n\nWhen a collapse happens, same triangles disappear (NumIndicesToLose), onc or\ntere vertices may be made redundant (munverticesTaLoze—loss of some triangles\nmay leave vertices completely unused), and some indices in remaining triangles will be\nchanged (NumindicesTochange). OF course, the reverse happens during a vertex split.\n\nBecause the materials are so independent, sometimes nwo edge collapses must be\nperformed at once, to preserve the mesh seams as much as possible. This is when, as\ndiscussed earlier, the two edges actually are the same edge in space, so must collapse\ntogether even though they refer to diflerene vertices. The engine must continually\ncompare the value of the next edge collapse or verrex split chat could be performed\n\nSection 4 Polygonal Techniques\n\nagainst the level of detail required from the mesh based on its position and other\nvariables.\n\nIn the simple system presented here, these edges are noc taken into account, bur\nthey can be done quite well by simply giving all edges in the same place the same pr-\nority, even though they are unconnected in the data structure.\n\nOffline Calculation\n\nHere | will assume that the mesh dara has heen loaded by some means into a friendly\nformat. For the sake of readability, the algorithm will be che simplest rather than che\nmost efficient, particularly since we are not so worried abour the expense of offline\ncalculations.\n\n‘The procedure can be summarized as repeatedly deciding which is the mex bir of\nderail to be lost, and removing it fem the mesh, while generating the edge collapse\ndata thar will be needed by che renderer later. When it is decided chat a vertex should\nbe removed, all triangles thar refer to it must be changed, and any triangles thar are\nmade degenerate swapped to the end of the list. Similarly, che vertex is moved to the\nend of the remaining vertex list.\n\nOf course, swapping triangles and vertices to the ends of their lists changes all ref\nerences to them, in other edge collapse structures as well as in the remaining mesh.\nThete may be other code (such as an animation system thar is about to use the same\nmesh) that needs to know abour vertex reordering.\n\nSuggested Offline Calculation Optimizations\n\nLooking at the code, it is obvious that extra temporary connectivity informarion\nwould be useful in the mesh. For example, the code often looks for “alll triangles thar\nreference this vertex” by bruce force. Also, the code repeatedly searches through all che\ntriangles for the next edge to collapse, Huge performance improvements are possible\nif you put the edge collapse candidares into a prioriry heap.\n\nEdge Selection Improvements\n\nThe most effective edge selection improvement is to make edges thar affect dis-\ncontinuities in the mesh less likely to collapse. This makes many more mesh shapes\npossible, and also allows objects to be subdivided further into subobjects. Each mesh\nsubdivision gives an cxtra degree of freedom in level of detail choice—see the previ-\nous discussion about making huts and trees separare from the landscape mesh under-\nneath them. See Figure 4.12.6.\n\nA Further Variation on Progressive Meshing\n\nInstead of being able to change level of detail at che resolution of one verrex at a rime,\nyou could just store several pre-calculated index lists at various resolurions. The\nchanges between these levels of detail of course will be more obvious. This system\n\n4.12 View-Independent Progressive Mashing 463\n\nPush the veriex into the other object\n= likely cobapse, Even though this is a seam i\ncan be mede less likely to\n\nCOLE Spert\n\nFIGURE 4.12.6 Whar was one mesh becomes ove subtly intersecting ones, or just wo\ncoincident ones.\n\nbecomes more useful if the polygon counts or frame rates are so high that the popping\nis not a problem.\n\nAn advantage is char you can throw away the edge collapse list, which is actually\nquite a large data structure, certainly comparable to the extra index lists you are stor-\ning in this new method. You ales lose the collapsing/ splitting code, and you don't\nneed a separate index lise for cach active instance of cach object. The renderer\nbecomes much simpler—you are back to a normal mesh renderer, bur just with code\nto select which index list to use for each object at a given moment,\n\nSource Code\n\nCode for the progressive mesh generator and the renderer is contained on the CD. It\nis written in a general manner with little system dependency.\n\nReferences\n\n[Duchaincau97] Duchaineau, M. ct al, ROAMing Terrain: Realtime Opemally\nAdapting Meshes, 1997, available online: hitp://wwwlloLgov/graphics/ ROAM/\nroam. pdf.\n\n[(Garland97) Garland, M., and Heckbert, PS., Surface Simplification Using Quadric\nError Metrics, Siggraph 1997 Proceedings, pp. 209-216, August 1997.\n\n[Hoppe96) Hoppe, H., Progressive Meshes, Siggraph 1996 Proceedings, pp. 99-108,\nAmpuse 199,\n\n[Hoppe97] Hoppe, H.. View-dependent refinement of Progressive Meshes, Siggraph\n1997 Proceedings, pp. 99-108, August 1997.\n\n[Hoppe98)] Hoppe, AH. Efficient implementation of progressive meshes, Compurers\n& Graphics, Vol. 22(1), pp. 27-36, 1998.\n\nSection 4 Polygenal Techniques\n\na\n\n[Lindstrom?9] Lindstrom, P, and Turk, G., Evaluarion of Memoryless Simplifica-\ntion, IEEE Transactions on Visualization and Computer Graphics, VoL5(2),\nApril-June 1999.\n\n[Renfard96] Ronfard, R., and Ressignac, J,, Full-Range Approximation of Triangu-\nlated Polyhedra. Eurographics 1996 Proceedings, in Computer Graphics Forum,\n15(3), August 1996, pp. 67—-76-\n\n[Svarovsky99] Svarovsky, J., Extreme Detail Graphics, Game Developer's Conference\n1999 Proceedings, alsa available online: heop-//www-svarovsky.teeserve.co.ule/\nExtremeD.\n\n4.13\n\nInterpolated 3D Keyframe\nAnimation\n\nHerbert Marselas\n\nKeyframing is a simple and effective way of animating a 3D object. However, since\neach keyframe only represents the extremes of the object's motion, this can make che\nabject appear to jump between positions.\n\nLinear Interpolation\n\nOne solution is to add more keyframes to make che transition between keyframes less\njamming. Another more economical method is to programmatically create in-between\nanimation trames using énrerpedstion.\n\nInterpolarion—also known as blending, morphing, or tweening—is the process\nof creating a new position berween owo existing positions In this case, we are inter-\npelating two known keyirame positions py and p, co create a new position pit).\n\nThe easiest interpolation solution is linear interpolation. In this case, a line is\ndrawn between the same position in we adjacent keyframes p, and p,, and then we\ncalculate where on this line the new position p(t) exists (Figure 4.13.1).\n\n(siven the desired time of the new animation position, the total number of\nkeyframes, and the coml time of che animasion, the point berween the nwo closest\nkeyframes can be calculared.\n\nThe function caleulateFranePercentage demonstrates this. Given the total\nnumber of keyframes in the animacion, the total time of the animation, and the\ndesired time, the keyframes on either side of the new position and the percentage\nbetween che owo frames are calculared and renurnedd.\n\nae. ae ce P(t) = Po + tps - Po)\n\nFAT)\n\nFIGURE 4.13.1 Example limear interpolation and formula.\n\nSectlon4 Polygonal Techniques\n\nvodd calculateFranePercentaga(long dwTotalAninfranes,\nfloat TTotalaninTine, float fDesiredTine,\nlong BdwrirstFrama, long EdwsecondFrane,\nfloat &fPercentage)\n\nfi determine which frases are involved\n\nfloat TTimaPerFram = ¢TotalAninTime |\n(float) deTotalAninframes;:\n\nduriretFrane = 0;\n\nat [MDesiredTime > fTotalAninTine)\nTDesiredTime -= fTotalAninT ine;\n\nTor (float f= 0.0f; f <= fDesiredTing; f += TTimaPerFrane)\ndwFiretFrane+4 -\n\n!i sat Tiret frane\n\nif (f = tDesiredTine|\ndaFirstFrane-;\n\nit (cwFiratFrame = 0}\nOwFirstPrane = dwTotalAninFrames - 1:\nalse\nLf (deFirstFrame >= dwlotalAnioFrames}\ndwFirsthrame = Of\n\nii 38 s8cond frame\noetecandFrane = dwFrirstFrame + 1;\n\n1T (dwSecondFrane >= dwiotealAninfranes)\ndesecomdFrane = O;\n\nff calc the percentaga\n\nPercentage = (fDesiredtime - ((flont) dwFiratFrane *\nfTinePerFrame}) * TTimePerFrane:\n} ff ealeulateFramePercentage\n\nFirst, calculateFranePercentage increments through each frame until ir finds\nthe keyframe that is ight before the desired time. This assumes thar the keyframes\neach have the same duration. IF che keyframes are nor set at uniform intervals, this\nfunction will have to be changed accordingly.\n\nWith the first keyframe found, ic is checked against the number of keyframes in\nthe animation. Then, the second keyframe is determined by incrementing che first\nkeyirame number by one, The second keyframe number is alse checked against the\ntotal number of keyframes in the animation. This code assumes that the animation is\ngoing to loop back to the start of the animation after displaying the last keyframe.\n\nft should be noted thar the calculateFramePercentage function, as with all of the\n\n4.12 Interpolated 3D Keyframe Animation 467\n\nfunctions in this article, are presented more for readabiliry chan performance. One\neasy performance improvement is to pre-compure values such as fTisePerFrane.\n\ninterpolating Vertices and Normals\n\nWith the two keyframes and the percentage berween them identified, this data can\nnow be used to generate the new animation frame. The combineVvertices function\ndemonstrates using these values to combine the vertices from the selected keyframes.\n\nvoid coabineVertices(long dwvertexCount, float fPercentage,\nvectora *pFiretFramevertices,\nvectors “pSecondFramevertices,\nweetor’ “ptonbinedVertices)\n\nfor {long i = 0;\n1 = daVertexCaunt;\ni++, PFirstFramvertices«+,\npoecondFrameVertices++, pConbinadvertices++)\n\n“plonbinedvVerticee = *pFiretFranavVertices *\nfPercentage = (\"pSecondFranmeVertices =\nSpFirsthranevertices) 5\n\n}\n}\n\nThe percentage that was calculated im calculateFramePercentage is usecl te com-\nbine the vertices from the tern keyframes irutes a single now position between them.\n\nThis same method of combining the vertices of bath keyframes ean also be\napplied rt] combining the normals of the keyframes. LF the lacy frame normals were\nnormalized before interpolating, the combined value wont need to be normalized\nunless there ix a large differenee between the normal vectors.\n\nThere can also be a performance savings if separate lists of Gee normals (for back-\nface culling) and vertex normals (for lighting) are stored in each keyframe. The face\nnormals must always be interpolated, but interpolating the vertex normals can be\nskipped if you're trying to improve performance, This means that the vertex lighting\nwon't be correct, bur in many situations, the user won't notice the difference,\n\nHermite Spline Interpolation\n\nOne drawhack to linear interpolation is that some interpolated animation frames may\nhave a tendency to deform to a greater or Iesser extent. To solve this, a slightly more\ncomplicated interpolation system must be usec, This next method, Henmite spline\ninterpolation, takes into account the two keyframes on eather side of the desired posi-\nnon (Figure 4.13.2).\n\nSumilar to calculateFramsePercentapa, calculateFramePercentagaspline deter-\nmines which keyframes are on cither side of the desired animation ume. Additionally,\n\nSectlon4 Polygonal Techniques\n\npit} based on Lincar interpolation Plt) based om spline incerpolation\nFIGURE 4.13.2 Lincarly interpolated position vs. spline interpolared position,\nthe frames immediately before and after chese two keyframes are also calculated.\nThese additional keyframes are used to refine the calculation for the new position.\nwold calculateFranePercentageSpline(long GuTota LANinF rames ,\nfloat fTotalAniaTine, float fDesiredTime,\nlong SdwFirstFrame, long SdwSecondFrame,\nlang &twThirdFrama, long 4dwFourthFrane,\nfloat &fFercentage)\n\nif determing which frames are involved\n\nfloat fTimaPerFrane = #TotalAninTine |\n(float) dwiotalaninFranes:\n\nduSecondrrane = 0:\n\nif (fDesiredTima > fTotalAniaTine)\nfesiredTina -= fTotalAninTime;\n\nTor (float f = 0.0%; f <= fDesiredTime; # += TTinePerframp)\ndeSecondFrana++s\n\nff set Segond Treme\n\nif (f > fOesiredTine)\ndesecondFrame --;\n\nif (dwSecondFrana < 0)\ngeSecondFrane = dwTotalAninFranes - 1;\nelse\nif (dececondFrame >= dwiotalAninfranag}\ndwSecondFrane = oO:\nff set frame before second trane\ndwFirstFrame = dwSecondFrame - 1;\n\nif (dwFirstFrame =< 0)\nGeFirstFrame = dwlotalAninFrames - 1;\n\n// sot upper frase\n\n4.13 interpolated 3D Keyframe Animation 465\ndethirdFrane ~ dwSecondFrame + 1;\n\nif (dwihirdFrage >= dwiotalanimFranes)\ntwihirdFrane = 0;\n\nif S8¢ franée after the third frame\ndeFourthFrané = dwihirdFrame + 1;\n\nif (dwFourthFrame >= owilotalAnimFranes)\newFourthFrame = 0;\n\nff get the upper percent\n\nfPercentage = (fDesiredtime - ((Tloat) dwSecondFrame *\nfTimePerFramg)) * fTimePerFrame:\n} ff calculateFramePercentaga\n\nThe positions from the four keyframes are used to calculate the new p(t) using the\nfollowing equation:\n\nple) = (20° — 3c? +1) p, +(e — 20? +d, +(e? — ym, + (=2e? + 37),\n\nThe first and fourth keyframes are used to calculate the tangents ms; between che\nfirst and second keyframes, and the third and fourth keyframes, respectively.\n\nSpline Interpolating Vertices\n\nThe combineverticesSpline function demonstrates calculating the tangents and then\nthe Hermite spline interpolated position pit).\n\nWoid canbineVerticesSoline(loang dwVertexGount, float fTPercentaga,\nweotora *pFirstFramevVerticas,\nweetord “*pSecondFrameVertices,\nwectord “pThirdFramevVertices,\nveetorad *pFourthFramevVertices,\nweetord *pGombinadVertices)\n\nflsat t = Percentage;\nfloat t2 = t * t;\nfloat +9 = t2 * t;\nyveetord ad, mi;\n\ncanst float alpha = 0.07;\n\nfor (Leng i = 0;\ni = dwvertexGount;\ni++, pFirstFranavertices++, pSacomiFranavertices++,",
      "page_number": 450,
      "chapter_number": 47,
      "summary": "This chapter covers segment 47 (pages 450-461). Key topics include float, mesh, and meshes. Edge Choice Functions\n\nI believe that once you have an edge choice system that gives fairly acceprable results,\nthere is little to be gained in trying complex evaluation functions.",
      "keywords": [
        "edge collapse",
        "Edge Collapse List",
        "vertex",
        "Edge",
        "vertices",
        "keyframes",
        "mesh",
        "collapse",
        "thar",
        "che",
        "triangles",
        "position",
        "float",
        "Collapse List",
        "animation"
      ],
      "concepts": [
        "float",
        "mesh",
        "meshes",
        "edge",
        "positions",
        "position",
        "collapse",
        "collapsed",
        "vertex",
        "interpolated"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 35,
          "title": "Segment 35 (pages 347-359)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 44,
          "title": "Segment 44 (pages 413-428)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 34,
          "title": "Segment 34 (pages 326-336)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "Segment 63 (pages 609-616)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 36,
          "title": "Segment 36 (pages 347-355)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 48,
      "title": "Segment 48 (pages 462-474)",
      "start_page": 462,
      "end_page": 474,
      "detection_method": "topic_boundary",
      "content": "470 séction 4 Polygonal Techniques\nEL Ce\n\nPThirdFraneVertices++, pFourthFramaVertices++)\n\nnd = ({1 = alpha) # 2.0f) *\n((*poecondFramVertices - “pFirstFrameVertices) 4\n*pThirdFranavertices - *phecondFrameVertices);\n\nmi = ({1 - alpha) / 2.0T) =\n((*pThirdrranevertices - \"pSecondFraneVertices) +\n“prourthFraneVertices - *pThirdFraneVvertices);\n\n\"pGosbinedVertices = (((2 * t3) - (2 * tz) +4) *\n\"pSecomdFramVertices) +\n(ite - (2 * te) * t) * mo} +\n(itd - t2) * mij} +\n((l-2 “ tay + (3 \" tep) *\n\"pThLrdFramevartices }z\n\n}\n}\n\nAnother new addition to this calculation is the variable alpha, alpha controls the\ntension of the tangent to the spline that being calculated. While alpha can be changed\nto make the tension higher (positive values), or lower (negative values), leaving alpha\nat zero is good enough for most animations,\n\nIf you've determined thar a fixed value for alpha is sufficient for your animation,\nyou can pre-calculare the first part of the tangent equation m,, ((1 — alpha) / 2), and\nreplace it with a constant, 0.5 in this case.\n\nWhy Hermite Splines?\n\nAt first glinee, it may seem an odd choice of a Hermite spline over a better known\nspline such asa B-spline. While B-splines offer additional continuity, this comes ar\nthe cost of less control over the tendency of the interpolated curve.\n\nSummary\n\nee eee\nInterpolating keyframe animations is an easy and inexpensive way of improving ani-\nmation quality. Linear interpolation can be performed for very little cost pcr Vertex.\nHermite spline interpolation improves the quality of interpolated keyframes over lin-\near interpolation, but comes at a grearer per-vertex cost.\n\nReferences\n—— a erat eee on\n[Foley96) Foley, J., van Dam, A., Feiner, 5., and Hughes, J. Corpater Graphics: Prin-\neipler ana Practice 2“ Edition. New York: Addison-Wesley Publishing Company,\nIne, 196.\n\n4.14\n\nA Fast and Simple Skinning\nTechnique\n\nTorgeir Hagland\n\nThis article describes a skinning method that is most beneficial for lower polygon\ncharaceers (les than 500 polygons), where the artists and animators need 100% con-\ntrol aver what their vertices are doing. The method can in short be described as a\ndever way of modifying and sorting an object's vertex list and re-mapping the face list\naccordingly.\n\nWhy Low-Polygon Count?\n\nWhen dealing with low-polygon count models, each vertex has a big visual impact on\nhow the model's silhoueme looks. As an example, let's look ar your elbow. The only\nbones influencing it would be the upper and lower arms. When flexing your biceps,\nthe lower arm influences how the vertices on the inside of your elbow move. Ie pushes\nthose vertices up from the direction of your lower arm and averages it with the orien-\ntation of your upper arm. The end result looks like you have a very thick dbow, This\ntechnique only takes into account ane bone per vertex.\n\nThe Mathoad\n\nThe artist creates a single skin model; for example, a space soldier. They then dupli-\ncates this skin, scales it down fractionally, and proceeds to cut this smaller skin up into\neven smaller bits (body pares), which are used as bones. As each bone is created, it is\ngiven the same name as the skin with a number appended to in, so it can easily be rec-\nognized as a bone by our program.\n\nOnce we have identified a skin and its bomes, we take che geometry of the bones\nand store the vertices in ome big list. Each entry in this lisr contains the vertex position\nand the bone this vertex is a part off\n\nNow foreach vertex in our skin, we find the vertex in che bene list chat is dlosest\nto it. We cransform the skin vertex by the inverse marrix of the bone that the vertex\nwas closest to. This will bring the san vertex inco the local coordinate system af che\n\nar\n\n472 Section 4 Polygonal Techniques\n\nbene (in the draw loop, the vertex is cransformed back again, so even though the\nbane-skin is smaller, ir has no impact on the end result since the position is relasive).\nThe transformed vertex is stored in a temporary list thar we accumulate, where we\nalse store the original vertex list index and a poinrer to che bone that influences it.\nThe influencing bone has a counter char keeps track of che number of vertices it rrans-\nforms.\n\nWhen all the vertices of the skin have a bone influencing them, we process the\ntemporary list that we created. This list is then sorted based on the order of the bones.\nFor each bone, the number of vertices it influences is stored in the original skin's ver-\ntex list, and the faces must remap the vertices chat they reference since we just\nchanged all the vertex indices.\n\nListing 4.14.1 contains sample code that solves for bone influences anc remaps\nthe faces accordingly, Even though this sample code uses the 3D Studio Max file\ntoolkit, the technique can easily be used with any 3D modeling package. I only use it\nto keep the source size small, and to make sure the focus of this is on the influence\nsolving and draw loop, not the model conversion, etc.\n\nAfter executing the eode in Listing 4.14.1 we have:\n\n* Askin, with each vertex transformed into the local coordinate system of the bone\ninfluencing it. The vertex list is somed by the order of the bones.\n* Alistof bones, with a counter for how many vertices each bone should transform.\n\nThe draw loop for the skin can then be as simple as Listing 4.14.2.\n\nSummary\n\nThis method is fast and simple, and warks especially well for law-polygon characters,\nFor higher-polygon characters, the edges are smoother, and you will need several\nbeames influencing each vertex. You will also then most likely store two or three pont.\ners for each vertex to the bones char influence them. This means you can no longer\npre-store the inverse transformed vertices, and for each frame you need to apply the\ninverse transform and a percentage-based roration for each bone thar influences it\nThis causes more of a problem for the tool thar creates the influence data. Commer-\ncal packages that export bone information do exist, and you no longer have to worry\nabour how the influencing is done, just how to ereate your draw loop, If you do\ndecide to create the influence tool yourself, T highly recommend making a tool char\nallows the artist to “paint” influences directly onto the geometry. This way he does\nnot have to second guess a mathematical algorithm.\n\nListing 4.14.1\n\nvold Solvabonein?luences(databasedds \"db, Skin \"skinptr)\n{\n\nf* sllecate a big workbuffer */\n\n4.14 A Fast and Simple Skinning Technique\n\nBonePoint \"bonepaintptr=\n(BonePoint\" jmalloc( 30000 sizeot (BanePoint) ):\nBanePoint \"curbonepoint=bonepointptr;\n\nlong Nrfoneverts=0;\n\n/* Make 211 the bones’ vertices into one big vertex\nList with information on what bone each point came from */\n\nMATRIM tmpmat:\n\nBane \"boneptr=skinptr->BonePtr;\n\nwhile (boneptr}\n\n{\nmesh3ds “bonenesh=HULLs\nGetWeshbyNamesde (db, boneptr->Nane,kbonenesh) ;\nassert (bonemesh):\n\nCopySdsWatrix( topmat , bonemesh->locmetrix) ;\nInverseWatrix( tapmat ,boneptr->Watrix) :\n\npointids *“boneneshpointe=bonemesh->vertexarray;\n\nNrBoneVertst+=bonemash-snverticas;\nassert (Nrfoneverte<30000} ;\n\nfor(int 1-0; i<bonemesh->nvertices;i++)\n\n{\nCUPbonepoint-sPaint. x\"boneneshpoints->x;\ncurbonapoint-=Point.ybaneneshpoints->y3\ncurbonapoint->Point. 2-baneneshpoints:>z3\ncurbonapolnt-*BonePtrebaneptr:\nbonemashpointe+=;\ncurbonepoint++;\n\n}\n\nRe liashOih] Sis (dbonamesh) +\nbonaptr=bonepte -staxther:\n}\n\n1\n\nmashsos \"skinmeash\npointads \"skinmeashpoints Skineesh->vertexarray:\nBanePoint *ekinpointptr (BonePoint\" jrallocy\nBKInneSsh-nwvertices* sizeof (BanePoint) } 5\n\nBonePoint *curskinpeint = skinpointptr;\n\nSkingtr->ieshPtr;\n\n/* Find the closest bone vertex t6 @#ach skin vertex */\nTor (int 170) i<ekinmesh->nvertices;i++)\n\n{\ncurskinpolnt->Point.x > skingeshpoints->x;\ncurskinpoint-*Point., > skinseshpoints->y;\ncurskinpolnt->Point.z = gkinseghpoints-=z;\n\ni* need to stare original vertex index, for\nface remapping */\n\ncurskinpoint->Index me d5\n\n47a\n\nTe yin Bastion'd: Polygonal Techniaues\n\n/* no bone is influencing this bone yet */\ncurskinpoint->BonePer = HULL:\n\ncurbonepoint=bonepaintetr;\nfloat mindist=ie6:\n\nfor(int 7=0;]«NrBoneverts: j++)\n{\nfloat dist=\nCalcisthotSquared(skinzeshpoints,\nScurbonepoint->Point) j\nif{dist<mindist)\n{\nmindist-dist;\nCUrSsKinpoint ->BonePtr=\nCuUrbane point ->BonePir:\n}\ncurbonepointe+;\n}\ncurskinpoint++;\nSkinmeshpoints++:\n\n}\n\n/* Sort all the vertices of the skin by bone,\nand remap the faces accordingly */\nskinneshpoints = skintesh«>vertexarray:\nfacegds “skinfaces - skinmesh->tacearray;\nlong CuriIndex=0;\n\nboneptr=skinptr->BonePtr;\n\nwhile(boneptr]\n\nif\n\ncurskinpoint=skinpaintptr;\nfor (i=O;i<skinmesh-*nvertices:i++)\n\n{\nif (curskinpoint->BonePtr==boneptr)\n\nTransforna(boneptr-vatrix,\n(float*}Sturskinpoint->Point,\n(float*}skinneshpoints):\nAenapFaceList(skinmesh,\ncurskinpoint->Index, Curlndexs+} ;\nbonéptr=>8rVerts++:\nSkinmeshpoints++:\n}\ncurekinpoint++;\n}\nboneptr=baneptr-WextPir:\n}\n\niM\" Clean up after the romagping «/\nCleanUpFacelist (Sskinmesh} ;\n\nfraa(skinpointptr) ;\nfrea(bonapointptr) ;\n\n4.14 A Fast and Simple Skinning Technique\n\nListing 4.14.2\n\nvoid glfrawthar(}\n\n{\n\nmeshdds *“qashptr\nBone \"boneptr\npointads *vartptr\nfagadds “faceptr\n\nSkinPtr->MeshPtr;\nSkinPtr->BonePtr;\nhesnptr->vertexarray;\nneshptr->facearray:\n\n/* For Each bone in the skin, transform % amount\n\nof vertices with the bone’s current animation matrixt/\n\npointdds *skinptr=SkinPtr->fointPtr;\nwhila(boneptir)\n{\n\nMATHIX mat;\n\nMencpy (knat , &boneptr-sAninPtr[CurFrane],\n\neizeot (MATRIE 13\n\nfor (int i=0;isbonmeptr-=HrVerts;i++}\n\nTranstorm(mat, (flaat*)vertpers-,\n(float*)skinptre+];\n\nDOnEPTr=boneper-+hextPtr :\n}\n\n\" Then Simply draw the objeot using the tacelist*/\nskinptre2kinPtr->Poaintetr;\nglbegin(GlL TALAWGLES) ;\nglcalarat(1,1, 1p;\nfor(int i=; i¢neshptr-=ntacesiite)\n{\npointdds \"vieSskainptri faceptr-=v1] >:\nPOLNESds \"vl=Sskinptr[ faceptr->v2]*\nPOLNTSds \"vi-hskinptr[| faceptr-=vd];\n\nglvertaxdat (vis>e visay vi->Zz)7\nplvertaxdt (vi->\" .ve->y,¥2-Fz)7\nglvertexat (va->0 ve-Sy,wi-z):\nFaceptr4+;\n\n}\nglEnd():\n\nReferences\n\n475\n\n[Lander98] Lander, Jel, Game Developer Magazine, May 1998: Rerl-time Skeletal\n\nDefornuition.,\n\n4.15\n\n476\n\nFilling the Gaps—\nAdvanced Animation Using\nStitching and Skinning\n\nRyan Woodland\n\nAs hardware becomes faster and more feature-laden, game developers are searching for\nways to make characters look more compelling, Of che many caregories that can be\nimproved, character animauon is peshaps one of the most important.\n\nCurrently, most 3D games are starting to use some sort of skeletal representation\nfor their characters as their topology for animation. These systems attach geometry to\n“bones” in a character. The bones are then animated and, consequently, the attached\ngeometry inherits che motion creating adequate animation. Usually, however, che\ngeometry used co represent characters is rigid in narure, which is not the most useful\nrepresentation for modeling organic creatures that are definitely nor rigid in nature,\n\nBeciuse the geomenry is complerely rigid, any nwo pieces that are supposed to be\nconnected to each other (an upper arm and a forearm, for example) display blatant\ndiscontinuities at the joint at which they are connected. This obviously can become a\nproblem, since the characters we are trying to represent are more often than not made\nup of a continuous skin that does not show any cracks or separazions.\n\nIn this article, I will discuss the topics of stitching and shinming as ways to create\nmore realistic organic animation. Stitching is actually just a less computationally\nexpensive subser of skinning anc will therefore be discussed firer. Both of these rech-\nniques assume one continuwows mesh that is attached to a bone structure for a charac-\nter as opposed to many meshes attached to a single bone in traditional rigid-body\nanimation. This continuous mesh is deformed relative wo the character's bone scruc-\nture, yielding a character thar does not create visible (and often very annoying) BAaps at\njoints when animating.\n\nIn the following sections, I will be using the example of an arm to demonstrate\nvarious features of stitching and skinning. The basic mesh used is picture in Figure\n4.15.1.\n\n4.15 Filling the Gaps a7T\n\nFIGURE 4.18.1 Chor basic arm mesh,\n\nStitching\n\nSa ee\nAs mentioned earlier, sucching operates on a continuows mesh attached no a bone\nstructure. In ngid-body animation, a polygon is transformed by one matrix represene-\ning the bone to which thar polygon is attached. With stitching, cach vertex in a poly-\ngon can be transformed by a different matrix representing the bone to which che\nindividual vertex is attached. This means thar we can create polygons thar “srirch”\nmultiple bones together simply by attaching different vertices in the polygon wo dif-\nferent bones. When the bones are manipulated, this polygen should fill the gap you\nwould see in ngid-body animation.\n\nOne of the major differences between stitching and rigid-body animation is che\ndata topology for representing a character. With rigid-body animation, a bone must\nsimply have a pointer to some geometry it is to animate. The matrix yielded by the\nenrresponding bone then transforms that geometry. For stitching, it is necessary for\neach vertex in the character's skin vo keep track of the hone to which iris artached.\n\nBIFUCT Vertex\n\n{\nTlost #, +:\nTlOSE Nu, ¥, Z;\nunsigned long color;\nunsigned lang boneindex;\nhi\n\nBefore animating a character that has been correesly bound to this data topology,\nwe need to deal with the problem that our vertices are not in the correct space co be\nproperly transformed. The problem is this: a marrix used to transform a bone for ani-\nmation assumes thar the bone starts with its pivoc point at the origin of the ceardinate\nspace of the character. This makes sense if we consider a hand bone in a normal\n\n478\n\nSection 4 Polygonal Techniques\n\nhuman. This bone should start with its pivot point at the origin of its coordinare\nspace so that we can easily rorare the bone around thar point. The bone is animared\n(roraced) and then transformed to the end of the forearm bane. This process repeats\nfor che forearm bone—the hand and the forearm are then animated and moved out to\nthe end of the upper arm bone. This continues down through the hierarchy until che\nentire skeleton has been properly transformed.\n\n(Given the spatial relationship between the skin's vertices and the bones of the\ncharacter, it is necessary to transform the vertices of the skin into the local coordinate\nspace of the bones to which they are attached befare transforming them by the bone's\nanimation matrix. To do this, we need to keep a maurix in each bone thar tells us how\nto transform geometry back into the local space of the bone. This matrix should be\nthe inverse of the matrix used to transform the bone from its local space into the char-\nacter's mesh, given che orientation of the mesh without any animation being applied.\nSee Figure 4.15.2 for a depiction of the local spaces for each bone in our arm mesh.\n\nTherefore, the data structure of our bones should look like the following:\n\nstruct Bone\n{\n\nMtx orientation:\nMtx animation;\nMtx inverseQrientation;\n\nMts final;\n\nBone “child;\nHone “sibling;\n33\n\n(nce we have this data, we are ready to animare our character, To do chis. we\nmust simply step through the vertex data and transform each vertex by the orientation\nmatrix and then the animation matrix of che comesponding bane.\n\nFIGURE 4.15.2 A depiction of the bones in our arm.\n\n4.15 Filling the Gaps\n\n476\n\nAll of these transformations can be done faster by processing che bone hierarchy\nand generating a final wansformation matrix for each bone concatenating a bone's\nINVErse Orlentation, concatenated orientation, and concatenated animation matrices\n\ntogether and then transforming geometry by the resulting mateo,\n\nwoid Buil@Matricas ( Bone *bone, Mtx forward, Mtx orientation )\n\n{\n\n}\n\nWt« localForward;\nWt local0rientation;\n\nff COncatanate the hierarchy's orientation matrices ao\nff that wa can generate the inverse\nconcatenatea(bone->orientation, orientation ,\n1lhcalirian tation) 5\n\nff take the inverse of the orientation matrix for this bone\ninverée{localorientation, bone->inversedrisntatian) |\n\nff COnCatanate this bone's orientation onto the Torward\nff matrix\n\nConcatenate(bone-2arientation, forward, LocalForward);\n\nif canéatenste this bone's animation ante the forward matrix\nconcatenate (bone->animation, lacalFoermrd, localForward);\n\ni# build the bone's final matrix\ncondatenate (bone->inversedrientation, lacalForward,\nbone ->final};\n\nif (bone->child)\nBuildMatrices(bané->child, localForwand,\nlocaldrientatian) ;\n\nif (bone-»sibling)\nBuildMatrices(bone->sibling, forward, orientation) ;\n\nUsing the preceding technique on the arm mesh, a bend of 45 degrees and 90\ndegrees to the foreartn bone produces the images in Figure 4.15.3.\nStitching is a very valid technique, since it casily takes advantage of any hardware\nthat provides a transform engine. Ik is mecessary to generate the final stitching matrix\non the CPU, but the hardware can easily use these matrices to transform any number\nof vertices we pass it.\nAsan optimization to this technique, I suggest breaking up the continuous skin\nLi] that the verbiccs exist in the lacal Space al the hone hn which they aic attached. This\n\nprevents us from having to do an extra matrix concatenation per bone per frame of\nanimation,\n\n480 Section 4 Polygonal Techniques\n\nFIGURE 4.15.3 2: Stitched arm mesh bent wo 45 degrees. 4: Bent oo 90 deprees.\n\nSkinning\n\nWhile stitching is a valid technique, it has some problems, In cases of extreme joint\nrotation, geometry tends to shear massively and appear quite unnatural. Using the\ntechniques discussed! earlier, a forearm notation of 120 degrees displays quite a nasty\nshear effect at the elbow. This results because we only have one polygon co span the\nendre gap berween the upper arm and the forearm. The larger this gap becomes, the\nworse the solurion looks, as shown in Figure 4.15.4.\n\n‘To prevene this, we can implement a full system of skinning where a vertex is not\nlimited to being affected by a single bone; it can instead be influenced by multiple\nbones. This makes sense if we look ar the behavior of the human body. The skin on a\nperson's elbow is not affected by the orientation of just one bone. The movements of\nboth the upper and lower arm bones affect ic. Similarly, skin in the neck and shoulder\nis affected by the orientations of the arm, neck, and chest.\n\n‘To enable this, cach vertex in a skinned mesh must contain a list of bones that\naffect it. Each vertex must also carry a weight per bone thar tells us how heavily\naffected the vertex is by the bone. For this example, we will assume linear skinning,\nwhich means all of the weights of a vertex must add up to 1.0. Because of this, given\n» bones by which a vertex is affected, we need to store #—1 weights, since the remain-\ning weight should be 1.0 — (werghr, + weight; +... + weight,_,}.\n\nBEruct Vertox\nFloat s, t;\n\nFloat x, y¥, Zi\nunsigned long color:\n\n4.15 Filling the Gaps 4a4\n\nFIGURE 4.15.4 Uply stitched arm mesh bent co 120 degrees,\n\nunsigned long bonelndext;\nunpagned long boneindexz;\n\nfloat weight:\n\nhi\n\nAs mentioned earlier, sticching is a subset of skinning, and therefore suffers from\nthe same local-space transform issucs as stitching. Therefore, we should use che same\nbone representation as shown previously.\n\nIn order to do full skinning, we need to transform each bone by each mato\naffecting it, then multiply the result by the corresponding weight, and, finally, accu-\nmutate the results. The equation for skinning looks like:\n\n(verter * metre? right) + (vertex * matrox! * weightl) +o. +\n(vertex “ matrocN © weight)\n\nwhere the sum of all weights 0.4 = 1.0.\nWhat we are effectively doing is a linear interpolation berween transformed ver-\ntices. The following is che code used to perform this operation on a given mesh.\n\nVectaraD TransfaraVertes ( Vertex “vert, Bone \"baneArray }\n4\n\nVeetorao tenp;\n\nVectoarad final:\n\nSection4 Polygonal Techniques\n\ntemp = kFornvec(vert--poaition,\nbone] vert->bonaIndex1]->Tinal)\n\nFinal.x = temp.x © vert->waignt:\nfinal,.y = temp.y © vert-=waight;\nfinal.z = temp.z * vert->weight:\n\ntenp = kFornvec(vert->position,\nbone[ vert->bone Index? ]->tinal}\nfinal, += teap.x * (7.0 - vert->weight):\nfinaly += temp. y * (7.07 - vert->weight};\nfinal,z += temp.z * (71.0F - vert->weight};\n\nraturn final;\n\n}\n\nUsing the technique outlined previously, we were able to generate the following\noutput for forearm rotations of 45 degrees, 90 degrees, and 120 degrees, respectively.\nNote that even in the extreme 120-degree example (see Figure 4.15.5), the continuity\nafthe elbow geometry is still maintained.\n\nAs you can see, a major problem with skinning is that it is computationally\nexpensive. Unfortunately, these compurarions ate not well supported by today’s hard-\nware transform engines. An alternative way of performing the linear interpolation eal-\nculations, which potentially takes advantage of some current hardware\nimplementations, is to generate a skinning matrix to be passed to hardware co per-\nform the final transform. To calculate the skinning matrix, simply interpolate the\nmatrices linearly based on che weight:\n\nfrearriel * weaghtO) + (negtrixt *weight]) +... + { marrdcN * weight¥)\n\nwhere the sum of all weights 0..N = 1.0.\n\nThis method is only useful if dhe same skinning matrix can be used for multiple\nvertices; in other words, different vertices are weighted identically between the same\nbones. The less this case is crue, the less the gain of this method will be.\n\nFIGURE 4.15.5 «: Slonned arm mesh bene vo 45 degrees. 6: Bent to 90 depress, = Bene ro\n130 depress.",
      "page_number": 462,
      "chapter_number": 48,
      "summary": "This chapter covers segment 48 (pages 462-474). Key topics include bone, vertex, and skinning. The method can in short be described as a\ndever way of modifying and sorting an object's vertex list and re-mapping the face list\naccordingly.",
      "keywords": [
        "bone",
        "Vertex",
        "skin",
        "vertices",
        "animation",
        "Skinning",
        "Polygonal Techniques",
        "che",
        "matrix",
        "arm",
        "Simple Skinning Technique",
        "bone thar",
        "Technique",
        "bone animation matrix",
        "boneptr"
      ],
      "concepts": [
        "bone",
        "vertex",
        "skinning",
        "skin",
        "weight",
        "animations",
        "animation",
        "animators",
        "animated",
        "animate"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 4,
          "title": "Segment 4 (pages 64-82)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 38,
          "title": "Segment 38 (pages 367-374)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 45,
          "title": "Segment 45 (pages 429-442)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 48,
          "title": "Segment 48 (pages 469-476)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 46,
          "title": "Segment 46 (pages 443-452)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 49,
      "title": "Segment 49 (pages 475-482)",
      "start_page": 475,
      "end_page": 482,
      "detection_method": "topic_boundary",
      "content": "4.15 Filling the Gaps 403\n\n==\n\nTr is importane co mete that the skinning technique outlined previously is not a\ncompletely mathematically correct technique. If nonmals are wansformed using this\ntechnique, the results are nor guaranteed to be normalized. If per-vertex lighting is\nrequired for a character using this technique, post-transform normals must be re-nor-\nmalized before lighting calculations.\n\nAdvanced Topics\n\nThe skinning example assumes all the weights influencing a vertex must add up to\n1.0. It is a possibility, however, to create some compelling special effects with weights\nthat do nor sum to 1.0. For instance, it is possible no place an extra bone in an arm\nthat simulates a bicep muscle. All of the vertices in the arm's skin should be weighted\nnormally between the wpper arm, lower arm, and shoulder. However, the vertices near\nthe bicep should also be weighted based on their distance from the bicep bone—\ncloser vertices should have higher weight values. When the arm bends, apply a scale to\nthe bicep bone co creace the appearance of a muscle flexing.\n\nThe skinning technique outlined is not mathemarically correct because we are\nessentially linearly interpolating matrices. Instead of representing bones as matrices, it\nis possible 1o represent them as a quaremion. SLERP berween the quaternions based\non the per-vertex weights and chen produce a matrix from the result, This should\nyield a somewhat better-looking skinned mesh.\n\nReferences\n\n[Lander93) Lander, Jef, “Skin Them Bones: Game Programming for the Web Gen-\neration,” Game Developer Magazine (May 1998): pp. 11-16.\n\n[Terzopoulas87) Terzopoulos, Demetri, et al, “Elastically Deformable Models,”\nComputer (Graphics, Vol 21, oo.4 (SIGGRAPH 1987)- pp. 205-214.\n\n4.16\n\nReal-Time Realistic Terrain\nGeneration\n\nGuy W. Lecky-Thompson\n\nTerrain is the centerpiece of many games, an important backdrop in same, and just\nsomething to fill the space in others. No matter how it is used, ir will still artract\nunwanted arention if it is badly represented and, by the same coken, will add to the\nanmosphere, playability, and long shelf life of the game if done well.\n\n‘The use of the term rernain conjures up images of landforms, lakes, mountains, or\neven desolate craters in airless armosphezes for most people. While this is an impor-\ntant aspect of building the game, the word ternain may be used in a much broader\nsense. It can cover objects, names and buildings, parts of the game universe that che\nplayer will interact with, and pieces chat only give support to those parts.\n\nThe aim of this article is to equip the reader with several algorithms that enable a\nrealistic terrain to be created, within which the game may be played.\n\nThe emphasis here is on generation, and not storage. That is to say, the algo-\nrithms are presented in a manner thar leans toward using them to create terrain in\nreal-time, ancl not generation for storage, with a view to replaying the contents ar 2\nlarer date, Used with the techniques defined in the Predicneble Random Nor bers arti-\ndle in this book, a powerful near-infinite universe can be generated.\n\nLandscaping\n\nThe first technique that ean be used to create basic terrain is fexzy danalcaping. Essen-\ntially, it is simply creating topography in a completely random fashion, with scant\nregard to the real world. It is presented here simply as a starting point upon which we\nmay build future algorithms that will prove of more use.\n\nHere is some pseudocode thar generates a finite grid:\n\ny= -1;\n\nwhile y =< 100 {\nx= 0;\nyoy oeed,\nsrand(y):\n\n4.16 Real-Time Realistic Terrain Generation\n\nwhile x = 100 {\nMap(x, ¥) = rand (3);\nK=x + 1:\n\n}\n\nAAs can be seen,.chis will simply populare a 100 x 100 grid with a series of random\nnumbers between 0 and 3. We can then assign colors to the numbers such that 0) is\nblack (water), 1 is dark gray (plains), 2 is light gray (land), and 3 is white (mountain).\nThis effect is seen in Figure 4.16.1. Note also that the random number generator is\nseeded on part of the grid reference of the individual square. This ensures that we can\nalways recover the value without needing to go through the entire grid [Lecky99], bur\nonly through thar line,\n\nThis is slightly less perfect chan one would hope, since we would like to seed\nbased on a discrete square. To do chis, we would need to create our own random num-\nber generator to rid us of the annoying effect seen in Figure 4,16.1, which results from\nusing the ANSI srand function: srand (x + (x * y)) foreach grid square,\n\nGood-looking fuzzy terrain is more realistic chan chat shown in Figure 4.16.1, so\nwe need to perform some additional processing on the resulting “map.” The tech-\nnique that we shall use is one that can he applied to any of the terrain-generating algo-\n\nrithms presented here, indeed to any abstract set of random figures that require a\ngrouping trearment.\n\nFIGURE 4.76.1 A tthe 1 00 nde Pe ed ey bee\n\nSéection4 Polygonal Techniques\n\nThe driving philosophy is to ensure that the randomness of the map is reduced by\nensuring that neighboring squares hold a similar value, but at the same time allowing\ndifferences between specific sets or areas of squares. As usual, it is far easier to watch in\naction than to explain. The pseudocode looks like this:\n\nStep = 4:\nfor y= 0) y = 100; y = ¥ + step {\nfor x = 0; x = 100; x = x + atep {\ntotal = 0;\nfor y_local = y; y local <= y + step;\ny_local = y_loeal + 1 {\nTor x_local = x; x_local <= x + step:\nx_local = x_lncal + 1 {\ntotal = total 4 map (x_local, y_local);\n}\n}\naverage = total | (etep « step);\nfor y_local = yi y local <= y + step;\ny_local = y_local + 1 {\nfor w_local = ™; x local <= x + step;\nx_local = x_local + i {\nBap (x_local, y_local) = average;\nI\n\n}\n}\n\n‘The effect of applying this smoothing algorithm can be seen in Figure 4.16.2.\n\nWhile the net result is far from perfect, the overriding feeling is thar the map has\nbecome much less random than before.\n\nIt works by dividing the grid into a series of larger squares, and then subdividing\nthem. The average value of the subdivisions is then computed and propagated\nthroughout the subdivisions. The overall effect is one of smoothing.\n\nThe choice of subdivision size here is quite important also—too large a subdivi-\nsion will create wide expanses of similar values, and too small a subdivision will not\nproduce the desired effect.\n\nAn improvement to thit algorithm is to approach ir from a slightly different\ndirection. The end result is the same, modifying discrete pointes of the terrain based\non the surrounding points. This time, however, we will select che four comer points\nof the square for the averaging process, rather than use every poine. Also, we will only\nchange the center points of cach of the four quarters of the chosen square, rather than\nevery poinc.\n\nThe following code is snipped from the terrain-generation software that appears\non the CD.\n\nTor { ant square size = width; square_siza > 1; square_size j= 2 }\n\nint randes_range = square_size;\n\n4.16 Foal-Time Realistic Terrain Generation 487\n\nFIGURE 4.16.2 A smoothed version of our tandem terrain grad.\n\nfor { int xi = row_offset; x1 < width; «1 += square size }\n\n{\nfor { int yi = row_offset; yi < width; y1 += square_size }\ni\n\nif Galculate the four corner offsets\nint x2 = (M1 4 square size) %& width:\nint ya (yl * a9uaré Size) %& width:\n\nfi Get the values\n\nint di = this->terrain[xij[vil:\nant a@ = this->terrain|x2][v1]*\nint 23 = this->terrain[xi][y2]:\nint i4 = this->terrain[x2][y2];\n\ni? Create weighted averages, based on\n\nint pi= ({i1 \" 9) + (12 * 3) + (i3 * 3) 4+ (d4)) s 18;\ndnt pe = {£1 * 3) + (12 * op * (a3) + (a4 * 3)) Ff 185\nint pS = ((il * 3) + (12) + (13 * 8) + (i4 * 3)} / 16;\nant pt = (({il} + (42 \" 3) + (43 * 3) + (i4 * 99} / 16;\n\nff Galculate the center points of each quadrant\nInt ¥3o= (x1 + square_size/4) & width;\n\nant ya = (yl + Square_size/4) & width;\n\nMa = (xd * Square _size/2) & width:\n\nYo = (yS * square_size/2) % width:\n\nif Set the points to the averages calculated above\n\nSection 4 Polygonal Techniques\n\nthis->terrain [x3][ya] = pi;\nthis=->terrain [x2][ya] = pes\nthis->terrain [x3] [y¥2] = Aa;\nthis->terrain [x2] [yz] = pd;\n}\n}\n\ni} For the ngxt row, move in alightly\nFow_offset = square _size/4;\n\n}\n\nFigure 4.16.3 shows the four comer points and the bounding rectangle of the\n\n~ four center points used in che calculations above.\n\nThis technique was first introduced to me by James McNeill [McNeill95], and is\nanc of the most reliable examples of “smoothing” I have seen to date. There are end-\nless variations that involve adding random offsets to the calculated points, amongst\nothers, which lead to more variable landseapes.\n\nAs an enhancement to the two techniques discussed here, we may introduce a\nthird mechanism, known as Fault Line landscape generation. Fault Line landscape\ngeneration works by choosing nwo points at random and drawing a line at a given\nheight between them. Next, nwo more points are chosen, and again, a line is drawn\nberween them. This is repeated until there are acertain number of lines on the screen,\nasin Figure 4.16.4.\n\nThe next step is simply to apply the subdivision technique explained previously\nte smpoth the differences between the points. This results in a series of “islands” beeing\ncreated as can be seen in Figure 4.16.5, See Jason Shankel’s article, Ancor! Terrain\nGenenstion—Fanilt Formation, in this volume for further information on this tech-\nnique.\n\nWhile this may seem simple ar first, the line drawing itself is in fet more com-\nplex. As the disceming reader will have noticed in Figure 4.16.5, the lines are not\n\nFIGURE 4.16.3 Subdivision coordinates.\n\n4.16 Real-Time Realistic Tarrain Generation\n\nFIGURE 4.16.4 Random faule limes.\n\nFIGURE 4.16.5 Paul lines smoorhed inca idands.\n\n450 Section4 Polygonal Techniques\n\ndrawn at a2 constant “height.” That is, the value atcribured co each point along the line\nchanges with respect to the distance from the starting point to the ending point.\n\nThe algozichm used to decide the “height” of each point is a sine curve, whose\namplitude is based on the distance between the owo points. The following code sep-\nment shows the core line-drawing algorithm at work thar forms part of the terrain\npenerator software on the CD.\n\nda\n\n{\nthis->terrain[ (int)_etart][(int})y start] =\nnCurrentRhandomValve:\nx_start = x start + x_diff;\ny_start = yostart + y dirt:\n\nI} Apply a sine function oscillating between 0 and 255\n/}/ The sin function showld be called with values from\nii =pif2 te pife\n\nif (m_diff < y_diff)\n\nnCurrentiondonvalue = (sin(x start) \" 128) + 128:\nelse\n\nnturrentiandonValue = (sin(y start) \" 128) + 12a;\n\n} while ({iy_start < (float}this-:terroin_ width) &&\n{y_start > 0.0)) BA\n({z_start = (float) this->terrain_height) Bh\n(x_start > O.0}});3\n\nThis is performed for cach line to achicve an effect akin co 2 mountain range,\nalbeit with a very smooth oscillation.\n\nThe important point co note about all of the techniques discussed is chat the\nlandscape that is generated is repeatable. That is, using the same basic input values,\nidentical landscapes can be generared at will, They do not need so be stored anywhere.\nThis ts the underlying principle for creating terrain in general, and is the core theme\nto the remainder of this article.\n\nUsing these techniques along with the principle of generation, we can say that\nsince in theory every time we seed the random number generator, we will get a differ-\nent set of random numbers, the possibilities for generating terrain are infinite. Fur-\nthermore, since we can re-generate or re-calculate at will any point of any terrain, we\nnever need more than just man-cime storage, which leaves us space on the delivery\nmedia for much more than just level files.\n\nOme of the most common structures in the game-playing arena (if you'll pardon the\npun) is the maze. Doon uses several to good effect, for example. In addition, ladders",
      "page_number": 475,
      "chapter_number": 49,
      "summary": "This chapter covers segment 49 (pages 475-482). Key topics include terrain, square, and generation. References\n\n[Lander93) Lander, Jef, “Skin Them Bones: Game Programming for the Web Gen-\neration,” Game Developer Magazine (May 1998): pp.",
      "keywords": [
        "Filling the Gaps",
        "Terrain",
        "local",
        "square",
        "Realistic Terrain Generation",
        "Realistic Terrain",
        "points",
        "Random",
        "size",
        "int",
        "Real-Time Realistic Terrain",
        "technique",
        "square size",
        "width",
        "Generation"
      ],
      "concepts": [
        "terrain",
        "square",
        "generation",
        "generated",
        "generates",
        "generator",
        "point",
        "pointes",
        "width",
        "techniques"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "Segment 64 (pages 617-624)",
          "relevance_score": 0.68,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 48,
          "title": "Segment 48 (pages 461-471)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 62,
          "title": "Segment 62 (pages 601-608)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "Segment 63 (pages 609-616)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 10,
          "title": "Segment 10 (pages 91-99)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 50,
      "title": "Segment 50 (pages 483-490)",
      "start_page": 483,
      "end_page": 490,
      "detection_method": "topic_boundary",
      "content": "4.16 Real-Time Realistic Terrain Generation 454\n\nand levels-rype games also use a two-dimensional variation of the maze. These mazes\noften increase in complexity according to the skill of che player, and may be littered\nwith all manner of rreasure,\n\nToo often, though, these use up so much storage space (Oven WAD files for\nexample) thar you simply cannot put enough of chem on a (CD te satisfy the player. A\ntruly realistic terrain (in the broadest sense) requires che illusion of infinity, and so it\nwould be a great boon if we could somehow creare these containers in real time.\n\nTf no attention should be paid to the “shape” of what is being created, it is\nextremely simple to create something thar will contain passages and paths, bur with\nno rooms. (The author fondly remembers a few early arcade games like that...) Basi-\ncally, che aim is to imagine that the playing area is contained within a finite space,\nwhich we will call a box.\n\nThis box is then subdivided by drawing horizontal lines from the left-hand side ro\nthe right at random intervals. Next, these sub-bowes are divided by drawing vertical\nlines from the top of the box to the boom, again ar random intervals. A possible\nresult is shown in Figure 4.16.6,\n\nseen from this angle, this is mot very inceresting ar all, but it is all a question of\nrepresentation. Imagine the black lines to be passageways, Now imagine that che play-\ners only see the passageways from the first-person perspective; all they will know are\njunctions and passages.\n\nIn fact, it still wouldn't be especially convincing—it is still missing rooms and\ndeac-ends, Boch of these will increase the reality of the experience. Rooms are quite\neasy, because all thar is required is that any space that has dimensions exceeding che\n\nFIGURE 4.76.6 Random limes divide our be.\n\nSection4 Palygenal Techniques\n\nsmallest box can be considered a room. Working out the dimensions of the smallest\nbox is almost roo easy,\n\nSince we know thar all the horizontal and vertical lines must meet at some junc-\nture, it follows char the smallest box is the junction of the two vertical lines with the\nsmallest horizoncal separation, and the nwo horizontal lines with the smallest vertical\nseparation. Anything larger than thar in beth directions can be considered a room;\nwhatever is left is just passageway. Based on that, what emerges is shown in Figure\n4.16.7 (here we have added a little to the sizes used to work our the passageways and\nrooms).\n\nBy placing entryways on the walls at various places, we have created a playing area\nthar can be generated entirely on the fly. Increasing the number of lines, or decreasing\nthe size used to determine what is a passageway and whar is a room, will affect the\ncomplexity and hence the case of play.\n\nHowever, it is still not very realistic. In fact, it looks more like the intersection of\na couple of streets, rather than a building. So let ws treat it like char, and determine\nhow we may turn the “roms into “buildings.” The passageways will remain streets,\n\nRather than blindly chopping the “room” into pieces as we did previously, build-\nings can be made more realistic by subdivision, Taking a square, we divide it at a ran-\ndom position into qwo pieces, vertically. Then we divide each of the two pieces into\ntwo more, horizontally. Next, we may choose to divide each of the resulting pieces\ninto two, again vertically. This can be repeated as many times as is required. In Figure\n4.16.8, we have taken one of the larger squares from our previous ¢xample.\n\n‘The algorithm for doing this is fairly complex; however, here is an acceprable\nvariant for vertical lines:\n\n1. Start at the leftmost side, at a random height.\n2. Count the number of squares to the right until a wall is encountered.\n\nFIGURE 4.16.7 a: Before line removal. 4: After line removal,\n\n4.16 Real-Time Realistic Terrain Generation 493\n\nFIGURE 4.16.8 Rooms creaned by subdivision\n\n3. Atarandom number of squares from the left, draw a line from the top to the ber-\ntom.\n\n4, Repeat steps 1,2, and 3 to taste.\nAnd its equivalent for drawing horizontal lines:\n\n1. Start at the topmost side, at a random width.\n\n2. Count the number of squares down until a wall is encountered,\n\n3. Ata random number of squares from the cop, draw a line from the left to the\n4, Repeat steps 1, 2, and 3 to taste.\n\nOf course, the algorithm needs to ensure thar when counting from top to borrom\nfor indeed left to right), that this is performed along a line, to avoid “floating” lines\nappearing that start in the middle of the square. All lines that are drawn must have a\nstarting point and an ending point at a wall.\n\n‘The next step is to insert doors in the walls. This can be done in a variety of ways,\nbut perhaps the easiest is ro work, again from top to bottom, or left co right, and\ninsert a door in internal walls such that sections of walls have a maximum of V doors\nin them.\n\nIf this is done completely at random, we nin the risk of having some walls with\nno doors, and potentially some rooms oo which there is mo direct access. Depending\non whether this creates a problem, the algorichm must be adapted.\n\nNaming Algorithms\n\nGiving objects, places, or fearures realistic names is a real chore when it comes to most\ngame design. Five, by David Braben and lan Bell, came up with some classics (Lave,\n\nSectlon4 Polygonal Techniques\n\nDisa, Reidquat, Leesti, Orevre, enc.) for che first star system. The first of a sLagger-\ningly large galaxy, in a universe of near-infinite scale, Considering that the machine\nthar the game was running on (with 16K RAM) was a limined-resource second-gener-\nation microcomputer, this was a huge achievement, Clearly, dhere was no way that\nthese could have been stored (diskettes had yet to be invented), so they must have\nbeen generated,\n\nWe could begin by generating a word of six letters, each one chosen ar random.\nWe might come up with something like “ndpgbs,” which is not terribly convincing,\nWhat is required is some method by which we can ensure thar letters thar are next to\neach other fir naturally, The first step is w create a table of letter-frequency pairs, so\nthat fora piven letrer we can say that there are a limited number of possible letters that\ncan follow it, and calewlate the chance that each one may follow it.\n\nThe following listing is the key to a technique known as the Markovian List (see\nale [Dewdney0)):\n\nvoid AddLetters(char * szWord, unsigned long ulTable| 28) [28))\nint n¥ordlength, nFirstletter, nlastLetter, AlLetter;\n\nff Decapitalise the word\nTor (fAletter = 0; nletter < (int) strlen({szWord)-iinlettere+}\ntolower (szlord[nLatter]};\n\nff Add the first, and last to thea table\nmvardlength = (int}strlen(szWord);\n\nnFiretLetter = (szWord[O] = ‘a\") + 1:\nnlLastletter = (szWord[nWardlength-1] - ‘a'} 4+ la\n\nwlTable[O][nFirstLetter]*+; // Space followed by letter\nulTable[nlastlLotter][27]*4+; // Letter followed by space\n\nTor (nletter = 0; nletter < nWerdlength-2; nletter++)\n\nnFirstletter = (szverd[nLetter] - *a\")ot 1\nnLastletter = (szWord[nLettert+1] - ‘a') + 1;\n\nulTable[nFirstLetter] [mLastletter]++;\nI\n}\n\nThe algorithm represenced here needs little explanation, other than te say thar for\na given word, we specify which letters are the starting and ending ones, and add them\nta the table. Then, for each pair, we update the table such that the position referenced\nby the letters is incremented, cementing a relationship benween the nwo thar we will\nmake use of larer.\n\nAs can be seen, this requires storage space of the order of 28x28x4 bytes (3,136),\nwhich fulfills our criteria of getting it into a 1GK RAM machine. Indeed, removal of\nall the blank entries will probably reduce the space requirements even more.\n\n4.16 Real-Time Realistic Terrain Generation 455.\n\nOnce we have passed the algorithm over a selected text, or texts, we will have a\ntable that contains all possible lecter pair frequencies for chose texrs. We should also\nstore the average word length, toa.\n\nUsing this table, we may now generate a word, starting with the firse letter. To do\nthis, we should choose a random letter such thar it may begin a word; in other words,\nit falls in a column of the table referenced by wfTable/O}, such chac wf Tabdefol fs} is\nereater than zero. In addition, we can use the values stored in chis row to determine\nthe chance of a specific cell being chosen.\n\nTo do this, we simply add the values of all the cells referenced by nfTabtefO} {i}\n(where #runs from | to 26). Next, we call che random number generator to retrieve a\nvalue between 1 and the value we have calculared. We then pass through the row\nagain, sumone the frequencies as before, uncil the random number that we have is\nless than the running cotal, This is our leer; for example afFable/Ol/4) is a “d.” The\nfollowing code shows a genetic form of this algorithm, which can be applied to any\nletter.\n\nint GetLetterPositLon(unsigned tong ulWordTable[ 28] [26], int\nnPravious }\n\nint mtounter;\nunsigned long wlFrequencyTotal, ulFrequencyRunninglotal,\nULABRGoRLetter:\n\nulFrequencyTotal - 0;\n\nfi Get the Trequeancies\nfor (nCounmter = 1; nCounter =< 27; mCounter++})\n{\nulFrequencyTotal = ulFirequencyTotal +\nulWordTable[nPrevious] [mCounter] -\nI\n\nii Choose a ‘target’ frequency\nulRendonletter = rand(} & (ulFrequencyTotal);\n\nii Mowe through the table until we hit tha ‘target’ frequency\nulFréquencyRunningTotal = O;\n\nnaCounter = 1;\n\ndo\n\nUIFrequencyRunningTotal = ulFrequencyfunningTotal +\nulWerdTable[nPrevious] [nGounter];\nACoNTEre+ 5\n} while (ulFrequencyRunningToatal < ulRandgmletter);\n\nreturn mounter;\n\n}\nIn order co build a word of six letters in length, the general algorithm would be:\n\nWard(O] = GetLetterPosation (word_table,O)\n\nSection4 Polygonal Techniques\n\nKil\nwhile x <6 {\n\nThis is the essence of the software NameGen that appears on the CD, and for\nwhich full source code is available, The NameGen code is also used in the demonstra-\ntion program Unitsen (for creating star maps, with named planers).\n\nHowever, as it stands, the word-generarion algorithm doesn't preclude strange\nwords such as “flecee” or “nooooo” creeping in. The problem is that there are a certain\nnumber of letters that can form chains. That is, an “o” can be followed by an “o,” and\nanother “o,” almost to infinity. The random number generator may prevent this to a\ncertain extend, but even a repetition of three “o's” is a little ugly.\n\nso, our werd-building algorichm should become:\n\nWord[O] = GetletterPosition (word_table,O)\n\nx= 4\nwhile x <6 {\n\nword[x) = ((GetLatterPosition (word_table, word[x-1] — ‘a'))\n=1) + ‘a’\n\nx = RengveChain( word, x}\n}\n\nWhere che Resovethain function returns the current letter index into word if it is the\nthird ina chain of itself This could be coded as in che following listing:\n\nint Removethain( char word(M4x LENGTH], int letter_position }\n\n{\nint nPos = oO:\n\nint nOccureances = 0;\nwhile (nFos = strlendword)}\n\nif (word[nPos) == word[letter_position])\nPOCCUPEMGes++;\n\n}\n\nif (NOpcurences > 2) return letter_position — 1;\n\nreturn letter_position + 1;\n\nI\n\nThis will clean up the word, and if there is no excessive chain, increment the lee\nLer POSINON Souter,\n\nThe final step that can be taken in enswring that the word is authentic is to\naddress the last letter, and make certain thar it is one that can commonly end a natural\nword, Some letters, for example, are commonly followed by a vowel in the English\n\n4.16 Real-Time Realistio Terrain Generation 407\n\nlanguage, such as “J.” In order thar words do not creep in that end in such letters, we\nmust perform at least two operations.\n\n‘The first operation is to ensure thar the letter may follow the one thar it is adja-\ncent to, and to ensure thar the chosen lecrer may end a ward (be followed by a space).\nIn addition, we must also he careful that such a leteer exists; otherwise, we may end up\n\nin an endless loop. To de all this, the following code is adapted from the GetLetter-\nPosition function already described.\n\nint GetEndlLettar (unsigned long ulWerdTable[28)(28], int nPreviows)\n\nJ\n\nint nGgunter;\n\nunsigned long wlFrequencyAd)sacentTotal ,\nulFrequencyAunninglotal, wlAandonletter,\nulFrequencyendingtotal:\n\nU1FrequencyAdjacentTatal = 0:\nwlFréquencyEndingTotal = 0;\n\nif Get the frequencies\nfar (mtounter = 1; nGountar =< 27: nGountert++)\n{\nWIFrequencyAdg|acentTotal = olFrequencyAdjacenttotal +\nulWordTable[nFrevious][aCaunter];\n\nUIFrequencyEndingTotal = wlFrequencyEndingiotal +\nulWordTablel 27] [Counter];\n}\n\nii Ghoose a “target” frequency\nulRandomLetter = rand() % wlFrequenoyAdjacentTotal:\n\nff Mowe through the table until we hit the ‘target’ trequency\nuIFréquencyRunningTotal = 0;\nACounter = 1:\nde\n{\nWIFraquencyRunningTotel = wlFrequencyRunningTotal +\n\nulWordTable[nPrevious) [Counter]:\nnGowuntar++;\n\naf (ulFrequencyEndingTetal > o)\naf {(ulFrequencyRunningTotal == ulRandomLetter) &&\n{ulWordTable[27][nCounter) f= oO)\nbreak;\nelse\nif (ulFrequancyRunningTotal >= ulRandonLetter)\n\nbreak;\n} whilg (1 == f):\n\nreturn nGounter:\n\n}\n\n490 Sectlon4 Polygonal Techniques\n\n‘in improved version char selects che leteer as a function of the combined proba-\nbilities of the target leter being adjacent to the source lemrer and at the end of a word\nis left as an exercise for the reader.\n\nAdditional points to nove are that this method is limited only by the use of allpha-\n\nbet (it must be Roman), and chat no attempt has been made to capitalize che begin-\nning of words.\n\nReferences\na\n[Dewdney90] Dewdney, A. K., The Tinkertay Computer, WH. Freeman, 1990,\n\n[Lecky99] Lecky-Thompson, Guy W., Algorithms for An Infinite Universe, Gamasu-\ntra, 1999.\n\n[McNeill95) McNeill, James, SubDiv Applet, mcneja@wwe.edu.",
      "page_number": 483,
      "chapter_number": 50,
      "summary": "(The author fondly remembers a few early arcade games like that...) Basi-\ncally, che aim is to imagine that the playing area is contained within a finite space,\nwhich we will call a box Key topics include word, random, and letters.",
      "keywords": [
        "word",
        "Realistic Terrain Generation",
        "thar",
        "letter",
        "lines",
        "random",
        "Realistic Terrain",
        "Real-Time Realistic Terrain",
        "Terrain Generation",
        "int",
        "Oven WAD files",
        "random number",
        "che",
        "number",
        "vertical lines"
      ],
      "concepts": [
        "word",
        "random",
        "letters",
        "algorithm",
        "lines",
        "returns",
        "rooms",
        "techniques",
        "follow",
        "frequencies"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 12,
          "title": "Segment 12 (pages 101-108)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "Segment 64 (pages 617-624)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 22,
          "title": "Segment 22 (pages 205-213)",
          "relevance_score": 0.5,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 24,
          "title": "Segment 24 (pages 229-237)",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 62,
          "title": "Segment 62 (pages 601-608)",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 51,
      "title": "Segment 51 (pages 491-499)",
      "start_page": 491,
      "end_page": 499,
      "detection_method": "topic_boundary",
      "content": "4.17\n\nFractal Terrain Generation—\nFault Formation\n\nJason Shankel\n\nIn nature, forees such as the separation of rectonic plates, mass-wasting, and shoreline\ncfosion create terrain feacures like escarpment, mesas, and seaside cliffs, In chis arti-\ncle, | will show how we can use a fault formation algorithm to generate these kinds of\n\nherrain.\n\nFault Formation\n\nSeart with an empey height field. Draw a random line through it and add an offset\nvaluc dAaight to cach value on one side of the line (See Figure 4.17.1):\n\nNeat, decrease dAfergit, draw a new line, and repear the process. Continue gener-\nating lines and decreasing f@Hefg/t uncil a sufficient level of detail is generared.\n\nFigure 4.17.2 shows cerrain height fields at 4, 8, 32, and 64 iterations (higher ele-\nvations in whire}.\n\nFIGURE 4.17.1 ‘The first sep of our heighr Geld.\n\n4o6\n\n500 Section 4 Polygonal Techniques\n\n4 iterations 8 iterations\n\n32 iterations 64 iterations\nFIGURE 4.17.2 Terrain height fields created by thir process,\n\nDecreasing dHelght\n\nWe want co decrease @Afeighr linearly with cach iteration, but we don't necessarily\nWant it to drop te zero.\nLet @Geighr, . be che value of @Feight at each iteration. The value of dHfeight a1\n\niteration #, is given as:\n\nHeight; = dHeighty + (iln\\adHeight,-dHeight,)\nGenerating Random Lines\n\nWe want our lines to intersect well with the height field, so generating purely random\nvalues for a linear equation isn't desirable, since the vast majority of lines will contain\nthe entire height field on a single side.\n\n‘To generate a line, it is best to pick owe random points within the height field and\nute them to determine the linc.\n\n4.17 Fractal Terrain Generation S04\n\nPz\n\nf\nFIGURE 4.17.3. M[lustration of choosing a “random line.”\n\nWe can determine which side of a line a poinc is on by calculating the s compo-\nnent of a three-dimensional cross product (Figure 4.17.3):\n\nLet be a line defined by che poines pl and p?\n\nLet ep be a vector in the direction pl — p2\n\nLet o be a point in the height field\n\nLet ve be a vecvor in the direction pl\n\n‘Treated as three-dimensional vectors, xp and vo have z-components of zero.\n\nLet ex = ep & pe\n\n[fens > 0, the point ¢ lies on left side of the line. If mez < 0, the point a lies on\nthe right. [fiz = 0, ¢ is on the line.\n\nErosion\n\nThe fault formation technique creares dramatic differences between neighboring cells\nin the height field. For alow number of iterations, this results in very unrealistic ter-\nrain. Even at high numbers of iterations, the terrain still looks highly aliased, like a\nPiece of paper thar has been sliced multiple times with a razor.\n\nThe problem is char we have unrealistic high-frequency data in our height field.\nIn nature, the sharp divisions berween neighboring cells would be dulled by erosion.\n\nTo simulate erosion, pass the height field chrough a low-pass image filter,\n\nRobert Krten [Krren94] suggests a simple FIR filter. A FIR. filter converts the\nSOQUCIICE X 4, 3 Ayek, OO the sequence yy, Fs. 7y--), according to the formula:\n\nKe aa + (1b;\nWhere # is a filtering constant berween 0 and 1. Low & means less erosion, high &\nmeans more. Typically, a £ of abour 0.5 works well for this application.\n\n502 Sectlon4 Polygonal Techniques\n\n4 iterations\n\n32 iterations 64 iterations\nFIGURE 4.17.4 An eroded version of Figure 4.17.2.\n\nIf we take the FIR filter function and apply it across the rows and columns of the\nheight field im both directions, we will get a nicely eroded landscape (Figure 4.17.4).\n\nFigure 4.17.4 shows the same terrain as Figure 4.17.2 after erosion. Color Plate 1\nisa. 3D rendering of the eroded 64 iteration stage.\n\nSample Code\n\nThe algorithm in the sample code lets you set different numbers of iterations, the\nd@Height for iteration 0 and iteration m, the erosion factor (4), and che number of iter-\nations between erosion passes,\n\nReferences\naint neat ait ee ee ee ee ee\n\n[Krten94] Kren, Robert, “Generating Realistic Terrain,” Dr. Dobbs Journal (July\n194},\n\n4.18\n\nFractal Terrain Generation—\nMidpoint Displacement\n\nJason Shankel\n\nMountain ranges like the Rockies, Sierras, and Himalayas are formed by a geological\nprocess called weft. Lateral pressure from the movement of tectonic plates causes the\nsurface of the Earth to wrinkle like fabric, pushing up mountain ranges. In this arti-\nele, I will show bow we can simulare uplift with a recursive midpoint displacement\nalgorithm, also known as the plasma fraceal or the diamond-square algorithm.\n\nMidpoint Displacement in One Dimension\n\nIn one dimension, midpoine displacement works like this. Start with a line Scement\nAB (Figure 4.18.1):\n\nSens\nFIGURE 4.18.1 Line segment AB.\nTake the midpoint C and displace ir by a random value between <dHeight2 and\n\n+dAeigint/!2, for some suitable dHeight (the length of AB is a good candidate) (Figure\n4.18.2):\n\na\nik\n\nFIGURE 4.16.2. First displacement sage.\n\nReduce the value of dHeight and recurse co the segments AC and CA (Figure\n4.13.3):\n\n505\n\nSection4 Polygonal Techniques\n\nFIGURE 4.18.3. Second displacement stage.\n\nRepeat uncil you generace sufficient detail (Figure 4.18.4):\n\nA\n\nFIGURE 4.18.4. Nih displacement stage.\n\nAreach iteration, dHeight is multiplied by 2\", where ris the roughmess constant.\n\nThe magic value for ris 1. If r= 1, then dHeight is divided by 2 at each iteration,\nwhich is also the rate at which the horizontal line segment length decreases. When r-\n1, the generated terrain will be perfectly self-similar (small seetions will resemble large\nSOCIO).\n\nWhen r> 1, dHeight decreases faster chan the line segment length, so early itera-\ntions have a disproportionately large effect am the cerrain. r > 1 is good for creating\nsmooth terrain with a few prominent features (mountains or valleys).\n\nWhen r< 1, dieighs decreases slower than the line segment length, so late itera-\ntions have a disproportionately large effect on the terrain. r < 1 is goed for creating\nchaotic terrain.\n\nFigure 4.18.5 shows three terrains with varying values of r (higher elevations in\nwhite).\n\nJ r= 1/4\n\nFIGURE 4.78.5 Samples of terrain with various rvalues.\n\n4.18 Fractal Terrain Generation 505\n\nMidpoint Displacement in Two Dimensions—\nDiamond Square\n\nJust as the line segment is the basic unit of one-dimensional midpoint displacement,\nthe rectangle is the basic unit of ewo-dimensional midpoint displacement.\n\nRectangles are a bit more complicared than line sepments, since we have to calcu-\nlate not one but five midpoins for cach rectangle, That is, we must caloulare the mid-\npoint of the rectangle irself, as well as the midpoints of each of the four line segments\nthat make up the sides of the rectangle.\n\nTn the diamond-square algorithm, the calculation of the rectangle’s midpoint is\ncalled the diamond step, and the calculation of the side midpoints is called the square\n\nstep.\nStart with a rectangle (A820), seeded with height values ar the four comers (Fig-\nure 4.18.6):\nA ff\nC fr]\n\nFIGURE 4.18.6 Square ARCO,\n\nCalculate che height at the midpoint E by averaging the values at A, B,C, and D\nand adding a random value berween -dArighn!2 and +@Heright!? (diamond step) (Fig-\nure 4.18.7):\n\nee\n\nIp\n\nFIGURE 4.78.7 First displacement saps,\n\nSection4 Polygonal Techniques\n\nEs (Ae Be CoD + nandom(-dHeight!2, +dHeight{2)\n\nNow, calculate che heights at the midpoine of the line sepmencs (7, G, A, and J)\nby averaging the comer values and the midpoints of the adjacent rectangles, and\nadding a random value berween -dHeight!? and +dHeighe!? (square step) (Figure\n4.18.8):\n\nF\n\nG E H\nc 2... Bb\ni\nFIGURE 4.18.8. First displacement stage, continued.\n\nMultiply @Height by 27 and repeat the process for the squares AGE, FBREN,\nGECY, and FAID (Figure 4.18.9):\n\nFIGURE 4.18.9 Second displacement stage.\n\nRepeat until you've reached a sufficient level of detail.\n\nAn important thing to note about the square step is that the square values rely on\nthe diamond values af neighboring squares.\n\n4.18 Fractal Terrain Generation 507\n\nFor example:\nfos (Pelt J+ Aid + random(-dHeight'2, +dHeight(2}\n\nSo, as the algorithm iterates through each level of detail, ic must first perform the dia-\nmond step for the entire grid before performing che square step.\nTo calculate a square step value on the edge of dhe terrain (4, for example), treat\n\nthe cerrain as though it wraps. In the case of A, take £ as being adjacent to Hon both\nthe right and the left:\n\nAw (Be Di QE M4 + random (-dieight!2, +d Fleigin(2)\n\nDiamond Square in Height Fields\n\nWhen using the diamond square algorithm to fill in a height field, it is best to pick a\nsquare height field with width 2° for some integer . This ensures that the rectangle\nsize will have an inceger value at cach iteration.\n\nSee Color Place 2 for a rendering of a terrain generated into a 256x256 height\nfield.",
      "page_number": 491,
      "chapter_number": 51,
      "summary": "This chapter covers segment 51 (pages 491-499). Key topics include value, displacement, and displace.",
      "keywords": [
        "height field",
        "Fractal Terrain Generation",
        "height",
        "line",
        "Terrain",
        "Fractal Terrain",
        "Terrain Generation",
        "Terrain height fields",
        "Fault Formation",
        "Midpoint Displacement",
        "Displacement",
        "field",
        "Polygonal Techniques FIGURE",
        "iterations",
        "square height field"
      ],
      "concepts": [
        "value",
        "displacement",
        "displace",
        "height",
        "lines",
        "decrease",
        "decreasing",
        "terrain",
        "square",
        "let"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "Segment 64 (pages 617-624)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 48,
          "title": "Segment 48 (pages 461-471)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 24,
          "title": "Segment 24 (pages 231-239)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 45,
          "title": "Segment 45 (pages 429-442)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 36,
          "title": "Segment 36 (pages 360-367)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 52,
      "title": "Segment 52 (pages 500-507)",
      "start_page": 500,
      "end_page": 507,
      "detection_method": "topic_boundary",
      "content": "4.19\n\nFractal Terrain Generation—\nParticle Deposition\n\nJason Shanke!\n\nIn nature, volcanic mountain ranges and island systems like the Pacific Rim's \"Ring of\nFire” are generated by lava flaw. In this article, I will use a particle system borrowed\nfrom the field of molecular beam cpitaxy co simulare lava flow.\n\nMBE Models\nMolecular beam epitaxy, ar MBE, isa process for depositing thin layers of atoms on a\ncrystalline substrate. We can adapt the models used in MBE simulation to approxi-\nmate lava flow. For an in-depth analysis of che mathematics of MBE, see [Barabisi95],\n\nParticle Deposition\n\nThe idea is to drop sequences of particles and simulate their flow across a surface com-\nposed of previously dropped particles. Dropping a sufficient number of particles will\nproduce stractures that look like the flow patterns of viscous fluid (lava).\nStart with an empry height field and drop a single particle ante it (Figure 4.19.1).\nNow, drop a second particle on the first and agitate it until it comes no rest (that\nis, until none of its neighbors is at a lower altitude) (Figure 4.19.2),\n\n|\nee Pl eee\n\nFIGURE 4.19.1 A single dropped particle,\n\n4.19 Fractal Terrain Generation : Sod\n\nFIGURE 4.19.2 Two dropped particles.\n\nContinue dropping particles (varying the drop point periodically) until you have\na decene sized pile (Figure 4.19.3).\n\nYou can control the shape of the terrain by controlling how the particle drop\npoint is moved, Keeping the drop point in a single place will create a large peak. Mov-\ning the drop point periodically will create chains of multiple small peaks.\n\nFigure 4.19.4 shows different terrains generated with this technique (higher alci-\nrudes in white).\n\nInverting the Caldera\n\nReal-world volcanoes, especially active volcanoes, have very distinctive mountaintops.\nAfter flaw stops, the lava ac the top of the volcano cools and recedes back into che\nEarth, creating a familiar bowl-shaped region at the top called a cade’ens.\n\nFIGURE 4.18.3 A collection of particles.\n\n=e\n\nSection’ Polygenal Techniques\n\nFIGURE 4.19.4 Some height helds generared with this technique.\n\nWe can generate a caldera for our particle mountain by inverting the height field\nvalues above a certain altitude about the horizontal plane defined by char altivade,\n\nImagine a height field generated by particle deposition (Figure 4.19.5).\n\nDraw a line (or rathez, a planc) through an arbitrary altioude (Figure 4.19.6).\n\nThen invert all dhe height Geld values above the line about the line (Figure 4.19.7).\n\nCuring off the peak this way can result in a highly aliased caldera edge. To make\nthe caldera look more realistic, apply am erosion filter (see the “Fracea! Terrain Gerer-\nation—Fault Formation” article} to blunt the sharp edges.\n\nApplying the caldera cutoff to the entire height field can generate undesirable\nresults. If the terrain has multiple peaks, the caldera line for one peak can interfere\nwith other peaks.\n\nPaine\n\nFIGURE 4.19.5 A height field penerated by particle deposition.\n\n4.19 Fractal Terrain Generation Sii\n\nCaldera Line\n\nFIGURE 4.79.6 The calelers line,\n\nCaldera Line : “toa\n\nFIGURE 4.18.7 [nvert the height field values above che caldera line,\n\nIt is best to implement the caldera inversion using a floocl-fill technique. Starting\nfrom an initial poine, invert the point and check ies neighbors. For each neighbor.chat\nis above the caldera line, invert it and check its neighbors, Continue until you run out\nof neighbors.\n\nColor Plate 3 is a 31D rendering of a volcanic island system generated with parti-\ncle deposition.\n\nSample Code\n\nThe sample code lets you control the number of piles, the particles dropped per pile,\nthe movement of the particle drop location, and the caldera depth. Caldera depth is\nexpressed as a percentage of peak height [0..1]. Using a caldera depth close to | will\n\npenerate sinkholes instead of mountains.\n\nReferences\n\n[Barabasi95] Barabdsi, A. L., and Stanley, H. E, Fracte! Concepes in Surface Growth\n(Cambridge University Press, 1995)\n\n9.0\n\n2D Lens Flare\n\nYossarian King\n\nLens flare is an optical effect created by interreflection between elements of a lens\nwhen the camera is pointed toward a bright light. The result is a shifting pamern of\ntranslucent shapes and colors emanating from the light seurce. The effect is often seen\nin TV broadcasts when the sun enters the video camera's Geld of view,\n\nIn real life, lens flare is considered a defect, and camera manufacturers go to great\nlengths to eliminate it through special lens coatings. Video pames, however, like to\nemphasize and exaggerate all the cooler aspects of reality, and lens flare is definitely\ncoal. Real lens flare is due to complex interactions of light with surfaces in the optical\nsystem of a camera. Video game lens flare is all about appearances. This article shows\nhow to implement an attractive lens flare effeer using only asmall amoune of code and\narmwork, without needing to know anything at all about physical optics.\n\nApproach\n\nReal lens flares are created in the lens system of the camera and so naturally appear\n“on top of” the scene being viewed. Each element of a flare is a reflection of the light\nbouncing off a secondary lens and onto the primary lens. Since the lenses are in pre-\ncise vertical alignment, the reflections fall along a lime in the final image, where the\ndistance of the reflection from the center of the image is proportional co the distance\nof the corresponding secondary lens from the primary.\n\nThese observations justify che treatment of lens flare rendering as a 2D problem.\nThe flare is rendered as an overlay on the 3D scene, and the elements of the flare are\nrendered along a line intersecting the projected position of the light and the center of\nthe screen, at sherwn in Figure 5.0.1.\n\nAt this point, we abandon all reference to physical optics and focus entirely on\naesthetics. The lens flare effect is rendered with a small collection of textures, one for\ncach style of fare element—circles, rings, hexagons, sunbursrs, and so on—as shown\nin Figure 5.0.2, The gray-scale vexrures are combined with vertex colors to produce\nsubtle coloring. Alpha blending is used to make the effect translucent. Elements are\nrendered in a variety of sizes.\n\no15\n\n516 Sections Pixel Effects\n\nio *\ntale i ]\nat te i\n\nieee H\na ag !\nLy\nie |\nSaat\nEee\ni. \\\nI *, ane —\n\nFIGURE 5.0.1. Lene flare rendering is a 20) problem. Elemencs of che lens flare are rendered\nalong a line berween the projected position of the light source and the center of the screen.\n\nFIGURE 5.0.2. The lens flare effect is rendered using a small collection of gray-scale texpures.\n\n‘To be cruly effective, che lens flare effect must animate convincingly with camera\nmovement. The overall movement of the flare is determined by tracing the line fram\nthe projected light position through the center of the screen. Varying the size and\ntanslucency of the flare elements produces additional subrlery. This variation is\nachieved by sealing the size and alpha value of the flare elements based on the distance\nberween the projected light position and the center of the sereen; when the light is far-\n\n5.0 20 Lens Flare Bi?\n\nther from the center, the clemencs are smaller and more cransparent, and when the\nlight is closer to the center, they become larger and more opaque.\nA ample of the results of this approach are shown in Color Plate 4.\n\nimplementation\n\nPutting all this together boils down to performing the following steps for each ele-\nment of the lens flare:\n\n1. Determine position and size of the flare element.\n2. Detetmine texture, color, and manslucency of the element.\n3. Render the element as a 2D sprite with the computed properties.\n\nIn this implementation, a flare is a collection of elements. Each element has the\nfollowing static properties:\n\n* Texture. The available textures (shapes).\n\n* Distance. Proportional distance along the line from the light source to the center\nof the screen.\n\n« Size. Normalized size of the clement (before scaling).\n\n* Color, Red-green-blue (RGB) color used to shade the element while rendering,\n\n* Alpha. Translucency of the clement (before alpha scaling).\n\nThe flare also has an overall scale factor and a maximum size, used co control the\nelement size: during rendering, These properties are all determined at initialization\ntime. In the demo code, the properties can be determined randomly or loaded from a\nflare description file.\n\nDuring rendering, the dynamic properties of each lens flare clement are com-\nputed based on their static properties and the position of che light source on the\nscreen. Texture and color of the flare are unaffected, bur position, size, and alpha level\nare all dynamic, depending on the movement of the camera relative to the light\nSOUICE.\n\nIn pseudocode, the lens flare effect is rendered as follows:\n\nTunction renderflare:\n\nflara if flare object to be rendered\n(ix,1y) ff projected positien of light on scraan\n(ex,ey) ff geanter of flare (nernally center of screen)\n\n{i} Compute how far off-center the flara source is.\nMaxflaredist = sqrti(ex 2 + cy*2)\nTlaredist = sqrt({lx - cxj*2 + (ly - ey)*2)\n\n{? Deteraine overall scaling based on off-center distance.\ndistancescale = (maxflaredist - flaredist) /maxflaredist\n\n‘i? Flare is rendered along a Line from (lx,ly) to a\nf} point apposite it across the center point,\n\nBig Section & Pixel Effects\n\ndz = cx * (ex - Lx)\noy = cy * (cy - Ly)\n\nfor each element in flare\n4\nff Position is interpolated between (lx,ly) and\nif (ox, oy).\npx = (1 - slement distance} \"le + element .distance*dx\nBy = (7 - elesent distance) \"ly + alement .distance*dy\n\nff Size of alement depends on ite scale, distance\nff scaling, and overall scale of the flare itself.\nwidth = element.size * distancescale * flara.scale\n\nff Width gets clamped, so the off-axis flares keep a\nff good size without letting the cantered e#laments\nif get too big.\nAf (width > flare .naxsize)\n\nwldth = flare.maxsize\n\nff Flare elements are square (round) so height 4s\nff just midth staled by aspect ratio.\nheight = width * aspectratio\n\nif Alpha is based on element alpha and distance scale.\naipha = ¢lement.alpha * distancescale\n\nif Oraw the element's texture with computed\n\nif propertias.\n\ndraerectangle( alement.texture, eleneat.colour,\nalpha, px, py, Width, height 4}\n\nSource Code\n\nThe lens flare demo includes OpenGL source code and a Windows executable. The\nsource code is separated into an API and sample code thar uses the API. The API\nincludes structures that deline the properties of a flare as well as the following func-\nbons;\n\n* FLARE initialize. Initialize flare elements, given a list of properties by the caller.\n* FLARE_randomize. Generate a list of flare elements with random properties.\n* FLARE_ render. Render the flare ata piven screen position.\n\nThe deme uses these finetions to create a lens flare effeecr controlled by the mouse.\nThe mouse cursor is used as the screen location of the light source, Lens flares can be\nrandomly generated or loaded from a file. See the README-TXT file included with\nthe demo for additional details on the demo ineerface.",
      "page_number": 500,
      "chapter_number": 52,
      "summary": "This chapter covers segment 52 (pages 500-507). Key topics include flare, lens, and distance.",
      "keywords": [
        "Lens Flare",
        "Flare",
        "lens flare effect",
        "Lens",
        "flare elements",
        "che lens flare",
        "Fractal Terrain Generation",
        "flare effect",
        "caldera line",
        "Caldera",
        "Caldera Line FIGURE",
        "line",
        "Particle",
        "Deposition Jason Shanke",
        "light"
      ],
      "concepts": [
        "flare",
        "lens",
        "distance",
        "scaling",
        "scale",
        "elements",
        "element",
        "particle",
        "caldera",
        "height"
      ],
      "similar_chapters": [
        {
          "book": "C++ Templates_ The Complete Guide",
          "chapter": 50,
          "title": "Segment 50 (pages 1600-1629)",
          "relevance_score": 0.49,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.49,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 42,
          "title": "Segment 42 (pages 401-412)",
          "relevance_score": 0.49,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 6",
          "chapter": 20,
          "title": "Segment 20 (pages 343-360)",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 6",
          "chapter": 30,
          "title": "Segment 30 (pages 523-540)",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 53,
      "title": "Segment 53 (pages 508-522)",
      "start_page": 508,
      "end_page": 522,
      "detection_method": "topic_boundary",
      "content": "3.1\n\nUsing 3D Hardware for 2D\nSprite Effects\n\nMason McCuskey\n\nThe past few years have seen an explosion in the 3D capabilities of graphics cards, In\nthe span of a few years, we've moved from 256 colors at 320 * 200 to fully 3D aceel-\nerated, 1,600 = 1,200, 32-bit color. Even though most of today’s cards tend co ignore\nthe 2D world and ship with feature lists tailored to 3D, a phenomenal amount of pro-\nceasing power is still available in chem, which can be harnessed to achieve stunning\n2D effects.\n\nThis article sheds some light on how to use 31) hardware co achieve 2D effects.\nSpecifically, we take a look at how to do alpha blending, sprite scaling, and sprite rota-\n\ntion.\n\nGoing 3D\n\nThe basis of this entire article is char inevitably, a 31D scene must be rendered to a 2D\nsurface for display. This is as true in Direct3D's Immediate Mode (where a 3D ren-\ndering device must be attached to a surface) as it is in OpentsL.\n\nEverything you see in a 3D scene is made up of primitives (usually triangles or\nquads), Groups of primitives are arranged together in various ways to form more\ncomplex polygons. Any group of primitives can have a “texture” applied to it, which\ngoverns how the group looks. We don't need to get into the many details of textures;\nfor the purposes of 2D effeers, all we care abour is the facr that we can load a texture\ninte OpenGL and then assign thar texture to a quad (rectangle) primitive.\n\nSetting Up the 3D Scene\n\nThe “trick” to displaying sprites using 31D hardware involves how you set up your 3D\nworld. Even though the 3D) card gives us the power to render polygons in any rotation\nand position in 3D space, the secret to achieving 2D effects is vo set up our 3D scene\nso that everything is directly Geing the camera. After all, if we set up a real-life 3D\nmodel of our 2D game, we'd realize that our 2D sprites are basically rigid pieces of\n\n519\n\n520 Sections Pinel Effects\n\npaper at which the camera is directly pointing. In other words, in 3D), our 2D game\nlooks like a really complicated diorama. Fach sprite is a billboard, and the camera\nalways remains a fixed distance from the sprites and never moves (unless yOu Wane it\nto, which can produce some interesting effects).\n\nKeep this paradigm in mind as you read che larer sections on setting up textures\nand displaying sprites.\n\nSetting Up the Texture\nantiteieeil ited atten EEE\n\nSetting up the texture requires several OpenGL. calls:\n\ng1Pimzel Stored ((GL_UNFACK_ALIGNWENT, 1):\ngicentéextures(1, (Gluint*)anTexturelo) ;\nif (atexturelp == 9)\n{ Glanum gle-glGetErrord); /* handle errors! */ }\ngIBindTaxture (GL_TEXTURE 20, mlexturelD);\nQLTexParameteri(Gl TEXTURE 20, GL_TEXTURE_WAAP_S, GL CLAMP);\nglTexParameteri(GlL_TEXTURE_2D, GL_TEXTURE_WAAP_T, OL CLAMP):\ngliexParameteri(Gl_TEXTUAE_2D, GL_TEXTURE_MAG FILTER, GL_LINEAR)-:\nglTexParaméteri(GlL TEXTURE_2D, GL_TEXTURE_MIN FILTER, GL_LINEAR};\nglTexInagezD(GL_TEXTURE_20, 0, GL_AGEA, 128, 128, 0, GL_AGaA,\nGL_UNSIGNED BYTE, gpgtezture);\n\nThis section of code, part of the ca0Sprite::Init() method in the example program,\ninitializes our texture in OpenGL. gagtexture is a pointer co an array of RGBA pixel\nvalues (4 bytes, one cach for red, green, blue, and alpha values). The call to gl textn-\nage2D() sets up a texture using the epgrexture pixel array. The g1TexParameteri()\ncalls set various properties of the rexcure, including our wrapping mode (GL_cLAMP,\nwhich means “dont wrap the texture”), and our filters for growing and shrinking the\ntexture (in this case, we're using linear filters).\n\nDrawing the 3D Sprite\n\nNow that we've gor the texture set up, we're all ready co draw the sprite. To use a\nsprite, the client application first sets up all the parameters for the sprite (position on\nthe screen, size, transparency of alpha value, etc.). The cliene chen calls the pisplay{}\nmethod to render the sprite.\n\nThe following code comes from the CDSprite::Dieplay() method:\n\nif Set up the rotetion and translation matrices\nplPushiatrix();\n\npliranslate?(m_ix, m_iv, O};\nglfatatef(m_fAatation, 0, 0, 1);\n\nThe first thing this code does is set up the rotation and rranslation (movement)\nmatrices. Open(SL uses a matrix stack, which allows us to apply global changes to our\n\n6.1 Using 3D Hardware for 20 Sprite Effects S21\n\nvertices as we create them. Any vertex that we create is transformed using the matrix\nat the top of the stack. Before we create any vertices, we need mo set up a matrix that\nrotates the vertices and moves them to the position where the sprite is supposed to be\n(ma_sA, m_s¥).\n\n‘To get the mamix we need, we push a new identity macrix onte the modelview\nstack, then multiply it by a wanslation matrix to the sprites position (the third argu-\nment to gl Translate is the z coordinate) and a rotation matrix using the m_fRata-\ntion variable. The second, third, and fourth arguments to glRotatet tell OpenGL\nwhich axis we want to perform the rotation around—in this case, just the z-axis. The\nz-axis is the one thar's perpendicular to your monitor; it is “going into” and “coming\nout of” che screen.\n\nThe next thing we need to do is set our blending mode and texture mode. The\nfirst several lines of code set up our blending mode. We alpha-blend our sprite with\nwhatever has already been rendered to the frame buffer The equation used is sre-\nColer\"mcAiphatdemCalor\"(I-ocAlpha), After that, we set up the texture mode, Our\ntexture mode indicates thar the pixels we're poing to render are che source color and\nalpha modulated (multiplied) by the texture. After that, we call che glBindtexture()\ncommand, which tells OpenGL that we want che following primitives to be textured\nusing aTextureZD, the ID we got when we set up the sprite’s texture earlier.\n\nI! Oree the sprite\n\nQlEnable(GL_ALEND);\n\ngiblendFunc(Gl_GhG ALPHA, OL_ONE_MIWUS SRC ALPHA);\n\ngiEnable (GL_TEXTURE_20);\n\nQLTexEnvt (GL_TEXTURE_ENV, GL_TEXTURE_ENV_IOOE, GL_MOOULATE};\nglbindTexture(GL TEXTURE 20, mTlextureZo) ;\n\nAThis glBegin() function call tells OpenGL that we're starting our\nfivertex list and will be working with quad prinitives.\n\ngifegin(GL QUADS):\n\nNow we sec up our four vertices, one vertex for cach of the four comers of our\n\nquad primitive. Each vertex has:\n\nI. A color, We're setting the color via the glColor4ub() function. In this example,\nthe color of all our verrices is pure white, RGB (Oxff, Ouff, Oxf).\n\n2. A corresponding texrure coordinate (set via the glTexCeord2f() function), which\ntells OpenGL how the texture is stretched or shrunk on Our cqusael primitive. A\ntexture coordinate of (0.0, 0.0) represents the upper-Ieftmose vexture pixel (texel};\na texture coordinate of (1.0, 1.0) represents che lower-righomost texel. In effect,\nwhat we're saying in this example is that the texture is stretched perfectly so thar\nit exactly fits the quad. (Keep in mind thar the quad itself can be any size, and the\ntexture grows and shrinks with it; all we're setting here is how the texture is\nattached to the quad.)\n\n3. A position in 3D space, set via the call to givertexat(). In chis example, we're\nputting the local origin of the sprite at its exact center, which puts the upper-left\ncomer of our quad ac (-m_iWidely!2, -m_tHeight/2). The lewer-right vertex is\n\nS22 SectionS Fixel Effects\n\n— re\n\n(mi Wisttiv2, m_itfeight/2), where a_awidth and m_iHeight are the width and\nheight of the sprite, This effectively centers the sprite on its local origin, which is\nneeded so thar when the sprite rotates, it spins around local ro its center.\n\ngltolordub(Oxff, Oxtt, Oxtt, n_iAlpha}:\nglTextoord2f(O.0F, O.0F):\nglVertexst(-m_iMidth/2, -m_itpight/2, 0):\n\nglColordub(Oxft, Oxff, Oxff, m_iAipha);\nDQTaxCoordet(1.0F, OOF);\ngivertexst(-n_iWidth/2, m_iHeight/2, 0);\n\ngiColordub(oxtt, Oxtf, Oxf, m_iAlphah ;\nglTexCoord2f(1.0F, 1.0F);\nglVertexaf(m_iWidth/2, m_aHeignt/‘2, Oo};\n\nglColorsub(Oxff, Oxff, Oxff, m_iAlphal;\nglTexCoord2f(o.0F, 1.0F);\nglvertexaf(n_iwidth/2, -m_iteight/2, 0};\n\nAnd finally, this bit of code ends our scene and puts the graphics stare and matrix\nstack back the way they were when we entered:\n\nglEnd();\nglDisable(GL_TEXTURE 2p);\np1Disabloe(GL_BLEND);\n\nft Pop the matrix we set up above\nglFopWatrix| } f\n\nAdding Effects\nee\nNow that we've got down the basics of drawing, we can add some effects. I's a happy\nenincidence that one of the most sought-after 2D cffects—alpha blending—also hap-\npens to be very easy to do in 31D. To achieve alpha blending. we simply specify an\nalpha value for each of the vertices that make up our sprite. ‘Take anocher quick peck\nat the code above; in che calls to gitolersub(}, the fourth argument (in the example,\nthe m_fAlpha variable) i¢ the alpha value for the vertex, The alpha value is similar to\nthe red. green, or blue color values; it can be anything from 0 ro 255, with 0 repre-\nsenting complere transparency and 255 representing complete opacity. So, for exam-\nple, to create a sprite thar’s “halfway” transparent, we simply need to sct the alpha\nvalue of all four sprite vertices to 128.\nOF course, if we want to create a different kind of special effect, we can vary the\nalpha value of each verrex independently. For example, if we sct the ewo left vertices to\n0 and the ewo right vertices co 255, we get a sprite thar fades gradually from com-\npletely transparent (on its left side) to completely solid (on its right side).\nTo create some colorful effects, we can specify different colors for each of the four\nvertices in our quad primitive. We do this by pucting different RGB values in the call\n\nS.1 Using 20 Hardware for 2D Sprite Effect: 523\n\nto git¢eloraub. OpenGL automatically blends the colors together, so if we set the left\nside of our quad blue (RGB(0,0,255)), and the night side red (RGB(255,0.0)), we end\nup with a nice gradient of color going from blue to red across the sprite. In this way,\nwe can add quick highlights of color without having co go to all the trouble of setting\nup an OpenGL light source. Please note that if you dont want OpenGL to apply a\nsmooth color/alpha gradient to your polygon, you can change the behavior by calling\nglShadeModel(GL_FLAT).\n\nScaling our 3D sprite is easy, noo. The good mews is that the 31D hardware tales\ncare of stretching the texture; all we need to de is sec up the vertices of our sprite.\nSuretching of shrinking the sprite is as easy as increasing or decreasing the width or\nheight of our quad primitive. If we wane to seretch the sprite along the x-axis by a fac\ntor of two, we simply make the width of che sprite a_iwidth*2 instead of m_iwidth.\nSimilarly, to stretch the sprire by a factor of ewo along the y-axis, we make the height\nof the sprite m_iHeight*2 instead of m_ikeight. To shrink the sprite to half its size,\nwe divide width and height by nwo. Any possible stretching combination can be\nachieved, and the great part is char you don't have to worry about the individual pix-\nels of the sprite, It’s all taken care of for you.\n\nRotating the sprite is simple, too. Again, irs just vertex position manipulation,\nWe can specify an angle (in degrees) and pass this angle to OpenGL ginotatet func-\ntion, which applies it to the current cransformarion matrix. Again, the individual pixel\nlocations are automatically caleulated by the 3D hardware.\n\nTo create another interesting effect, we might change the axis of rotation for our\nsprice. glRotatet takes an angle and three parameters; these three vector parameters,\nat their simplest, allow us to tell OpenGL which axes we want to rotate abou. It\nmight be worthwhile to rotate about the x- or y-axes, effectively flipping the sprite\nhorizontally and vertically in 3D, rather chan simply rorating abour the z-axis (spin-\nning the sprite).\n\nConclusion\n\nAc first, this approach to 2D sprites might seem like a lot of needless work; irs often\neasier and more familiar to 2D programmers to draw sprites via Aliaing fismerions\n(such as DirectDraw’s B1t() of Win32's Biteit()). However, learning how co “bli”\nwing 30) hardware pays off in the long run, since it ultimately becomes much easier\nto implement advanced 31D effects, such as alpha blending of sprite scaling. In addi-\ntion, for the typical computer system, offloading the graphics processing required for\nalpha blending or scaling to the graphics card is a smart move, since it frees the CPU\nto concentrate on other tasks, which ultimately gives you more room to make a becter\n\nSatie.\n\n9.2\n\nMotif-Based Static Lighting\n\nSteven Ranck\n\nThis article describes a way to introduce more dynamic propertics into precomputed\nstatic lighting. The approach produces stunning animated lighting at 2 computational\ncost that is only slightly greater than conventional static lighting.\n\nMany games employ static lighting by precomputing the light colors ar each ver-\ntex. This results in convincing Gouraud lighting at almost no compuration cost, It\nalso produces very staric-looking light. This article describes an algorithm that adds\ndynamic animation to static lighting bur still executes at nearly the same speed as con-\nventional static lighting. For example, two torches close together on a rock wall pro-\nduce firelight on che wall thar flickers and interacts approprianely.\n\nConventional Static Lighting\n\nSad\n\nConventional static lighting is simply precompured Gouraud RGB values stored with\neach vertex and used in a diffuse fashion during rendering, The precomputed RGB\nvalues are generated by either a cool or the game's initialization code. In cither case, 2\ntool is used to place lighes on an object and assign characteristics such as color, inten-\nsity, radius, radial falloff, and light type (omni, directional, spot, and che like). Since\nwere dealing with static lighting, the lights and all their properties are constant. In\naddition, their positions are fixed in the object space of the object they are lighting;\nthat is, staric lights canmot move relative to the object chey arc lighting. From the light\npositions and properties, the effect of each light on each of the object’s vertices ean\neasily be computed using any desired lighting equation. Figure 5.2.1 demonstrares a\nsimplified 2D representation of this concept.\n\nFigure 5.2.1 shows an object with six vertices being statically lit by wo lights.\nVertex 3 falls within only Light A’s influence, Vertex 3 falls within only Light B's\ninfluence, Vertex 2 falls within both lights’ influences, and the remaining vertices fall\noutside boch lights’ influences. Because Light A and Light B are static, they are fixed\nin the object's coordinate space; if the object moves and rorates in world space, Lights\nAand B move and rotate along with the object. Therefore, the RGB lighting compu-\ntation at each vertex can be computed only once (because it never changes) and stored\n\n5.2 Motif-Based Static Lighting 525\n\nLight.\n(apiece of mfr)\nTees objet beng re\nshiscadly lt. Comsiscr 2: a\nof wrstices (MEW vi = WaT Wi\nod LrSerapfieg See é a\n\nhee ee\n\nFIGURE 5.2.1. A scattcally-lit mesh objece.\n\nas part of the vertex structure. For this reason, static lighting is useful for lighting\nobjects by lights thar are attached ro the abject, Good examples of this concept are\nstreetlights lighting a street and hull lighes illuminating the spacecraft co which they\nire mounted,\n\nIn Figure 3.2.1, the staric RGB for Vertex 3 is computed simply by using the ver-\ntex’s position and normal with Light A in a conventional lighting equation. Vertex 3\nis similar, bur with Light B. Vertex 2 is influenced by both lights, so the resulting\nRGB is simply the sum of the cwo lighting equations, The remaining vertices aren't\ninfluenced by either light, so their RGB is (0,0,0), and it is then the sole responsibil-\nity of dynamic and ambient lighting to light those vertices.\n\nThe lighting equations used are completely up to the designer's preference and\ncan be as complex and computationally expensive as desized, since they are used for\nprecalculation. Regardless of the actual equations used, we can wire the lighting\n\nfunction as:\nf= ffl, ¥) (5.2.1)\nCr=lel, (5.2.2)\n@ icp\nCe = ie Es\n\nwhere\n\n2 represenes the lighr’s properties (position, intensity, radius, radial Glloff, light\ntype; and so on)-\n\nSections Pixel Effects\n\nrepresents the vertex'’s properties (position, normal).\nAU, Wis the lighting equation.\n/is the light’s scalar incensicy at the vertex, as computed by the lighting equation.\nLy i the light’s color (red component).\nfg is the lights color (green component).\ntn is the light's color (bluc component).\nCys the final red color component, ready to be stored in the vertex structure.\nCis the final green color component, ready to be stored in the wertex structure.\n\n(gis the final blue color component, ready to be stored in the vertex structure.\n\nHere's an example of a lighting equation for a simplified omni-light:\nJIE V) = (Dye) (R-D)/R (5.2.3)\nwhere:\n\nOv. is the unit vector from the vertex to the light.\nMyis the vertex’s unit normal.\n\nis the distance from the vertex to the lighe.\n\nAis the light’s influence radius.\n\nAn omni-light is a point light chat radiares light in all directions. The intensity\nof the light rays diminishes (attenuates) che farther the vertex is from the omai-\nlight's position. In the preceding equation, the (R — 19) /@ term performs this dis-\ntance attenuation. If the vertex lies on the light's position, 0 is O and (R-— D)/R\nreduces to 1, which is the maximum brightness. If, on che ether hand, the vertex lies\non the outer boundary of the light’s influence, D equals Rand (R— D)/ R reduces to\nO. Lf the vertex lies somewhere berween the light’s origin and its outer boundary, (R\n— 2) / 8 produces a number between 0. and 1. More sophisticated omni-lighrs use a\ndistance attenuation function that models the physical world more closely. However,\nthe linear attenuation in our equation is good enough for this example. Of course,\nwe also require that f{2, W) return © if the vertex lies outside che lighr’s influence\nradius (2) > A).\n\nThe first term in our omni-light equation, (D,,*/V¥,9. performs another attenua-\ntion based on the dor product of the lipht ray from the om ni-lighe to the vertex being\nlit and that vertex’s normal vector. This is called a diffise lighting factor and is a very\ncommon way of brightening vertices thar a higher ray hirs directly head-on and cark-\nening vertices thar a lighe ray hits more at an angle, We further imply thar f(D,\"\nis negative, we remurn O for (ZV. Thar is, if a light ray is hitting our vertex from\nbehind, we prevent the ray from lighting the vertex.\n\nEquation 3.2.3 produces a decent looking omni-light, but higher-quality results\ncould be obrained with more complex lighting equations, In any case, Equation 5.2.3\n\n5.2 Moti-Based Static Lighting 527\n\nyields a single sealar, which is the overall intensity of the light at the vertex. Equation\n3.2.2 then multiplies cach component (red, green, and blue) of the light’s color by\nthis intensity, producing the final three-color components to be stored in che vertex\nstructure. Ar render time, these color components are simply retrieved and used\ndirectly to Gouraud light the object. Here's a possible vertex structure and the render-\nnme OpenGL code fragment to draw a starically lit wianele:\n\nPinclude \"mtxlib.h'\n\ntypede? struct {\nfloat TR, TG, TB; Jf Static AGA color (0.0 -» 7.0)\n} Coler_t;\n\ntypedef struct {\nvectors Pos; f/f This vartex's 30 position in model-space\nColor_t StaticGolor; ff RGB to be used for this vertex\n} Vertex_t;\n\nvoid OrawyTriangle( const Vertex_t \"pil,\nCONST Vertex_t “pV2Z, const Vertex_t *pwa } {\nglBegin( GL_TRIANGLES 4;\n\ngltolorsf( p¥i->StaticCelor.¢R, p¥1-2StaticColor.1c,\npVi->StaticColor.1B };\ngivertexdt( pWi->Pos.\", pVi->Pos.y, pVI->Fos.z J:\n\nGiGolorat( pi2->Staticlalor. fh, p¥v2--5taticColor.fG,\np¥2->Staticloler.#B }:\ngivertexst( pv2->Pos.4, pVv2->Pos.y, PVE-FFos.z ):\n\ngitolorst( pVa->Staticlelor.fA, pva-\"StaticGolor.tG,\npVS-=StaticColor.?e 4}\nplvertexst( pva-sFos.%, p¥a->Pos_y, pWG->Fos.z 1\n\nplend();\n}\n\n(ne drawback to conventional static lighting is that it does produce static results.\nThat is, the RGB values for the vertices are constant from one rendered frame to the\nnext. They do norvary at all. For sunlight, moonlight, and many other non-changing\nlight sources, this isnt a problem, However, for more complex light sources such as\nflickering neon tubes, torch flames, campfires, and blinking hazard lights, conven-\ntional static lights cannot be used because they require the RGB values to animate from\none rendered frame to the next. Conventional static lighting cannot achieve this result,\nat shown in the example code. This is where motif-based static lighting COmes In.\n\nMotif-Based Static Lighting\n\nThe advantage of conventional static lighting over dynamic lighting is execution\nspeed. There simply are no run-time computations performed: RGB values are\nretricved [ram the vertex structure and Plugged clirectly inco the color values for the\nrendering vertex. However, the drawback is thar static liphring produces static results,\nThe RGB values for each vertex are precomputed, stored, and never change from\nframe to frame. Motif-based static lighting provides a more dynamic look than con-\nventional static lighting at a negligible performance hit.\n\nMotil-based staric lighting is still a form of static lighting. Thar is, the static lights\nlighting the object are fixed in the object's coordinate space, as is the case with con-\nventional static lighting. However, with motif static lighting, we are able te animate\nthe RGB components of the lights in real time, The type of animation is completely\nup to the designer. Some animations, such as a light switch on the wall of a room that\ntums on the room's light, might be under che player's concrol. Orher animations, such\nas lames, flickering lights with electrical shorts, and blinking lights, might be algo-\nnthmically controlled. Furthermore, some lights might have constant RGB values.\nEach of these animacions (including chose that are constant) is called a Highs moif.\n\nTo implement mocif-based static lighting, the game needs a motif table that con-\ntains an RGB entry for every light motif. The motif table acts as a palette, as we'll see\nlater. Figure 5.2.2 shows an example of a nine-entry mouf table. Each entry holds an\nRGB color. Depending on the cype of motif, the RGB color is either precaleulated ar\ngame-initialization time er computed dynamically once per frame. Regardless, the\nRGB values stored in the motif table are full-intensiry, unattenuared light colors.\nInstead of storing RGB colors directly in the vertex structure (as we did before with\nconventional static lighting), we now simply store an index in the vertex struceure that\nindexes into the motif table, We'll go inte detail on this concept soon.\n\nFor constant motif lights for which the color remains constant from frame to\nframe, the RGB value of the light (that is, the light’s raw, unattenuated color} is sim-\nply stored in the motif table at initialization time and left there for the duration of the\ngame or level. In Figure 5.2.2, table entries 7 and § contain the RGBs for two con-\nstant motifs: dark red and bright blue,\n\nFor mot lights for which the color is controlled by the player (eg.. a light\nswitch), the RGB value is updared when the event happens (the player flips the light\nswitch, for example). In Figure §.2.2, table entries 4 and 5 contain the RGBs for ewo\nstatic lights controlled by light switches, Initially, they might both contain\nRGB=(0,0,0), sec during initialization. When the player turns on Switch 0, the game\ncode stores the color of the light in entry 4, For example, if the light is a bright green\nlight, wed store RGB=(0,1,0) into encry 4. If the player turned the light off again,\nwed store RGB=(0,0,0) into entry 4. In Figure $.2.2, entry 5 is for another swirch\nthat controls a differenc see of lights that could be located either in an entirely differ-\nent room or in the same room. It is completely possible that the nwo lights are close\n\n6.2 Motif-Based Static Lighting 529)\n\n——— SS\n\nenough that they affect the same vertices in the same room (similar to the way both\nLight A and Light B affect vertex V2 in Figure 5.2.1). If this is the case, the player\nexpects to see the twa lights interact and light the room properly with the actions he\nor she takes with dhe two light switches. We'll see a little later how motif static light-\ning handles cases like this one\n\nEntries 0 through 3 in Figure 3.2.2 contain ah animated RGB color for a flicker-\ning torch. Motifs such as these are algorithmically implemented and updated Once per\nframe. Here's a code fragment that generates a flickering flame motif, called once per\n\nframe =\n\n#defing FLAME SPEED 4.0f\n\nif Constants determined via axperimentation:\nfdetine FLAME Ka (0.0937 * FLAME SPEED)\nfdefine FLAME K? (0.1377 \" FLAME SPEED}\ndefine FLAME Ko (0.1957 \" FLAME SPEED)\nAdafine FLAWE K4 (D.1e6f = FLAME SPEED)\nFdefine FLAME KS (0.170 = FLAME SPEED)\n#define FLAME KG (0.287f © FLAME SPEED)\n\nii Generates the RGB color for a particular frame of the flame\n\nif motif and stores it in \"*pColor. nGameFranmeGounter is singly\n\nif the frame numier of the game's current frame and is\n\nfj inerenented once per tranc.\n\nvold GenerateFlamelotif{, unsigned int mianeFrameGounter,\nColor_t \"pGelor } {\n\nFIGURE 5.2.2. Example azotif table.\n\nSection 5 Pixel Effects\n\ncouble @SinSun;\nfloat fIntensity, tangle;\n\nTAngle = (float}nGanerFrameCaunter;\n\ndéinsum =\nsint TAngle * ]\n+ sin( TAngle * ]\n+ sin( TAngle \" FLAME KS }\n+ sin( TAngle * Ke j\n+ sin{ fAngle * }\n+ sin{ fAngle *\n\nTintensity = (float)dSinSum * o.1f;\nintensity += 0.77:\n\ndif( TIntensity => 1.0T ) {\nfintengsity = 1.0:\n}\n\nplolor-=th = fIntensity;\nplolor->tG = fIntensity * O.4f;\npeolor->fh = O.o0f;\n\n}\n\nAr the top of each game loop, the game calls GenerateFlamemotit() ro generate the\nflame motif and then stores che resulting RGB into dor 0 of the motif rable. It's likely\nthat a room has more than one torch, and if all che torches used the same motif, they\nwould all flicker in syne and would noticeably look bad. So, in our motif table, we\noffer a variety of torch moarifs so that the desipner can assign different torch motifs to\nneighboring torches. Often, it is not necessary to write different algorithms to have a\nvariety for a particular motif. Instead, simply phase shifting the frame counter and\ncalling the same algorithm function suffices and provides stunning results for a frac-\nHon of the work,\n\nModif light algorithms are usually simple functions, but even if a more computa-\ntionally expensive function were needed, it would still be executed only once per\nframe, and so the overall performance impact on the game is likely to be negligible. In\nthe preceding code, for example, the CPU overhead of calling sim() six cimes once per\nframe is insignificant compared with the 1/60th of a second the game has to execute a\nsingle frame. Even so, the overhead could be minimized by wHiting a custom sin{)\nfunction that performed a table lookup at the sacrifice of precision, because precision\nisnt very important for lighting computations. In any case, the beauty of motif-gen-\nerator functions is that they're called only once per frame, as opposed to dynamic\nlighting calculations that are executed once per vertex per frame!\n\nNow that we have established the motif table, let’s curn our attention co the ver-\ntex structure. For conventional static lighting, the precomputed RGB color was stored\ndirectly in the vertex structure. However, for motif-based static lighting, we need to\ndefine the vertex structure differcnuly, like chis:\n\n5.2 Motif-Based Static Lighting S31\n\ntypede? struct +\nWeCtard Pos; if This vertec's 30 position in aedel-space\nint oMatit Index; if Indax into the moti? table\nfloat fintensity; Ji Intensity of the light motif's\ni? FOB at this vertax\n} Wertex_t;j\n\n‘The vertex structure removed the StaticColor field and replaced it with the nila -\ntifindex and fintensity fields. These fields cell che rendering engine which light\nmotif from the motif table to use as well as the intensicy of the light motifs RGB ar\nthat particular vertex. Both of these values are established ac cither tool cime or game-\ninitialization time. Che motif index simply replaces the lighr’s color property; instead\nof the designer placing a campfire light and assigning ir an orange color, a motif is\nassigned instead. The designer positions the light and assigns the light properties such\nas intensity, radius, radial falloff, and light pype as usual. However, when assigning the\neolor, the designer can choos: a motif fom a set of possible motif values. For the\ncampfire example, the designer might select the torch mosif. This morif describes nor\nonly the color but also the animation of the static light. The torch motif ernulares a\nflickering flame both in color and animation of color.\n\nThe fintensity Geld is simply I from Equation 5.2.1, which is the lighting equa-\ntion we used for conventional static lighting, applied to this vertex. The position of\nthe light and the light properties thar che designer has set interace with the vertex posi-\ntion and normal to produce J, which is simply the intensicy of the lighe ar chat vertex.\nRefer to Equation 5.2.3 for an example of how all chese parameters interact to yield I\nfor an ommni-lighe.\n\nNow that we have the intensicy (from the fncensicy field in che vertex strucnure}\nand the RGB color (from the motif table encry indexed by the nMotitindex field in\nthe vertex structure), we have everything we need to compute Equation 5.2.2 for our\nvertex's final run-time RGB values.\n\nHere's an OpenGL code example char renders a motif statically lit triangle:\n\ntypedef onum {\nMOTEF_FLAMEO,\nMOTEF_FLAME1.\nMOTIF FLAME2,\nMOTIF_FLAMES,\nMOTIF _ S81 TCHO ,\nMOTIF_SW1ITCHI ,\nMOTIF_LIGHTMING ,\nMOTIF_DARK_RED,\nMOTIF_BRIGHT_BLUE,\n\nMOTIF COUNT\n} Motit_a;\n\nColor_t aMotifTabla[MOTIF_COUNT];\n\nwoid DrawlyTriamgla( const Vertex_t \"pvt,\n\nSection Pixel Effects\n\nconst Vertex t “pW2, const Vartex_t \"pa 4) f\nGolor_t *pColor;\nfloat TR, fG, fB;\n\ng1Bagin( GL_TAIAMGLES }:\n\npeolor = SaWotifTable] pVv1->nMotifindex |;\n\nFR = pColor->fA * pV1->fIntensity;\n\n7G = pColor->f6 * pVi-=TiIntensity;\n\nTB = pColer->f8 * p¥i-=flintensity:\n\ngiteloraf( TA, fG, fB };\n\nglvertexat( pvwi->Pos.™, pV1->Pos.y, pl->Pos.z jr\n\npColor ~ SaWotitTable[ pV¥2->nuotit Index Fe\n\nTA = plolor->th * p¥ve->fIntensity:\n\nTG = plolor-23G * p¥2->fIntensity;\n\nTh = pOolor-of8 \" pv2->fIntensity;\n\ngitolorafi fh, #G, TE }:\n\npiveartexat( p¥2->Fos.x, pW2->Fos.y, pW2->Pas.z 3\n\npGolor = SaMstitTable[ pv3->nllotifindex |:\n\nTR = pColor->fR * pV3->fIntensity:\n\n7G = pColar->#G * p¥d->fIntensity;\n\nTH = pColor-2t8 * p¥a->fIntensity;\n\ngicolorati fA, TG, fo jz\n\nglvertexSt( pV3->Fos.x, pVa->Pos.y, pva->Pos.z J:\n\ngiEnd(} 3\n}\n\nThis implementation suppores only one motif per vertex, which isn't tea helpful\nwhen a model has a vertex under che influence of more than one static light (as in Fig-\nure 3.2.1). To support more than one motif, we need to extend the vertex structure so\nthat it hat a mociffintensity pair for each motif light affecting it, A general solution is\nshown here:\n\ntypedat struct {\nint nMotifindss; ff Index into the motif tabla\nTinat fiatensity; ff Intensity of the Light motif's\niy} AGB at this vertex\n} MotifEntry_t;\n\ntypedef struct {\nvectors Pos; if This vertex's 3D position in model-space\nint mMotifentryGownt; /! Number of motif entries\ni/ pointed to by pMotifentry\nMOTITENtry_t \"pMotifentry; // Pointer to an array of\n\nff Motatentry t structures\n} Vartex_t;\n\nThis implementation provides for any number of motifs, but it can be complex to\nimplement. Another solution is easier to work with bur is less flexible and could con-\nsume more memory:\n\n5.2 Moatif-Based Static Lighting 533)\n\nAdatineg MAX_MOTIFS _PEA_VTX iy If Inpléesentation-specific value\n\ntypedef etruct {\n\nweetord Foe: Jy This vwartex's 20 position in sodel-space\nint nMotifEnteyCount; i) Musber ef motif entries in\n\niy aWotifEntry[]\nWotitEntry t aMotifEntry [WAX MOTIFS PER VTx];\n\n} Vartex_t;\n\nWe'll work with chis last implementation for darity, but advanced developers\nshould consider che more general implementation,\n\nTo support more than one light influencing a particular vertex, we simply per-\nform the motilfatenuate computation descobed carlier and then sum the colors\n\ntogether, like his:\n\nvoid ConputeVertexColar( const Vertex_t \"pv, Color_t “pColor j {\n\n}\n\nColor_t *pWotifGelor;\nTloat TH, TG, TB;\nint i;\n\nff Zere color components:\nTH = fG = fB = O.0F;\n\nff Step through all the motifs affecting this vertex\nff and sum their colors:\nfor( i-0; i<pv->niotifintrytount; i++ ) ff\npMotifColor = SavotifTable|\npy: >allotiféntry(i)-nMatitindgsx 15\nfR += plotifGolor-=fA \" p¥-Sallotitentry[i] .tIintensity:;\nf& += plotifGolor->fG * py->allotitentry[i].tintensity;\nFB += pliotifGelor->f6 * pil->allgtifentry[i]-fintensity;\n}\n\nfi Make sure final calor is from 0 to 1:\nif( fA > 1.0f ) fA = 1.0f:\nif( fG > 1.08 ) f@ = 1.0f:\nif( fh > 1.0f ) #8 = 1.0f;\n\n/? Store final colors in return variable:\n\npGolor->fH = fR;\npeolor->+f@ = fG;\npGolor->f8 = fB;\n\nvoid OrawMyTriangle( const Vortex_t \"p¥1, canst Vertax_t *pV2,\n\nconst Vertex_t \"pia ) {\nColor_t Color;\n\nplBegin( GL_TAIANGLES );\nComputéeVertexColor| pvi, &Colar j;\n\ngitelorsf( Color-fH, Color.7@, Color.fB };\npivertexst( pil->Fos.u, pYi--Pos.y, p¥1->Fosg.z );",
      "page_number": 508,
      "chapter_number": 53,
      "summary": "This chapter covers segment 53 (pages 508-522). Key topics include light, colors, and motif.",
      "keywords": [
        "Static Lighting",
        "light",
        "vertex",
        "conventional static lighting",
        "Motif-Based Static Lighting",
        "RGB",
        "light motifs RGB",
        "texture",
        "motif",
        "RGB color",
        "Static",
        "color",
        "static lights lighting",
        "Sprite",
        "motif static light"
      ],
      "concepts": [
        "light",
        "colors",
        "motif",
        "vertex",
        "sprite",
        "effects",
        "static",
        "flames",
        "texture",
        "textured"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 49,
          "title": "Segment 49 (pages 479-486)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 23,
          "title": "Segment 23 (pages 441-462)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "makinggames",
          "chapter": 17,
          "title": "Segment 17 (pages 140-147)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 45,
          "title": "Segment 45 (pages 431-439)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 54,
      "title": "Segment 54 (pages 523-530)",
      "start_page": 523,
      "end_page": 530,
      "detection_method": "topic_boundary",
      "content": "534 ; Section Pixel Effects\n\nComputevertexGolor( p¥2, &Golor );\nglColoraft( Color.fA, Color.tG, Color. f8 };\ngivertexaf( pv2->FPos.2, PV2->Poe.y, P¥E->Pas.z j;\n\nComputeVvertextolor( pv3, &Golor );\nglGolorsf( Coler.fA, Color.?G, Color. fe };\ngivertexaf( pVad->Pos.x, pVa-=Pos.y¥, pva->Pas.z };\n\nglEnd();\n\nConclusion\n\nFor a performance cost slightly higher than thar of conventional Ligh rig and far less\nexpensive than dynamic lighting, mocif-based static lighting can help bring a scene to\nlite by providing RGB animation for precompured light data. Campfires, flickering\ntorches, electrical shorts, beacon lights, and more are now possible withour having to\nuse expensive dynamic lights.\n\n0.3\n\nSimulated Real-Time Lighting\nUsing Vertex Color\nInterpolation\n\nJorge Freitas\n\nReal-time lighting effects are an essential part of today’s 3D gaming experience but\ncan be computationally intense for systems with limined resources, On such systems,\nthe visual effect of real-time lighting can be simulared by interpolating between pre-\nealeulated sets of vertex colors.\n\nThis technique was originally developed for use with human figures in a spores\ngame, Twenty-three Heures were to be drawn each frame, using skinned models with\na multiple vertex weighted, skeletal hierarchy. The primary goal was co climinare\ncostly lighting calculations from the rendering pipeline while retaining the look of\nreal-time lighting.\n\nThe lighting in the world consisted of either the sun or four static floodlights and\nan ambient lighting value used to darken figures running into shadow, There were\nalso several special lighting effects, including the reflection of the grass color on the\nplayers’ socks and shorts, projected shadows under arms and between Ices, and col-\nored lighting based on the current weather condition or time of day, In addition, dur-\ning a night game, the lighting “hot spot” needed to be positioned relative wo che\nclosest Hoodlighe.\n\nAn inexpensive way of calculating changing lights on the figures needed wo be\nfound. Precalculation was the answer. As much information as possible regarding che\nlighting was precalculared. Ideally, the lighting for every pose and each possible rora-\ntion of the figure would have been precaleulated, but that was impractical due vo the\namount of memory required to store che information.\n\nInstead, the lighting was precalculated fora number of fixed rotations, and inter-\npolation was used to generate the vertex color values for the given figure's rotation.\n\nLighting Method\n\n‘Typically, the method for generaring real-time vertex lighting goes like this:\n\nEas ba]\n\n536 SectionS Pixel Effects\n\n. Transform the normal for each vertex in the object.\n\nDetermine the angle at which the light is facing the vertex normal,\n\n. Using the facing angle, determine the intensity of the light at that vertex.\n. Repeat for each light illuminating the vertex.\n\n. Add the ambient light intensiry.\n\nes\n\nReal-time lighting using the above method requires many computations, which\nwe reduce dramancally using the interpolation method.\n\nIn order to fake the real-time method, we must set some constraints on our 3D\nscene:\n\n* Determine how many light positions are needed for the interpolation.\n* Determine the axis of rotation used to base the interpolation calculation.\n\nThe vertex cobor lists represent the lighting on che abject at distinct orientations of\nthe figure relarive to the lighting in the scene, whether the lighting is one light source\nof 100. A full 360-degree rotation is required, so we must determine how many vertex\ncolor lists we will use. A minimum of three positions ix necessary, each 120 degrees\napart. Note that by using more lists, we decrease the range of values we must interpo-\nlate berween, thereby increasing the accuracy of our faked lighting.\n\nArtwork Creation\n\nWe assume that the vertex color lists are generated in a 3D content creation applica-\nton. OF course, it's possible no use a real-time lighting method to generate the vertex\ncolor lists, bur the artistic task of attractively lighting a 31D scene should be left to\nthose most qualified: the artists.\n\nIn our example of human figures, the axis of rotation used to determine che light-\ning angle was assumed to be the vertical axis (typically named Yin a left-handed cour-\ndinate system) because the figures always ran around on a flat plain (a grassy field),\n\nThe example in Listing 5.3.1 uses four vertex color lists, cach penerated 90\ndegrees apart. Using a power of 2 number allows us to shortcut some of the integer\nmath by replacing multiplies and divides by shifts, and MODs with ANDs. However,\nfor the sake of clarity, the example code does not use integer shore cuts,\n\nLights are added to the 3D scene corresponding to the lights in the game world.\nAny number of lights can be used without impacting performance, since the resulting\ndata will be lists of vertex colors.\n\n‘The first vertex color list is assumed to represent the lighcing when the ebject is at\na rotation of 0 degrees. The object is artistically lit at four rotations, each 90 degrees\nfrom the previous one, The lighting for each rotation is saved asa vertex color list, cre-\nating four lists of vertex colors char will be used in real time.\n\nThe vertex colors can be tuned by the artiss in the 31D creation application to pro-\nduce some of the desired special effects. Green can be mixed into the lower leps to rep-\nresent the reflection of the grass color, the areas between the figure’s legs and under\n\n6.3 Simulated Real-Time Lighting Using Vertex Color Interpolation Sa7\n\nthe figure's arms can be darkened to give the impression of projected shadows, and the\nfigure'’s skin can be tinted to indicare racial skin tones.\n\nInterpolated Lighting\n\nHere is an explanation of the steps necessary to gencrace the interpolated vertex light-\ning.\n\nCalculate Facing Angle to Virtual Light Source\n\nThe vertex color lists represent the lighting on the object at distinct orientations rela-\ntive to the light source. The position of the light source can be stored as a simple addi-\ntive value, representing the direction of the light in the scene. The facing angle is\ncalculated by adding the offset to che object's rotation and using the remainder from\ndividing hy the number of degrees in one full rotation (360).\n\nfacing angle = ( object rotation + additive light position } % 360\n\nNote that the light can be “rotated” around the object by cycling the additive\nlight position valuc berween 0 and the number of degrees in one full rotation.\n\nDetermine Which Two Vertex Light Sets ta\ninterpolate Between\n\nBased on the facing angle, we must determine which owo sets of vertex colors in our\ntable between which we should inrerpolare (the base color list and the target color\nlist), Each set of vertex colors was pre-generaced using the same delta, 90 degrees\napart, in. our example, We divide the current rotation by the delta value between each\nset of vertex colors, which becomes the base color list. The target color list is the next\nvertex color list in our table.\n\nbase color list = facing angle / vertex color delta\n\nif {| base color liat == last vertex color list }\ntarget color list = first vertex coler list\n\nelse\n\ntarget color list = next wartex color list\n\nCalculate Interpolation Percentage\n\nWe need to determine how far berween the owo vertex color lists to interpolace. This\npercentage represents how close to the target color list we should interpolate. The per-\ncentage is calculated by dividing the remainder of the base color list calculation by che\nvertex color delta, giving us a value berween 0.0 and 1.0,\n\npercentage = ( facing angle % wertex color delta ) / vertex colar delta\n\n533 Section S Pixel Effects\n\nFor Each Vertex Color, Perform the Interpolation\nWe now calculare the vertex color list representing the current lighting for the object.\nTo calculate each vertex color, each color component (RGB) must be interpolated,\nand we repeat the process for each vertex in the object.\n\ncolor = old color + ( maw coler - old color } * percentage\n\nFor Each Vertex Color, Apply an Ambicnt Light AGB\nModifier and Clamp Resulting Values\n\nOptionally, we can apply an ambient light modifier to the calculared vertex color list.\n\nThe modifier can take the calculated color out of the acceptable range for each com-\nponent (0 to 255), so we must clamp each component separately.\n\ncolor component = color component + ambient color\n\nif { color conponent = 6 }\ncolor component = o\nelse\n\nif { coler conponent > 255 )\ncolor component = 255\n}\n\nNote thar the precaleulated vertex color lists can be created to ensure the ambient\nlight modifier doesn't take the calculated vertex colors our of the acceptable range. By\nlimiting the smallest and largest values for each color component and by limiting the\nsize of the ambient color modifier, the damping becomes unnecessary.\n\nConclusion\n\nThis technique is effective for reducing the number of calculations necessary to repre-\nsent real-time: lighting and has been used on PCs and game consoles. To generate a\nsingle vertex color requires only three subtractions, chree multiplies, and three adds\n(six adds if an ambient color is used). Even if real-time lighting is necessary in your\nSD game, interpolated vertex color lighting can be combined with real-time lighting\nto help relieve same of the computational burden of rendering your scene.\n\n‘To further decrease the number of computations, you need mot perform the light-\ning calculations for every rendered frame. By keeping a unique verrex color buffer for\neach object, the lighting can be calculated once every nwo, three, or four frames,\ndepending on the rate at which the object changes orientation relative to the light\nsource. Further savings can be had by alternating che objects chat are being re-lit each\nframe.\n\nAlthough this method is very simple, with it an extremely complex mathematical\nmodel can be precaleulared, Remember, we'te crying to achieve the perception of real-\nistic ligheing effects in our 3D games. The viewer doesn't care what mathematical\n\nSs. Simulated Real-Time Lighting Using Vertex Color Interpolation 539\n\nmethod has been employed vo create the effect, just that it makes the game world look\ncool.\n\nListing 5.3.1: Example Code\n\nFor this example code, we assume there is one vertex color per vertex in the object.\nNore thar the data structures contain only the information necessary for the vertex\n\ncolor interpolation. The divides and MODs (96) can be replaced with shifts and\nANDs, but these have been omitted for clarity.\n\nif\n—_\nif defines\nif\nif\n/* number of vertex color lists */\n\ndefine MUMBER_OF_AnGE LISTS 4 /* number of radians in 360 dagrees */\nfdefine WUMBER_OF_AADTANS 1024\n\nif\n\nif :\n\nif structures\n\nif =\n\nif\n\ntypede? struct\n\n{\nfloat alpha;\nfloat rad:\nfloat green;\nflaat blue;\n\n}ABGE_ DEF:\n\ntypedef struct\n\ni\" angle used for simulated lighting */\n\nint angleothotation:\n/* number of vertices in object */\nint nvertax;\n\n/* pointers to vertex color lists \"/\nARGE_DEF  “pARGA[ MUMBER_OF_ARGS LISTS J;\n}OSJECT_OEF;\n\nif\n\ni\n\nff variables\n\nif\n\nif\n\n‘* pointer to buffer usad to store the calculated AGH's */\n\nARGH DEF *opVartexColorautfer; |* global additive ambient light AGe */\nARGS DEF gémblentlight; /* additive value to offset light “hot epot\" */\nint glightOffset;\n\nfi\n\nie\n\nSection’ Fizel Effects\n\nif tunetions\nif\nif\n\nPPT eee eee\n\nFunetion ; interpolateVertexAGas\nLinearly interpolates between two lists of vertex colors.\n\nInput:\nARGE DEF “piraA - pointer to first source vertex color list\nARGE_DEF *pSrch - pointer to second source vertex\n\neolor list\nARGE_DEF *pDest - pointer to storage for calculated\n\nvertex colors\n\nant nAnGE ~ number of vertex colors to interpolate\nTloat Percentage = amount to interpolate between two vertex\n\ntables (0.0 - 1.0)\n\nOutput:\nFills pOest with the caloulated vertex colors\n\nited ll et tedetettt tte L o |\n\nWedd interpolateVertexRGbs|\nARGG_DEF “para, /\" pointer te saurce vortex color data ™/\nARGG_DEF *pireBh,/\" pointer to seaurce vertex color data ™/\nAROB_DEF *plest,/\" pointer ta dest vertex color data */\nint nARGE, i\" number of vertex colors to interpolate \"/\nfloat percentage ) /* interpolation anount, O te 1 */\n\n{\nint index; \"index into arrays of ANGE DEF's *;\nfloat red, {* temporary storage tor coleulated Ra's *;\ngreen,\nblue;\n\nfor { index = 0; index < mARGB: indexe+ }\n{\nfi\nif calculate interpolated ARGE\nif\nred = pSrcA[ index ].red + { pSreBl index ]_red -\npSrcAl index ].red } * percentage:\ngreen = pGreAl index ].green + ( pareBl index |.green -\np&rcA[ index ].green } * percentage;\nblue = poreAl index ].blue + { pSrcB[ index ].blue -\nPSroA[ index ].blue } * percentage;\nif\nff add ambient Light\nif\nred += ginbientlight.rad:\ngreen += gAnbientlight. green:\nblue ‘= gAnbientLight.blue:\nif\nii clamp AGE's\nif\n\n5.3 Simulated Real-Time Lighting Using Vertex Color Interpolation 544\n\nif ( red > 255.0 )\nred = 265.0;\nalse\n\nif { red = 9.0 }\nred = o.0;\n\n}\n\nif { green > 255.0)\ngreen = 255.0;\n\nelse\n{\nif { green < 0.0 )\ngreen = 0.0;\n}\nif { blue > 255.0 }\nBlue = 285.0;\nelse\naf ( blue < 0.0)\nblue = 0,0;\n}\nif\n{i store reselts\nif\n\npOest[ indax ].red = red;\npOest[ indax ].green = green;\npierst[ indax ].blue = blue;\n\n}\n\njtett dtd he CE eee ee ne 2\n\nFunction : caloulateSinylatadLighting\nCalculates the vertex colors used to represent tha lighting at the given\nangle of rotation.\n\nInput:\nORIEGT BEF \"ptaject - pointer to object structure\n\nhe ae ae ee ee\n\nvoid calculateSimulatedLighting( OBJECT_DEF \"pObject j\n\n{\nfloat parcentage\nint quadrant;\nint angleothoetation:\n\nARGE_OEF \"parca,\n\"pores;\n\nangletfhoetation = [ poject->angledfaatation +\nplightOtfset ) % WUNBER_OF RADIANS:",
      "page_number": 523,
      "chapter_number": 54,
      "summary": "This chapter covers segment 54 (pages 523-530). Key topics include lighting, color, and vertex. Lighting Method\n\n‘Typically, the method for generaring real-time vertex lighting goes like this:\n\nEas ba] 536 SectionS Pixel Effects.",
      "keywords": [
        "Vertex Color",
        "vertex color lists",
        "Color",
        "Vertex Color Interpolation",
        "color list",
        "Vertex",
        "lighting",
        "vertex color lighting",
        "target color list",
        "Real-Time Lighting",
        "base color list",
        "calculated vertex colors",
        "vertex color delta",
        "vertex color data",
        "Simulated Real-Time Lighting"
      ],
      "concepts": [
        "lighting",
        "color",
        "vertex",
        "lists",
        "interpolation",
        "interpolating",
        "interpolate",
        "index",
        "effects",
        "gaming"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 44,
          "title": "Segment 44 (pages 432-439)",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 22,
          "title": "Segment 22 (pages 421-440)",
          "relevance_score": 0.68,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.67,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "Segment 48 (pages 456-465)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 23,
          "title": "Segment 23 (pages 441-462)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 55,
      "title": "Segment 55 (pages 531-541)",
      "start_page": 531,
      "end_page": 541,
      "detection_method": "topic_boundary",
      "content": "SectionS Pixel Effects\n\npercentage = [tloat) (angleifRotation 4%\nHUMBER_OF_ARGB_LISTS ) /\n(float) ( NUWGER_OF_RADIANS / NUMBER_OF_ARGH LISTS };\n\nQuadrant = angleOffietation / { NUMBER_OF RADIANS |\nWIMBER_OF_ARGB LISTS ):\n\nParcA - pObject->pAnGe[ quadrant J;\n\nif ( quadrant == (NMUMBER_OF_ARGB LISTS - 1 ) }\nporch = pObject->panGsy o ];\n\nelse\nPSrch = pObject->pAnGa[ quadrant + 7 J;\n\ninterpolatevertexAGhs( péres, pares,\nopVertexColorauffer,\npObject-+nVertex, percentage 4);\n\n0.4\n\nAttenuation Maps\n\nsim Dietrich\n\nVertex lighting is good for many applications and is well known and understood. It\nhas many benefits, including the benefit of properly handling surfaces not facing the\nlight, but vertex lighting can have artifacts when the size of the triangle is large with\nrespect to the range of a poine or spotlighr,\n\nJaehe maps are another approach to calculating lighting that can avoid these cri-\nangle tessellation-relared artifacts, but they require expensive CPU operations to\nupdate for dynamic lights and require potentially slow upload to the video card. Suill,\nlight maps are a good solution for static lighting and shadows.\n\n‘This artide introduces a novel technique known as attenuation maps. This tech-\nnique can be used to implement dynamic point lights with proper quadratic attenua-\ntien using multitexture operations. In addition, the technique can be used for\nspherical, ellipsoidal, cylindrical, and rectangular lighting or CSG operations, accu-\nrate te 2 per-pixel level, wiehout using the stencil buffer.\n\nExplanation\n\nThe attenuation function for lighting is typically like se:\nx = lightPosition.™ - vartexPosition.%;\n¥ = lightPosition.¥ - vartexPosition.¥;\nZ£ = lightPesition.2 - vertexPosition.7;\nD = aget(xex # ¥*¥ + Z*z):\nAtt = 7 / (G0 + Ci\" + G2*p*p):\n\nPor our purposes, we assume that we want only quadratic attenuation, so assume\nthar COis 1 and Ci is 0, giving:\n\nAct = 1 7 qi + C2o*D);\n\n3D textures provide a simple method of encoding this function. Directly store\nthe function in a 30 rexture as a function of X. ¥ and 2 for the three texture coordi-\n\n543\n\nSections Pixel Effects\n\nnares. Then, simply set up texture coordinate generation to calculate dX, d¥i and di?\nrelarive to the light position, use the texture matrix to scale each dX, dV and dz by 1\nover the light’s range, and scale and bias so the center of the texture comesponds to\n(0,0,0).\n\nThe equation that the texture matrix computes in this case is:\n\n((Light.% — Wertex.x) / Liaghthange}) / 2.07) + o.5f;\n((Light.¥ = Yertex.¥) / LigntAange) | 2.0f) + o.5f:\n\n5\nT\nFR {({Light.2 -— Vertex.zZ) / LigntAange) s 2.07) + O.5T:\n\n“a6\n\nHowever, 3D textures aren't yet widely available, so we must make do with 7D\nand 11) cexqures. Even were 31D textures available, it would be advantageous to find a\nless Texture memory-intensive method of calculating attenuation.\n\nWell, first, since we have only 2D and 1D textures available, thar means chat we\ncant compute the function with only a single texture because we can't use all three\ncoordinares X, Fo and 2 at once. This means that we have to break che function ince\ntwo OF More parts.\n\nHow can we express the attenuation function in such a way that we can imple-\nment it using 2D) and 1D textures? Let's start by breaking X and Y into a 2D texture\nand # into its own 1D texture.\n\nMowe break X and Finto one texture and 4 into another, thar means chart the\nresult of the function of Nand Y, which we call ¢(x,¥), and the resulr of the function\nbased on 2, which we call g(7), must be expressible as colors.\n\nIn ether words, if we are storing che function as some combination of two tex-\ntures, we must express the final function as a sum or multiplication of two colors,\nSince colors can hold only positive values from 0 to 1, this affecrs which form of\narenuation function we can choose.\n\nThe previous attenuation function is:\n\nAtt = 1 / (1 + c2*0*D);\n\nSome samples of this function follow:\n\nAnfdj==]\nAp? )== 05\nArf Large D ) approaches 0\n\nAs D pets larger, the artenuation approaches 0.\nLets try to encode this function in nwo textures. First, we expand 2*D into its\ncomponents:\n\nBD = sqrt(xX*X + W!¥ + ZF?)\nOF = (x*x + y*y + F*Z)\n\nNow we restate the artenuation function in terms of XK and 2\n\n5.4 Attenuation Maps HS\n\nAtt = 1 / (1 + Gae{xex + Yer « 2e7})\n\nNow ir seems we are stuck because we cant express the Act function as the sum or\nproduct of the two functions f(%,¥) and (2%) due to the face thac.¥, F. and “are all\nin the denominator. We have to find another function that we can separate.\n\nWe dont have any way of summing two colors and then taking a reciprocal, so we\nhave to find a function that has the same effect but doesn't require a reciprocal,\n\nSquaring numbers greater than one produces larger numbers, wheteas squaring\nnumber in the range (0..1) produces a smaller number. For instance, 0.5 * 0.5 equals\n0.25. This is why we had to ser che constant in our artenuation function, CO, co 1: In\nprevents really close lights from becoming brighter than they should.\n\nRemember that colors are always expressed in the range [0.1]. That means char\nthe result of f(x, ¥) and g(Z) must produce results in the same range [0..1].\n\nOne function that both does nor require reciprocals and produces results within\nthe range [0.1] is:\n\nAte = 1 = Bo\nAEE = 1 = (EP 4 ¥*¥ + 2*?7)\n\nWe can encode t(x,¥) ina 2D texture as (X*X + F*F) and g(Z) ina 1D rexeure\nas simply 2°. Figures 5.4.1 and 5.4.2 give examples of these two textures.\n\nNote how the edges of che texpures shown in Figure 5.4.1 are clamped to be\nexactly one. By adding these owe functions together via multitexturing, we can com-\n\nFIGURE 5.4.1. 7X, F) = ON + FFD\n\nSection 5 Pixel Effects\n\nFIGURE 5.4.2. 2f2) = 272\n\npute D\"D on a per-pixel basis. Using inverse blending, we can use the alpha-blending\nunit to finish the computation and compute 1 — DD.\n\nSa, one procedure for implementing point lights with attenuation maps is as fol-\nlowes:\n\nCraw antient Light and/or global illumination in the scene\n\nFor each Point Light in the scene {\n\nFor each Object that is approximately near or within the\n\nLight's range {\n\nFor each Vartex in the Object 4\n\nSubtract the Wertex Position fram the Point Light\nPosition\n\nScale the Position by 1 / the Point Light's Aange\n\nScalé and 818s the result to range from oO to 1\nfor points inside the Light's Range\n\nStore Position.” in the & texture coordinate of\nTexture oO\n\nStore Position.¥ in the T texture coordinate oat\nTexture O\n\nStore Position.2 in the & texture coordinate ar\nTéxture 1\n\ni\n\nSet up the nultitexture hardware to choose the Light Color\nin the color unit\n\nSat up the multitexture hardware ta cespute Texture O +\nTaxture 1 in the alpha unit\n\nSat up the alpha-blender to conputa Sreteler * InvSreAlpha\n+ Framebuffer\n\nOptionally set the alpha test to raject pixels with an\nAlpha of 1. This avoids rendering pixels that are outside\nof the light range.\n\nDraw the Object\n}\n\n5.4 Attenuation Maps 547\n\n=\n\nAlternatively, we can use texture coordinate generation and the texture matrix to\ncompute all per-vertex operations on the GPU:\n\n* Set up texture coordinate generation for the first multitexture stage to give cam-\ncra space Position.\n\n= Set up the texture matrix co subtract the light’s ¥ and ¥ position, chus giving us\n(2X, a'Y), which are stored in Sand Tof texeure 0.\n\n* Set up the second multitexture stage to use texture coordinate generation to give\nus Camicra space position, just like before,\n\n* Set up the texture matrix to rotate Z onto the X-axis, and then subtract the light’s\n# position, piving us a which is storecd in 5 for texmure 1.\n\nThis technique can be modified to fit a variery of light options. One option for\ngraphics hardware or APIs (such as OpenGL) that don't allow differing color and\nalpha-texture blending modes is to factor the light color into the rexture itself, This\nmodification also allows other blending modes, such as multiplicative frame buffer\nblending, to be employed.\n\nThe attenuation function we computed is:\n\nLaght@olor * {1 — (M°M 4+ yev + Fe?))\nMultiplying through by the LightColor gives:\nLaghtGolor — LightColor = (xX*x # v*¥ + 2*z} =\nLaghtGolor — (LightGelor * (X*X + ¥\"¥) + LightGolor * (7\"Z7)}\n\n‘This implies thar we need to pre-multiply the light color into both attenuation\nmaps to get the right effect, but we really need only one map. It curns out thar we can\njust use the center of the LightColor * OK + FY) texture for the LightColer * (Z*Z)\ncomputation. We can use the honzontal or vertical center, but the horizontal center\nrequires one less texture coordinate to specify and might provide beter texture cache\nperfonmance.\n\nComparing Attenuation Maps and Light Maps\n\nLight maps are commonly employed to stere static lighting data, such as shadows and\nlight calculated through a global illumination solution. Updating light maps ar run\ntime for point lights is complicated and cosely. Point lights performed with artenua-\ntion maps complement light maps nicely by taking over the chores of dynamic point\nlights, Instead of uploading new light maps to reflect a point light changing its color,\nrange, of location, the nearby scene can be simply rerendered using the attenuation\nmap textures to blend the lighr into the scene.\n\nCSG Effects\n\nBy using alpha test or stencil, we can vest for inclusion in perfectly spherical areas such\nas the falloff range of a point light For each pixel thar would be drawn with a point\n\nsectionS Pixel Effects\n\nlight, we can set the stencil to a certain value or blend into che frame buffer a constant\ncolor, thus being able ro do other range-based effects.\n\nRange-Based Fog\n\nOne application of this concept is per-pixel range-based fog. Simply render the scene\nas normal with no fog applied, and chen render the scene with che amtenuarion map,\ntreating the camera position as the “light position.” Set che cexmure marrix to identity,\nand then scale the macrix by 1 over the light's range. This technique allaws per-pixel,\nPErspecthve-correct range fre.\n\nThe $0_COLOA sent to the frame buffer blending unit should be che fog color\ntimes fog density. This gives a fog density of zero at the viewer, and at the maximum\nfog range the density will be one.\n\nWhen rendering che fog pass, set up the alpha blender to perform SRC_COLOR * 1\n+ DST_COLOR * [7 — SRE_COLOR}.\n\nOther Shapes\n\nSometimes a sphere is not what is needed; co make an oblong shape, such as a rectan-\ngle or ellipse, simply select minor and major axes and align chem to the world with the\ntexture matrix. We then have co scale the major and minor axes separately,\n\nConclusion\n\nBy cleverly choosing our attenuation function, we are able te perform a per-pixel\nspherical range calculation using two texture maps. The result of this calculation can\nbe used for per-pixel point lights, fog, or CSG effects.\n\n5.5\n\nAdvanced Texturing Using\nTexture Coordinate Generation\n\nRyan Woodland\n\nBecause today’s graphics processors are pushing more and more polygons, attention is\nstarting to turn to the use of bandwidth to create compelling texture effects. With the\naddition of multitexture abilities to many procestors, people are starting to wonder\nhow to creatively use these fearures. OF course, artist-applied texoure is the cechnique\nwith which we're all the mast firniliar, bur it's quickly being discovered thar mapping\ntexXtUres at Tun time can produce some very interesting results. Developers are starting\nto use texture coondinate generation to perform animation, lighting, reflection, refrac-\nvon, and bump mapping, ta name a few techniques. This article discusses a few of the\nMOSE COMMON fexture coordinate generation techniques.\n\nThe method of texture coordinate generation used most comfortably by most\npeople is thar of wansforming some data (postion, normals, texture coordinates) by\nsome matrix to yield a set of texture coordinates, This method is fairly easy co adopr\nbecause most 31D) programmers are familiar with the concept of macrix cransformation\nand because matrix transformation is often accelerated by hardware. This article\ndescribes only techniques that cin be performed using macrix mach.\n\nSimple Texture Coordinate Animation\n\nQuite often, games use a simple rotation or translation of texture coordinates to sim-\nulate simple effects such as reflection or to give the appearance of water or some mov-\ning material. The concept is simply this: A texture coordinate can be thought of as a\nsimple 21D point. Because programmers are accustomed to transforming points by\nmatrices, it is easy to see that a texture coordinate can be rotated, tramslaced, or sealed\nsimply by transforming it inte a 3% 3 matrix. Just as with geomenry, a homogenous\ncoordinate must be added to the s, ¢ pair to make the transformation possible. There-\nfore, the method of coordinate generation looks like this:\n\n(6D) * Sb = eh\n\n550 Sections Pixel Effects\n\nThe illustrations in Figure 5.5.1 were generated using simple rotation and scale.\nThe first picture shows a textured quad with no transformation applied. The second\nshows a rotation of the texture coordinates by 45 degrees. The third shows a texmure\ncoordinate manslation of 0.5.\n\nTexture Projection\n\nTexture projection is useful for a number of effects. Most often it is used to simulare\nlighting effects such as spotlights or shadows. The result of texture projection is fairly\nstraightforward: A texture is projected onco some geometry from some point in space.\nFor example, we can define a sporlight ar some point in a scene and project a texture\n(probably a light circle) onto the geometry, creating the illusion of a spotlight.\n\nAgain, the concepe of rexnure projection has its roots in normal 3D geometry tech-\nniques. When simulating a camera in 3D, a projection matrix is used to project vertices\nin camera space once the near clipping plane of the camera. These points are mapped\nin the range of —1 co 1 in both Xand 1 and chen they are transformed into screen space\nby a viewport transformation, which usually involves a translation and scale.\n\nFor texture projection, instead of modeling a camera in space, we are usurally\nmodeling a light. Light space vertices are projected back onto the near clipping plane\nof the light, and the resulting X and }valucs are used as Sand T values to map a tex-\nture onto the projected geometry.\n\nA light should be modeled just as a camera usually would. The near clipping\nplane should be set to reflect the dimensions of the texture that is to be projected. For\ninstance, a square near clipping plane should be used for projecting a square texture.\n\nNow, as mentioned, geometry chat is projected onto a texture needs to be in light\nspace, just as geometry to be projected onco the screen needs to be in camera space. In\norder to do this, we need to first wransform the geometry into world space. Onee this\nis done, the lighe matrix (just like che camera matrix) must then transform the geom-\netry. The geometry can then be projected by the light’s projection matrix.\n\nOnce geometry has been projected, another problem arises. Projected geometry,\nas mentioned previously, falls in the range of -1 co 1 in both X and F with (0, 0)\n\nFIGURE 5.5.1. Examples of texture coordinate penerarion through texture matrix transformations.\n\n6.5 Advanced Texturing Using Texture Coordinate Generation 551\n\nbeing at the center of the plane of projection as ir relates to the light. Texture coordi-\nnares usually run from 0 to Lin both Sand 7; with the origin of chat space being\nlocated at the upper-left corner of che vexture. To map the projected coordinates into\nTexture space, we must first scale chem by (1.5 00 pur them in the range from —0.5 to\n0.5 and then translate them by 0.5 co pur them in the range from 0 to 1.\n\nAll these matrices can be concarenared together to form one final projection\nmatrix for a given piece of peomesry. The order is as follows;\n\nM_obj * M_fight * M_proy * M_scale “ M_trans \"(en Oo) = fe 6 gl\nwhere:\n\n* Moby = the object's world space marrix.\n\n* M_light = the light matrix used to transform the geometry fom world space into\nlight ¢pace.\n\n* W proj =the light’s projection matrix.\n\n* M scale = (0.5 scale manrix.\n\n* M_trans = 0.5 transhtion matrix,\n\n‘The result of this calculation is 2 four-dimensional point. For simple texture pro-\njection, the r coordinate should be completely ignored, yielding an (s, ¢, q) triple. If\nthe hardware allows, pass these chree coordinares down for rasterization. The q coor-\ndinate is used to perform perspective correction: however, this must be done at raster-\nEzation time for it to be correct.\n\nFigure 3.5.2 was generated using texture projection. Ir shows the frustum of the\nlight that was used to project che circular highlight onto the sphere geomienry.\n\nBy projecting geometry in this manner, a few unexpected results can occur. First.\nTexture coordinates usually behave in a tiled manner. This means hae there is really no\n\nFIGURE 5.5.2. Texture projection example.\n\nSection 5 Pixel Effects\n\n—— SS\n\ndifference between a set of coornlinates that rangres from 0 to | and a see cheat ranpes\nfrom —1 to 0. Therefore, cextures thar are projected nig geometry shouled usually\nbehave in a clamped manner, meaning that che ourside border of the neeture i¢ repeated\nand applied co any texture coordinare less than 0 and grearer than 1. For this reason,\nrexture borders should be colored to behave correcely with the texture combine mode\nof cheice.\n\nThe second and more complex problem is that of what | call shie-nhroneh, When\nWe Project a texture onto a sphere, for instance, the texture appears on both the front\nand back sides of the sphere as it relates eo the light. This ts because vertices on both\nthe front and back of the sphere project into the comect texnure space.\n\nThe image in Figure 5.5.3 highlights chis problem. You can see that the spotlight\ntexture projects correctly on the front of the sphere, but it also shines through to the\ngeometry on the back of the sphere.\n\nThere are a couple of ways to fix this problem of shine-through. The first is to\nperform a dot product between the vertex normal and the light normal to determine\nwhether the vertex is back facing. IF the vertex is back facing. simply set the texture\ncoordinate to something out of the range of 0 to 1.\n\nSecond, you can use the output of the standard lighting equation co determine\nwhether a vertex is back facing. Place a parallel light at the location of the texture pro-\njector Lf che color output from chis parallel light for a vertex is black, you know that\nthe vertex is back facing, because the only way for this vertex co become black is if the\nassociated normal ts facing away from che light.\n\nFIGURE 5.5.3. Shine-through in texture projection.",
      "page_number": 531,
      "chapter_number": 55,
      "summary": "‘This artide introduces a novel technique known as attenuation maps Key topics include textures, textured, and lighting. Covers function. Directly store\nthe function in a 30 rexture as a function of X.",
      "keywords": [
        "texture",
        "texture coordinate",
        "texture coordinate generation",
        "light",
        "light maps",
        "point lights",
        "texture matrix",
        "Texture Projection",
        "function",
        "Attenuation Maps",
        "coordinate",
        "ARGB LISTS",
        "coordinate generation",
        "Light range",
        "range"
      ],
      "concepts": [
        "textures",
        "textured",
        "lighting",
        "maps",
        "map",
        "mapping",
        "projection",
        "projected",
        "coordinates",
        "space"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "Segment 48 (pages 456-465)",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 42,
          "title": "Segment 42 (pages 401-412)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 23,
          "title": "Segment 23 (pages 441-462)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 46,
          "title": "Segment 46 (pages 443-452)",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 56,
      "title": "Segment 56 (pages 542-549)",
      "start_page": 542,
      "end_page": 549,
      "detection_method": "topic_boundary",
      "content": "5.5 Advanced Texturing Using Texture Coordinate Generation 553\n\nReflection Mapping\n\nTo perform reflection mapping, I use a simple method called sphere mapping. The\nbasic idea for chis method makes two ASSL pthons.\n\nFirs, no maceer the size and shape of the object being mapped, it is assumed to\nreflect the surrounding environment like a sphere. This concept is important because,\nlogically, a point on a character's hand should reflect something different than a point\non a character's foot with the same normal. With sphere mapping, these owe points\nreflect exactly the same thing because they have the same normal.\n\nSecond, the reflective sphere like which the object will behave is assumed to be\ninfinitely small. ‘This means thar all rays from the point of the eye in the scene to any\npoint on che infinitely small sphere are parallel to each other.\n\nGiven these limitations, the sphere-mapping method operates om basic laws of\nreflection. Take, for instance, a ray from the cye poine in a scene to a poine on the\nreflective sphere. This ray should hit che sphere and reflect around the normal ar the\npoint of contact. Whatewer this reflected ray hirs should be seen reflected ar che paint\nof contact on the sphere. Figure 5.5.4 illustrates this concept.\n\nSince it is not computationally feasible co perform one-bounce ray tracing for every\npoint on a sphere, we instead create a cexrure map that contains the necessary environ-\nmental information. This map is called a spherinal reflection map, or a sphere map.\n\n—]+._ Incident Ray\nps Fofiected Fay\n\nsurface Mannal\n\nFIGURE 5.5.4. Rays are reflected around the surface normal at the point of contacton a\nreflective object.\n\n554 Sections Pixel Effects\n\nThe basic definition of a sphere map is a single texture map thar conrains a full\n360-degree view of the environment surrounding a point in space. There is one big\ndrawback to using sphere mapping for reflection: The texture used as the reflection\nmap is viewpoint dependent. This means chat te be completely comect, the rexcure\nmap must be dynamically creared each time the camera moves. I have found, how-\never, that for some common effects such as generating a specular highlight on a car or\ncreating lighting effects on a character, refusing to update the sphere map based on\nviewpoint is often not nociceable. (For an in-depth discussion of generating sphere\nmaps see [Blythe?9].)\n\nOnce you have an adequate sphere map, texture coordinare generation is a snap.\nSimply transform an object's normals into world space using the inverse wansform of\nthe object's model matsix. Then transform the normals into view space using the cam-\nera matrix. Finally, assuming your camera is looking down the —2 axis, simply use the\nAand Ycomponcness ofa normal as the Sand T coordinates, respectively, for the asso-\nclated vertex.\n\nObviously, using this technique, normals with a <2 componenc generare the\nsame 5, J coordinare pair as the same normal with a +2 component. This warks our\nfine because any vertex with a—2 component in its associated normal is by definition\nback facing and will not be seen, since this calculation is done in view space,\n\nColor Phare 5 was produced simply by mapping a corus with a spherical reflection\nmap of an outdoor environment.\n\nUsing this technique, it is very easy to perform reflection, specular mapping, and\ndiffuse lighting using the comect texcure maps.\n\nFor a view-independent method of generating these effects, please see [Hei-\ndrich98), which describes dual-paraboloid mapping. In addition, cubic environment\nmapping is a wonderful way to generate dynamic lighting and reflection effects if the\ntarget hardware provides support for it. Please see [Nvidia00] for more information.\n\nReferences\n\n[Blythe] Blythe, David, Adnenced Graphics Progamming Techniques Useng OpenGL,\nAvailable online at heop://realiry-spicom/blythe/sig99/advanced99/ notes/nodetO\nchum, April 7, 2000.\n\n[Warr92] Ware, Alan, and Wart, Mark, Adpertced Animation and Rendering Tech\nniques, ACM Press, 1992.\n\n(Heidrich?8) Heidrich, Wolfgang, and Seidel, Hans-Peter, View-independent Envi-\nnonment /Mepr Eurographics/ACM Siggraph Workshop on Graphics Hardware\n1998, available online at www).informarik_uni-crlangen.de/ eng) research/render-\ning/envmap/, March 22 2000.\n\n[Nvidia] NVIDIA technical brief, Perfier Reflections anal Specrler Lighting Effects\nwith Cube Environment Mapping, available online at wwow.nvidia.com! Market-\ning! Developer! DevRel.nsif WhitepapersFrame?QpenFage, March 10, 2000.\n\n5.6\n\nHardware Bump Mapping\n\nsim Dietrich\n\nBump mapping, firse described by Jim Blinn in [Blinn78], is a technique that simu-\nlates the way light reacts 0G 2 rough or dimpled surface by applying a texture to an\notherwise smooth polygonal surface. The applied texture is known as the durep map,\nhence the term bump mapping.\n\nSeveral methods of bump mapping are available in hardware today. This article\nconcentrates on elucidating the common issues around modern bump-mapping tech-\nniques thar programmers encounter when moving from “bumpy sphere” demos to\nactual game implementation. Since bump mapping is actually a lighting computa-\nten, I discus bump mapping in terms of illumination.\n\nBump-mapping techniques either caloulate or approximate a dot product\nberween the light vector £ and the surface normal Nin order to calculate diffuse light-\ning. For the sake of simplicity, | assume thar the dot product operation is calculated\non a per-pixel hasis. ‘This functionalicy ts available from several hardware vendors at\nthe time of this writing and will likely remain available in che furure-\n\nSpecular lighting can be achieved by calculating che dor product between the\nhalf-angle vector AY and the surface normal Wand then raising the result to some\npower. We concentrate on diffuse illumination, but bear in mind chat all techniques\ndiscussed can be applied ta specular bump mapping or lighting as well.\n\nDot product-based bump mapping and per-pixel lighting are huge subjects, so we\nconcentrate on explaining the problem at hand and some practical solutions. Specifi-\ncally, this article avoids discussing texrure blending modes, cube maps, texture for-\nmats, and other things at that level of implementation detail, instead concentrating\non how ta properly bump map or light an arbitrary model or mesh.\n\nHow Do | Apply a Bump Map to an Object?\n\nThe simple answer to this question is to simply texture map the object with a texture\nrepresenting the bump map. A more useful answer requires more information on\nwhat effect we are trying to achieve on which platform, Various hardware bump-map-\nping techniques require different source data for the bump-map texture, from alpha-\n\n555\n\n556 _ Sections Pizel Effects\n\nheight maps co RGB surface normal maps and RGB @LifV maps. Since both RGB\nsurface normal maps and RGB @UWV maps can be generated from alpha-height maps,\nI assume that the original source data for the bump map is an alpha or gray-scale\nheight map.\n\nAs stated, we assume that we have a per-pixel dot product operation, thus, |\nassume we have a way of generating the appropriate texture formar thar directly\nencodes surface normals in RGB formar. One such format maps the X, ¥, and 7 vector\ncomponencs from [—1_.1] floating point into the [0255] range of the RGB channels.\n\nThe fact that we have normals stored in an RGB texture presents an interesting\nquestion: In which space are these normals defined? Model space? World space? Some\nother space?\n\nThe fundamental bump-mapping of diffuse illumination operation, © J, does\nnot care in which space the vectors are defined; it is essential, however, to ensure that\nNand £ are expressed in the same coordinate system.\n\nWe-will see thar this seemingly innocuous issue is one of the most important con-\nsiderations when evaluating dot product-based bump-mapping techniques. The next\nsection describes each option and where it might be most appropriate.\n\nChoosing a Space for the Normals\n\nLet's start with a simple example of a sphere that we want to bump map in model\nspace. We assume for now thar the bump map is uniquely cextured across the sphere;\nin other words, that each point on the sphere maps to its own section of the texture so\nthat no tiling or mirroring of the bump map occurs.\n\nIn this case, we go through cach cexel in the bump map, find where ir is mapped\non to the sphere in model space, and generate the surface normal for char location.\nNext we generate a 3 X 3 coordinate system for that location on the sphere, using the\nsurface normal as the +2 axis. This is commonly known as samgenr space because it\nrepresents a space that lies tangent 0o che surface.\n\nIn order ta generate taNgent space, wo unique vectors are required, and the third\nvector can be generated from the other owe, In this case, however, there is no obvious\nchoice for a second vector because there is an infinite number of tangent spaces with\nthe same 4.7 axis, so an arbicrary choice must be made.\n\nWe choose the + axis in model space as our second vecror. We then make a cross\nproduct of +} with our surface normal to generare the third veetor, which serves as\n+4. We can then stop or take che cross product of +2 with +X to generate a new +¥\naxis. Normalizing all three vectors gives us the three columns of our 3% 3 matrix chat\nfepresents tangent space at thar point on the sphere surface.\n\nNow we hive a basis matrix ar che appropriate point, and we can take the bump\nvector from our bump map, expressed in world space, and rotare it into local tangent\nspace using our matrix. We now have a bump vector for char particular point on the\nsphere. We can now replace che world space bump vector in the texture with the ran-\ngent space bump veccor.\n\n5.6 Hardware Bump Mapping 557\n\nNow at ruin time we can take a light vector £ expressed in world space and norare\nic through the world to model manmrix, giving £' Since L’ is now relative co model\nspace, we can perform \"© N beoween this light vecter and the bu Mp-Map VECwors.\n\n£'is constant fora particular model space matrix, so it is valid in general only for\nthe current model hierarchy level. This is conveniens in that it allows £\" to remain\nconstant for an entire portion of the model being bump mapped.\n\nAt run time, we can sct up the texcure-blending units to compute:\n\n‘Texture - Coneane(alor\n\nWhere Texture corresponds wo the surface normal map with RGB encoded normals\nand GonstantCelor- comesponds to our constant L’ vector, converted into RGB form.\nThis technique is known as object space or model space bump mapping. Its advantage\nlies in no run-time overbead other than a single vector rotation per model hierarchy\nlevel, Its disadvantages include having to uniquely texture objects, which takes a Large\namount of texture memory. In addition, skinning or morphing objects need cheir sur-\nface normal textures regenerated every frame-\nThe desire to overcome these disadvantages leads to the next technique.\n\nAnother Approach: Using Tangent Space Bump\nMapping\n\nSince we have defined tangent space already for our sphere, chat means we have a\ntranslation from model space to a local space defined at each vertex. We can leverage\nthat information to eliminate the necessity of both unique cexcuring and of having to\nrepemerate the surface normal CEL y3 in the Case of animated models. Insread of reren-\nerating the normal maps to be relative to model space, we leave our normal maps as\nthey arc, instead generating a matrix to rotate the light vector from model space into\ntangent space.\n\nWe assume chat our original height map represencs height “out from the surface.”\nMathematically, che “owe” direction of the height map corresponds to the +7 axis of\nOUL tangent space at every point on the surface of the sphere. We use this to create a\nmathematical way of translating [rom the bump-map space co the local tangent space\nat any point on the sphere.\n\nOne way to accomplish this task is to calculare our tangene space exactly as in\nmodel space bump-mapping described previously, but only ar cach vertex of the\nsphere, and store the tangent space matrix in a data structure corresponding to that\nvertex. When lighting or bump mapping that vertex, we use che 3 % 3 tangent space\nmatrix to convert our light vector inta local tangent space. So, rather than wsing the\ntangent space macrix to convert the surface normals, as we did previously, we use the\nmatrix to convert the light vector instead. Remember thar the space in which the dot\nproduct is performed is irrelevant, as long as boch veccors are defined in the same\ncoordinate space.\n\nSection5 Pixel Effects\n\nIn model space bump mapping described previously, the generation of a tangent\nSpace Matix occured as a preprocessing step at every poine on the sphere im order to\npenerate a unique bump map across che sphere. In tangent space bump mapping, we\nonly penerate a tangenc space macrix ac each vertex of the sphere.\n\nAt tun time, we take our 2 vector for each vertex of the sphere and rorace ir, first\nthrough the world-to-model matrix and then through the local cangence space matrix\ngenerated during preprocessing and scored ac that vertex. This gives us 2) the light\nvector in local tangent space. OF course, £' is correct on only a per-vertex basis. In\nmodel space bump mapping, £’ was constant for the whole model hierarchy level.\nNow J’ varies from vertex to vertex.\n\nSo, whereas before, we stored £*in a constant color, it now has to be interpolated\nacross a triangle.\n\nTo perform tangent space bump mapping, we can set up the texture-blending\nunits to perform:\n\nTexrure - Diffusetolor\n\nWhere Texture is our surface normal map and DiffuseCelor is an iterated color\nvalue represencing\n\nWe leverage the handware's color interpolation capability co “rotate” our £ \"vector\nfrom one space to another, We are actually performing a linear interpolation berween\nlocal £\"vecoors at each vertex, rather chan true sotation or spherical interpolation, but\nfor most purposes this works well, Note that perspective-correct color interpolation is\nareal help for these cases.\n\nOn mubtitexture hardware, it is desirable to use a cube map or paraboloid map to\ninterpolate £* instead, but char topic is beyond the scope of this article. Suffice it to\nsay thar using a linear interpolation of £' veetors leads to darkening artifacts when\nbump mapping with respecc to local lights near large triangles. This effect is caused by\nalmost opposice L* vectors being shortened when linearly interpolated across the inte-\nrior of a triangle. Cube maps can also assist with handling properly interpolated light\nVECIOM across anisotropically scaled mormal maps,\n\n‘Tangent space bump mapping is much improved over model space bump map-\nping in that bump-map textures no longer must be unique and can be dled across a\nsurface. In addition, skinned or morphed models need only regenerate the 3 x 3 ran-\ngent space matrix for each animated vertex and do not have wo recreate che surface\nnormal map each frame.\n\n‘Tangent space bump mapping is less CPU-efficient than model space bump map-\nping in char it requires more rotations of £ into local tangent space at run time. In also\nrequires updating of model data at run time, which may introduce GPU stalls or\nadditional dara copying.\n\nA more subtle disadvantage of tangent space bump mapping is not necessarily\napparent when creating a demo ofa bumpy sphere, but that can be a challenge when\nincorporating bump mapping into an actual game environment. The problem is thar\n\n5.6 Hardware Bump Mapping 558\n\ntangent space bump mapping requires defining a relationship berween how the bump\nmap is applied and the surface of the object.\n\nIn order to generate the local tangene space matrix, we need to know more than\nthe Fact that the “out” direction of the height map corresponds to +2 in tangent space.\nThis is the same problem as in the model space bump mapping example. We must\nhave two unique vectors in order to define a three-dimensional coordinate system.\nMost bump-mapping aamples available on the Web today (cinca 2000) have an arbi-\nwary, implicit mapping whereby they simply choose a world or model space axis, such\nas +}, in onder to generace the ramgent space macric.\n\nHere is a description of our problem. Let's say a programmer and artist work\ntogether to bump map our sphere using this bump map. Now say char che artist\ncomes in the next day and rotates the bump map %) degrees on che model and\nimports it into the game. Instead of the light appearing to come from above, the light\nnow appears to come from che side! So, the programmer comes in, sees che problem,\nand updates the tangene space matrices by taking into account the *0-depree roration\nto fix the problem.\n\nThe fact thar this problem could be fixed in this way implies thar the artist is sup-\nplying informacion char the programmer is not aunomacically taking into accoune in\nthe mapping from tangent space to bump map space.\n\nThe artist knows how she wanes che bump map applied, so che program should\nrespect her choice. The bump map can be applied like any colece texmurc: thus it may\nbe stretched, warped, projected, and 20 Of. (hur simplistic fatigent Space rict hese Fails\nto take inte account how the bump map is actually applied no a model and assumes\nthat there is a simple correspondence berween the bump map and the underlying sur-\nface. Tangent space bump mapping requires knowing how the texcure was applicd—\nin other words, planar, box, spherical, or cylindrical mapping.\n\nIris this assumption thar makes tangent space bump mapping difficult to incor-\nporate into a game, especially one with existing arrwork that we dont wane co recex-\nture with bump maps in a restrictive way.\n\nA Solution: Texture Space Bump Mapping\n\nTexture space bump mapping is similar to tangent space bump mappingand primar-\nily differs in the way that the local matrices are penerated for cach vertex.\n\nRather than generating tangent space matrices at each vertex, texture space bump\nmapping creates what I call a tecture space matrix that takes into account exactly how\nthe texture was applied to the surface by the artist.\n\nTo generate this matrix, we need to look at each tangle and how ic is texture\nmapped. It may be rotated, scaled in Sor 7, flipped, or projected. It tums out that\nwhat we need to know in onler to mathematically acaount for bow the texcure is\napplied are the texture gradients, The texture gradients are nine scalar values that rep-\nresent the direction of Sand 7 with respect to the A, F and 2 ames,\n\n8\n\nSection 5 Pixel Effects\n\nWe calculate the vexture gradients as follows; let's stam with the plane equation of\n‘OWL triangle:\n\nWe can use any three independent variables in our plane equation, so | use X, 5 and\nF, instead of X, FF and 2.\n\nfix: Are Cre DO -\n\nNow we can usc this equation to calculate our texture gradients with respect to X.\nLet's assume thar we have two unique «and two unique s values and subtract one\nfrom the other to give ws ale and ads. For this step, we assume that-tis held constant,\n\njx! + sl 4 Cr+ D= 0\n\nvic + Bila Cr+ O= G\n\nAx) + Bs + Cr+ De» Axl + Bil + Ces D\n\nAxl + Brl + Cr+ D—f Act + B+ Cr+ D) a\nAx! — Ax + Brf — Br = 0\n\nA) + Bais) = 0\nAja) = -—Ayd5)\naay = RA\n\nThe gradient of X with respect to § is thus —B/A_ This gives us 2 measure of how\nA changes with cach change in 5. The same can be computed for dT. We can then\ngenerate the gradients of Fand 2 similarly. [fA is found to be 0, we can safely set the\ngradient co 0. That simply means that S doesnt change at all with respect co 5,\n\nWe now have six scalar values that represent hew X, Fo and 2 change in model\nspace as we walk across the rexture in Sand T.\n\nWe can use this information to derive a marrix between the §, and SxT axes,\nand the X, K and 2 model space matrices:\n\njx Tx (SxT)x\nsy Ty (S*T)y\nSz fee (S507 2\n\nAt mun time, we can move the light vector into local model space using the\nmodel's hierarchical matrix stack, Then we can pur the light vector through this\nmatrix for each vertex and store che resulting vector in che diffuse or specular iterated\ncolors. Now the dot product can be computed benween the normal map and a light\nvector defined in the same space as the normal map.",
      "page_number": 542,
      "chapter_number": 56,
      "summary": "This chapter covers segment 56 (pages 542-549). Key topics include mapping, maps. The\nbasic idea for chis method makes two ASSL pthons.",
      "keywords": [
        "space bump mapping",
        "Tangent Space Bump",
        "space bump",
        "Bump Mapping",
        "bump map",
        "model space bump",
        "taNgent space",
        "space",
        "Model space",
        "Bump",
        "Texture Space Bump",
        "space bump map",
        "map",
        "Mapping",
        "Advanced Texturing"
      ],
      "concepts": [
        "mapping",
        "map",
        "maps",
        "space",
        "texture",
        "bump",
        "lighting",
        "vector",
        "normal",
        "model"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "Segment 48 (pages 456-465)",
          "relevance_score": 0.61,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 23,
          "title": "Segment 23 (pages 441-462)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 45,
          "title": "Segment 45 (pages 429-442)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 46,
          "title": "Segment 46 (pages 440-447)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 57,
      "title": "Segment 57 (pages 550-561)",
      "start_page": 550,
      "end_page": 561,
      "detection_method": "topic_boundary",
      "content": "5.6 Hardware Bump Mapping Sei\n\nTexture Space Issues\n\nSome of the issues that arise from generating a basis from textures are summarized.\nThe inost apparent issoe that arises when implementing this task ts flipped textures,\nSinec texoures don't have a “sidedness\" and normals do, we need to detect this case by\ncomparing the face normal of the triangle to the rexture'’s SX Taxis. If the dot product\nbetween them is negative, we can simply flip the 57 axis. At times an artist mirrors\npart of a texture on a symmetrical object. In this case, two triangles that straddle this\nboundary have opposite 5% J axes. In this case, the programmer or artist must dupli-\ncate the vertex,\n\nAt times programmers are forced to duplicate vertices for the sake of different tex-\nture coordinates, This situation can indicate a discontinuicy in how the texmure is\napplied to the surface. The way to solve this problem is to create a texture space basis\nmatrix for each triangle individually, Next find which vertices are geometrically\nthared between triangle faces—in other words, which vertices share X, ¥, 2 positions.\nNow for each vertex, take the §, T and S*T axes of each triangle that touches that\nvertex and sum them. Now normalize the resulting 5, Tand 5x7 axes, This action is\nanalogous to creating vertex normals from face normals, cxcept that we are calculating\nthree vectors at a time. The three resultant vectors now make up a mew “average tex-\nture space” to store at each vertex of the model.\n\nThe price of normalizing the resultant column vectors is chat now anisowopically\nscaled textures cant be handled properly. If we have cube maps or some other way to\nnormalize the vectors, we can skip the normalization secp and thus handle anisomrop-\nically scaled textures with ease.\n\nConclusion\n\nDot product-based bump mapping and per-pixel lighting have arrived and along with\nthem some interesting parameterization issues. The need to interpret flar texcures as\n3D surface normal vectors necessitates either regenerating the surface normal texrures\nto match the model, as in model space bump mapping, or generating a basis macrix\nfor cach vertex, as in tangent and texture space bump mapping.\n\nReferences\n\nHere are three great resources for more information on per-pixel lighting:\n\n[Blinn?8) Blinn, James, “Simulation of wrinkled surfaces,” Computer Grapher (S/G-\nGRAPH 78 Proceeatng:), vol. 12, no. 3, pp. 286-292, August 1976.\n\n[Everitt00] Everitt, Cass, “High-Quality, Hardware-Accelerated Per-Pixel Illumina-\ntion for Consumer Class OpenGL Hardware,” master's thesis, available online at\nwww. r.nu/—cass/ thesis, May 2000.\n\n[NVIDIA] NVIDIA's Developer Relations site ac wwwnvidia.com/Developer.nsf,\nMay 2000.\n\nGround-Plane Shadows\n\nYossarian King\n\nProjecting shadows of arbitrary objects onto other objects or arbitrary terrain is diffi.\ncult. However, if you are projecting shadows onto a flat ground plane, there is a sim:\nple solution. The “obvious” approach is vo draw a sprite of some sort at a character’:\nfeet, perhaps generated by rendering the character in profile ro an off-screen butler\n‘This method suffers from misregistration effects between object and shadow. Thi:\narticle presents a simple technique for ground-plane shadows that performs a physi-\ncally correct projection with very litde computational overhead.\n\nOne additional transform matrix is used oo “squash” the vertices in an object onte\na flat horizantal surface of arbitrary height. The direction and height of the light\nsource relative to the object determine the shadow projection matrix. Given this\nmatrix, the object is rerendered with che additional cransform to draw the shadow.\n\nTranslucent gray polygons are used in place of the textured palygons of the abject\nto create the shadow effect. The object used for the shadow need noc be the same as\nthe original ebject; typically you use an object with a lower polygon count co improve\nperformance. The polygons of the shadow object overlap after projection onto the\nground, which produces artifacts in the cranslucent rendering. These artifaccs can be\neliminated using a hardware Z-buffer.\n\nThe technique can be extended to project shadows onto any 3D) plane, nor just a\nplane aligned with the coordinate axes, Used twice, the technique can project shadows\ninto the corer berween a floor and a wall,\n\nShadow Math\n\nEEE\nShadows result when a solid object comes between a light source and a surface. A\npoint on the surface is in shadow if a ray from the light to the point intersects che\nobject. In a rendering system, the object is represented by a collection of polygons.\nCasting rays from the light through each of the vertices of the model once the surface\noutlines the areas of the surface thar are in shadow. For a single polygon of the object,\nthis method gives a projected shadow polygon on the surface.\n\n5.7 Ground-Plane Shadows 563\n\nLinformunarely, chis method does not lend itself directly to practical real-time ren-\ndering. It is cosdy co calculate the inversection berween the ray and the surface. The\nprojected shadow polygon needs to be subdivided to conform accurately co the sur-\nface, an operation that is arbitrarily complex, depending on the complexity of che sur-\nface. An alternative to rendering the projected shadow polygons is co modify the\nvertex colors of the surface, darkening the vertices thar are in shadow, bur this has the\ndrawback of reducing the precision of the shadow and making ic dependent on che\nvertex density of the surface. Dynamic shadow map textures can be used to compute\nshading at a higher and more uniform detail chan allowed by vertex shading, but this\nprocess is also expensive.\n\nThe problem can be simplified, however, if the shadows need be cast only on 2\nhorizontal ground plane. For many gare applications such as sports simulations and\ncorridor games, horizontal surfaces are the norm, and the simplification can be used.\n\nFigure 5.7.1 shows ground-planc projection in 2D. A light at point £ casts the\nshadow of a point / onto the ground planc (dhe A-axis) ar some point 5. We want to\ndetermine «x, the X coordinate of point 5.\n\nUse of similar triangles shows chat:\n(oc — px) _ py\n(xx — ty) iy\n\nFIGURE 5.7.1. A light ata peane 2 casts a shadow of point Fionn the ground plane at\npaint 3.\n\n| 4\n\nSection’ Pinel Effects\n\nsolving for oc\n\n= ix — &)\niy\n\nBut this expression for o: includes sx, so we haven't actually solved for the\nunknown. However, the anky use of ec on the night side of the equation is in (sx — fy),\nwhich is the horizontal distance from the shadew point to the light. By assuming thar\nthe light is relatively far away from the object relative to the length of the shadow, we\ncan approximate (sx — £:) with (ax —é,), the distance from the object to the light. This\nyields;\n\n= px t py\n\n(ox — fx)\n= pet op\nor simply:\na= pet ke” py\nwhere:\ni (ax — tx)\n\niy\n\nThe distance light source assumption is equivalent to treating the light as a direc-\ntional light rather than a point light source,\n\nExtending this to three dimensions and projecting the shadow point S onto the x-\nz plane, we per:\n\n= pet kl” py\nv=o (5.7.1)\nsf = pet kl\" py\nwhere:\na= @=4)\nly\ngoa ist =#)\nhy\n\nBy projecting cach of the vertices of the object onto the ground plane, we get a\ncollection of projected polygons that can be rendered to create the shadow of the\nobject. To do the projection, we just need to calculate the values of #7 and £2, which\n\n5.7 Ground-Plane Shadows 565\n\n——= SS\n\nare completely determined by the relative position of the object and the light. Imple-\nmentation of chis technique is deseribed in further detail in the next section.\n\nImplementation\n\nIn a typical rendering pipeline, a model vertex ot is transformed inte a view space\npoint # before projection into screen space. This operation is written as:\n\np= OT\"\n\nwhere Tis a matrix representing the model transformation that converts model vertex\nmi inte world space, and (is the camera transformation that converts world space\ncoordinates inte view space. In order to renderan object, we transtonm each of its ver-\ntices inte vicw space, then project inte screen space and render the resulting polygons.\n\nTo easily incorporate dhe shadow projection process into the rendering pipeline,\nEquation 5.7.1 can be rewritten in macrix form as\n\nr= 5%\n\nwhere:\nc= (oxy ot, 1) is the projected shadow point in world space,\np= (pe. py pe. 1) is che point on the object in world space.\nSis the shadow projection matrix, written as\n\n1 #0 6\noe o 0 0 0\nG6 #2 1 6\noO 0 OO 1\n\nNow to render the shadow of an object, we simply insert che shadow projection\nmatrix into the vertex transformation:\n\nB= OS\n\nThis expression makes use of the shadow projection marrix to transform the\npoints of an object into the projected shadow points on the ground plane. The\nshadow projection matrix $ depends only on the constant: &f and £2, which are\ndetermined from the relative position of the object and the lighr.\n\nThis technique can be used to rerender an object projected flar onto the ground.\nIfthe shadow matrix $ is simply inserted into the pipeline and the object rerendered,\nthe result is a flattened version of the object—complete with textures, shading, and so\non, To render the object as a shadow, we con render cach verrex as a flar-shaded\ntranslucent gray, ignonng the texture information in the model. In practice, using a\nmodel with fewer polygons than the original object reduces the cost of rendering a\nshadow.\n\n566 Section 5 Pixel Effects\n\nFIGURE 5.7.2. Projecting the teapot geometry onvo the ground plane renders the shadow of the teapot\nobject. The artifacts caused by overlapping transtucenc polygons are dliminated with the hardware Z-\nbufficr, as shown on che mehr.\n\nOne problem with this method is that the polygons projected onto the ground\nplane overlap, and when the overlapping polygons are drawn with translucency, the\noverlapping areas show up darker than the non-overlapped areas. ‘This artifact can be\ndiminated using the hardware #-buffer: After the first shadow polygon has been\ndrawn, the overlapping portion of subsequent polygons is removed by the Z-buffer. If\n#-buffer imprecision causes arcifacts, then as the shadow polygons are rendered, each\ncan be biased further away im 2, so chat the Zcompare eliminates the overlapping\nareas.\n\nFigure 5.7.2 shows a teapot rendered with a projected shadow. both with and\nwithour che use of the 2-buffer ro remove artifacts.\n\nExtensions\n\nAs presented, this article makes it easy to project shadow geometry onto a horizontal\nground plane. The method can easily be extended to other axis-aligned vertical\nplanes. With a bit more work, it can also be extended to arbitrary planes, An arbitrary\nplane can be represenced as a roration and translation of the horizontal ground plane.\nShadows are projected onto the arbitrary plane by roraring and traniating it back to\nhorizontal, projecting the shadow, and then transforming back the plane position.\nThe light position must also be transformed. By using the projection technique mul-\nHiple times, shadows can be simultaneously cast onto multiple planes, such as the cor-\nner between a wall and the floor.\n\n0.\n\nReal-Time Shadows on\nComplex Objects\n\nGabor Nagy\nThis article presents an effictene algorithm capable of creating realistic shadows in\n\nreal-time applications. The algorithm can take advantage of today’s fast texture-map-\nping and 3D transformation hardware.\n\nIntroduction\n\nShadows are among the most important depth cues in human vision, In computer\neraphics, they can give an image the final touch of realism. Without shadows—even\nwith realistic lighting and texturing effects—computer-generated images look artifi-\ncial; the objects appear ro float in space, even when they are lying on a surface. This\ninability for humans to sense the relative position and depth im computer graphics is\nespecially apparent when the camera is not moving (no parallax information).\n\nUnuil recently, only compurationally expensive algorithms such as ray tracing and\nradiosity could produce accurate shadows, in which both the objects Cascing the shacl-\nows and the ones receiving them are of arbitrary complexity.\n\nThe algorithm presented here is optimized for real-time applications, It provides\na very good balance berween realism and rendering performance while being casily\nextendible to all situations. With the always performance-hungry game programmer\nin mind, this article highlights points at which significant optimization for perfor-\nmance is possible using hardware features.\n\nSome of che basic ideas in this article have been around for a while, bue most\npapers describing them dont deal with che importance implementation details we\ncover here.\n\nThe Light Source, Blocker Object, and Receiver\nObject\n\nConsider the simple example shown in Figure 5.8.1. The torus (footer object or\nblecwer) blocks some of the light coming from che light source, casting a shadow an\n\nS67\n\nSection S Pinel Effects\n\nFIGURE 5.8.1. Shadow, receiver, blacker, and lighe source.\n\nthe wall. The wall receives the shadow, or “lack of light”; dherefare it is called the\nreceiver object, OF recerper.\n\nIf the light source is a poine light (infinitely small), the blocker object blocks the\nlight of char light source in a well-defined volume, usually referred to as a shaatow val-\nwane (see Figure 5.8.2), A shadow is created on a receiver object where its surface inter-\nsects with the shadow volume. As Figure 5.8.2 shows, the shadow volume has a\ntruncated, cone-like shape, starting at the blocker object and continuing to infiniry:\nWhereas the shadow volume really starts at the contours of the blocker abjecr, its\ncone-like shape originates from the light source.\n\nLet's examine how the cross section of the shadow volume changes as We Fer fur-\nther from the light source. We call the point on che blocker’s surface that is nearese to\nthe light source , and the one farthsese from it Pa\n\nWe can divide the shadow volume into three regions:\n\n1. Between the light source and P,\n2. Between P,and P-\n3. From poo infinity\n\nIt's easy to see that in Region 3, che cross-section of the shadow volume has a con-\nstant shape, but it increases in size as we get further from the light source.\n\n5.8 Real-Time Shadews on Complex Objects 569\n\nShadow volume\n\ni\n\nFIGURE §.8.2. The shadow volume.\n\nBecause of this phenomenon, unless one or more receiver objects are in Region 2,\nthe shadow velume can be accurately modeled by projecting a pwo-dimensional mask\nfrom the position of the poine light source, Consequently, using che same projection,\nwe can map this 2D mask on the receiver objects to define che shadowed areas! This\n2D mask is called the shadow map, and it can be simply derived by drawing the\nblocker object's silhouere as sen from the light source,\n\nNotice that we cannot see the shadow cast by the torus in Figure 5.8.3a because\nthe torus exactly obscures it! This isa good indication chat indeed, we can simply use\na properly projected 2D image or mask (see Figure 5.8.3b) to define the shadow vol-\nume. This method is usually referred to as projective shadow mapping.\n\nThe Objectives of This Article\n\nTo draw shadows using the method introduced, we need no do the following:\n\n1. Create a shadow map for each light/blocker object pair.\n\n2. Calculate the shadow map (texture) coordinates to use on the receiver object's\nVertices.\n\n3. Render the receiver objeces with the shadow map applied as a 2D texture.\n\nSection S Pixel Effects\n\nFIGURE 5.8.3. The blocker object as sen from. a, the light source, and &, ie silhowetre.\n\nCreating the Shadow Map\n\nThe first thing to do in order to render the shadow Map is SC Up a perspective projec-\nHon originating ar the light source. This projection projeas the blocker object onto a\nvirtual screen plane between the light source and the blocker object, yielding che\nshadow map shown in Figure §.6.4.\n\nShadowvolume\n\n4\n\n.\n\nshadow map\n\nFIGURE 5.6.4. The shadow map projection (also Color Plate 6).\n\n5.8 Real-Time Shadows on Complox Objects STi\n\nThe Light Coordinate System\n\nFirst, we define a new coordinare system with its origin ar the light source and its 2-\naxis pointing at the blocker object. The Z-axis of this coordinate system determines\nthe center line of the perspective projection, while its X}-plane defines the orientation\nof the screen plane on which we project the shadow map. IF we transform the blocker\nobject into this Mehr coordinate system, illustrated in Figure 5.8.5., we can easily project\nit onco this plane.\n\nTo define an arbitrary coordinate system, we need to know the position of its ori-\ngin and its orientation. We already know the position of the origin: Irs the position of\neur light source. We can describe the orientanon of the light coordinare system by the\ndirection of its three axes: Noe. Fugue and Zc, all 31D unit vectors in world! coordi-\nmates.\n\nFinding Zaye:\n\nScarting with the 2,4, axis, we can easily find X),,,and Vp... @.., 15.2 direction vector\nthat starts from the light source and points at the blocker abject. Ler's assume thar the\nblocker object is polygonal, and we have an array of all che polygon vertices that are\nused in rendering this object. Now we have a set of “target” poines in 3D space (the\nvertices of the blocker) and another point: che position of the light source. A fast and\n\nFIGURE 5.8.5. The light coordinate-system (also Color Plate 7).\n\nSTr2\n\nSection S Pixel Effects\n\nefficient way to obtain a “good” direction vector is to average the vectors that start at\nthe light source and point to each vertex. (We discuss a better approach later.)\nWre call the vector we have computed the magn direcient vector or MDV:\n\n4 Sv — Pie)\n\nMpDY=-—\n\nr\n\nwhere WV, ts the number of vertices considered in the blocker and #9... is the position\nof the light source.\n\nNormalizing MOV yields 2p.\n. MDV\n“p. =>~ =\n* |MBv\n\nOptimization Tip #1\n\nSince we will normalize A{DV, we don't have to divide the sum of light-to-wertex vec-\ntors by JV), saving one divide operation. We can also calculare P,.,.“.N, in advance and\navoid the — P.,, in the vertex loop, because:\n\nity at,\na = Pipe) 2\n\nHere is the C code to compute ick\n\ntypadet struct\nEsdType X,¥,2:\nshort Flags;\n\n} EadVertex;\n\nWold SnadowWatrix(Matrizx LelockerLocalToworloWatrix)\n\ni\nunsigned Jong L¥a, Li, LH, Le;\nfloat Mx, My, Mz, LPlightX, LPlightY, LPlightz,\nfloat LWOVX, LMOVY, LOVE, Sf Mean Direction Vector\nfloat Lelightex, Light’, L@lightz, fy Zlight weetor\n\nii Initialize Mean Direction Veotor to (0.0, 0.0, 0.0)\nii\nLOWE = LMOVY = LMDWZ = 0.0;\n\nLvartex = Lilesh-sVertices;\n\ni] AVEPage Vertex-to-Light vectors\nI",
      "page_number": 550,
      "chapter_number": 57,
      "summary": "This chapter covers segment 57 (pages 550-561). Key topics include shadows, object, and objectives. At times an artist mirrors\npart of a texture on a symmetrical object.",
      "keywords": [
        "shadow",
        "light source",
        "object",
        "light",
        "shadow map",
        "Blocker Object",
        "shadow projection",
        "shadow volume",
        "shadow projection matrix",
        "projected shadow",
        "Sei Texture Space",
        "source",
        "Mapping Sei Texture",
        "projected shadow polygon",
        "shadow polygon"
      ],
      "concepts": [
        "shadows",
        "object",
        "objectives",
        "lighting",
        "projecting",
        "projection",
        "polygons",
        "polygonal",
        "texture",
        "textured"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.68,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 48,
          "title": "Segment 48 (pages 469-476)",
          "relevance_score": 0.68,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 47,
          "title": "Segment 47 (pages 458-468)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 42,
          "title": "Segment 42 (pages 401-412)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "Segment 48 (pages 456-465)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 58,
      "title": "Segment 58 (pages 562-569)",
      "start_page": 562,
      "end_page": 569,
      "detection_method": "topic_boundary",
      "content": "5.8 Real-Time Shadows on Complex Objects 873\n\nLin = LMesh-=huadt vertices;\n\nLUD = LPLightx * Lyn;\n\nLWOvY = LPLlightY * Lin;\n\nLUDVZ = LPLight2 * Lin;\n\nfor(LvG = OL WG = LWn} LVO++, L¥ertax++}\n\nMx=LVartex->X3 Wy=L¥ortes-2¥3 Wz=LVertex->Z;\nESdM_MateixTransformax4 (LBlockarLocalToworldMatrix, LX, LY, LZ};\n\nLWOVX -= LX;\nLMOWY -= LY:\nLMOWZ -= L?:\n\n}\n\n/i Hormalize Mean Direction Vactor (MoV)\n\nff\n\nLVF = sort (LMOV%* LVS 4+ Ley\" Levy +LMDV2* LED?)\n\nLVF = 7.0 / LVF: {/ We can save 2 divisions by doing this in\nff @tvance...\n\nLflight’ = LHW * LVF;\nL2lightY = LMOWY = LVF;\nLflight2 = LMEW2 * LVF;\n\n}\n\nEsdM_WatrixTransfarm3x4 isa macto function thar transforms a 31D vector given by\nfx, dy, and Mz with a3 * 4 matrix (actually the top-left part of a i x 4 matrix).\n\nFor the rest of the source code, please refer to the example program on this book's\ncompanion CD-ROM.\n\nFinding Xjeeq amd ¥ijots\n\nThe projection to map the shadow-map texture on the receiver object is the same as\nthe one used to draw the shadow map; therefore, the orientation of the shadow map\n{rotation around the Z),4, axis) does not matter. In other words, rotating the Might\nplane around #,,,, does not make any difference. This means that for the Ass, axis, we\ncan use any unit vector chat is perpendicular to 7,4, (refer back co Figure 5.8.5). We\ncan get thar vector as the cross-product OF Zinte and any other vector that i noe paral-\nlel wich 2;..- Let’s call this “helper” vector V\n\nWe know that at least two of the X, Kf or 2-axes of the world’ coordinare system\nmicet these criteria, 3¢ for simplicity, we use a unit vector V[x,y,<), with one coordinate\nbeing 1, the ochers 0,\n\nA vectors largest component (X, Foor 2) determines its dominant direction:\ntherefore, to get a vector that points far enough away from Zijgie We set CO 1 the com-\nponent of V'that has the smallest absolute valuc in 2)... This eliminates floating-point\nprecision worries when performing 2 vector cross-product operation on 2,4, and V-\n\nsections Pixel Effects\n\nFor example:\n\nIf 2,¢=(0-381, 0.889, 0.254), Vwill be: (0.0, 0.0, 1-0) = 7, iy\n\nIf #5,@(-0,889, 0.254, 0.381), Vwill be: (0.0, 1.0, 0.0) =\nand soon.\n\nThe cross-product of 4.4, and V yields a third vector thar is perpendicular to\nboth of them. After normalization, this vector yields X;,.,,, the X-axis of the light coor-\ndinate system:\n\nae Ee xV¥\n\nWith AZ, and 2)... given, the ¥4,4, axis is just another cross producr away:\n\nNote that this step gives usa unit vector, so we dont have co normalize ¥;,,,,\nsince:\n\n[age| = 1 and |Z,4.| = Land Rep tZig = Nag, X Zaye] =I\n\nWith Aggie Vigge and 4). and P,., known, we can create the matrix that trans-\nforms a point from world coordinates to fight coordinates hy simply filling in these\nvalues\n\nYotXya Yor Fiy FokZiy 0.0\nZokXn4, ZotVig, ZofZ,,, 0.0\n-Xof Py, —YofP.,, —ZofF,,, 1.0\n\nM pantrretighr =\n\nThis is why we used Ap. Fi.-and 2;,,00 describe the orientation of the light\ncoordinate system.\n\nThe next step is to pre-mulciply this marrix with the blocker object's /onsl-te-\nwertd matrix. This step gives us the Jocal-to-Nght matrix for the blocker.\n\n!M tact rLacalT Ligic = Mi ncoberiacalTi Weed M ts nidTetight\n\nAs the name implies, the matrix transforms 2 point defined in the focal coordinate\nsystem of the blocker into the light coordinase system. Such wansformed X and ¥\ncoordinates define the paneifel or artbogomal projection of the blocker object onto che\nshadow-map plane (which is parallel with the XY plane of the light coordinate sys-\n\n5.8 Real-Time Shadows on Complex Objects Ts\n\nDefining the Perspective Projection\n\nTo make this 2 perspective projection, we need a field of view, or the Xand ¥ “projec-\ntion ratios.” We can find the projection ratios (Ry and Ry) for cach vertex of the\nblocker object by transforming che vertex with Mitctertocetitigie and dividing the resul-\ntant Yand Yooordinates by the 2 coordinare:\n\npo | Vac,\n: Vere\n\nAdaptive Projection\n\nWe could always use the same rario for che projection, but that would lead to the\nblocker object's silhowette changing size in the shaclow map if we move the light\nsource closer or farther away from it. The same problem arises if we change the size of\nthe blocker or if the light source looked ar ir from a different angle. These changes\ncould result in a tiny image of the blocker in the middle of the shadow map or an\noversized image thar doesn't fit in the shadow map (see Figure 5.8.6). In the first case\n(Figure 5.8.Ga), we get a low-resolution shadow map with bad artifacts on the receiver\nobjects. This is a waste of shadow-map merry,\n\nThe latter (Figure $.8.6b) causes incorrect shadow shapes and possibly “shadow\nleaking” (see the section “Texture Coordinates and Shadow-Map Coordinates\"). In\nthis case, the shadow-map size is not large enough,\n\nInstead of one fixed valuc, we use the largest Ry (Ay...) a8 the horizontal ratio for\nthe projection, whereas the largest Ay (Ay,,,.) gives the vertical ratio. This makes che\nperspective projection adaprve for boch the X and ¥ direction, meaning thar che\nblockers silhouette always properly fills the shadow map, making the best usc of all\nthe picels in it.\n\nFIGURE 5.8.6. Non-adapaive (@ and &) and adapuve blocker orojecdion [rh\n\nSection 5 Pixel Effects\n\n‘This concept is very important because we want to use the minimum necessary\ntexture size, for the following reasons:\n\n* ‘Texture memory is always a scarce resource, and the maximum texcure size might\nbe limited by other factors.\n\n* On some hardware, alter drawing the shadow map image, we have to transfer it\nfrom the frame buffer to a dedicated texture memory, and the speed of this crans-\nfer is limited by bus and memory bandwidth.\n\nNow we can fill our a standard perspective projection matrix for the blocker\nobject:\n\nO85 SMap Wideh 0 0 0\nA razz\n0 pee cea eeat 0 0\nF moe\n\nMH choPainaioe = rg Al\n0 0 ne\n\ncee = © ke\n\nfo\n\nwhere Sidap Wide and SiMapHeight are the horizontal and vertical resolutions of the\nshadow map in pixels, Z_,,and Z¢, are the distances of the near and far clipping planes\nof the viewing frustum from the lighe source.\n\nPre-multiplying this matrix with dM sicheri seat totigte Feels the 4% 4 macrix that per-\nforms a perspective projection from blocker local coordinares ro shadow-map coordi-\nnates:\n\nMaictertacelTathadnatteg = Mp chertocel tatigte *! Vl peecherPrecenien\n\nIn OpenGL, we can simply load an idenocy macrix inco the PROJECTION matrix\nand JM nihertscaTiShednitee INOO the MODELVIEW macrix and start drawing the shadow map\nusing the blocker's local coordinaces.\n\nOptimization Tip #2\n\nTo decrease the time it takes to create the shadow map, we can wee owe or three differ-\nent versions of the blocker object geometry for the various rendering stages:\n\n* To set up the shadow map projection, we blocker geometry with a minimum\nnumber of vertices. We wont need connectivity data (e.g., polygons) or normal\nveotors here. All thar matters is that no polygons of the blocker should be ourside\nthe projected shape of this volume, no matter the angle from which we look ar ir,\nbecause that would draw on the one-pixel edge of the shadow map, ruining texture\n\n5.6 Heal-Time Shadows on Complex Objects\n\naT?\n\nCamping and causing “shadow Icaking.” We might even use a “good” bounding\nvolume such as che blocker's bounding-box, which could eliminate the need to\ncompute MDW (just use a vector from the light source to the center of the bound-\n\ning bene).\n\n* ‘To draw the shadow ALP, Wc blocker geometry witha Minimum or oo Surpance de\n\ntar! but Necessary contour detail\n\n* And, of course, to draw the blocker object, we need the geometry with all che sur\nface detail and surface properties (c.g., normal vectors) to make the object look\n\nspiky.\n\nOptimization Tip #3\n\nif che rendering engine is programmable, we can use a very simple (and possibly fast)\n\nrenderer code to draw the shadow map:\n\n* No lighting needed; a simple “Hat-color” renderer will do.\n* Wo clipping needed (the blacker’s image always firs in the shadow map!).\n\n* Wo depth testing (4-buflering) needed.\n\nProjecting the Shadow Map on a Receiver Object\n\nNow we have a shadow map associated with a blocker object and a light source. This\nshadow map can be projected on any number of receiver ebjeces, and because it is ap-\nplied as a texture, the receiver objects can have any complex shape (curves, holes,\n\nridges, and so om).\n\nAs mentioned before, we use the same projection to project the shadow map on a\nreceiver as we used to create the shadow map, The only differences are the image offset\nand scaling factors, because we use the [0..1] coordinate range as opposed to the\n\n[0...Sreap Wish] or [0..SrapHeight] ranges.\nThis is the appropriate projection matrix:\n\nOA? SMap Width a\nMian\n0.49\ni ——* Slap Alcighe\nAM a cteePrajucrive = ae\nth 0.5\n0 th\n\nThe next thing co do is to pre-multiply chis matrix with Mops arorces!\n\n=\n\nSection S Pixel Effects\n\nMeacrmsintundinsT = Ml teutecigte ” 1M poriverPajecsion\n\nThe resulting manix cansforms a point from world coordinates to shadew-map\nrexture coordinates (the resuling Xand F give Sand 7 respectively).\n\nPre-multiplying Mos usmsutusiesr With the receiver's local-to-warld matrix yiclds\nthe marrix that we need co go from receiver local space directly to shadow-map texture\nspace.\n\nAM inka TeSbasheasMeg ST = DE peter igte . AM pcotnertrejerriaw\n\nTexture Coordinates and Shadow-Map Coordinates\n\nThe shadow map is an image with a finite number of pixels and integer coordinate val-\nues—for example, 256 % 256. However, texture coordinates are usually normalized\nfloating-point values, meaning char che range [0..1] refers co pixel coordinanes [0.255]\nhorizontally and [0.255] vertically. So what happens oucside the [0..1] range? We have\nto make sure char che rexel used on che receiver is che color used for “no shadow\" (black\nin Figure 5.8.7).\n\nOn most 31D hardware with texture mapping, you have at least reo options\n\n* ‘Texture repeat. Outside the [0..1] range, the texture is simply repeated—aa, for\nexample, in che [—1_.0] range of texture coordinates, the texture produces the same\nimage as the [0..1] range.\n\n* Texture clamping. The pixel on the edge of the texture image is repeated every-\nwhere ourside the [0_.1] range, or you can define a specific “border color” that is re-\npeated ourside the normal range.\n\nIt's easy to see thar we have to use texture clamping because we want a uniform ef\nfect on the receiver object outside the [0.1] texture coondinare range.\n\nTexture clamping effectively saves us from vesting the receiver objects for intersec-\ntion with the shadow volume. Because not all 3D hardware and APIs provide a separate\ntexture border color, we have to leave a one-pixel-thick border on the shadow map. If\nwe accidentally draw in this border, that pattern would be repeated on the receiver, pro-\nducing a leaking effect (shadow leaking\"). To make sure that nothing is drawn in chis\nborder, we have to slightly decrease the Xand F scaling factors in the projection macri-\nces (elemencs (0, 0) and (1,1)). This is the reason for using the value 0.98 (instead of\n1.0) in Mp ceePrejcsien aNd 0.49 (instead of 0,5) in Mp vetserPepersiee Nove thar these values\ndepend on the resolution of the shadow map. (See the example program on the CD for\nthe proper formulas to calculate them.)\n\nRendering the Receiver Objects\n\nThere are many differenc ways to draw the object receiving the shadew. The two most\neormrmon mechods are\n\n5.8 Real-Time Shadews on Complex Objects 57g\n\n* Single-pass rendering, If there is no other texture on the receiver object, we can\n\ndraw it in one pass, applying a black-on-white shadow map asa texture and using\nthe light source ro illuminate the object.\n\n* Multipass rendering with subtractive blending. [fa receiver already has a texture\n\non itand the hardware doesnt support multitexturing, we need multiple passes:\n\n1. Draw the receiver abject normally.\n\n2. Draw the shadow pass with subtractive pixel blending, using a white-on-black\nshadow map. This successively decreases the surface color intensity where\nthere is a shadow cast. Use “GREATER-OR-EQUAL” or “LESS-THAN-OR-\nEQUAL” Z comparison functions for drawing multiple passes. This way, if\nyou pass the same primitive, it overwrites or blends the current pass with the\nprevious one,\n\nPor a brief description of pixel blending, please refer to the “Convincing-Looking\n\n(class for Games” article elsewhere in this book.\n\nExtensions and Enhancements to the Basic\n\nAlgorithm\n\nSimplicity and high performance usually come at a price. This projective shadow-map-\nping algorithm is ne exception to thar rule: It has some limitations. However, most of\nthese limitations are very easy to overcome, and the algorithm can be extended to han-\ndle these cases.\n\nBack-face Shadow Elimination\n\nOne side effect of projective shadow mapping is that it normally maps a shadow on the\nside of the receiver facing away from the light source.\n\nhal\n\nWe can correct ehis problem by either:\n\n- Determining whether a triangle is facing away from the light source and, if it is,\n\nassigning out-ofrange shadew map coordinates for all its vertices. (The example\ncode on the CD-ROM that accompanies this book does this.)\n\n. Setting up the rendering of the receiver in such a way char the receiver is com-\n\npletely black on the side facing away from the light source (no ambient lighting).\nThis is the proper method because it is closer co what happens in reality, How-\never, if there is more chan one light source in the scene, the “back” fee of the\nblocker can be lit by another light. In this case, we have to use multipass render-\ning and add the ambiente light and light coming from other light sources in sepa-\nfate drawing Passes.\n\nReceiver Is Behind the Light Source\nYou have to explicitly check for this case and not map a shadow on the receiver object.\n\nBao SectionS Pizel Effects\n\nMultiple Light Sources\n\n‘This case requires multipass rendering with subtractive blending on the receiver object.\nUse a receiver rendering pass for cach shadow map. The multiple passes successively de-\ncrease the intensity (RGB values) in the shadowed areas on the surface of the receiver,\nmaking even the shadow intersections look correct.\n\nMultiple Blockers\n\nThis case also needs multiple passes. There is one difference, though: The cumularive\neffect of shadow inrersections is incorrect because the owo blockers block the light of\nthe sane light source. Use the stencil buffer te mer daw in the screen area where there\n\nis already a shadow drawn.\n\nReferences\n\n[Blinn €8] Blinn, James, “Me and My (Fake) Shadow,” jive: Bint Commer, pages 53-61,\nJanuary 1988.\n\n[Foley90] Foley, etal., Comparer Graphic: Principles and! Practice, second edition, pages\n745-753, Addison-Wesley, 1990.\n\n[Blythe96) Blythe, David, and MeReynolds, Tom, Programming swith Opentl- Ad-\nnamed Rendering, SIGGRAPH \"96 Course Notes, August 1996.\n\n[Heckbert96] Heckbert, Paul, and Herf, Michael, Rar Soft Shadows, SIGGRAPH \"96\nVisual Proceedings, page 145, August 1996.\n\n[Heckbert97] Heckbere, Paul, ancl Herf, Michael, Steevdeting Sof? Shadows with Graph\nier Hardware, CMU-CS-97- 104, Computer Science Deparument, Carnegie Mel-\nlon Universicy, January 1997.\n\n[Woo97] Woo, Mason, Neider, Jackic, and Davis, Tom, OpenGL Programming Guide,\nsecond edition, Addison-Wesley Developers Press, Silicon Graphics, 1997.",
      "page_number": 562,
      "chapter_number": 58,
      "summary": "This chapter covers segment 58 (pages 562-569). Key topics include shadows, mapping. Lflight’ = LHW * LVF;\nL2lightY = LMOWY = LVF;\nLflight2 = LMEW2 * LVF;\n\n}\n\nEsdM_WatrixTransfarm3x4 isa macto function thar transforms a 31D vector given by\nfx, dy, and Mz with a3 * 4 matrix (actually the top-left part of a i x 4 matrix).",
      "keywords": [
        "shadow map",
        "shadow",
        "blocker object",
        "map",
        "light source",
        "receiver object",
        "texture",
        "receiver",
        "shadow map projection",
        "object",
        "blocker",
        "light",
        "Lin",
        "Texture Coordinates",
        "projection"
      ],
      "concepts": [
        "shadows",
        "map",
        "mapping",
        "maps",
        "coordinate",
        "projection",
        "projected",
        "objects",
        "vector",
        "blocker"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 25,
          "title": "Segment 25 (pages 482-502)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "Segment 48 (pages 456-465)",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 45,
          "title": "Segment 45 (pages 431-439)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 47,
          "title": "Segment 47 (pages 458-468)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 59,
      "title": "Segment 59 (pages 570-580)",
      "start_page": 570,
      "end_page": 580,
      "detection_method": "topic_boundary",
      "content": "9.9\n\nImproving Environment-\nMapped Reflection Using\nGlossy Prefiltering and the\nFresnel Term\n\nAnis Ahmad\n\nIn order co render a realistic scene, we must be able oo handle surfaces that can reflect\nthe environment around them. Environment mapping [Blinn76] has been used to\nimplement approximate reflections in real time. Wicw-independent implementations\n(such as dual parabolic maps [Heidrich®9) for older hardware or cube maps on newer\nhardware} area recent enhancement to environment maps,\n\nEnvironment maps map the scene around a particular point (the Maps origin) to\none or more texture maps. This is accomplished by associating each rexel no a vector\non the unit sphere. The value of cach texel is the amount of light arriving at the map's\nongin through the texel’s associated unit vector. Consequently, the environment map\ncan be indexed hy generating and converting unit vectors to texture coordinares or, in\nthe case of cube maps, by using the vector itself as a texture coordinate. Thus, by con-\nverting reflected view vectors to texture coordinates, one can index the corset points\non the environment map to allow for simulated reflections.\n\nAlthough simple and elegant, these environment maps only simulate the appear-\nance of shiny surfaces—surfaces whose reflections behave like perfect mirrors, regard-\nless of the viewing angle. A common enhancement to this approach is to combine the\nchvironment map with a diffuse texture map. Although this enhancement does\nimprove the quality of the image, it does mor address che underlying problem of an\noverly simplified reflection model, This article discusses the assumptions that lead co\ntus simplified model and deseribes two techniques, glossy prefiltering and Fresnel\ntemm weighting, which improve and extend existing approaches to using environment\nmaps.\n\na2 oe Section 5 Pixel Effects\n\nThe First Incorrect Assumption\n\nThe primary faule with ceaditional environment maps is che assumption thar all sur-\nfaces thar reflect light do so perfecely—thar is, che assumption char every incoming\nphoton char hits a sweface has all its energy reflected in one particular direction. This\nsimplified view of reflection is appropriate only for mirrors or for other highly specu-\nlar surfaces. For other cypes of reflective surfaces (dull metals, organic surfaces, and\nthe like), a more general view of reflection is meeded.\n\nAS shown in Figure Ie surhees generally Sitter light if miLhy directions. The\namount of energy reflected in a particular direction depends on properties of the sur-\nface involved, particularly its roughness. The result ts a somewhat blurrier reflection\n(since the light contributing co che image you see did noc cravel along a single, simple\npath from the lighe source to your eye).\n\nIn order to help describe how lighe scamers on reflection, computer graphics\nresearchers have introduced the bidirectional reflecnnce ditribusion funcrion (BRDF)\nthat serves as an abstraction thar models surface reflection. A BRDF computes che\nprobabiliry thac a photon arriving ac the surface in a given (incoming) direction will\nbe reflected in a particular (ourgoing) direction. Whereas a BRDF can take an arbi-\ntrary number of parameters (including surface attributes, the wavelength of light, and\n\nFIGURE 5.9.1. a: Simplified view of the reflection of light. b:A more realistic view of the\nrellection of ght.\n\n5.9 Improving Environment-Mapped Reflection 583\nEee\n\nso on), the two meresary parameters are the light’s incoming direction and the desired\nourgoing direction. BRDFs are usually used to model reflectance in global illumina-\ntion solvers, Now, we see how they can be used to improve environmenc maps.\n\nWolfgang Heidrich and Hans-Peter Seidel deseribe a technique, called glossy pre-\nfiltering, that uses the Phong BRDF to apply appropriate blurring vo environment\nmaps. Fach texel of the filtered environment map is produced by finding its corre-\nsponding unit vector (used as the outgoing direction) and computing the color at that\ntexel with the following integral:\n\n!\npref(o) = s-¢-[ plo i) - arig(i) - deol)\nth\n\nwhere:\n\nereg is the original texture map.\n\nprefis the prefileered texture map.\n\nris the roughness parameter (reciprocal of the Phong exponent).\nsis the coefficient of specularicy.\n\ncis the Phong correction factor, (+41) / 1.\n\niand o are the incoming and outgoing directions (respectively).\np(x) is a function thar returns x if x >= 0 and rerurns 0 otherwise.\n£1 is che domain of the integral, che unit sphere.\n\naioli) is the measure of the solid angle in the direction of i.\n\nIn order to be practical, glossy peeliltering requires an input texture with a high\ndynamic range, that is, a texture whose values extend beyond the [0..1] range. This\nrange is needed te model the relatively high intensity of energy coming from light\nsources compared with the intensity of energy reflected off non-emitting surfaces, A\nnormal texture can be converted to one with a high dynamic range by multiplying all\ntexels corresponding to 2 light source by a large-scale factor. Note thar che preceding\nequation is used to apply the Phong BRDF to environment maps. Jan Kautz and\nMichael McCool [Kaur(0] describe a technique that allows for the use of any iso-\ntopic BRDF to prefilter environment maps.\n\nGlossy prefiltering has many advantages: The prefiltering need be done only\nonce, irs flexible, it’s fairly easy to implement, and it requires no change vo the ren-\ndering pipeline, since it merely filters traditional environment maps as a pre-process,\nThe disadvantages of glossy prefiltering are that ir's slow to compute (and can't be\nused for dynamic environment maps), it increases che memory requirements for tex-\ntures (since each surface type requires an entirely new set of maps), it requires input\ntextures with a high dynamic range, and it requires integrating over a sphere, which is\nmOn-Crivial,\n\nk3\n\nSection S Pinel Effects\n\n8 eee\n\nThe Second Incorrect Assumption\n\nAnother assumption made when using environment maps is that the reflecting sur-\nface is metallic, When non-metallic surfaces reflect, che reflectance depends on the\nangle between incoming direction and the surface normal. The Fresnel term\n[Foley90] is used to simulate this dependency by modulating the reflectance. It uses\nthe incoming lighr’s angle and the surlace’s index of refraction to compute the appro-\npriating weighting. The formula for the Fresnel term is:\n\np-tene? |, [Ast =)\nMeth | [te O +i)\n\nwhere\n&=cos8\nGis che angle between the incoming direction and the surface normal\nf= +e —1\n\n1). is the index of refraction of the surface divided by the index of refraction of che\nTransmitting medium, as a function of wavelength, Sinec the index of refraction\nfor air is 1, you can usually simply supply the index of refraction of the surface.\n\nBecause in games you typically deal with surfaces and atmospheres thar have a\nconstant index of refraction, the only variable in the above equation is & Thus, the\nFresnel term can be written as a function of &, which is a variable in che range [10.1].\nThus, as noted by Heidrich and Seidel, we can precompure the Fresnel term and store\nit as a one-dimensional texture. By rendering the Fresnel term tinea che alpha channel,\nwe can incorporate it into the rendering pipeline using cither of the following meth-\nods:\n\nC=C, 7 F+Cy or C=C, \"F+C,*(1-F)\nwhere:\n\nC; C,. Cyare the final (output), mirror, and diffuse color values, respectively.\nFis the Fresnel term.\n\nUsing the Fresnel term in this way provides a more realistic reflection while con-\nsuming very litte memory. The disadvantage is that using it could require an addi-\ntional pass.\n\nConclusion\n\nWith the high performance of texture-mapping hardware and the increasing size of\nTexture memory, ic makes sense 00 use texture-mapping techniques to improve the:\n\n6.9 Improving Environment-Mapped Reflection 585\n\nquality of rendered images. In this article, two such techniques were presented. Each\nis simple and requires very linle work to incorporate into existing rendering pipelines.\n\nAcknowledgments\n\nI would like to thank Michael Mefool, Michael Anttila, Sim Dietrich, and Mark\n\nDeLoura for reviewing this article.\n\nReferences\n—— ee\n[Blinn76] Blinn, J., and Newell, M., “Texture and Reflection in Computer:\n(Generated Images,” Communications of rhe ACM, 19:542-546, L976,\n[Heidrich99] Heidrich, W., and Seidel, H.-P, “Realistic, Hardware-Accelerared Shad-\ning and Lighting,” SIGGRAPH \"99 Praceedings, pages 171-178, August 1999.\n[Foley90] Foley, J.. van Dam, A., Feiner, 5., and Hughes, J., Computer Graphics: Prin-\ncipier and Practice, pp. 766-770, 1990,\n[Kaucz00] Kautz, J, and McCool, M.. “Approximation of Glossy Reflection with Pre-\nfiltered Environment Maps,\" Proceedings Graphice Interface\n\n5.10\n\nConvincing-Looking Glass for\nGames\n\nGabor Nagy\n\nThis article presents a few extensions to the algorichms most widely used to render\nglass objects in real tine.\n\nIntroduction\n\nRendering good-looking glass objects at interactive frame rates has long been a chal-\nlenge. Unul we have computer hardware char is fast enough for real-time ray tracing,\nwe MUSE compromise somewhere.\n\nTransparent Objects\n\nThere are three main visual properties of glass. A glass object i¢ usually:\n\n* Transparent. [¢ lets through some of the light hitting it, malang objects behind ix\npartly visible.\n\n® Refractive. It refracts light going through it and distorts che environment that\nshows through.\n\n® Reflective. It reflects some of the light hitting it, making the environmenr show\n\non its surtace.\n\nThis article mainly deals with the wansparent and reflective properties of glass.\n\nRasterizer, Frame Buffer, Z-Buffer, and Pixel\nBlanding\n\nTo draw a transparent object with today's 3D hardware, we usually use che fearure\ncalled pixel bienaing, or simply blending. Pixel blending is implemented in the last\nstage of a rendering pipeline, in the pexel renderer, after rasterization.\n\nThe rasterizer does the conversion of a primitive (triangle, line, and so on) into\npixels with Nand screen coordinares and a depth (4) value.\n\n5.10 Convincing-Looking Glass for Games 587\n\nA simple pixel rendered with 2-buffering enabled will:\n\n= Compute the 2 (depth) value of a pixel to be drawn.\n\n* Compare thar value with the Z value stored at the corresponding position in the\n#-bulfer.\n\n* If itis determined that the pixel to be drawn is closer co the viewer (iris in font\nof the object or objects already drawn at that location), it simply overwrites the\npixel color and Z value im their respective buffers; if not, it does not change the\nframe buffer or 2-buffer at all.\n\nIn OpenGL, a smaller 2 value means that a pixel is closer to the viewer. Before\ndrawing a scene, the 2-buffer is initialized (cleared) vo che maximum Z value at each\npeel. This value depends on dhe bit-clepth of dhe 2-buffer. Note thar this value might\nbe the exact opposice, depending on your 3D API and hardware.\n\nOpaque Objects vs. Transparent Objects\n\nBecause the standard Z-buffer technique simply overwrites a pixel if it belongs to a\nsurface that is closer to the viewer than the one already drawn, it is only capable of\ndrawing perfectly opaque surfaces. To draw a transparent surface, instead of overwrit-\ning the pixel color in the frame buffer with the incoming (source) color, we need to\nsomehow blend che ewo colors.\n\nIn OpenGL, we can use the blending function to perform this task. We can\ndefine the blending function by calling:\n\ngiblendFunc(stactor, dfactor};\n\nThe color to put in the frame buffer is usually determined by:\nROB pate = ROB sume” sfactor + RGB gemseion * dfizctor\n\nwhere RGB. represents the red, green, and blue eamponents to be pur in the frame\nbuffer, AGH. is the incoming pixel components, and RGB... is the value\nalready in the frame buffer at the corresponding pixel.\n\nDepending on the OpenGL version, sfactor and dfactor can have many different\npredefined constants. For example:\n\ng1BLlendFunc(GlL_Ow, GL_ZERO):\ndoes a simple overwrite, because:\nRGB ote = RGB iam £ + RGB gunn 0\n\nin the frame buffer, we can call:\n\nQiblandFunc(GlL_ONE, GL_ONE};\n\nSao iu Sections Pixel Effacts\n\nThis gives us che following blending formula:\nAre eres Ait, Le *I4 RGB ga inatien vty\nTo make pixel blending work in OpenGL, we have to enable it by calling:\n\nglEnabie(GL_ALEND);\n\nFor a full description of pixel blending. please refer to your OpenGL manual\n[Woot].\n\nSince we have to consider the # values, we refer to pixels as AGRZ.\n\nWhen rendering a 3D scene with transparent objects, we can have one of the fol-\nlowing cases. The pixel currently being rendered (RGRZ,,.) belongs to either an\nopaque object or a transparent one and:\n\n* Tis Z value indicates that it is closer co che viewer chan che corresponding pixel\n(RGB Z pevweriee! already in the frame buffer (it is in front of the object or objects\nalready drawn at that location).\n\n* tis further from the viewer than RGA...\n\n* Ttis at the same distance as AGAZ\n\nDrawing Opaque Objects\n\nLet's examine what happens when we draw an opaque object. If RGAZ,,.,,,, 13 Closer ta\nthe viewer than GRE secure WE CAN Simply overwrite che frame buffer + Sti it. Hew-\never, if KGAZ,,., is further than RGOBZ gine WE Might scill have to draw it if it is\n\n“behind” a transparent object! Usually, we can simply avoid this problem by drawing\nall the opaque objects firsr.\n\nDrawing Transparent Objects\n\nWe use the valuc A,r (ijehe or Opacity valuc) co define how opaque the currently\ndrawn pixel is. A,_..-0.0 means that che pixel i completely rransparenc; 1-0 means it's\ncompletely opaque. If the pixel being drawn (AGE...) is in rove of the one in the\nframe bulfer (RGBZ cei!) WE Reed this formula to determine the resulting color:\n\nBlend Formula A: RGB.) = ROB oe * Aur * ROB gina” (LOA ee)\nIf RG BZ, one is behind RGBRZ,,,..<.. We Deed this formula:\nBlend Formula B: RGB, = RGB ace (1 0—A gerinmrion + RGB ennrnion ~A daiamsinn\n\nThis formula uses the presence of alpha-bivplanes in the frame buffer to keep\ntrack of the opacity of each pixel; see [Woo!7] for more details, We alsa have co\nupdate the alpha values of the pixels drawn.\n\n5.10 Convinelng-Looking Glass for Games S65\n\nClearly, we have cwo different blending functions, or owo different courses of\naction to take, depending on whether AGBZ,__. is in front of RGAZ,___...or behind\nit. Since we can define only one blending function at a time, we have co find a work-\naround for this problens.\n\nDepth Complexity\n\nThe core of the problem is dpe compledty: che possibly multiple pixels (belonging to\ndifferent primitives) occupying the same screen position but with different depth values.\n\nAv depth complexity of 1 means char there are no primitives overlapping on che\nscreen. We would not even need 2-buflering in this case. When drawing a transparent\nprimitive, we only have to blend it with the background color, using Blend Formula A.\n\nA depth complexity of 2 means that the number of oveslapping primitives ar each\npixel is 2_ In this case, an opaque pixel cither obscures che background or a transpar-\nent pixel or itis behind only ame_opaque of transparent pixel.\n\nNote that the depth complexity of a 31 scene can change when the camera\nmoves.\n\nFortunately, OpenGL gives us some control over how the Z-buffering is per-\nformed. Specifically, we can disable # overwriting, so when a pixel is drawn, only che\nRGB values are changed in the frame buffer. Combined with some other features, this\nallows us to find solutions for most cases.\n\nA Simple Solution\n\nTo draw opaque and transparent objects in the same image, we can take a nor per-\nfectly correct but simple approach:\n\n* (lear che 2-buffer.\n\n* Draw all the opaque primitives (triangles, lines, and the like) with Z-resting and\n<-overwticing enabled,\n\n* Drew transparent primitives with back-face culling enabled (to minimize depth\ncomplexity between transparent pixels), <-werwnting disabled, and using Blend\nFormula A.\n\nThis method makes sure that opaque surfaces always obscure wansparent ones\nand that opaque surfaces behind transparent ones show through. Ir also guarantees\nthat two transparent surfaces always blend correctly if both surfaces have an alpha\nvalue of 0,5, because 0.5 = 1.0 — 0.5, so Blend Formula A and Blend Formula B are\nequivalent. Therefore, it does not matter if che currently drawn transparent pixel is\nbehind or in front of the one im the frame buffer. For alpha values other than 0.5 or\nmore than two transparent objects behind cach other, the results are not accurate but\nare still acceptable in many cases.\n\nSection S Pixel Effects\n\n\"Simple\" Solution #2\n\nThis method is designed to solve the problems mentioned in the previous section by\nmaking sure thar the currently drawn primitive is always in front of the one already in\nthe frame buffer:\n\n* Clear “buffer.\n\n* Draw all the opaque primitives (criangles, lines, and so on).\n\n* Sort all transparent primitives by depth and draw chem in farthest-to-nearest\nender,\n\nThis way we need only Blend Formula A.\n\nThe major caveat of this approach is char the depth sorting might cause a signift-\ncant performance hit, especially if there are many transparent objects in different hier-\narchy nodes. There are also cases in which a primitive is neither complerely in front\nnor completely behind another (as in Figure 5.10.1). so we need a per-pixel depth\nsort, which would be extremely computationally expensive.\n\nAs long as the depth sorting works correctly, there is no limit to the depth com-\nplexity this method can handle, Note thar with chis method, we don't have to draw\nthe opaque objects first, but doing so could simplify the process.\n\nA Slightly Different Approach\n\nOpenGL lets us choose a depo fiunerion for #-buffering. The depth function deter-\nmines which # values pass the #-comparison. In OpenGL, ir is ustially dessthan,\nwhich means that if a pixel’s £ value is less chan the value in the Z-buffer, the pixel is\n\nFIGURE 5.10.1. Indeterminate depth order of triangles.\n\n§.10 Convincing-Looking Glass for Games 5o4\n\ndrawn. This allows us to split the drawing of a primitive into nwo steps, using two dif\nferenc blending formulas. We need the presence of alpha values in the frame buffer for\nthis method.\n\nThe process is shown below:\n\n1. Clear 2-bufler\n2. Clear the alpha-buffer with value 0 (transparent).\n\n3. Set function to prearer-ohan (draw behind), use Blend Formula A, and draw the\nfirst transparenc primitive with 2 overwriting disabled. In addition, write the\nalpha value of the primitive into the frame buffer so chat subsequent pixels\nbehind it are blended correctly.\n\n4. Set 2 function to fee-than-or-equal (draw in frone), use Blend Formula A, and\ndraw this primitive again with Z overwriting enabled. Write the alpha value of the\nprimitive in the frame buffer so char subsequent pixels behind it are blended car-\nrectly.\n\n3. Repeat the last owo steps for cach transparent primitive.\n\n6. Ser 2 function to greater-than (draw behind), use Blend Formula B, and draw all\nopaque primitives with 2 overwriting disabled. The alpha value co write in the\nframe buffer is 1.0 (or che maximum integer valuc),\n\n7. Set Z function to fess-than-or-equal (draw in frome) and draw all opaque primi-\ntives with # overwriting enabled and blending disabled.\n\nUnforcunarely, if more than one pixel is drawn in any given position of the frame\nbutter (with differenc deprhs}, the opacity of this piel can no longer he represented\nby a single value. It depends on the depth or how many pinels there are in front of che\none being drawn. This is caused by the height-field-like narure of the #-buffer: It can\nstore only one depth value on a pixel, with subsequence pixels overwriting the old val-\nwes. In orher words, the 2-bufter has a fixed-depth complexicy of 1.\n\nTake the example in Figures 5.10.23 and 5.10.2b, Assuming that there are owo\nsurfaces drawn in the frame buffer:\n\n® Srofie, —Alpha: A, = 05\n* Sropftce, — Alpha: A, = 075\n\nIf, the pixel being drawn, is between Surface, and Surfaces Ageccien i 0.5 (only\nSurfitee, is in front of P). However, if? is behind both Surface, and Surfaces Ay cin\nis the cumuderite opacity ot Surface, and Surface, which is A,*A;-0.475.\n\nThis approach is slightly more flexible chan the one described in our simple solu-\ntion, without having to depth-sort the transparent primitives, but it has more limita-\nions and is more complicated than Solution #2. Furthermore, the frequent changing\nof the depth function at each primitive might cause a noticeable performance hic. A\nslight “tuning” of this method is recommended, depending on the application (espe-\ncially reeardine che modification of the aloha values in the frame buffer).",
      "page_number": 570,
      "chapter_number": 59,
      "summary": "This chapter covers segment 59 (pages 570-580). Key topics include pixel, surfaces, and reflection.",
      "keywords": [
        "environment maps",
        "Frame Buffer",
        "Pixel",
        "Blend Formula",
        "che",
        "Transparent Objects",
        "Environment",
        "maps",
        "Transparent",
        "surfaces",
        "frame",
        "Environment maps map",
        "Buffer",
        "objects",
        "formula"
      ],
      "concepts": [
        "pixel",
        "surfaces",
        "reflection",
        "reflect",
        "reflections",
        "reflectance",
        "value",
        "mapped",
        "maps",
        "map"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.7,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 42,
          "title": "Segment 42 (pages 401-412)",
          "relevance_score": 0.7,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 23,
          "title": "Segment 23 (pages 441-462)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 48,
          "title": "Segment 48 (pages 469-476)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 25,
          "title": "Segment 25 (pages 482-502)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 60,
      "title": "Segment 60 (pages 581-588)",
      "start_page": 581,
      "end_page": 588,
      "detection_method": "topic_boundary",
      "content": "Section 5 Pixel Effects\n\nE\n\nP\n\nFIGURE 5.10.2. a; Effect of a single transparent SUrtace OF a pizel behind it 6: Cumulative effect of\ntultiple transparent surfaces.\n\nNon-Planar Glass Objects\n\nIf we look at a glass bowle or cup, we notice thar it appears darker at the edges, where\nthe surface normal starts to point away from the viewer, This is because light coming\nthrough the object is refracted at higher angles, so less of it reaches the viewer. We can\nsimulate this effect by illuminating the object with a light source char is always ar the\nSale position als chee CAT fa ia “head-lighe’). Such a light SLICE produces less illurrii-\nnation the more the surface normal poinss away from the viewer. A simple diffuse\nbead-light is very easy to implement and is computationally imexpensive.\n\nReflections\n\nFor simulating reflections, we can use sphere- of cube-environment mapping.\nOpenGL supports the use of spherical environment maps (with fish-cye images as\nenvironment maps). After initializing a texture, we can enable sphere mapping with\nthe following calle\n\nglTexGeni (Gl §, GL_TEXTURE_GEM MODE, GL_SPHERE_MAP) ;\n\nglTexGeni (Gl 1, GL_TEXTURE_GEM_WODE, 6L_ SPHERE_MAP) ;\n\nglEnable (GL_ TEXTURE _GEN 8);\npl&nable (GL_TEXTURE GEN T);\n\nThere are rin excellent articles on this subject, ET +] please refer co chem for fur=\nther details (see References).\n\nColored Glass\n\nUntil now, we referred to the opacity of a surface as a single value. If a surface is\nbehind a transparent one, the surface in front evenly decreased the R. G, and B color\n\n5.10 Convincing-Looking Glass for Games Bad\n\ncomponent: of the one behind. We can use different opacity values for the R, G, and\nB componeats to describe the pigment in a piece of colored glass. This might require\nthe use of multiple drawing passes as described in the following sections,\n\nPutting It All Together\n\nSingle-pass Rendering\nWe can render the glass object in a single pass with:\n\n= An environment map applied as a 2D texture, the texture coordinates computed\nby a sphere-mapping algorithm\n\n* “MODULATE” texturing algorithm and a head-lighe\n\n* The proper pixel blending and 2 testing set up to draw it as a transparent object\n(as described in our earlier solutions)\n\nMultipass Rendering\n\nTo gain more control over che final appearance, we can perform two rendering passes:\n1. Pixel blending and 2 testing set up to draw it as a transparent object (as described\npreviously), We can also apply lighting on the object co simulate a diffuse surface\n\non the glass.\n\n2. Render the reflections on top, using additive blending (as in the single-pass case).\n\nWith two passes, we can define both the opacity and the reflectivicy of an object\nby changing the blending factors at each pass, We can also apply more complex for-\nroulas with multiple passes.\n\nImplementation\n\nFor implementation details with OpenGL, please refer to the sample program and the\ncomments in the source code on the included (D thar accompanies this book,\n\nTo see whar this technique looks like in action. take a look ar Color Plates 8-11.\nThese images were rendered on a Sony PlayStation 2.\n\nReferences\n\n[Greene86] Greene, Ned, “Environment Mapping and Ozher Applications of World\nProjections,” JEEE Computer Graphics and Applications, volume 6. number 11,\npp. 21-29 November 1986,\n\n[Woo97] Woo, Mason, Neider, Jackie, and Davis, Tom, OpenGL Programming Guide,\nsecond edition, Addison-Wesley Developers Press, Silicon Graphics, 1997,\n\n3.11\n\nRefraction Mapping for\nLiquids in Containers\n\nAlex Viachos and Jason L. Mitchell\n\nIn chis article, we Present a concise and practical method of refraction-mapping lige\nuids in opaque containers on real-time consumer 3D) accelerators. Refraction, reflec\nton, and Fresnel terms are computed for water simulations at interactive rates.\nMethods for enhancing realism, including caustic effeers and particulate matter are\nalso addressed.\n\nIntroduction\n\nThe goal of this article is to present a rendering solution only. We are nor constrained\nby the water simulation used. For the sample code provided, however, we have chosen\nto use surface simulations based on Erik Larsen's newave sample (available online at\nhop:!/realicy-s¢j.com/opengl/glur3/ehuc3.html).\n\nThe illumination equation computed by this rendering method is fairly typical in\nthat it incorporates refractive, reflective, and Fresnel cerms, The Fresnel term is exsen-\ntally used asa blend factor between the refractive and reflective terms [T#'087):\n\nRemit = Fresnel * Refraction + (1-Fresnel) * Reflection\n\nThis is also a common practice in RenderMan shaders [Apodaca99].\n\nAdditionally, we address techniques for iNuminating the interior of the container\nas well as computing caustic effects. For all these techniques, we assume thar che\nviewer is outside the container and that the container is opaque.\n\nRefraction Term\nce arbre pe tasted a Pa\n\nSnell's Law\n\nA ray from the eye co cach vertex in the warer simulation is computed. This is the eye\nray in Fipure 5.11.1. Snell’s Law is chen used to refract the eye ray for each of these\nvertices. This mesh of polygons represents the interface berween the air and warer.\n\n5.11 Rofraction Mapping for Liquids in Containers. 595\n\nEye Ray\n\nea Water Normal\nasa:\n\nFIGURE 5.17.1. Snell's Low in practice.\n\nSince the ratio of indices of refraction of water te air is 1.33, we use this value to com-\npute the refracted ray asa function of the water normal ar the given vertex, a: shown\nin Figure 3.11.1.\n\nReferring to Figure 5.11.1, the angle berween the water normal and the eye ray\n(@) is known as the angle of wecidence. The angle between the refracted ray and the\nnegated water normal (@)) is known as the angle of refraction. Snell's Law expresses the\nrelationship between these two angles and the ratio of the indices of refraction of the\nnwo media (air and water) as\n\nan in(@) = ae(Oo oor fh nse (GO) = snfO)\n\nFor the air-to-water interface, n, / n, is 1.3393, which gives us a simple formula for\ncomputing @, from ©:\n\nO, = resin [1333 sin(Q)]\n\nFrom here it is a simple matter to compute the refracted ray from the eye ray 30\nthat we can then decemmine the intersection with the container.\n\nintersecting with the Contalner\n\nOnce the refracted ray is computed, it i: necessary to determine the point of intersec-\ntion of the refracted ray with the container. This step ts the key to giving the visual\nimpression of a container of a particular shape. Paraboloid or hemisphere intersection\nvests, although simple and efficient, invariably give the impression of a dish-shaped\ncontainer, particularly if the viewer can move interactively in the scene. The water\ndemo used ar the Microsoft X-Box launch is an example of this [McQuade2000). To\ngive the impression of a more complex and realistic container, we have experimented\nwith a number of geometrically simple containers, and the results have been quite\nconvincing, In chis article, we stick with a simple parallelepiped container for brevity.\n\nFIGURE 5.11.2. The refraction map (also see Color Plate 12).\n\nReferring back to Figure 5.11.1, we are now interested in intersecting the\nrefracted ry with the walls of the container, In this case, our container is made up of\nfive rectangular faces. Ray-plane intersections are computed fer each face until che\nintersection with the container is found, Once this point is known, we convert this\nposition on the inside of che container to a texture coordinate in a single refraction\nmap, which shows all five faces of che container, as in Figure 5.11.2,\n\nIn Figure 5.11.1, the refracted ray intersects the bowom face of the pool. This\ngenerates a texture coondinate in the corresponding region of the refraction map\nshown in Figure 5.11.2.\n\nWumination af the Container Interior\n\nIt ts possible to pre-light the interior of the container to further integrate the con-\ntainer into the rest of the scene. This is an importance visual cwe to consider when\nusing your water simulation im a larger scene. The source code included on the CD\n\n5.11 Refraction Mapping for Liquids in Containers 507\n\nthat accompanies this book demonstrates the cechnique without additional geometry\nsurrounding the water pool, but the same technique, with the pre-lit refraction map\nshown in Figure $.11.2, has been incorporated inno the ne@idT/on graphics engine\nand is shown in Color Plates 13-16.\n\nReflection Term\n\nAny typical parameterization can be used for the reflective term of the illumination.\nWe chose to use 2 single-paraboloid environment map [Heidrich98] for our static\nscenes because this is supported on a wide array of hardware. A cube map could casily\nbe used for dynamic scenes. A dynamically updated planar reflection map can also be\n\nappropriate in same circumstances.\n\nFresnel Term\n\nNow thar the reflection and refraction terms have been computed, they must be com-\nbined using a Fresnel cerm. For details on the Fresnel equations, see the article\n“Improving Environment-Mapped Reflection Using Glossy Prefilrering and the Fres-\nnel Term” elsewhere in chis book. For the purposes of this article, the Fresnel equa-\ntions determine the ratio of reflected light to refracted light at a point on the water\nsurface as a function of the viewer's angle to the surface. In computer graphics, this\nterm is usually treated as simply a blend factor between the refractive and reflective\nterms, but it can also work well when multiplied only with the reflection map\n[Ts'o8? 1, [Apodaca99].\n\nAdditionally, che function itself can be modeled as a simple sinusoid or sinusoid-\nsquared falloff in the range of zero to one and tuned to caste. The sample program on\nthe accompanying CD computes the dot product berween the water normal and the\neye ray at each vertex. This gives the cosine between the vectors, which can be used\ndirectly as the Fresnel term or squared fora different look.\n\nThis equation can be cvaluaned directly at each vertex and linearly interpolated\nacross each polygon, as in the sample on the CD, or it can be computed per pixel as 2\nrexture lookup [Bastos?9)) .\n\nRendering with Hardware\n\nAll these computations have generared texture coordinates for the vertices in the mesh\nrepresenting the interface berween the air and warer. The texture maps used are static,\nand the mesh can be rendered in a single pass on consumer-level hardware that sup-\nparts at least pwo-texture multitextuning, the EXT_texture_énv_combine extensicn\nand the EXT_texgen_reflection extension, fora single paraboloid covironment map.\nThe Fresnel term serves as the blend factor between the two maps and is stored in the\n\nSoe SectionS Pixel Effects\n\nprimary color interpolator’s alpha channel. Recall chat our goal is to compute the fol-\nlowing equation:\n\nRemalt = Fresnel * Refraction + (1-Fresnel) * Reflection\n\nWith the reflection map in texture zero, the refraction map in texture 1, and the\nFresnel term in the primary colors alpha channel, we can do this blend using\nARG_multitexture and ExT_teaxture_env_combine:\n\nglActiveTexture(GL_ TEXTURED ARB) ;\n\nglTexEnvt (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COWBINE_EXT):\n\nglTexEnvé (GL_TEXTURE_ENV, GL_SOURCEO_AGB_EXT, GL_TEXTURE);\n\nglTéexEnv? (GL TEXTURE ENV, GL_OPERANDO RGB EXT, GL_SAC_ COLOR);\n\nglTexEnvt (Gl _TEXTURE_ENV, GL_SOURCE1 RGB_EXT,\nGL_PRINARY_GOLOR EXT);\n\nglTexEnvt (GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SAC_ALPHA);\n\nglTexEnvt (GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_MOOULATE};:\n\nglTexEnvt (GL TEXTURE ENV, GL AGS SCALE ExT, 1.0%);\n\nglTexEnv? (GL TEXTURE EMV, GL_SOUACEO ALPHA ExT,\nGL_PRIWARY_GOLOR_ENXT):\n\nglTexEnvt (Gl_TEXTURE_ENV, GL_OPERANDO_ALPHA_EXT, GL_SRC_ALPHA):\n\nglTexEnv? (Gl TEXTURE_EMV, GL_COMBINE ALPHA EXT, GL_REPLACE);\n\ngLTexEnvt (GL_TEXTURE_EMV, GL_ALPHA SCALE, 1.0f);\n\nglactiveTexturea(GL TEXTURE1 ARB);\n\nglTexEnvt (GL_TEXTURE_EMV, GL_TEXTURE_ENV_ MODE, GL_COMBINE EXT);\nglTexEnvt (GL_TEXTURE_EMV, GL_SOURGED_RGB_EXT, GL_TEXTURE):\nglTexEnvt (GL_TEXTURE_EMV, GL_OPERANDO_AGS EXT, GL_SAC COLOR);\nglTaxEnvt (GL_TEXTURE_EMV, GL_SOURCE1_AGS_EXT, GlL_PREVIOUS ExT);\nglTexEnvt (GL_TEXTURE_ENV, GL_OPERAND1_AGS_EXT, GL_SRC COLOR):\nglTextnvt (GL_TEXTURE_ENMY, GL_COWIBINE _FAG3_EXT, GL_ADO};\ngiTexEnvt (GL_TEXTURE_ENY, GL_RGB SCALE EXT, 1.01);\n\ngLTaxEnvt (GL_TEXTURE_ENY, GL_SQURCEG_ALPHA EXT, GL PREVIOUS ExT);\nglToxEnvt (GL_TEXTURE_ENY, GL_OPERANDO_ALFHA EXT, GL_SRC ALPHA);\ng1TaxEnvt (GL_TEXTURE_ENY, GL_COMBINE_ALPHA EXT, GL_REPLACE) -\nglToxEnvf (GL_TEXTURE_ENY, GL_ALPHA_SCALE, 1.0);\n\nSince this is just 2 blend berween two static textures, the stress put on the render-\n\ning system is minimal; this technique is so far just a method for computing texture\ncoordinates. In spire of this simplicity, the visual results are surpcisingly realistic.\n\nFuture Extensions to This Technique\n\nWe have outlined a simple equation for water that includes reflection, refraction, and\nFresnel germs. Ocher viswal phenomena, such 2s caustics and Scattering due to partic-\nulate matter, can be modeled as well,\n\nCaustics Inside the Container\n\nOne of the most importane extensions to this technique is the use of caustic effects on\nthe interior of che container. One way to incorporate caustics into the scene is to\n\n5.11 Refraction Mapping for Liquids in Containers 599\neach cn oo oa cele La\n\nmodel the refraction of light rays from a given light source and their intersection with\nthe container in much the same way that we are modeling this for the viewer's pasi-\ntion. Light transported along these rays could then be accumulated into a dynamic\n“caustic map,” which would be composited with the refraction map using multitex-\nture [Stam96]. Then again, for some applications, it might suffice to simply use a sta-\nTic caustic map thar scrolls along the interior of the pool over time. See the article\n“Advanced Texturing Using Texture Coordinate Generation” for a discussion of how\nto use the texture matrix to scroll texture coordinates frame to frame. This inexpen-\nsive technique was used in the Zora’s Domain level of The Legend of Zelda: The Oca-\nring of Time co give the impression of caustics refleceed off the surface of a lake onte\nthe surrounding cave walls.\n\nModeling Particulate Matter\n\nModeling the particulate matter present in the warer is an important visual cue thar\ncan casily be added co this system. In fact, the distance thar the refracted ray travels\nthrough the medium in the container is computed as.a by-product of the intersection\ntest, Using this term, is is possible to blend in a “water color\" at the vertices in much\nthe same way that terrain engines and flighe simulators blend in a fog color to simu-\nlate atmospheric effects. It should be noted char only the refractive term is affected Ley\nparticulate macter in the water.\n\nConclusion\n\nWe have presented a concise method of simulating refractive, reflective, and Fresnel\neffects of liquids in simple geometric containers in real time on consumer 3D hard-\nware. The technique was designed from the ousset co run efficiently on consumer\neraphics accelerapors. As such, the technique im its current state merely computes new\ntexture coordinates for the reflection and refraction maps and does no updates to the\ntextures themselves.\n\nWe have also presented some areas for extending the technique to include caustics\nand particulate matter as well as ideas for implementing these extensions.\n\nReferences\n\n[Apodaca99) Apedaca, A., and Grr, L, Adbanced Renalerifan: Creating CGI _for\nJfonan Picture, Morgan Kaufmann, 1999.\n\n[Bastos99) Bastos, R., Hott, K., Wynn, W., and Lasera, A., “Increased Phororealisin\nfor Interactive Architectural Walkthroughs,” ACM Sympostwnr on Interactive 3.D\nGraphres, pp. 183-190, 199.\n\n[Heidrich98] Heidrich, Wi, and Seidel, H.-P, “ fiew-independent Environment\nMaps,\" EurographicYACM SIGGRAPH Workshop on Graphics Hardware,\n1998.",
      "page_number": 581,
      "chapter_number": 60,
      "summary": "This chapter covers segment 60 (pages 581-588). Key topics include texture, textured, and mapping. We can\nsimulate this effect by illuminating the object with a light source char is always ar the\nSale position als chee CAT fa ia “head-lighe’).",
      "keywords": [
        "texture",
        "EXT",
        "ALPHA ExT",
        "container",
        "refraction map",
        "Refraction",
        "texture coordinates",
        "Fresnel term",
        "TEXTURE ENV",
        "Fresnel",
        "MAP",
        "COMBINE ALPHA EXT",
        "env",
        "water",
        "alpha"
      ],
      "concepts": [
        "texture",
        "textured",
        "mapping",
        "map",
        "refracted",
        "refraction",
        "colored",
        "light",
        "containers",
        "caustic"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 45,
          "title": "Segment 45 (pages 440-449)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "Segment 48 (pages 456-465)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Game_Engine_Architecture",
          "chapter": 23,
          "title": "Segment 23 (pages 441-462)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 43,
          "title": "Segment 43 (pages 424-431)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 45,
          "title": "Segment 45 (pages 431-439)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 61,
      "title": "Segment 61 (pages 589-596)",
      "start_page": 589,
      "end_page": 596,
      "detection_method": "topic_boundary",
      "content": "E\n\nSection 5 Pixel Effects\n\n[McQuade(}0] McQuade, L., Perona! Communication, 2004).\n\n(Is'o87] Tso, P, and Barsky, B., “Modeling and Rendering Waves: Wave ‘Tracing\nUsing Beta-Splines and Reflective and Refractive Texture Mapping,” ACS Trans-\nactions on Graphics (6), pp. 191-214, L987.\n\n[Saam96] Stam, J. “Random Caustic: Natural Textures and Wave Theory Revis-\nited,” SIGGRAPH , available online at www.syntim.ingia.fe/syntimy research!\nstam/causticsheml, 1996.\n\nAPPENDIX\n\n6.0\n\nThe Matrix Utility Library\n\nDante Treglia II and Mark A. DeLoura\n\nMatrix libraries are an integral part of game programming, and essencial in a wide\nvariety of applications such as advanced graphics, physics, collision detection, cte. It\nwas inevitable thar many of the articles would need to use some matrix operations\noutside of the OpenGL matrix functions. Therefore, with the input of many contrib-\nutors, a (C++ matrix library was written for all accompanying demo software to utilize.\nIt was intentionally designed to be an instructional nool, easy to read, and general pur-\npose, so very few optimizations have been added. We encourage you ro customize the\nlibrary for your game, and optimize it for your environment.\n\nSpecification\n\nThe libraries contain five main classes: vactor2, vactora’, vectors, matrixa3, and\nmatrixes. These represent vectors and marices of the corresponding size (e.g,\nmatrinégé is a 4x4 matrix). Vectors have public members called x, y, 2, and mw, and\nmatrices are composed of arrays of vectors. This library was designed ta provide the\nsame functionality and format as the OpenGL mamix functions; therefore, matrices\nare maintained in columm-row order. Most of the standard matrix and vector opera-\ntors have been overloaded; however, the cross product and dot product operations are\nprovided as utility functions for a more coherent notation.\n\nWOttors VRt5\nweotors veci(0.0, 1.0, 0.0);\nvectors vecz(1.0, 0.0, 0.0);\nmatrixa4 mtx = RotateRadWatrixes('x\", DegToAad(45.0));\nWeo = mtx * GrossFroduct (vac, VEC);\nLISTING 6.0.1. Answer vec = (0.0, 0.707107, 0.707 107]\n\nThere are a few things to keep in mind when using these libraries. First of all, the\ndefault constructors do not initialize members of each dass, This diminares redun-\n\n604\n\nB02 : Appendix 6.0 The Matrix Utility Library\n\ndant operations for instances of vectors or mamrices whose members are immediaccly\nset. The classes provide appropriate initialization constructors and set methods. Sec-\nond, a point class is not provided. You will need to ensure char a homogenous com-\nponent is set (usually to 1-0) for vectors that are treated as points. Finally, if you need\nto load a marrix onto the OpenGL matrix stack, it is safe to casta pointer-to-matrix44\nto a pointer-to-floar. Enjoy!\n\nvectord pointa;\n\nmatrindd tranMtx = TranslateMatrix44(-10.0, 0.0, 8.0};\n\nPoints.set(d.0, 0-0, 0.0, 1,0}:\npoints = tranktx * pointd:\n\nLISTING 6.0.2. Answer; points = [-10.0, 0.0, 5.0, 1.0]\n\nSource Code\n\nThe code for the entire matrix library is on the CD. Please refer to the library for\n\nmore informacion on hew to use it,\n\nAcknowledgments\n\nSpecial thanks to everyone who contribured to chis library, especially Stan Melax,\nMiguel Gomez, Pete Isensee, Gabor Nagy, Score Bilas, James Boer, and Eric Lengyel.\n\nAPPENDIX\n\n6.1\n\nThe Text Utility Library\n\nDante Treglia II\n\nThere comes a point in every game's development when output is necessary. For such\npurposes, it fs very convenient to have this output displayed on che sereen, expecially\nif your game uses full screen mode. Many games today have “console” modes, which\nin mext cases were used by the programmer during the development of the game. You\nmay find it beneficial to write such a library and incorporate it inte your game. This\ntext library is a basic implementation of an ourpur text library written for OpenGL, It\nis small, easy to use, and most importantly, easy to hack! The texture used to create\neach 8x8 character is only 16K Bytes, so this library is perfect for debugging and pro-\nfiling.\n\nSpecification\n\nThe texe utility library is composed of one class named TextBox. It provides two\nmethods for drawing text to the screen. The first is by providing a screen coordinate\nand a string. The library automatically pushes the necessary orthographic projection\nto draw che text in screen space. It also pops the matrix, which preserves the previous\nmatrix state. The second method i: a customized version of the first. It requires that\nyou initialize an area of che screen to be the “text box.” Then, all the text printed\nthis box (there can be multiple boxes) will wrap and scroll within the box, much like\na standard shell, A convenient printf () function, similar to the standard C function,\nis used to print text. Unlike che first method, the text is stored in memory until the\nnext screen is drawn, so the printf() funetion can be used at any point during the\ngame. Text can be printed in any color with a transparent or opaque background.\n\nSource Code\n\nThe entire source code for the rext utility library is contained on the CD, along with\na demo. Please see che code for more details on how to use it.\n\nAPPENDIX\n\n6.2\n\nAbout the CD-ROM\n\nMark A. DeLoura\n\nEnclosed with this book you will find a CD-ROM thar is filled with all of the code\nfrom this volume and more! We feel very strongly thar for this book co really be of use\nro you, you need to have the source code in a form that you can use.\n\nHere are a few of the things you'll find on the CD-ROM:\n\n* All the source code listed in each article.\n\nComplete demos of many of the technologies described in this book. The demos\nrun under Windows and Linux.\n\nThe pliSerup Monolithic version.\n\nThe GLUT (OpenGL Unilicy Toolkit) disibution.\n\nThe Matrix Unilicy Library.\n\nThe Text Unilicy Library.\n\nLinks to groovy game programming sites.\n\nComplete installation and usage instructions are included on the CD-ROM in the\nAbour This: D hom file. Please read this firsc.\n\nAlso, be sure to check out the Website, www.gameprogramminggems.com/ for\nmore information about the book and about game programming in general!\n\nIndex\n\nA® alporchm\naesthetic opimnanens, 24-271\nMaster Node List and Priotiry Queue Open Lim\n\nimplemenation, 283-296\nnaviration meshes and. 744-705\npachfinding. 2h)\npath plannins with, 254-2462\npriorizy queues for specd, 291-282, 283-286\nipeed optimmations for, 272-287\nweaknesses of, Db1—262\n\nALL See Arrificaal Intelligence {Al}\n\nAligniacne, 305-306\n\nAlpha-bera proning, 251-253\n\nAlpha blending, 195, $22-523\n\nAninarions\nkeviraming for, 465-170\nlight moaif, 528-534\nrexture coordinate animadon, 549-550\n\nArray Prey cla. 103\n\nArrays\nbit arrays, 101-103\nCampiled Vertes Asays (CWA), 356-358, 399-360\nSee ake Vocors\n\nAgtificial latdligenor (An\nengine desten, 221-2396\nfintic-state machine, 2737-248\nfuery logic, 319-329\nncuital nets and, 330.350\nscriprine behavior matshde godke, 234\nin scmpes, &\n\n@imert maar, 109-114\neopy-and-pate, 113-114\ncIAnoMmizing. Li=tbS 112-114\nembedding and, 110-111\n“Ignore Always\" opcion, 112-113\n{potasicn implometaton, 113\n\nAoclanen\naulo-anel heterozecration, 334\nHopiteld nets for, 345-350\nneural nets and, 342, 336\n\nAmenustion maps, 43-348\n\nAustanomous agents, 305\nAomidance, Fb\n\nBarefissoarce class, H-33\nBasic object memory manager, 68\nEefl, Tan, 133\nBirary trees, wavelets princple and, 182-184\nBitArray class, 101-102\nBeAr 2) clas, 102-103\nBitArray 2 class, 102-103\nBieProcp clase, 10\nBirwise eperations, 101-103\nBiistine fanctions, 529\nBoids, 305\n(CBoid class, 311=312, 314-317\nconsents on, JOR-309\nperceptian range of, Ma\nBenes, Sr Skeletal pqprescotations\nBat creation, 6\nBounding volumes, 380\nactress and, 440, 445146\niphere collisson deesction aleorithn, 4-395\nBrben, David, 133\nBranching instruction in script linguapes, 5\nB-spline:\ncamer come cures, I74-F76\nex. bermice splines, 470\nBugs. Sor Dicbagging\nBuildings, 49)—894\nalzonthms for, 492-453.\nKump mapping\nnormals, etre space fine. 556-557\nBeret dpace hump mapping, 957=959\ntexture space bump mapping, 559-561\nBRaoyaney, dioulating, 191-193\n\nCaldera. inverting, 09-410\nCalling conventions, 61-62\n(alls\n\nprofiler, 123\n\n605\n\n606\n\nAppendiz 6.0 The Matrix Utility Library\n\nEchos procedure cally (RPC), S6—5%\nanieras\nB-spline cueves for conerod, 374-376\ncontrol technaques for, A71={379\ndamping, 377-478\nexposed functionality of, 3\neye space and depah value, 363-304\nfirst-person cameras, SF 1-3F3\nlens flare siemolations, $15—518\nlevel of derail and, 433-434\norientation of 36h, 375\nquaternions and onmcrel of, 379\nsonpicd camera, 37-377\nthird-person comers, 378\nVethot cainonad, 366-470\nZooming, ay\nCanmnull-Rom spline. 266, 267, 376-377\nCaunic, simelating, 598-599\nCBoid class, 311-312, 514-317\nCitor das, 49-310\nCarel mOrsineepolason clas, 144\nCED iid in rerpalerion lass, 147\nChor Ganiainiepeition class, 147-145\nCKlock class, 310-511, 312-314\nChaus, adding via messaging, 223\nChisses, 4\ncoupling, avoiding. 15—16\n\ndesigsing in Objex-Oricated Programming (OOP),\n\nll-12\nfinire-arare machine class, 257-245\nhandle clax, 70\nFreaker clases, 15-16\nprooy dace, 102-105\nClineartnferpelsion, 1438\nCade\nin-game profiling, 120-130\nreusing, 6\nCohesion, 305-36\nCollision detectnn, 390-402\nbounding sphere, 390-393\nLine-plane intercon, 34-35\nootree cansmucrion for culling, 43o444\nproitst-in-tintanple text, Sh—5O7\ntriangle “flamening.” 3952595\ncreingle-to-seianple, SMb, 39-397\nCompiled Vervex Arrays (CWA), 356-398, 359-300\nCorn pélers\ncalling conventions af, &162\nlimitations of, 24, 31\n\ntemplares 25 virrual, 20-22\nConupoution, 12\nCompression meghoeds\n\nimage compression, 1H5=186\n\nwavelets, | B2-1 8G\nConsole gare prices\n\ndoce loading. 9091]\n\ndebugging, 113-119\n\ndeprh-of-play technique, 133-140\nConstane, in data-driven dozen, 3-4\n(Concaimers\n\nEarnie comcaimers, “AZ\n\neohtasner adapter, 42, 53-54, 21-22\n\nmaps, 10=53\n\nSTL 41-42\n(Containment, 12\n(oats\n\narrival costs, 295\n\nhesirimic com, LF G27\n\npath function cost, 259=760, Fi 265\nCoupling of clases, avoiding, 15-16\nCrisp eres, 319-320\nCroustalk, 3-537\nCalling\n\nField of Wiew Cullieg Code, 425-429\n\nFrustam culling, 422-423\n\nexclusion culling, 421-931\n\nGOIree consmucrion for, 439-445\nCylinder-Erustam iittersection test, 300-35)\n\nalgorithms, 382-384\n\nradii, calculation of effective, 3E2, 3B3\nGrlindess, peneralized, 258\n(Cinder tests, $H0-389\n\nDaniping, 377-375\nDaca\nbig arrays foe, 11-103\nduplicue dase syndrome, 6-7\ninliemance, 6-7\njunk dara and security, 107\nloadin: quickly, 85-91\npreprocessing, HH\n=avIng, fa\ntenes for ercating.\nwarelers as analysis onl, 195=186\nDatalases, handle-lasce| roars manager for, GSP 4\nDara-driwen design, 2-7\nela plicate cata, os\nediting tools in, 7\nhard coding arnl, 3-5\ntext files and, 3\nDebupping\nconsole game syecems, 115=1 15\n\nreal-time in-game profiling, 120-130\n\nIndex oT\nSS ee\n\nStats aysnem. for, 1152119\nDcharzification methods, 327-328\nDep valucs of vertex, 341264\nDreques, 41—42\nStarland Templar: Library (311), 48-50\nDesigning, Li-12\nDerail, levels of, 433-j58\nView-independent progressive mevhes, 454464\nDiagenalizing, 156\nDiamond-square algorithm, 505-507\nDpijketra’s algorithm, 294\n1 + Computing, 417110)\nDLLs, generic fiinction-binding. 96\nDoom, 490-49]\nDouble-ended quewes, 41-12, 48-50\nDuplicace data syndrome, 67\nDynamic Link Libraries (IXLLs), generic friction\nbinding, 56, Gt\n\nEdges\ndifficule, 458549\nedpe choice functions, 458\nedge collapic, 455, 441-462\nsclecgiam Improwssnecnte, lit\nEditing noobs\nin data-driven dese, F\nmame bevel, 7\nState sytem for data-editing, 115-119\nEigenvaluss and eigenvectors, 15\nElite, 153, 499495\nEmbedding, 12\nSe Mao and imformason embedding, 110-111\nEnceyptian\nonline games and, 14-108\nrevere eiginecring and, 107\nEnemy Nations, 307\nEngines, Al\nevent-driven wi, polling objeces, 221233\nideal characteristics of, E21\nricsage abject, 222233\nstare machines, 235-3235\nEnginet, physics, 30-102\nEngines. scripting, 36-67\nEqvitonment mapping, 193-194\nExquarions\nNewton-Ealer cqpuations, 140-160\nfor simulating rigid bady motion, 140-160\nErosion, tcrrain, HM S2\nEaler angles, 196, 307-308, 37 1=<372\nEuler method\naccinacy of 1ED-181\nEuler angles, 196, 307-308, 371372\nexplicit, 1FB=179\n\npambal lock and Euler anples, 196\nimplicit, 179-181\nnusnerical srabiliry and, 177-151\nTigd body motion, 150—1m0\nEverr-driven objec, 271-223\nExclusvesor (MCR) operons, 107, 108\nExremigns, OpenGL, 357-358\nEye space, 363-364\n\nFarade pattem, 15-16\nFactonal cemplatcs, 22-33\nFactory pattems, 18-19\nFaults, fractal terrain generation, 455-903\nPeedhack, in Hopfield iets, 346-347\nFeet, for game objects, (4\nFtbonaced rimbers, 2-27\nField-ol-view culling, 422424, 425429\nFintte-srare machines (FSh{s), 237-248\ncresting stares for, 247243\nusing FiMoler, 243\nFire, liste mocif, 528-534\nFIR filrers, 301-902\nFloating objects, warer simulation and, 191-193\nFlocking, 305-318\ndignmend, 305-306\navonbiner, 3\ncohesion, 35-306\nniesiery and, 306\nScparuon, 5 —G\nsteenng behaviors, 305—20G\nFag, Tange-hared, 548\nFractal retrain generation\nFault formation, 499502\nmidpoint displaccenent, 203-507\nFrigmencarios, memory, 92-100\nFrames\nas handles, 3%\nmicmory allocarion, frame-based, 92-100\nFresnel eeriri\nfor reflections, 381-945\nrefraction mzpping, $4\nPrati\ncylindes-{rasnom imtersoction tex, 340-389\nFrustara culling, 422—(23\nview frustumes, 361383\nP3Mb (finite-state machines), 257-248\nFunctionality, exporting, $6=67\nFunction abjeces, 52\nFunction everhead, 353-454\nFunctions\ncalling functions, 63-44\ndomains and ranges of. 163-166\nFunctions, exporring, $6—67",
      "page_number": 589,
      "chapter_number": 61,
      "summary": "This chapter covers segment 61 (pages 589-596). Key topics include classes, functions, and functionality. DeLoura\n\nMatrix libraries are an integral part of game programming, and essencial in a wide\nvariety of applications such as advanced graphics, physics, collision detection, cte.",
      "keywords": [
        "Matrix Utility Library",
        "Pixel Effects",
        "Utility Library",
        "Library",
        "Utility Library Dante",
        "Matrix",
        "Library Dante Treglia",
        "Text Utility Library",
        "matrix library",
        "Matrix Utility",
        "Text",
        "Text Unilicy Library",
        "Wave Theory Revis",
        "Source Code",
        "text library"
      ],
      "concepts": [
        "classes",
        "functions",
        "functionality",
        "function",
        "library",
        "libraries",
        "matrix",
        "matrixes",
        "mapping",
        "maps"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 9,
          "title": "Segment 9 (pages 160-181)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 8",
          "chapter": 53,
          "title": "Segment 53 (pages 511-519)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 2",
          "chapter": 56,
          "title": "Segment 56 (pages 544-551)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 33,
          "title": "Segment 33 (pages 314-325)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "Segment 63 (pages 609-616)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 62,
      "title": "Segment 62 (pages 597-603)",
      "start_page": 597,
      "end_page": 603,
      "detection_method": "topic_boundary",
      "content": "608\n\na\n\nFunnccors, 52\n\nFisezy loge, 319-329\ndelumificaion metheds, $27—328\nFurey eoavinal, 322-3268\nfurzy landscaping, 424-485\nFurey sets, 520-321\nlingruisric variables of, 325\noperations, 321-322\na, Caditional logic, 31-320\n\nGame-path planning, 244-262\nCoame urees, 249-753\nalpha-beta pruning, 251-253\nmovesondering meiads, 152-155\nmamas alporithin, ZHI-251\nGenPrafiletn Simary, 179-130\nGimbal flock, 16\n(Zhes, rendering, 586-593\ncolored plas, 392-395\nmultipass, 593\nreflections an, 392\nsingle-pass, 393\nGlobal objects\nry. singlerons, ay\nCordis\ncaloulsting neighboring eeanes, 259\nrectangular pod space parccions, 255\nserch space apriminions, 2735\nwitd in mapping, 403\nCoraups\nflocking behaviors, 305-318\nmoving, 27]\nGuided miile, shore arc quacemion and, 214-215\n\nHaar warelecs, 1 #41\nHackers, online gums pemoieds, 104-108\nHall-Life, 307\nHanelleMgr clave, rif\nHandles\nframes and memory. 15-96\nhandle das, 70\nAandiler cls, 71-72\nim ftexiiamager, £5865\nreamed Manager and, 69-70\nHard coding. avoiding, c=\nHarelware\nbump mapping, 555-54]\nrendering tefeacton with, S97-S98\nHash eables, 280.781\nHeaders, 104\nHebb, Donald, 345\nHebbian nets, 345-346\nHebb necs, 345-346\n\nHerding, 305-318\n\nHeemice iplines, keyframing and, 467—i70\nHeuristic cos algorithm, Py ere, |\nHicrurchical pathfinding, 775-276\nHierarchy design, 12\n\nHophield, John, 346\n\nHopfield ners, HiG=-350\n\nHorizon cfect, 253\n\nHunparn nos, 21]\n\nHoystereus thresholding, 435\n\nIdentity matrices, 26-27\n“Tgeore Always” option in\\asert, 112-113\nImages\n\nrenopaition and moural ners, 41-44\nwavelers for compresiian, 185— 12\n\nImmediare nome functmonms, 353-354\n\nInfinite universes, algoerirhurss for, 124-159\n\nInheritance, 6, 12\n\nIniial value problems, 177-178\n\nIecrahiliry, explicar a. implicant methods, 177-178\n\nInteraction detection, multi-resolution maps far,\n\n403-411\n\nInrerfaces\nscibene function-binding incerface, $37\nSTG stem wed during protacyping, 119\n\nInterpolations, 141-149\nCRadethuliereryoleron, 144\nCfurGan Girne ero ieian, 17\nCFaseOutShifilnerpolasion, 147-148\nChinar!aterpedatrom, 148\nRoaring-paine mach im, 141-142\nfragec-rate-dependent ease-cur, l4l-Lad\nfranve-cate-independent case-in and -our, 144-146\nfranve-rate-independenc linear innerpolarion, 144\ninceger mash in, 142-144\nlimitations of. 146\nlinear interpolation (lerp), 2065, 209-211\nspherical cubic interpolation (sized), 207-208\napheneal line interpolation (slerp), ho—207\nspline inrerpolarians, 28, 711-215\n\nThins, 2 boursdary conditions, 10\n\nberated deepening, 252-153\n\nTreranoes, rovers, 44151)\n\nKeytraming\n\nhermite spline, A676\n\nintespolaced 3D, 465-170\n\nlinezr msterpolarian, 465\n\napline interpolating vertices, 469-470\n\nrerriacs and normals, interpolating of, 467\nKinomatis, tamslation and rocarion, 14154\nKline, Ohristapher, 317-318\n\n609\na\n\nKren, Rehert, HP]\n\nLagrange series, 162=176, 172-175\neg, Taylos series, 174-175\nLandscaping, 44-10\nalgorithms for, 465-490\nFool: Line generation, 488-450\nFlcexy landscaping, 484-185\nSee abe Torain\nLava flows, simulating, 508-511\nLayering, 12\nLearning alporithims, 345-350\nLerss flare simulations, 519-318\nLerp, 206, 709-371\nLevels of detail (LOD, 432-458\n\nStandard Tomplace Library (STL), 46-49.\nSTL contaimers, 4142\n\nLoads, optimizing, BE-91\nLocations, parh search states, 757299\nLogic\n\nichipting, 46\nin scripes, $6\npa, daca in dary driven desipn, 3\n\nLogic fanctions\n\nAND, 358-24]\nOR, 353-341\nMOR. 358-Hi\n\nLogs of messages and state transitions, 232-233\nLook-ar urilities, 471\n\nalgorithm for selection, 435-437\nhysteresis thresholding, 435\nimplementsrien, 435-137\nmagnitication factors, 434, 437\ntlecman of, 455434\n\nthreshold selection, 437\nview-independent progrestive mebes, 4544-4\nLighting\n\nambaenr, 419-420\n\nattensstion maps, 343-548\n\nbump mapping for, $55-$61\n\nchange, 419420\n\nof conrainer interiors, 996-497\nconventional static lighting, 324-527\ndiffuse lighting faciors, 524, 555-556\nfog, tanger based, 548\n\night coordinate seems, 57 1—$74\nmocif-based scaric lighting, 528-554\nomni-clights, 526-527\n\nrealtime simularions, 455-942\nreflections, $$3-—554, $41-$85, 592\ntefraction chrouph water, 193-194\ntransparency, rendering, $86-593\nvertex color interpolation for, 537-542\nSer abe Shadows\n\nMGteros\nAssert macros, 109-1 14\nCpstylc forstue machine, 25-227\nMagnifscarion Eeetore, 454, 437\nManaper classes, 19-16\nAflaps\nbump maps for texmuring, 55561\nenvironmens maps, 193, 581\ngrid-based maps, 403\nLigh ieverdinane sytem foe, 571-974\nbphr maps, 343-548\neuulte-resolution mapy, 405-411\n,Sivironment mapped, $41-5845\nrefraction mapping, $4600\nshadow map, $67—5E0, 570\nHite variation problens, 403104\nsphenical reflection maps, 544-934\nSrandard Template Library, 50-53\nMaster mode lige, 282\nAiarrinca\nefficiency of templarized, 2-30\nidentity marrives, P4237\ninitialization of, 27\nfoval-to-waeld matte, J48-370\nmatriz-based cameras, 466-370\n\nLinear invespolition, 2G, 209-211\n\nLine-plase intorecrioa in collision derection, 394-395\nLinguistic variables, 323\n\nLiquids. refraction maps for, $4600\n\nmultiplication of, 229\n\nProjection matrix, 3451-362\n\nquatermions 24 feplacemend for, 195—] es\nSmale Wanaition mani, 238\n\ncaustic effeor inside container, 5O8—599\nomntaine and, 595-597\n\nFresnel werm, 594, $97\n\nparticulate marcer, medetine, $99\nSoell's Law, 34-995\n\nSee abe Wane\n\nLists\n\nOpen lets, AIF Rs\n\npalypon cwverlap, 442\n\niralsposition ak, £7-28\nMirrix-quaternion comversdons, 200-204\nMazes, 40195\n\nalporithms, 492493\nMBE (molecular beam epitaxy), 508\nMoCullock-Dins nes, 333-341\nMemory\n\nAS algorithm and, 2 Zr, 278-200\n\nCOUP ol, IS\n\n610\n\ni EE EEE\n\nMemory (tCoee,!\n\nflocking and, 346\n\nfrapenentarien, preverricen of, 92-100\n\nfrume-based allocaion of, 92-100\n\nheaps, 94-96\n\nIberatiee dubeueocieing menor, 347, 330\n\nleaks, prevencion. nt Es\n\nmanagement af, 80-87\n\nmoral meta ad, 342, 346\n\nOpenGL extensions and, 357-358\n\nrelraseng, 95—100)\n\nibomEp, avraiding, A=) 1\n\nvootom, 45, 45\nMeshes\n\nnavigation meshes, 288-304\n\nprogressive, 438, itt\n\nvertex collapse and split, 445-455\n\nview-dependent and sindependene, 456-458\nMessage objec, 222-223\nMesrage Reuter, 75-1\nMaange\n\ndelayed sending, 229-230, 236\n\nlogging actraty and state transitions, 232-235\n\nnuacieg, 227-229, 245-246\n\nscope definition, 231-232\n\nseneing, 229-150\n\nsnooping, sailing, or peeking, 227\n\nunique [Dy in, 230\nMetaprogramming, templates, 20-35\nMethaxis, begin Oand eva (4213\nMicrosoft Developer Network Library, 66\nMielpoxinr displicemenc, rerun penerarion, 503-50\"\nMolecular beam opitaxy (MIBE), S08\nMamentuimt, near and anpulag, 14\nMotion\n\nflockieg implemeneszias, Sy7—309\n\nsimuluing med body motion, 150-160\nMountains\n\ncolderas, inverting, 09-511\n\nfractal terrain peneration, M3-S0\"\nMovement, navigation meshes and 3D, 288-304\nMoave-ordcring methods, 232-255\nMulrieresolurion mapa, 405—41 1\n\nNanve-manpling faciliry of (++, 65\nNance and naming, 10-11\nal peamtium for realistic names, 499-498\nHaimgariain Ritalion convention, 9-11\nnamme-manging Goality of Co4, 65\nNavigenenGell E92\nNavigation mesh\ncomsnuction of, 25)\n\nNastgation Mek, 292-293\n\ncontrollaay object etry eiiei£, 2a 95\nNavimesh, TH\nNegus: PSIG T Ot Sania algeridun, 240-751\nNerworks, prococals for online games, 104-108\nNeural ners, 3M 35h\nalponcium for, 345-350\nbiological analogs fer, 34-531\nclassification and reonpmizion, 34 1—=<244\ngame applications for, 331-332\nHebbaan neural meas, 345-346\nHopGchd nosral nom, 346-350\nnenenbes, 232-358\nplascmciny of, 330\nsrabilary, 336\ntemporal topes, 335-356\nMeurodes, 332-338\nMewton-Euka equations, 14-160\nincegracing. 158-159\nNodes, pathfinding, 278-280\ndecoupling. 27H-179\nmaster neue Gar for inorage, 2B0-28 |\n\nObjet Oeecnecel Pregeeaieienin (OOP), B19\n\nclasses, destening, 11-12\n\ncoding stybes in, 9-11\n\ndesign techniques and, B-19\n\nfagade pattcn in, 13-16\n\nEectory purer in, 18=19\n\nHungarian moracion, 9-11\n\nmingleson partes. 13-15\n\nanglaona, io\n\nStale paren in, 16-15\nOhpren, cveniabriven os, polling, 221-222\nOelwien Culiieg Gods, 429-131\nDOechusons, 425\n\nculling, 421431\n\nbounding volumes of, 445-446\ncansoruction of, 449-443\ndaa contained in, 440\nloose octrees, 446-153\nneighbors, 442\npolygon overlap lies, 442\nfer ray colligon teers, 41-15\nrepular os, loeec ocorees, 4514535\nised petites objec, 446-448\nHine alculaoon, progeesne meothes and, 462\nOnanislighrs, 526-527\nOnline games: network prococel for, 104-108\nOpacity et. tramipaneecy, 587-398\nOpen Gelds, hierarchical pachdinding, 269-2770\n\nIndex\n\nOpenGL\nExtemions for, 357-358\n‘Optimizing verncx submiwion for, $53=3400)\nspnine effeces, 19-424\n\nOpen lists, 262-286\n\nOricnration, P7308\n\nOrthoganality, 347-338\n\nPacker, 104\nrelay arracks, 103-106\ntampering, 104\nParallel proceuing, in warer simulations, 110-191\nParticle deposition, fractal terrain generation, 50—§1]\nParinoning\nlows: octress used fee, 445-148\nnerd et ai, IS6—3497\nspace, 257-259\nPachfineding,\nwith navigation meshes, 294\nnavigation mesic far, 228-304\nPath planning, 754-244\nA\" for, 254-262\ncost finctions for padhs, 259-260\nFunction costs, 259-200\nneighboring srates, 2 “]\nPARitioning space for, 257-159\nParhs\nacsthetic optimizacions for, 204-271\nB-spline cures, ST4-476\nCatznaill-Rom spline, 266-267, 376-377\ndecoupling pachfinding data, 278279\nhierarchical pathing, 268-270, 275-276\nAIT ne responiiveriess, 270-27 |\nnavigation meshes, Seb\nmode dare, 273-250\npauses, 270, 276\nsmboch paths, bS—2i\nstraight paths, 264-355\nwisibiliry teviny., 2M\nSee alo Pachiinding: Pada planning\nPatrolling, 2335 :\nPatterns, designing, 12-19\nPauses, 270, 276\nPayloads, 1M=105\nPerception ranges, 303\nPhysics engines, 390102\nPirch, 37-38, 371-372\nPla fractal alporichen, 4-07\nPlasticity, neural nets and, 336\nPainters, 6\nIn preproccmang daca, He\nTSOWIEE management and,\nuied im saving dat. 89\n\n617\n\nex. unique IDs in messaging, 230\nSoares pest, 306-457\nPolling objec, 221-222\nPolygon floors, 273-274\nPolygon overlaps algorithm, 442\nPolynomeals, 162-163\n\nAPPTOiTeAss Eo Pr poRomerric Aanesicite,\n\n1e-176 :\n\ndiscontinuities and. 175-176\n\ndomains and ranges of, 163-166\n\neven and add. 166-L67\n\nLagrange series, 172-175\n\nTaylor series, 167-171\nPopping,\n\nreducing, 432-828\n\npr. morphing venice, S60\nPrefiltering, glossy, 581-585\nPriority Quewe Object, 283\nPriarire quctc., 34.\n\nAY sped opsimizerons, 291-282, 283-286\nProjil:Begin, 124-125, 126\nProfiteDeonpOsrrarTeSwfer, 128-129\nProfifeEsd 124-125, 127-124\nProfiles\n\ncalls, adding, 123\n\nimplementation, 123-124\n\nreal-time in-game profiling, 120-130\nProjecnion riatrice:, 361362\nProximary pes, reducing number of, 403-411\nProxy clases, 102-109\nPhendo Rendon lacs, 156\n\nQed, 444145\nspace parrimoning, 254\nQhevtermons, 195—199\ncaoloalus Firnetions of, 20S 006\nemer. concal and, 374\naeteniion of complex members, 17-198\ninterpalating techniques, 205=213\nfincas interpolation {lerp), 206, 209-211\nMAEMO converons, Ti) 30g\nai macrix noplacemencs, 195-16\nnumestcal stability and shortest arc, F14—217\nphysical sigmifcance af numbers in, |-197\nfitations represented by, 19\nshores are quatemion, 214—218\nsphencal cubic interpolation (squad), 207-208\nspherical linear interpolation (dep), 205-207,\n209-211\nspline intcrpolations, 208, 211-213\n(Quatemion-to-martix conversion, SO-201\nQaecics, 4.\nof sare machines, 733\n\n612\n\nRand fonction, 114i\nRandomness\nfractals, random line generatian, “M-})1\nRandom numbers\nalporithm for, 135-136\npredaccable, 134-140)\npredicrable, algorithm for generating, 135-135\nmind search, 154-135\nsrand, 134-135\nRay collision texts, octrees for, 443\nReceiver objects, shadow maps, 578979\nReflecians\nenvironment mapped, FAL=5R5\nFresnel tem and, 581-555, 397\non glass, 592\nTEppAryp, 5595-554\nRefraction\nmapping. 193\nSnell's Law, 34-595\nRamos procedure calle (RPC), 3-30\nReplay, packer apracks, 105-106\nRetifemager dass, 83-06\nResolucion, macto- and micro-infinite, 133-134\ninfinite uniwerses, 137\nResource manner:\nhavc object memory manager, 63\nhandle-basnd, G8-79\nhandles, 65-70\nIneo ry Tanager afud, A087\npointers, 69\nResources, locking and unlocking, 86\nResponsivencs, comimoller, 270-27 |\nRepnoldz, Craig, 205-306\nRigid bodies, special properties of, 1535-153\nRigid body motion\ndynamics of, 154\nkinematics, [50-154\nqaateri ier POAnion,. 214-215\nfocetian, 14-154\nsimulating, 130-lG0\nRall, P7308, 371-372\noreo re () poumne, 2142218\nRocomons\nguaternios foramions, 20\nquaternions for nepreseneing, 199\n\nRouters, mare machine mesape route, 227-229,\n\n335-136\nRumga-Kutta method, U77=178\n\nScaling S25\nSerepeing fanguapes,\nSorpes, ith\n\nAl engines and, 234\n\nbranching instructions in, 3\n\n34 Findse se machines, 5\n\nscripted cameras, 373-377\n\nScripting engines, 3-67\n\nPca 6\n\nSearch algorithms, 254-262\naniline gaming feanures, 4-108\nreverse cnginecring bor, 10?\n\nSending random peneraror, algorithm for. 139\n\nSeparation, 305-306.\n\nSequencer containers, 42\n\nShadows:\nadaptive projections, 575-577\nan comple: cbpece, 567-340\neroumd-plane shadows, 562=5i0\nlight coordinate srstemes fier maps, 571-574\nligsher pource, blockers, and reserves, 567—569,\n\noFr—3Fo\n\nmathematics of, Hi2—=565\nmubiple light sources, 550\npempective projections, 575\nrendering implementation, 563-366\nwadumes of, SOR—9\n\nShine-through, 552\n\nShoreline, at boundasy comdinions, 1M)\n\nSimonyi, Charles, 9\n\nSinglerans, 36-10\naunemaric singleton utility, 440\nsingleton pacenns, 13-15\n\nSime of game objects, 403—404\nmagmalicatien facnors, 434i\n\nSkelesal repreentaiions\nfast skinning method, 471-472\nGEeNNors Co shone matnecs in. 13-196\nsutching, 477420\n\nSkinning, 480-103\nfast and simple mecthoel foe, 471-173\nslitching and, 476-463\n\nSlerp, 206-207\n\nSnell's Law, 394-395\n\nSpace\n310 movement, 283-504\nflecking amd local space, 207\nlocal space optimézation, 368-370\ntoded space, D8\nneural nets as partitioning, aaG-337\npattizioriing, 2572259\nseach space optimizations, 272-27\nsimplified movement in 3D, 288-204\nrangent space, 555-559\nworld spain. Sp8-359\n\nIndex\n\nSpeed. optimising for\nA* optiouzanons, 272-257\ndara losing, 34-91\nFist math template mereprogramming, 20\nmemory allocation, 42-100\nated visual qealicy, 14\nSphere mapping, $53-554\nSpherical cubic innerpolation (squad), 207-208\nSphereal linc mterpolacion (lerp), 206-207\nSpinning whject, shortest an quaremion, 711-219\nSplashes, stmulacing, 191\nSpline istenpolations, MY, 211-215\nSpeite effects, 519-523\nalphe blending, $22-523\ndrawing 3D), 520-522\nrotazing, 523\nscaling, 423\ntextures for, 524\nSquad, 207-208\nSrand, 134-135\nSeacks, $3-4\nSondand Terplate Library, Ca+ (STL), 41-45\nalgormthmes, 42\ncomainer adapter, 53-54\ncontuners, 41—42\ndeques, 48-40\ntteranacs, 2\nlisrs, 446-44\nmaps, P33\nPriory qQuacd, $4, 221-282\nquewes, 54\nranger, method to dercomine, 4243\nstacks, 53-44\nvector, 43-45\nState machines, 275-735\n(ome macros for, 275-237\ndeleting pame objec within, 230\nevent-driven using messages, 225-225\nFinice Stare Machines (FSM), 237-248\nMhikeage rouring, 277-229\nmultiple stare machines, 233\npucuscmde for, 224\nqueues af, 235\nswappeng, 233\nSaabe pacers, 16-18\nSearen, 257\nAY adporichn for push planning, 254=255\ncrearung for FSM, 249-243\nPSM state, 739-140\neeiphboriog states, 259\nTransat Matrices, 238\nSee abe Stare machines\nScaristics, real-time and in-game debugging, 115-119\n\n613\n\nSreering belavtars, 305—\n\nSticky plane problem, loose cctrees for, 444453\nStitching, 4774 9h\n\nSTL. Se Standard Templare Library, Cre (ST)\nSere Orafiiele Hivary, 120-130\n\nSeating, 305-318\n\nTangent space, 356-399\nTaylor, Chis, 7\nTador series, 161-162, 167-171\ntruncated, 171\nat, Lagratees sericx, 174-175\nTemplates\nCr+ senda compliance, 25\nGesonal, 22=235\nFibonacci numbers, 2-27\nPACE Operations. 25-30\nfar merprogrumiming, 20-35\nfor uiganomecny, 23-25\nas virtual oompilers, 20-22\nTemplaces, Cre, I-35, 41-45\nTemporal topic: and meural nets, 335-5:\nTerrain\nbuildenpe, Saas\nerosion dimuon, 301-02\nfault line gemeration, 488490, 499-502\nfractal cerrain pemeration, 499-511\nfurry hondscaging, 44485\nlandecaping. A849)\nmazes, 49493,\nmountings, Mk=911\nparticle depewition, 50B—51 8\nreal-time, realistic, 444-498\nvolcan, SOR—5] |\nTeor files in parse development, 3\nTextiarcs\nbump mapping for, $55-$61\nprojection of, 550-551\nreflection mapping, 553-554\nthadow maps and. 578\nshine-thorough problem, $52\ntexture coordinare peneration, 54-554\nThresholds\nhysteresis thresholding, 435\nseleccion, 437\nTorquc, 134\nToral Annilzilarses, *\nTrickball, virtual, 717\nTraffic, furey logic for modeling, 372-528\nTraniparency\ngis, 75-399\nrendering. 199\n\nTrees\n\n614\n\nIndex\n\nbinary, 182-184\n\nPaine trees, 249754.\nquodereess, 258, 444 j45\nSee ade Chores\n\nTriangle-co-nriang}e collision detection algorithm, 390,\n\n647\nTrigonomerric functions\npolynomial approaimstions for, 161-176\nTreo filrray class, 105\nTwo-dincnonal sprice effects, 519-925\n\nUnreal, 307\nUplift, simulating, 503-307\n\nVectors, 4) 12, 43-44\nassert macro for normalizing, 109-111\neqgenvectors, 156\nlacking implemensation, 307-208\nmamary af, 15\northepon alin of, S738\nrepresenting finite mtation wick, 151-144\ntied by vector cumeras, 367-37\nWertices\neoinpiled vertex amays, 3-347\ndata formar for submission, 3568-359\ninterleaved daca, 354-554\noprimizing slbmasson for Open, 353-360\npopping ex. morphing, 460\nprojected depeh valucs, 361=365\nrendering poformance, a55\nstrided and wecanmed data, 355-356\nverte: collapse and splir, 455-156\nVideo game comeoley\ndata loading, 90-91\ndebugging for, 115-119\ndepth of ply rechniques, 135-140\n\nViewpeunts, 196\nVWesibiliny\nmochesion culling, 421-45]\npeing of, 258, 274-275\nvisibility texing, 296\nWisual qualiry\nlevels of devail, 432-435\nPopping, 432-435\nWolcanos, terrain pemeration, 502-511\nWovels, 43\n\nWaver amulaion\nalpha blending Eng alssparency. 193:\nbuoyant objects, 191-193\ninstability of integration method, 190\ninteractive simulations, 187-14\nlight neftaction, 199-164\nparallel processing, 14-191\npaniculate matter im, 55)\nrendering, 193-194\napecd and visual qualiry, 194\nsplashes, 191\nwave oquanons, 1e7—La>\n\nWave equations, LAT-199\n\nWaveless, 182-156\nHaar waveless, 184-186\nimage oeniproasion, 185—186\n\nMOB (oochisive-or operator), 107, 108\nnee) octs and, 338-341\n\nYaw, 307-408, 371-372\n\nJette pares, 249\nfoaming, cameras, 377",
      "page_number": 597,
      "chapter_number": 62,
      "summary": "This chapter covers segment 62 (pages 597-603). Key topics include mapping, maps.",
      "keywords": [
        "319-329 delumificaion metheds",
        "Fisezy loge",
        "maps",
        "space",
        "319-329 delumificaion",
        "delumificaion metheds",
        "mapping",
        "interpolation",
        "algorithm",
        "Library",
        "Funnccors",
        "Fisezy",
        "navigation meshes",
        "rendering",
        "machines"
      ],
      "concepts": [
        "mapping",
        "maps",
        "map",
        "space",
        "objects",
        "machine",
        "interpolations",
        "interpolation",
        "interpolating",
        "game"
      ],
      "similar_chapters": [
        {
          "book": "Game Programming Gems 2",
          "chapter": 56,
          "title": "Segment 56 (pages 544-551)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 63,
          "title": "Segment 63 (pages 609-616)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 45,
          "title": "Segment 45 (pages 429-442)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 7",
          "chapter": 64,
          "title": "Segment 64 (pages 617-624)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Game Programming Gems 3",
          "chapter": 48,
          "title": "Segment 48 (pages 456-465)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        }
      ]
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "chapter": null,
      "content": "1.0\n\nThe Magic of Data-Driven\nDesign\n\nSteve Rabin\n\nGames are made up of ewo things: dagic and data. This is a powerful distinction. Sep-\narate, they are useless, but together, they make your game come alive. The logic\ndefines the core rules and algorithms of the game engine, while the dara provides che\ndetails of content and behavior. The magic happens when logic and data are decow-\npled from cach other and allowed to blossom independently.\n\nObviously, game data should be loaded from files, not embedded inside the code\nbase. The genius eomes from knowing how far vo run with this concept. This arricle\ngives seven ideas that will revolutionize the way you make your games, of at least con-\nfirm your suspicions.\n\nIdea #4: The Basics\n\nGreate a system that can parse text files on demand (not just at startup), This is essen-\ntial to putting data-driven design to work. Every game needs a clean way to read in\ngeneral-purpose data. The game should eventually be read in binary files, but the abil-\nity to read in cext files during development is cracial. Texe files are dead simple for\nediting and making changes. Withour altering a single line of code, your whole team,\nincluding testers and game designers, can cry out new things and experiment with dif-\nferent variations, Thus, something thar is crivial to implement can quickly become an\nindispensable tool.\n\nIdea #2: The Bare Minimum\n\nDon't hard-code constanes. Put constanis in text files so chat they can be easily\nchanged without recompiling code. For example, basic functionality such as camera\nbehavier should be exposed completely. [f this is done properly, the game designer,\nthe producer, and che kid down the street will all be able to alter che behavior of the\ncamera with nothing more than Notepad. Game designers and producers are often at\nthe mercy of programmers, By exposing algorithm constants, non-programmers can\n\n3",
      "content_length": 1893,
      "extraction_method": "OCR"
    },
    {
      "page_number": 2,
      "chapter": null,
      "content": "4 Section 1 Programming Techniques\n\ntune and play with the values to get the exact behavior they desire—without bother-\ning a single programmer.\n\nIdea #3: Hard-Code Nothing\n\nAssume that anything can change, and probably will. Lf che game calls for a splic\nsereen, don't hard-code it! Wrine your game to support any number of viewport, cach\nwith its own camera logic. In isn’t even any more work if ir’s designed right. Through\nthe magic of text files, you could define whether the game is single-screen, split-\nscreen, or quad-screen. The files would also define all the starting camera values, such\na5 position, direction, field of view, and ult. The best part is chat your game designers\nhave direct access co all elemencs within the tent files.\n\nWhen core design decisions are flexible, the game is allowed to evolve co its full\npotential. In fact, che process of abstracting a game co ins core helps renvendously in\nthe design. Instead of designing to a single purpose, you can design each component\nto its general functionality. In effect, designing flexibly forces you no recognize what\nyou should really be building instead of che limited behavior outlined in the design\ndescurrene.\n\nFar example, if the game calls for only four types af WRapoits, you could progeua\na perfeeely good system that encompasses all of chem. However, if you abseract away\nthe functionality of cach weapon, using dara oo define its behavior, you'll allow for che\npossibilicy of countless weapons chat have very distince personalities. All it takes is a\nfew changes in a text file in onder to experiment with new ideas and game-play\ndynamics, This minelset allows the game to evolve and ultimately become a much\n\nbenter gare.\n\nDid You Believe Me When | Said \"Nothing\"?\n\nThe truth is that games need to be cuned, and great games evolve dramatically from\nthe orginal vision. Your game should be able to deal with changing rules, characters,\nraces, weapons, levels, control schemes, and objects. Without this flexibility, change is\ncostly, and every change involves a programmer—which is simply a waste of\nresources. If change is difficult, it promotes far fewer improvements to the original\ndesign. The game will simply not live up to its full potential,\n\nIdea #4: Script Your Control Flow\n\nA scripe is simply a way to define behavior outside of the code. Scripts are great for\ndefining sequential steps that need co occur in a game of game evens thar need to be\nuigp¢ened. For example, an in-game cur-scene should be scripted. Simple cause-and-\neffect logic should also be scripted, such as the completion conditions of a quest or\nenvironment triggers. These are all great examples of the dara—driven philosophy ar\nwork.",
      "content_length": 2702,
      "extraction_method": "OCR"
    },
    {
      "page_number": 3,
      "chapter": null,
      "content": "1.0 The Magic of Data-Driven Design 5\n\nWhen designing a scripting language, branching instructions require some\nthought. ‘There are two ways to branch. The first is to keep variables inside the seripit-\ning language and compare them using mathematical operarors such as equals ( =) or\nless than ( < ). The second is ro directly call evaluation functions that compare vari-\nables that exist solely inside the code, such as IsLifefeloere reentage(so). You could\nalways use a mix of these techniques, but keeping your scripts simple wall pay off, A\ngame designer will have a much casier time dealing with evaluation functions chan\ndeclaring variables, updating chem, and then comparing them. It alsa will be easier to\ndebu\n\nTian Scripts require a scripting lanpuage, This means that you need to\ncreate an entirely new syntax for defining your behavior. A scripting language also\ninvolves creating a script parser and possibly a compiler to convert the script to a\nbinary file for faster execution. The other choice is to use an existing language such as\nJava, but thar requires a large amount of peripheral support as well. In onder nor ro\nsink too much time into this, it pays off to design a simple system. Overall, the ren-\ndency is to make the scripting language coo powerful, The next idea explains some\npitfalls of a complicated scripting language.\n\nIdea #5: When Good Scripts Go Bad\n\nUsing scripts to data-drive behavior is a natural consequence of the data-driven\nmethodology. However, you need to practice good common sense. ‘The key is remem-\nbering the core philosophy: Separate logic and data. Complicated logic gocs in the\ncode; dara stays outside.\n\nThe problem arises when the desire to data-drive the game goes too far. Ar some\npoinc, you'll be tempred to put complicated logic inside scripts. When a Script starts\nholding state information and needs to branch, it becomes a fmite state machine,\nWhen the number of states increases, the innocent scriprwriter (some poor game\ndesigner) has the job of programming. If the scripting becomes sufficiently complex,\nthe job reverts co the programmer wha must program in a fictional language that’s\nseverely limiting. Scripts are supposed ta make people's jobs easier, nor more difficult.\n\nWhy is it so important to keep complicated logic inside the code? Irs simply a\nmarter of functionaliry ane debugging. Since scripts are not directly in the code, they\nneed to duplicate many of the concepts that exist in programming languages. The\nnatural tendency is to expose more and more functionaliry until it rivals a real lan-\nguage. The more complicated scriprs became, the more debugging information is\nneeded to figure our why the scripts are filing. This additional informacion results in\nmore and more effort devoted to monitoring every aspect of the SCLIpL as it runs.\n\nAs you probably guessed, non-trivial logic in scripts can get very involved.\nMonths of work can be wasted writing seripr parsers, compilers, and debuggers. It's as\nthough programmers didn’t realize they had a pertecdy good compiler already in front\nof them.",
      "content_length": 3084,
      "extraction_method": "OCR"
    },
    {
      "page_number": 4,
      "chapter": null,
      "content": "6 f Section 1 Programming Techniques\n\nThe Fuzzy Line\n\nThere is no doubr thar the line berween code and scripts is furry. Generally, irs a bad\nidea to put artificial intelligence (AT) behavior in scripts, whereas it’s generally a good\nidea wo have a scripted trigger system for making the world interactive. The rule\nshould be: If the logic is tao complicated, it belongs in the code. Scripting languages\nneed to be kept simple, so they don't consume your game (and all of your program-\nMing resources).\n\nHowever, some games are designed to ler players write their own AL Most com-\nmonly, these games are first-person shooters thar allow the creation of bots. When this\nis the goal, it’s inevitable thar the scripting language will resemble a real programming\nlanguage. An example of chis situation is Quake C. Since bot creation was a require~\nment of the design, resources and energy had to be put into maki ng the scripting lan-\nguage as useful as C. A scripting language of this magnitude is a huge commitment\nand shouldnt be raken lightly.\n\nAbove all, remember that you dont want your game designers or scriptwriters\nprogramming the game. Sometimes programmers are trying wo shirk responsibility\nwhen they create scripting languages. Irs all too easy to lure game designers into pro-\ngramming the game, Ideally, programmers should be boiling down che problem and\nexposing the essential controls in order to manipulate the logic. That's why program-\nmers get paid the big bucks!\n\nIdea #6: Avoiding Duplicate Data Syndrome\n\nIts standard programming practice to never duplicate code, If you need the same\nbehavior (for example, a common function) in nwo different spots, it needs to exist in\nonly one place. This idea can be applied to dara by using references to global chunks\nof dara. Furthermore, by caking a reference to a chunk of data and modifying some of\nits values, you end up with a concept very close ta inheritance.\n\nInheritance is a great idea that should be applied to your dasa. Imagine thar your\ngame has goblins thar live inside dungeons. In any particular dungeon, your data\ndefines where each goblin stands, along with its propertics. ‘The right way to encapsu-\nlave this data is to have a global definition of a goblin. Each dungeon's data simply has\na reference to thar global definition for every instance of a goblin. In order to make\neach goblin unique, the reference can be accompanied by a list of properties co over-\nride. This technique allows every goblin to be different while eliminating duplicate\ndara.\n\nThis idea can be taken to multiple levels by allowing cach chunk of data ro have a\nreference, Using this technique, you can have a global definition of a goblin along\nwith another global definition of a fast goblin thar inherits from the basic goblin,\n‘Then inside each dungeon definition, regular goblins or fast goblins can be instanced\ncrivially. Figure 1.0.1 shows this inheritance concept using referencing and overriding\nof values.",
      "content_length": 2974,
      "extraction_method": "OCR"
    },
    {
      "page_number": 5,
      "chapter": null,
      "content": "1.0 The Magic of Data-Driven Design Tt\n\nFast Goblin Goblin Instance\n\nRisferense = Fast Gobi\nPasion = (3. 0.0)\nFuca = (1, 0, 0\n\nFIGURE 1.0.1. Data inheritance.\n\nIdea #7: Make the Tool That Makes the Data\n\nWith any large game, text files eventually become unruly and hard to work with. The\nreal solution is to make a cool chat writes the text files. Call this cool a game edivor, a\nlevel editor, or a script editor, but you'll speed up the game development process by\nbuilding the right tools. Having a tool doesn't change dhe data-driven methodology; it\nmerely makes it more robust and efficient. The time you save always makes the extra\ntool development ame worth it,\n\nConclusion\nnr\nIt's easy to buy into the data-driven methodology, bur it's harder to visualize the dra-\nmatic resules, When everything is daca driven, amazing possibilities unfold.\n\nAn example of this rule is the ame Total Annihilation. The designer, Chris Tay-\nlor, pushed data-driven design to the limit. Total Annihilation was an RTS thar fea-\ntured two distinct races, the Arm and the Core. Although the entire game was\ncentered on these two factions, they were never hard-coded into the game. Theoreti-\ncally, data could have been added to the Fame to support theee races, even after the\ngame shipped. Alchough this possibility was never exploited, ‘Total Annihilation tool\nfull advantage of iss flexibilicy. Since all unics were complerely defined by dara, new\nunits were released on a weekly basis aver the games Web site. In fact, many people\ncreated their own units with functionality thar shocked even the game's developers,\n\nThe data-driven design helped Toral Annihilation maintain a committed follaw-\ning in a crowded genre, Since Toral Annihilacion, other games, such as The Sims, have\nemployed the same idea by providing new data content over their Web sites. Without\ndevelopers’ serious commitment co the data-driven philosophy, this unprecedented\nexpandability wouldn't be possible.",
      "content_length": 1967,
      "extraction_method": "OCR"
    },
    {
      "page_number": 6,
      "chapter": null,
      "content": "1.1\n\nObject-Oriented Programming\nand Design Techniques\n\nJames Boer\n\nIris easy to understand the popularity of C++ among game programming professian-\nals, While not straying coo far from the highly portable and efficient oot of C, it also\noffers the design benefits of an object-oriented language. Inherent in this power,\nthough, is the requirement thar C++ code be properly designed and implemented.\nAlthough the object-oriented programming (OOP) paradigm was created to enhance\nprogram design, portability, and maintainability, the brutal fact of the marter is chat\npoorly designed C++ programs can he worse than poorly written © programs.\n\nMany books and articles give good advice on general object-oriented design prac-\ntices; very few teach those practices with game programmers specifically in mind.\nGame programmers are a slightly different breed than the typical application pro-\ngrammer. Because their work is always expected to be cutting edge, pushing both\nhuman and hardware constraincs wo che limit, game developers tend to be much more\nwilling to bend or even break traditional programming design rules. Unforcunately,\nthis tendency often has the megative side effect of creating unmaintainable code due to\na poor understanding or implementation of basic OOF principles.\n\nAs games grow more and more complex, companies are looking to reuse more\nand more code to mitigate ever-increasing development coms. Engine licensing is\nbecoming more prominent as companies focus om content and game play and will\nundoubtedly grow into a major and separate support industry in the near future. This\nsort of development work requires much more stabiliry and long-term planning than\nwas previously known in the game development world. No longer is it acceptable to\ncompletely scrap your previous code with each new game.\n\nThis article obviously can't even begin to cover all thar a game programmer needs\nto know. Instead, ir identifies key areas in which a game programmer, and a company,\ncan take steps co improve the quality and consistency of production code, which will\nin turn lead co both more robust and more reusable libraries and game engines. We\nalso point you woward resources that much more thoroughly cover the copics dis-\ncussed.",
      "content_length": 2242,
      "extraction_method": "OCR"
    },
    {
      "page_number": 7,
      "chapter": null,
      "content": "1.1 Object-Oriented Programming and Design Techniques 5\n\nCoding Style\n\n——————\nProgramming style can often degrade into a religious argument. I'm not going to\nenter the debacle of where curly braces should be placed, bur ir is imporant for a\ncompany to adopt a style, and for everyone in that company to use it.\n\nA company, not co mention an individual, should strive for consistency in class,\nfunction, and variable naming conventions as well. Many companies have ailopted a\nsimplified Hungarian notation scheme. The Hungarian notation was invented by Dr.\nCharles Simonyi, chief software archirect of Microsoft, years ago in order to help stan-\ndardize variable naming conventions. Some argue thar sich a naming convention is\nunnecesary in a type-safe language such as C++ and creates more work when chang-\ning data types (since it requires changing the variable prefix), but others appreciate the\nease and speed with which data types are visually identified.\n\nThe basic premise of Hungarian notation is to preface the variable name with an\nidentifier describing the rype of data che variable represents. For instance, an integer\nvariable named SomeVariable would instead be named iSomeVariable. In addition to\nvariable types, pointers can be represented. A pointer to some class Foo might be\ncalled pFoodbj. Prefixes can also be combined to provide more information than a\nsingle prefix can provide, For instance, a pointer co an integer would be represented\nby the prefix pi, ora pointer to a pointer would be represented as pp.\n\nOther types of scope information are often used in front of the rype prefix, Mem-\nber variables are labeled with a_, so an integer member variable mishe be labeled\na_iSomevar. Global variables (tsk, you shouldnt even really be using these) are repre-\nsented as g_, and some variations represent static variables as 5_, although this isn't\nseen as often. Although the formal Hungarian notarion can be somewhat complex,\nmany companies have adopted a simplified version of it. Table 1.1.1 presents an\nexample of a common variation on formal Hungarian notation. You can find other\ndescriptions in books such as [PerzoldG), or you can find Simonyi’s original paper on\nthe World Wide Web in various locations,\n\nThe most commonly used notational cypes are listed in the table. Objects are gen-\ncrally not given any prefix, with che exception of a few common classes such as those\nrepresenting 30 vectors and points. Your company might adopt eenventions for repi-\nresenting other commonly used utility classes as well, Note char most of the descrip-\ntive tags are quite logical and would mot require you to look them up ina table.\n\nThe exact syntax you adopr is not as impertant as the relarive consistency af\neveryone who conforms to it. If all company code looks similar, ir will be easier for\nprogrammers to work on code that they might not have written.\n\nOne word of caution: Don't over-engineer a coding specification. A page or rwe\nshould really be all that’s required eo describe che company style. IF programmers have\nto look up how a variable should be named, they'll be far less likely to use che stan-\ndard. [ hesitate to recommend stricdy adhering to SIMONV'Ss Original system. It's far\ntoo complex for day-to-day operations, and since readabiliry is now more important",
      "content_length": 3305,
      "extraction_method": "OCR"
    },
    {
      "page_number": 8,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\nee ee ee\n\nTable 1.1.41 An Example of Hungarian Notation\n\nge es |\nJ Inteper\n\nFE Float\n\nD Double (float)\n\nL Long (integer)\n\ntC (Character\n\nE Boolean\n\nDw Double word\n\n8) Word\n\nby or byte Byte\n\nv\n\n; Costyle (null-cerminated) string\nCommon Extensions Description\n\nStr C++ string object\n\nH Handle (user-defined type)\nV Vector (useralclinad class)\nrh Point (user-delined class)\nReb RGB oiplee (user-defined struct of type)\nModifier Description\n\nF Paincer to\n\nR Reference to\n\na Unsigned\n\n4 oF ary Array of\n\nScope Description\n\ntm_ Member varnable\n\n£ (sbobal variable\n\n& Stacie variable\n\n=\n\nthan type safery, there's no reason to create hard-to-read ende when a simplified ver-\nsion will work just as well.\n\n(Class names should also be designed for ease of maintenance and readability. A\nconvention that has gained some popularity among Windows programmens is the use\nof class prefices ro indicate general design intent. Classes beginning with the lemer C\nare designated as Conerete clases, or classes with a specific use and implementation.\nClasses beginning with the letter are Jnterfiece chares, or classes intended to be used as\ndesign templates. These classes are not used direcily by applications; instead, chey\nallow other classes to be derived from them.",
      "content_length": 1286,
      "extraction_method": "OCR"
    },
    {
      "page_number": 9,
      "chapter": null,
      "content": "1.1 Object-Oriented Programming and Design Techniques 41\n\nIn addition to or instead of these class prefixes, it can also be helpful to prefix\nclasses by functionality. For instance, alll classes dealing with a user interface (UI) sys-\ntem can be prefaced with OY. This is especially helpful in programming environments\nand tools thar sort classes in a project alphabetically.\n\nClass Design\n\n(C++ classes offer an unlimited amount of design flexibility, which can be both a good\nand a bad thing, There are no naming requirements, other than for your constructor\nand your destructor. However, you might want to self-impose a standandized class\nnaming convention. Here is a simple example:\n\nclass Sample\n\n{\n\npublic:\nSanpla() { Glaar();\n—Sanplai) { Destroy(}; }\n\nvoid Clear);\n\nbool Greate();\n\nvoid Update[):\n\nyold Destray():\n}i\n\nThe first thing you'll notice about this class is the trivial constructor, Implement-\ning classes this way isa good idea for 4 number of reasons. To start with, the C44 con-\nstructor has no return value. Therefore, it's simply nota pood idea ro do anything that\nmighe fail. So instead, we simply call Clear(), a fumetion diac clears out all the inter-\nnal member variables, The benefit of clearing variables in a separate fanction is that it\nallows you to clear the class variables at any time. You'll see why this is especially\nimportant later.\n\nAt times, you won't want to “activate” a class che moment it is created. This often\nhappens for wrapper classes that are themselves members of another class. Lastly,\nthere is an efficiency issue, Divercing the object's actual creation point from che con-\nstructor allows you to dynamically create an object once burt repeatedly call the cre-\nate() and Destrey() members to reuse che same object's memory. Dynamically\nallocating memory is expensive, so when possible, ir’s best to avoid doing so. As men-\ntioned, the Create() and bestroy() members do che work of actually creating and\ndestroying whatever ic is the object represents. The Creste(} function has a simple\nbool value for indicating success or failure. This value is both intuitive and easy to\nimplemenc. Another popular choice of return type is standardized exror code rypes\n(usually signed integers). Bools are casy ro use buc require additional errorquerying\nmechanisms if return codes are not provided. Exception handling, alchough theoreti-\ncally superior tte simple return vilues, cemds to be both expensive in Muno-time perfor-",
      "content_length": 2467,
      "extraction_method": "OCR"
    },
    {
      "page_number": 10,
      "chapter": null,
      "content": "12 Section 1 Programming Techniques\n\nmance and easy for programmers to overlook. In addition, exception handling is nat\nself-documenting, as error codes or return values are in header files,\n\nThere is also an importance caveat for the Deatroy() function. Since we want bath\nthe convenience of automatic cleanup and the Nexibility of “destroy and recreate on\ndemand,” we need to make sure that the Destrey() function can be called multiple\ntimes safely or withour the Create(} function having been called, Be sure to call the\nSlear() funetion at the end of your destroy function in order te reser all the object\nvariables back to their initial states.\n\nGame programming often means programming a real-time system instead of the\nmore commen event-based programming model found in most commercial applica-\ntions. We might want co recognize chis difference in our class designs. The last por-\ntion of the class is the Update() function. This is the “step” function, or the function\nthat gets called once every frame. [t's a big help to agree on a common name for this\nfunction. Depending on che class, you might or might nec want to implement the\nVadate() function with a bool repurn value to allew for checking of nun-cime errors in\nthe step function,\n\nClass Hierarchy Design\n\nKnowing how to make the most of class reuse through inheritance is a key factor in\nobject-oriented programming. Although a complete discussion of relationships\nbetween objects and how to implement them is beyond the scope of this article, there\nis a single design rule chat is of such importance thar it bears brief mention.\n\nThere are two primary methods of extending classes co work with each other:\ninheritance and layering. Jsheritance, of course, is deriving one class from another\nLayering is when one object is contained as a member of another object. Layering is\nalso known by such terms as composition. containment, and enabeadding.\n\nThe simple rule is this; fan object has an i-a relationship to another object, use\npublic inheritance. [fa Aws-a relationship describes the abjects best, then use layering.\nWhat exactly do the terms ir and Aar-a mean? Pretty much exactly what they sound\nlike. If we use them in a sentence, the meaning becomes clearer:\n\nClass Corvette fit type of class Car.\nClass Corvette Ata type class Radio.\n\nWhen deciding how to relate classes to cach other, it’s often helpful to actually\nspeak the two relationships out loud. More often than noe, the correct answer simply\nsounds correct.\n\nDesign Patterns\n\nWhen creating a solution to a common programming problem, most developers\nunconsciously refer to a similar problem chat they have solved previously and then",
      "content_length": 2670,
      "extraction_method": "OCR"
    },
    {
      "page_number": 11,
      "chapter": null,
      "content": "1.1 Object-Oriented Programming and Design Techniques 13\n\nextrapolate the new solution from che old. Design patterns are about formalizing\nthese general software solutions co give a. common frame of reference when discussing\neveryday engineering tasks, A number of design patterns are described more thor.\noughly in other books, but here we discuss parterns mast commonly used by and rel-\nevant to game developers.\n\nThe Singleten Pattern\n\nThe singleton pattern is used when a single global object must be accessed across a\nwide number of classes and/or modules. Simply creating a mon-local static object\nworks, but there are many problems inherent with that practice, noc the least of which\nis determining when the object will actually be created, compared with other objects\nwith the same global scope requirements. The singleton pattern solves this problem\nby foreing access chreugh a class, which stores a static object internally. Here's whar a\nbasic implementation might look like:\n\nClass Singleton\n\npublic:\nSingletoni& Instances}\n{\n\nStatic Singleton Obj;\nreturn Obj;\n\nprivate:\nSingletont()};\n\na\n\nThis simple cede solves the problem quite elegantly. However, if you want to\nderive new classes from this one, you'll be hard pressed ta come up with as elegance an\nemtension. By changing the design and requiring more specific intervention during\nobject creation and deletion, though, we can expand on the basic singleton concept\nand allow extensibility to our original class:\n\nclass SingletonBase\n{\n\npublic:\nSingletondage/ |\n{ cout << “Singletonfase created!\" << end): }\nVirtual =5ingletongasea i )\nq Gout << \"Singletondase destroyed!\" << endl; }\nWittual vold Ageass()\n{ Gout << \"SinglotonBase accessed!\" << endl: 3\nStatic SingletonBase* Getobj()\n{ heturn @pohy-- }\nStatic vold SetObj(SingletonBasa* pObj)\n{ mpObj = pooj; }\nprotected:\nStatic Singletonfase* m poh];\nhi",
      "content_length": 1870,
      "extraction_method": "OCR"
    },
    {
      "page_number": 12,
      "chapter": null,
      "content": "14\n\nSection 1 Programming Techniques\n\nSingletonBase* SingletonBase::m_ pony:\n\ninline SingletonSase\" Base()}\n\n{\naseert(Singletonbase: :Gebobj i);\nreturn SingletonBase: :Getob)();\n\n}\n\nff Create @ derived Singletan-type class\nclass SingletonDerived : public SingletoaBage\n\n{\npublic:\nSingletonberived( )\n{ cout << \"SingletonDerived created!” << endl; }\nvirtual -SingletenOerived()\n{cout << \"SingletonDerived destroyed\" << endl; }\nvirtual woid Access(}\n{ cout << \"SingletonDerived accessed!\" << endl; }\nprotected:\n};\ninline Singletonfarived\" Derived()\ni\nassert(Singletonberived: :aetdh] dhl;\nreturn (Singletonberived* )SingletonDerived: :GetObj ();\n}\n\nfy Using the coda...\n\ni} The complex singleton raquires more work to use, but is\nff gore Ttlaxible. It also allows mora control over object\nif creation, which is sometimes desirable.\nSingletonDerived: :Sat0bj(naw Singletonterived) ;\n\nI! Notice that the functionality has been overridden by the new\nii class, even though accessing it throewgh the original method.\nBase()-=Access();\n\nDearived(}-*Access( }j\n\nif This variation on a singleton unfortunately requires beth\nff explicit creation and deletion.\ndelete SingletonDerived: :Getobj();\n\nThis modified form of the singleton class is not quite as simple in the construc-\ntion and destruction phases, but the plobal access, which is the primary point of the\nsingleton, remains as accessible as ever. Furthermore, with the addition of inline\naccessor functions, the code becomes quite easy to read from the user's perspective.\n\nSingleton patterns are often used in situations in which you traditionally might\nthink of using a global object or pointer to reference a single instance of a class, An\nexample might be a manager-cype class, where only a single instance (thus, the mame\nof the partern) is required. Classes thar manage an application's sound, a wser inter-\nface, graphics, of even the game or applicarion inself are all likely candidates to\nbecome singleton-type classes.",
      "content_length": 1977,
      "extraction_method": "OCR"
    },
    {
      "page_number": 13,
      "chapter": null,
      "content": "1.1 Object-Oriented Programming and Design Techniques 15\n\nSo, why go vo all chis bother instead of simply creating a global object or pointer?\nThere are a few great reasons. First, if you were planning on creating global objects,\naccessing an object through 2 single function is easier than having to extern a global\nobject in all your files. In addition, you gain the benefit of controlling exacely when\nyour object is initialized. Second, if you're using a pointer instead of an object, you\ngain C++ control over every access of the object, meaning that you gain benefits of\naccess control, in turn meting that you can do things such as monivor every time the\nclass is accessed. Finally, if you create your singleton with dertved clases in mind\nusing the techniques described, you can extend your base class while maintaining\ncompatibility with the existing base class. Let's examine how this mighe work,\n\nIn order to make che most of this sort of extensibility, you can imapine a scenario\nsuch as the following: Library A utilizes a singleton class, as described previously.\nLibrary B must use Library Ain order to function, so it is dependent on those classes\nand includes their header files. Application C makes use of both Libraries A and B but\nrequires changes to be made to Library A for some game-specific items. Instead of\nhaving to create a new version of the library (and lose any improvements made to the\noriginal library by, say, a concurrent project), Application C can simply derive a new\nclass (Class D) from Library A. If, as part of our singleton convention, we require char\nthe application is responsible for allocating the object, we can subscinute derived Class\nD for Class A. By creating a mew accessor function with a new name thar remurns a\npointer to Class D instead of Class A, we can access all of D's new functions. How-\never, Class B will continue to use the old accessor function thar returns a pointer to A\nand so will expect the old functions to function similarly co the way they did before.\nNore that virtual functions behavior can be overridden, but you must ensure chat the\nnew functionality is compatible with the old to preserve backward compatibility.\n\nIn this way, the singleton pattern allows you co create a primitive library version-\ning scheme. You can sec how a simple technique can evolve inte a powerful mecha-\nnism for code organization and reuse. You can find in chis book another variation of\nthe singleton pattern in the article “An Automatic Singleton Utility.” by Seo Bilas.\nIn this article he describes an elegant method of using wemplares and public inheri-\n\ntaNce to automate the creation of singleton classes.\n\nFagade Pattern\n\nThe singleton segues nicely into the next partern we'll investigate: the japsde parters.\nThis pattern is generally used as what is often referred to as a manager claw. This is a\nclass that provides a single interface to a large collection of relared classes, usually\nsame sort of subsystem. These classes are often designed as singletons because it usu-\nally makes sense vo have only onc manager object per cype of subsystem, For example,\nyou need only a single object to manage access to pour audio or graphical user inter-\nface subsystems.\n\nA facade or manager is necessary in order to keep interdependencies berween\nclasses, otherwise known as coup/ing, to a minimum. One can imagine in a theoretical",
      "content_length": 3388,
      "extraction_method": "OCR"
    },
    {
      "page_number": 14,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\nSubsyetern|\n\nFIGURE 1.7.17 An cram ple of bad coupling.\n\nworst-case scenario thar every elass in a project “knows” abour and requires explicit\naccess to every other class, as illustrated in Figure 1.1.1. The maximum number of\ninterdependencies berween classes can be described as (n-1?, where nis che number of\nClasses IN a project.\n\nThe problem with this sort of interdependency comes when an entire subsystem\nneeds to be heavily modified or even replaced. Object-oriented programming protects\nagainst implementation changes within single classes, but a new paradigm is needed\nfor protection against more sweeping changes. The facade pattem solves the same sort\nof problem thar object-oriented programming protects against, bur on a much larger\nscale.\n\nThe general rule of thumb when implementing facade classes is this: Whenever\npossible, avoid exposing internal subsystem Classes to outside systems. This is not\nalways possible to do entirely, but with some clever coding and function wrapping,\nyou can reduce the exposure of these classes a great deal, as illustrated in Figure 1.1.2.\nEvery class you hide means that there is bess work to be done the next time that sub-\nsystem has to be reimplemented.\n\nState Pattern\n\nAlmost every game programmer has had to deal with the problem of keeping track of\nconstantly shifting game states in real time. States usually stare out as simple enumer-\nations, and behavior is implemented based on switching between states in a switch\n\n. case sermcture. Problems cin develop, however, when the number of states starts\ngrowing larger and functionality must be shared in a greater number of these states. A\ncur-and-paste nightmare can quickly ensue, wherein the programmer tries to find all\nthe stares that share code and make sure that any changes to one state occur in all of\nthem.",
      "content_length": 1856,
      "extraction_method": "OCR"
    },
    {
      "page_number": 15,
      "chapter": null,
      "content": "1.1 Object-Oriented Programming and Design Techniques 17\n\nSebsysiem]\n\nFIGURE 1.1.2. Using fagade classes to reduce interdependencies.\n\nA more elegant object-oriented solution is to simply use objects to represent logi-\ncal stares. The advantages of using objects are that states are better encapsulated, states\ncan logically share code in their base classes, and new stares can easily be derived from\nexisting ones using inheritance, These advantages reduce the typical problem of hav-\ning 00 cut and paste code between discrete states, as shown in Figure 1.1.3.\n\nAlthough the pattern does mot specify how state ransitions are to be made, it can\noften make sense to leave the transitions of classes to a central manager. In this man-\nner, inter-abject dependencies can be avoided, leaving only the manager te worry\nabout having to know all the different stare objects. Better yet, the stares can simply\nbe enumerated and created through the use of a factory object, which is explained in\nthe next section,\n\nThe state pattern does not necessarily have to be used only to represene discrete\nfame states, Tt can also be used in Al systems or even co represent different types of\ngame modes within a single game. By representing each game mode as a different\nobject, for example, you gain the flexibility of allowing new behavior to be added after\n\nooo ——— OnEnteri}\n| StateManager BaseState Update()\nDynamicallyswotches\nbrtweenstate\n\n1\n1\nobjectuinreal-time\n1\n1\n1\n\nStatel | State® | |} Stared\n\nFIGURE 1.1.3. Using che state parmem.",
      "content_length": 1527,
      "extraction_method": "OCR"
    },
    {
      "page_number": 16,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\nthe initial release through the use of dynamic link libraries (DLLs) or other means of\nadding an object to existing code dynamically.\n\nFactory Pattern\n\nThe factory pattern deals with organization in the creation of objects. A form of the\npattern is defined as a method for allowing abstract interface classes to specify when ro\ncreate concrete, derived implementation classes. This method is fren required in\napplication frameworks and other similar clase hierarchies, However, came program-\nmers Often deal with a specific subser of the factory parrern—namely, the use of fac-\ntory objects with enumerated object creation lecated in a cencral class, usually via a\nsingle-member function.\n\nIn Englich, this means thar a single object is responsible for creating a wide vari-\nety of other objects, usually relarecl by a common base class, This class often tales the\nform of a class with a single method that accepts some sort of class ID and returns an\nallocated object. The advantages of clustering object allocation inte a single location\nare especially noteworthy for eame developers:\n\n* Dynamic memory allocation ig expensive, so you want to carefully monitor allo-\ncations. Allocating all objects in a central area makes it easier to monitor these\nallocations.\n\n* Olten, common initialization or creation methods must be called for all objects\nwithin a class hierarchy. If all object allocation is put into central area, ir\nbecomes easy to perform any common operations (such as inserting chem into a\nresource Managerjon all objects,\n\n* A factory allows extensibility by allowing new objects to be derived from the\nexisting factory. By passing in a new class ID (which can easily be obtained from\ndata instead of code), you can provide run-time extensibility of new classes with-\nout changing the existing base code.\n\nThe final point stresses extensibility as a henefic of using the factory pattern. For\nthis reason, creating simple functions ot static dasses should be avoided, since you\ncannot derive mew classes from chem:\n\nBaseclass* ClassFactory::CreateObject (int in)\n{\n\nBasellass* pllass = 0:\nswitch( id)\n{\n\nCase i:\npClass = n@w Classi;\nbreak;\n\nCHSe 2:\npClass = new Class;\nbreak;\n\nCage 2:\nPClase = new Class3;\nbreak;",
      "content_length": 2261,
      "extraction_method": "OCR"
    },
    {
      "page_number": 17,
      "chapter": null,
      "content": "14 Object-Oriented Programming and Design Techniques 19\n\ndefaults\nassert(!\"Errort Invalid class ID passed to factory |\");\n\n/f perhaps perfors some comian initialization is heeded\npPClass->Init():\n\nréturn pilass:\n]\n\nYou can see thar chere is technically nothing sophisticated about a factory creation\nmethod. However, centralizing these object allocarions provides a powerful organiza-\ntion and extensibiliry mechanism.\n\nFactory patterns are used whenever large numbers of different objects within an\nobject hierarchy must be dynamically created at run time. This can include Al\nobjects, resources such as textures or sounds, or ever. more abstract objects such as\n\ngame states (as in the previous discussion).\n\nSummary\nee\n\nDeveloping good object-oriented techniques is not an end in iwelf. It should pervade\nevery aipect of your code, which will save you ime and trouble in the long run. Well-\nwritten object code is more flexible, more maintainable, and more extensible than\nprecedural code. Game programmers have not adopted a complex new languape and\nceding paradigm for their personal entertainment; there is a method to their madness.\n\n‘There are several references listed at the end of this article. Do yourself a favor\nand immediately pick them up if you don't yet own them. They are indispensable\ntools in learning the finer points of both object-oriented programming and C++ lan-\nFllage Usage in peneral.\n\nReferences\n——\n\n[(Gamma‘)4] Gamma, et. al., Dene Patterns, Addison-Wesley Longman, Inc, 1994.\n\n[Mcyers98] Meyers, Soom, Affective C+, second edition, Addison-Wesley Longman,\nInc., 1998.\n\n[Meyers96] Meyers, Scot, More Bifectine Ces, Addison-Wesley Longman, Inc.,\n1595,\n\n[Perzold96] Perzold, Charles, Programming Windows 95, Microsoft Press, Inc., 1996.",
      "content_length": 1765,
      "extraction_method": "OCR"
    },
    {
      "page_number": 18,
      "chapter": null,
      "content": "1.2\n\nFast Math Using Template\nMetaprogramming\n\nPete Isensee\n\nWhen programmers think of C++ templates, they usually chink of things like the\nSTL, generic containers, and type-safe macros. Most programmers are unaware chat\ntemplates can act as virtual compilers, creating tremendously optimized code in rerms\nof both speed and size. This unforeseen quality of templates was first noticed ly\nErwin Unruh in 1994. He presented the C++ Standards committee with a template\nprogram that didn’t compile but instead coerced che compiler into generating a list of\nprime numbers in its error messages [Veldhuizen)9].\n\nThis discovery led a number of language experts to focus on che use of templates\nas precompilers, Todd Veldhuizen and David Vandevoorde ereathy expanded on this\ncapability, showing char virtually any algorithm could be templatized, provided the\ninput parameters to the algorithm were known at compile time [Veldhuizen 5).\nGiven a good compiler, intermediate code can be completely optimized away, result-\ning in extraordinary efficiency.\n\nThe best way to see this in action is to consider a simple example.\n\nFibonacci Numbers\n\nThe Fibonacci sequence looks like this: 0, 1, 1,2, 3, 5, 8, 13, .... The general equation\nfor the sequence is Fib(n) = Fib(a-1) + Fib(n-2). A typical function to recursively gen-\nerate Fibonacci numbers is as fellows:\n\nunsigned RecursiveFibl unsigned nm }\n\niff a= 1}\nreturn ni\nréturn RecursiveFib( n-1 } + fecursiveFib( n=-2 )3\n\n}\n\nBelieve it or not, this simple function runs in exponential time. Ir's highly ineffi-\ncient and should never be used in production code. The function is simply a step-\nping-off point for generating a templatized version:",
      "content_length": 1686,
      "extraction_method": "OCR"
    },
    {
      "page_number": 19,
      "chapter": null,
      "content": "12 Fast Math Using Template Metaproegramming ai\n\ntemplates unsigned N > struct Fib\n\n{\nGnhiun\n{\nif Recursive definition\nWal = Fibs W-1 >;;Val + Fibs W-2 =::Wal\n};\n\nff Specialization for base cases\n\niy (termination conditions)\n\ntemplate <> struct Fibs 0 > { enum { Val =\ntemplate <> struct Fibt i» { enum { Val =\n\n=o\n— i\n\nfi Make tha template appear like a funotion\n#define FibT( m ) Fibt nm =2:Val\n\nAn example “call” co the template via the define:\n\nStet rGoue «x FAT, 4 py fy Fibt 4 *isVal\n\nSome important things co nore about the cemplatized version are as follows:\n\n* ‘The template function is not really a function ar all—ir's an enumerated integer\ncalled Val, recursively determined at compile time. The notation Val = Fib<N-\n1>2:Val + Fib«N-2>::Val is uncommon bur valid C++ synraw.\n\n* Fib is defined as a struct to simplify the notation. Seruct dara is public by default,\nwhich is exacthy what we want. Similar nocartion is used for all the following code\nlistings.\n\n* ‘The template parameter WW is used to specify che function input. This is an uncorm-\nmon but perfectly acceptable use of template parameters. For example, std::bit-\nseten> uses the numeric value Wi as its template parameter to define the number of\nbits represented. This numeric parameter must be known at compile time. Call-\ning FibT(i) when i is a non-const variable will generase a compiler crror.\n\n* To terminate the recursion, you must handle the base case properly. For Fibonacci\nnumbers, the base case is when N is zero or onc. With templares, che way to han-\ndle base cases is with templare specializacion. The notation tenplate<> indicates\na specialization. When W is zero or one, Val = W.\n\nWow comider how a compiler might evaluate FabT (4p:\n= Fibté=: i Val\n\nFibctie::Val 4 File: Val\n\nFibtze: Vel + Fibei>::Val + Fib<issival + Fib<0>::Val\na\n1\n\nFibti>; iVal Fifbete: Wal + 1+ 14-0\n1* 0 + 7+ + 0\n4\n\n'",
      "content_length": 1883,
      "extraction_method": "OCR"
    },
    {
      "page_number": 20,
      "chapter": null,
      "content": "a2 i Section 17 Programming Techniques\n\nSince all inputs are known at compile time, a compiler can reduce FibT(N) ta a\nconstant. In other words, the compiler can produce exactly the same code ax though\nyou had written:\n\nStd: scout << 37 Jf Fibs}\n\nThis is an amazing rool to have in your C++ tool kit, It’s not every day you can go\nfrom eponential rr time to constant run tine, With template metaprogramming, the\nprice you pay is additional compile time instead of additional execution time. For\ngames, execution time is usually more critical than compile time, so this technique is\nvery appealing.\n\nFactorial\n\nHere's another example of turing a standard function into a cemplatized version.\nFirst, the standard (C++ version for reference:\n\nunsigned RecureiveaFact( unsigned n }\n\nreturn {(f == 1) 7 0: {n * RecursiveFact(n - 1))):\n}\n\nAnd the template metaprogram version:\nfl Templatized tactorial(n)\ntemplate= unsigned NW > struct Fact\n{\n\nhi\n\nanum { Val = N* Fact= N - i >::¥al };\n\nff Specialization for base case\nTemplate <= struct Fact< 1 >\n{\n\nenum { Val = 4 }:\nIi\n// Make the template appear like a function\nHdefing FactT( nm ) Faet<= f =:: Val\n\nAAs in the Fibonacci example, the compiler can reduce a “call” such as FaetT(4) to\nthe constant 24. We've gone from linear run time to constant ran time. That's a pow-\nerful argument for using metaprogramming, There are two drawbacks: a compile-\ntime pesialey, which is typically insignificant, and a code readability penalty, which\ncan usually be hidden by a well-defined macro such as FactT(n).\n\nLet's step back for a momenct. Template metaprogramming is compelling and\nundeniably efficient, but not many games require a Fibonacci sequence or factorial\nnumber generation. Even if they did, it’s not likely chat the code will know the",
      "content_length": 1783,
      "extraction_method": "OCR"
    },
    {
      "page_number": 21,
      "chapter": null,
      "content": "12 Fast Math Using Template Motaprogramming 23\n\nrequired input parameters at compile time. Is this just a meat C++ party trick, or is this\nsomething that's actually useful?\n\nTrigonometry\n\nTime for a more complicated example. Let's take on the sine function. Many games\nuse sine tables or a similar method for fast ong calculations. What if we could make\nthe compiler read something like x = sie(].234) and generate a single move insmruc-\ntion? Template metaprogramming to the rescue!\n\nGenerating standard trig functions involves using a series expansion. For sines,\nthe expansion looks lilee this:\n\nsime(x) =x — (x9 / 3) + (SI — (xe he GEO...\n\nwhere xis in radians, 0< =x < 2m. To compute the cerms efficiently, we can rewrite\nthe expansion:\n\nsine(x} =x * rerm{O)\nwhere rr(z) is computed recursively as:\nterm(a) = 1 —x° f (2e4 2) / (2+ 3) * cerm(ael)\nYou can write this expansion without templares as follows:\nGouble Sine double fAad }\nconst int iWaxTerms = 10;\n\nroturn Thad * SineSeries( tAad, 0, iMaxTerms );3\n\ndouble SineSeries( double ffad, int i, int iMaxTerns }\n\n{\nif{ i = iMaxTeras }\nraturn 1.0;\nreturn 1.0 — ({ fad * fead / (2.0 \"i +2.0) / (2.0 * £ + 3.0)\n* GingSeries( fad, i + 41, iMaxTeras } };\nI\n\nIncreasing iWaxTerms improves accuracy at the expense of run-time speed. It's nor\ndifficult to convert this to a templatized version. The solution is presented in Listing\n1.2.1, The solution uses two template objects: Sine<A> computes A * term(G) and\nSerios<A, I» compures ferm(l) recursively out ta the number of terms specified by\nWaxTerms. With the template metaprogramming version:\n\ndouble x = SineT( 1.234 }:\n\nthe compiler can theoretically generate the same code as though we had written:\n\ndouble x = 0.4395 1820837463368:",
      "content_length": 1737,
      "extraction_method": "OCR"
    },
    {
      "page_number": 22,
      "chapter": null,
      "content": "24 Section 1 Programming Techniques\n\nThe actual value of stm('J.234) is 0.94381820937463370..., so the template ver-\nsion, which evaluates 10 terms, is accurate to approximately 15 decimal places! With-\nout much effort, we have a solucion in which we can get sines for free (ie., constant\ntime) by using the compiler as the workhorse. We don't have to compute a table ar\nrun time or embed a table in our executable, because the compiler can pemerate the\ntable entries we need (and oaly the ones we need) ar compile time,\n\nCompilers in the Real World\n\n‘There's potentially a big problem with template metaprogramming. Many compilers\navailable today (circa 2000) can't reduce the recursion and mathematics involved with\ncomplex templare-based algorithms. In the sine example, evaluating the series expan-\nsion to 10 terms requires the eampiler to reduce approximately 20 floating-point\nmultiplications, 50 integer multiplications, 20 FP divides, 10 EP subtractions, and 10\nrecursive calls down to one of nwo move instructions, Cova a compiler do tha? OF\ncourse. Shen a compiler do that? Probably, given ample resources (RAM and time}.\nWella compiler do char? It depends.\n\nT tested the preceding examples using Microsoft Visual C++ 6.0. VC6 did a splen-\ndid job with the Fab and factorial templates, producing single move instructions for\neach. It had more difficulty on the sine template, generating code thar is inferior even\nto the C run-time sin() function! By default, WC6 was able to unrall che recursion to\nonly cighe levels, and it hardly optimized the arithmetic ar all. Using the ViC6-specific\nFpragmas inline_depth(255) and inline _recursion(on) allowed ViC6 om unroll the\nrecursion complerely and optimize away all the math, so fortunarely, good results are\nstill possible.\n\nThe moral of the story is char all optimizations are guilty uncil proven innocent.\nExamine the code produced by the compiler, and evaluate che performance before\nand after templares are introduced as an optimization. You might need ta weak some\ncompiler flags to ger the results you want. In the future, expece compiler writers to\nfocus more heavily on template optimization and templace metaprogramming itself\nIn the meantime, program softly and carry a big profiler.\n\nTrigonometry Revisited\n\nGiven that C++ compiler technology is sill immacure when it comes to dealing with\npemiplares, is there anything we can do to improve our chances of the compiler doing\nthe right ching? Listing 1-2.2 shows another amempt at the sine funetion, The recur-\nsion has been removed and the series expansion is inline out to 10 terms. We're down\nto 12 multiplications, 21 divides, and 10 subtractions. We've also eliminated the tem-\nplate specializacion since it’s no longer needed.",
      "content_length": 2751,
      "extraction_method": "OCR"
    },
    {
      "page_number": 23,
      "chapter": null,
      "content": "1.2 Fast Math Using Template Motaprogramming 25\nne ee we ee\n\nThe resulting function is a bit easier to handle, from both a readabiliry standpoint\nas well as a compiler ssandpoint. Indeed, ViOG has an easier ime with this version.\nThe special #pragnas are no longer required for the compiler to generate a constant.\n\nAt this point can we clearly see the benefits and drawbacks of the rechnique. Tem-\nplate metaprogramming can generate massive speed improvements—sometimes, but\nnot always.\n\nTemplates and Standard C++\n\nNot many compilers are completely compliant with the C++ standard, especially\nwhen it comes to templaces. Templates are so flexible and powerful, compiler wrirers\nhave a tough job getting them right. In no place is this more apparent than Visual\nC++, which was slow to adopt templates in the first place and slower still to conform\nto the standard. For example, V6 does mor support partial specialization, making the\nspecialized versions for many of the templase functions more complicated and less\ngeneric than they need to be.\n\nMuch more important, however, is the support or non-supporr of flaating-point\ntemplate parameters. The sine template functions in Listing 1.2.1 and Listing 1.2.2\nuse a floating-point template parameter for the incoming radian value. However,\naccording to the (l++ standard, “a non-type template-parameter shall not be declared\nto have floating point ... type.” In other words, on a conforming compiler,\n\ntemplates double A » struct Sine // compiler errer\n\ngives an error message. The solution is to use a reference parameter instead:\n\ntemplates dowble& R > struct Sine |/ Ox\n\nInterestingly and unfortunately, Visual Ce+ 6.0 support: floating-point types as\ntemplare parameters but does mar support references as parameters, It has things com-\nplecely backward! To use the sine template code on conforming compilers, change\ndouble A to doubled R.\n\nMatrices\n\n——_—————— EE EE\nWhere template metaprogramming really comes into its own is the handling of\nmatrix operations. Three-dimensional games heavily use matrices, Templatizing key\nfunctions can generate noticeable speed improvements. In che following section, we\nuse templates to improve initializing, transposing, and multiplying matrices.",
      "content_length": 2238,
      "extraction_method": "OCR"
    },
    {
      "page_number": 24,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\nIdentity Matrices\n\nThe idensity matrex contains elements whose values are zero, with the exception of the\ndiagonal, which contains ones. We begin with a typical implementation. Norte the\nembedded for loops:\n\nmatrixaasé matrixss: :identity()\n\nfor (unsigned ¢ = 0; c <= 9] err}\nfor (unsigned r= 0; r= 3; ree)\ncoli cif r] = (cr)? 1.0 = O00;\nreturn *thia;\n\nThe template metaprogram version is shown in Listing 1.2.3. The parameters for\nthe template version include the manrix utx, the size of the matrix N (a square matrix\nis assumed), the current row Rand column C. Ar every iteration, we evaluate the next\nelement of the matrix.\n\nThe key thing to notice is the method by which we loop over the columns and\nrows. Ar each step in the algorithm, we know 1, which simply goes from 0 to m\nsquared. Given I, we can compute the current row by taking 1 modulus w. For exam-\nple, ifm is 3, the row sequence would be: 0, 1, 2, 0, 1, 2.0, 1, 2. 0. The current col-\numn is I divided by N mod Ww. LEN is 3, the colurnn sequence would be 0, 0,0, 1,1, 1,\n2, 2, 2, 0. The template specialization terminates the algorithm when 1 reaches N\nsquared. Now we can replace the original version with:\n\nmatrix33& matrixdd: sidentity )\n{\n\nIdentitylttxT( matrixds, “this, 3 )-\nraturn \"this;\n\nThe compiler can expand che new version to:\n\nmatrixdg& matrixdd: :identity()\n\n1\neol[ © ][ 0 J = 1.0;\neol[ O ][ 1] = 0.0;\ni\neol] 2 J[ 1] = 0.0;\neolf 2 ][ 2 ) = 1.0;\nreturn “this;\n\n}\n\nIn other words, the compiler can compdetedy somrodl the foop. OF course, we could\nhave unrolled che loop ourselves, but the template version is a general solution, It will\nwork for square marrices of any size (provided you include the specialization). For\nexample, the code for 44 matrices would look like:\n\nmatrinéad matrix44: identity!)",
      "content_length": 1817,
      "extraction_method": "OCR"
    },
    {
      "page_number": 25,
      "chapter": null,
      "content": "1.2 Fast Math Using Template Metaprogramming 2?\n\nIdentityltxT( matrizd4d, “this, 4 4):\nreturn \"this;\n\nMatrix initialization\n\nWe can create templarized initialization code by using che same technique we used in\ngenerating the idencity marrix. In fact, the only line that needs to change in Listing\n1.2.3 is the line thar determines each marrix clement value:\n\nmel GL A] = € C =A) Tf 1.0! 0.0: fF identity matrix\nwhich is replaced by:\n\nfix], © IL R ) = 0.0; Fi zero matrix\nor more generally by:\n\nmtx[ C IL R ] = static _cast< F =( Init }; s/ init matrix\n\nwhere F is the cype of value stored in each element and Init is 2 numeric template\nparameter thar defaults to zero. The general solution allows you co easily initialize\nmatrix elements to any constant value.\n\nMatrix Transposition\nTransposing a matrix flips the matrix using the diagonal as che axis:\nRatrixag& matrixda: :transpose()\nTor (unsignéd c = 0; c =< 3: cee}\nTor (unsigned r =o +1; fF = 3s r++\netd: :swap{ col[ c j[ r ], col{ r if ¢ 1);\n\nraturn \"this:\n}\n\nThis algorithm cries our for optimization because it dees so little actual work. For\na3™ 3 matrix, there are only three swaps, For a4 x4 matrix, there are only six. List-\ning 1.2.4 shows the templare implementation, We can now replace the original with:\n\nmatrixntah matrixgds transpose }\nTransutxT( matrixgs, *thig, 2 33\n\nreturn this;\n\ni\nwhich the compiler will expand to:\n\nHatrixass matrixda: transpose |",
      "content_length": 1421,
      "extraction_method": "OCR"
    },
    {
      "page_number": 26,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\netd::awap( colja)][i], coljijp[o) t;\netd rawap( coljd][2], colj2)(0) };\natdriswap( col[ij[2], colj2jfil };\nreturn *this;\n\nI\n\nThe embedded for loops are optimized away, leaving only the swaps themselves.\nSwap itself is an inline function, so we're down to only nine move instructions. Doesnt\nget much beter than char.\n\nMatriz Multiplication\n\nFor our final look at metaprogramming, we tomplatize metric multiplication. A cypi-\neal non-templatized implementation looks like his:\n\nmatrimddé metrixdd::operater *= (const matrixch’ mj\n\n{\nnatrixaa tj\nfor (unsigned r= 0; rot 3; ree]\ni\nfor (unsigned ¢ = 0; 6 =< 3; e*)\ntle][r] = 0.0;\nfor (unsigned k = 0; & = 3: ke4)\nt{elir] += col[(k)(r] * ae) [ke];\n}\n}\nthis = t;\nreturn \"this;\nI\n\nThe comesponding template metaprogram version is shown in Listing 1.2.5.\nMatrix multiplication has an inner loop chat becomes the additional template para-\nmeter K. Unlike the identiry OF transposition algorithms, which expand to A squared\niterations, multiplication expands to N cubed iterations (mote thar the specializations\ntake “W cubed” as a parameter). Now we can replace the original version with:\n\nmatrixzagh matrixgad:seperater *= (const matrixzaé m)\n{\n\nnatrixas t;\nZeroMixT( matrixds, t, 3 5\nWultMtxT( matrixds, t, \"this, m, 3 }:\nTehis = t;\nreturn \"this;\n}\n\nWe initialize the resulting matrix to be empty (zeroed) so that the += operator in\nthe MulttxIep] template will work properly. The compiler can expand the new mul-\ntiplication operator to something like this:",
      "content_length": 1535,
      "extraction_method": "OCR"
    },
    {
      "page_number": 27,
      "chapter": null,
      "content": "1.2 Fast Math Using Tamplate Metaprogramming 29\n\nmatrix33h matrix: ioperater *= (const matrixs3a nh\nmatrix3d3 t;\n\nI) ZerovteT\nt(O) [0] = 0.0;\nhier ee\n\nt[2][2] = 0.0:\n\nff MultutxT\n\nCLO][O] *= col[oj (0) \" mPa] fo);\ntLO]PO] *= col[i}{o] * m[ol]i):\neee\n\ntLS)[3] = ecol[2](9] * afd] [2];\ntl3}[3] = eol(3](o] * mpo][a];\n\n\"this = t:\n\nreturn *thigs;\n\n}\n\nThe multiplication template is a general solution for any square matrix. The code\nfor any arbitrary Vx NV matrix would be:\n\nmatrixWN& matrixWN::operator *= (const matrixNN& m)\n\n{\nMatrixnh t;\nZerautxT( natrixWN, t, W jj\nMULEMEXT( matrixhW, t, “this, m, Nj;\n*this = t;\nreturn \"this:\n\n}\n\nActual Matrix Performance\n\nHow efficient are the templatized matrix operations? The general-purpose answer ix\nthar your mileage will vary depending on the quality of che compiler and the compiler\noptions you chensc.\n\nT tested the matrix operations using WC6 with full optimizations, opdmizing for\nspeed, using the inline option “any suitable\" and the #pragmas inlina depth(2ss)\nand inline_recursion(on). | benchmarked cach operation 100 million times, with\nthe results shown in Table 1.2.1. All times are in milliseconds, The Unrolled column\nindicates whether or not the compiler was able to unrell che recursion.\n\n‘To see relative performance, I graphed these results to show how much faster the\ntemplanzed versions operated compared with the non-cemplatized versions (see Fig-\nure 1.2.1).\n\nWith the exception of multiplying 4% 4 macrices, the templatized versions were\nall considerably faster. Nor surprisingly, the matrix wansposition operations showed\nthe best improvernents. In the eases of the simpler algorithms, the compiler was able\nto completely unroll the template recursion. However, for multiplying 4 x 4 matrices",
      "content_length": 1758,
      "extraction_method": "OCR"
    },
    {
      "page_number": 28,
      "chapter": null,
      "content": "30 Section 1) Programming Techniques\n\nTable 1.2.1 Matrix Operation Test Results\na ____—_—_—————————\n\nNon-Templatized Templatized\n\nOperation {in Millisecands) fin Millisecornds) Unrolled =\nmarix33-:2er0 33,092 29,330 Completely\nmatrina4szena 36/063 50,297 Completely\nmatrix33-:identity 45,827 79,526 Completely\nmatrind4-identicy 46,845 29S Completely\nmatrix 3 Jctranspose 55,338 79055 Completely\nmatricii:ctranspose O0,638 30245 Partially\nmatrix33-op *= 62,94 50.352 Partially\nmatrixddscp \"= 326,390 FoLI01 Partially\n\nms Lo cain\nSnr peopared ta oon-besglale yew\n\nFIGURE 1.2.1. Relative performance of templite functions.\n\n(4° operations), the compiler only partially unrolled che recursion, and the overhead\nof the recursive function calls far outweighed any inlining improvements, so the\nresulting function was much slower than the original. These results simply show the\nimportance of profiling your “optimizations.”\n\nSummary\n\nTemplates can be a highly elective way of generating algorithms directly in the in-\nstruction stream. [he abilicy to reduce and unroall code in a generic way can be a very",
      "content_length": 1099,
      "extraction_method": "OCR"
    },
    {
      "page_number": 29,
      "chapter": null,
      "content": "1.2 Fast Math Using Template Metaprogramming |\n\npowerful programming technique. The notation for template metaprogramming is\nunusual at first, but it's not much more difficule chan examining standard recursive\ncalls. Macros can be used to hide the notation from the calling code.\n\nThe metaprogramming technique can be extended ta a wide variety of functions,\nincluding square-root caleulations, gitatest common divisors, matrix inversians—\nevent sorting. Any algorithm for which at least some of the input parameters are\nknown at compile time can benefit from templare mctaprogramming.\n\nCurrent compilers are still limited in dealing with templates, especially recursive\ntemplates. Compiler template error messages can range from cryptic to undecipher-\nable, As with any optimization, there is often a time and space cradeoff. In many cases,\ntemplate metaprogramming can generate the best of both worlds: very small and fast\ncode. In other cases, unrolled code can be much larger than the original version,\nreducing or even eliminating the speed advantage. Nevertheless, expect to see tem-\nplate metaprogramming play a significant role in Cr+ libraries and games of the\nfurture.\n\nListing 1.2.1\nrr\n\nff Series expansion for sin{ A).\ni) For conforming compilers, change double A to double& B\ntemplate= dowble A > struct Sine\ni\nenum { MaxTaras = 10 4; // increase for ACCUraCy\netatic inline double sin{}\n\nf\n\nI\nhi\n\nreturn Ao\" Series< A, 0, MaxTeras =:ivaly;\n\nTemplate double A, int I, int WaxTerne >\nStruct Series\n{\nenum\n{\nff Gontinue £8 true until we've evaluated M terns\nContinua = I+ 1 f= MaxTerns,\nNxtI = { I #1) * Continue,\natMaxternis = MaxTerms * Continue\n\n}\n\nff Recursive definition called once per tere\nStitio inline double yval()\n\n{\nreturn i -A* RS (2.0 * T+ 2.0) J\n{2.0 * 1+ 9,0) * Series< A * Continue, HxttI,\nAxtMaxterms =o valy);\nI\n\nhi\n\nff Specialization to terminate the loop",
      "content_length": 1885,
      "extraction_method": "OCR"
    },
    {
      "page_number": 30,
      "chapter": null,
      "content": "az Section 1 Programming Techniques\n\nTemplate <= struct Series 0.60, Oo, oO >\ni\n\nStatic inline double yval() { return 1.0; }\nti\n\nii Make the template appear like a function\nfiatineg SineT{ ro) Sines f =::sin{)\n\nListing 1.2.2\n\n_—_ n> gg\ni] Series expansion for sin( fj.\n/) Far conforming compilers, change double A to doubles aA\nteaplate < double R > struct Sine\n\n{\n\nff All values Known at compile time,\n\nff A decent conpiler should be able to reduce\n\nff te a single constant.\n\nStatic inline double sin(}\n\n{\n\ndouble Asqr = R ® A;\nreturn A\" [ 1.0 - Asqgr / 2.0 ff 4.0\n\n* { 1,0 - Aegr f 4.0 7 6.0\n* {| 1.0 - Regr / 6.0 ff 7.0\n* [| 1.0 - Regr / 6.0 / 8.0\n*{ 1.0 - Regr f 10.0 7 11.0\n*{ 1.0 - Regr f 12.0 f 13.0\n*\"{ 1.0 - Regr f 14.0 7 15.0\n\"{ 1.0-- Regr f 16.0 7 17.0\n\"(1.0 -- Ragr / 18.0 / 19.0\n*{ 1.0 - Regr /f 30.0 / 21.0\nboat omy Ke) feee eet Te See a fel 0\n\n}\n\na\n\nff Make the template appear like a fumetion\nFdefine SineT( r ) Sinme< pr »::8in(}\n\nListing 1.2.3\n\niY Templatized identity matrix; Wis matrix size\nTemplate= class tx, unsigned N > struct IdMtx\n{\n\nstatic inline void eval WtxA mtx i\n\n{\n\n}\ni\n\nif 4551gn8 each element of the matriz\n\nteaplate= class Wtu, unsigned W, unsigned ¢, unsigned A,\nunsigned I >\n\nstruct IdudtxImpl\n\n{\n\nidWtxImpl< Wtx, WH, 6, 0, O >:ieval( mix J;",
      "content_length": 1279,
      "extraction_method": "OCR"
    },
    {
      "page_number": 31,
      "chapter": null,
      "content": "12 Fast Math Using Template Metaprogramming ao\nee\n\nénuz\nif\nNutl = I # 1, ff Counter\nNinth = NwtI % N, ‘i Aow (inner loep)\nNietG = NxtI / N & WH ii Coluan (outer leap)\nie\nstatic inline void eval Mtx& mtx )\n{\n\netx CIP R)=( Gf) ? 1.0: 0.0;\niGMtxInpl< tx, M, Net, MxtR, Nxt >:teval( atx ey\n}\n};\n\ni) Specialize for 9x3 and 434 matrix\ntenplate<> struct IdutxImpl< matrixaa, 3, 0, 0, 3*3 >\n\n{\nStatic inline void evalj matrixns3& ) {}\nMe\ntéenplates> struct IdMtxInpl< matrix44, 4, Oo, 0, a\"4 >\n{\n\nStatic inline vold eval matrix44& } i}\nhs\n\nf/ Make the template appear like a function\nHeating IdentitylttxT( MexType, Mtx, N) \\\nTdutse< MixType, M =:roval( Wtx }\n\nListing 1.2.4\n\nSEE\nff Templatized transpose; W is matrix size\ntemplate Glass Ute, unsigned N > struct Transltx\n\nf\nStatic inline woid eval{ Mtxh mtx }\n{\nTraneitxInpl< Mtx, M4, 0, 1, 0 *::eval( mtx 13\ni\ni\n\ntemplates class Mix, unsigned N, unsigned ¢, UAisigned A,\nunsigned I >\nStruct TranslttxImel\n\n{\nenum\n{\nNxtI = I + 1,\nNzt® = Natl / NM & 4H,\nNath = ( Netl & No) + MxtG + 1\n\nbi\nStatic inline void eval{ Mtx& atx }\n{\niff R=}\nStdssawap( mtx[ C I[ A], mtxf RIL & ] 4;\nTransMtxImpl< Mtx, N, MxtC, Nxth, Nxtl >::eval( mex };\n}",
      "content_length": 1174,
      "extraction_method": "OCR"
    },
    {
      "page_number": 32,
      "chapter": null,
      "content": "a4 Section 1 Programming Techniques\n\nhi\n\nif Specialize for 3x3 and 4x4 matrix\ntemplate<> struct TransMtxInpl< matrixd, 3, 0, 1, 3*3 =\n{\n\nBtatic inline void avall matrins3& } {}\nhi\ntemplate<> struct TransMtxInpl< matrixdd, 4, 0, 1, 4°4 >\n{\n\n};\nif Wake the tenplate appear like a function\n\nfdefine TransltxT( MexType, Mex, No) \\\nTransWtx< MtxType, M >::eval( Ntx j\n\nstatic inline vaid eval( matrixd4& } {}\n\nListing 1.2.5\n\nif] Templatized multiplication; N is matrix size\ntemplate: class Mtx, uneigned N > struct Multittx\n\n{\nStatic inline void eval( Mtxk r, const Mtxh a, const Mtxi b )\n{\n\nMultiitxImpl< Utz, WH, 6, 0, 0, O >::eval{ r, a, b );\n}\nhi\n\ntemplate< class tx, unsigned W, unsigned G, unsigned fi,\nunsigned K, unsigned — =\nstruct Multitxiagl\n\n|\nenum\n{\nHxtI = I+ 4, ff Gounter\nNxtkK = Nett & NH, ff Internal loop\nHxtG = Nxti | WS H, ff Galenn\nMeth = Neti | hy ASN SS Ae\nti\nstatic inline woid eval( Wtwk r, const Mtxk a, const Mtx& b }\nFL GIL A) + al KIL A] * BT CoE K OO;\nMuLtetxInpl< Mex ,N,Nxtc, Meth ,Wetk,Nxtl 2::eval{ rya,b );\nt\nhi\n\nif Specialize for 3x3 and 4x4 matrix\ntenplate<> struct MultWtxImpl< matrixd3, 3, 0, 0, 0, 3*3*S >\n{\n\nATaTic inline void aval[ mMatrixci’, comet matrivs4,\n\nconst matrix33& ) {}\n\nIi\ntemplate<* struct MultWtxIapl< natrixdd, 4, 0, 0, 0, 4*4*4 >\n{\n\nStatic inline void aval( matrixé44h, canst matricdds,",
      "content_length": 1340,
      "extraction_method": "OCR"
    },
    {
      "page_number": 33,
      "chapter": null,
      "content": "1.2 Fast Math Using Template Metaprogramming 35\n\nconst matrixdéé } {}\nbi\n\nff Make the template appaar like a function\nWdefine MultitxT( MtxType, r, a, b, NW} |\nMuliutx< MtxTypa, N >:teval( r, a, b }\n\nReferences\nnt\n[Veldhuizen99] Veldhuizen, Todd, “Techniques for Scientific Ce+.\" Available\nwew.exuemeindiana.cdu/-tveldhui/paperstechniques!, August 1999.\n[Veldhuizen98] Veldhuizen, Todd, et al., “Blices-+ Numerical Class Library.” Available\nwww. conumerics. ong) lite! Aueuse 1998,\n(Veldhuizen96) Weldhuizen, Tedd, and Kumaraswamy Ponnambalam, “Linear Alge-\nbra with C++ Template Metaprograms,” Dr Dobbs Journal, August 1596,\n[Veldhuizen95) Veldhuizen, Todd, “Using C++ Template Metaprograms,” C++ Report,\nMay 1995.\n[Pescio97] Pescio, Carlo, “Binary Constants Using Template Metaprogramiming,”\nCiC++ Uber: Journal, February 1997.\n[Karmesin99] Karmesin, Steve, et al., “PETE, Portable Extension Template Engine,”\nAvailable www.acl.lanl ov! petes, February 1499.",
      "content_length": 960,
      "extraction_method": "OCR"
    },
    {
      "page_number": 34,
      "chapter": null,
      "content": "1.3\n\nAn Automatic Singleton Utility\n\nScott Bilas\n\nThis article presents an easy and safe method to provide access to a C++ class single-\nton while retaining control over when ic is instantiated and destroyed.\n\nDefinition\n\nA singleton is an object that has only one instance in a system atany time. Some com-\nmon examples of singletons in games are managers for rexture maps, files, or che user\ninterface. Each is a subsystem thar’ generally assumed to be available once the game\nhas started and will stay in existence uncl the game shu down.\n\nSome of these subsystems can be implemented using global functions and static\nvariables. An example would be a memory manager's nalloc() and free() functions.\nThese types of subsystems are noc singletons in char they don't have their functional-\nity encapsulated into a class and can't be represented using a single instance of that\nclass, There's no reason a memory manager such as this couldnt be converted into a\nclass and used as a singleton, but this practice isn't common.\n\nAn example of a singleton is a fectere map manager. It could be called Texturesigr\nand have methods such as GetTexture() and UseTexture(). Its purpese would be to\nfind texture maps in the file store, convert them to system graphies objects, make\nthem available to the rasterizer(s), and own chem until they are no longer needed, at\nwhich point it deletes them. Only one instance of Textureligr will be needed in the\nsystem, 50 this class would naturally be used as a singleton.\n\nAdvantages\n\nWhiar's che poinc of singletons? First, chey provide conceptual clarity because labels are\nvery important. Calling a class a singleton and following a naming convention (such\nas -Mgr, -Api, Global-, etc.) relates importance details abour how we intend that class to\nbe used.\n\nSingletons also provide notational convenience. Every object in a C++ system\nmust be owned by something. The ownership pattem of these objects depends on the",
      "content_length": 1947,
      "extraction_method": "OCR"
    },
    {
      "page_number": 35,
      "chapter": null,
      "content": "13 An Automatic Singleton Utility a7\n\ngame, but ir often resembles a multilevel hierarchy, in which each higher level owns a\nset of child objects, each of which in curn can awn child objects. Each object pub-\nlishes a set of functions to access its children. For example, co get at the Texturemgr\ninstance, you might need co call a sequence of functions such as Getapp( ) ->Getser-\nvices ()->GetGui()->GetTexturemgr(), where cach function revurne a pointer to che\nrequested child ehject. This system is inconvenient and not exactly efficient, consid-\nering the multiple dereferences. Singletons can solve this problem because they are\ntreated as global objects.\n\nThe Problem\n\n——— eee\nWell, then why not just use global objects? They are certainly convenient; the Tax-\ntureligr object could be accessed through a g_Texturelge object reference chat has\nbeen declared with external linkage at global scope (or within 2 namespace) or per-\nhaps through a function that returns a reference to that object instead. However, the\nconstruction and destruction order of global objects is implementation dependent\nand generally impossible to predict in a portable manner.\n\nThere are workarounds to all these problems, bur what we really want is a way to\nhave the convenience advantage of treating a singleton like a global object, withour\nthe inconvenience of losing control over when and where it Bets constructed and\ndestroyed.\n\nTraditional Solution\n\nThe textbook solution to managing a singleton usually looks something like this:\nTextureugré GetTextureligr( void }\nf{\n\nstatic T $_Singleton:\nreturn ( 3_Singleton }:\n\nThere are many variations that use cemplates and macros for notational conve-\nrience, bue the effect is still the same, This solution allows a singleton to only be\ninstantiated on demand—the first time this funetion is called. Ir’s convenient co use,\nbut ic leaves its destruction up to the compiler and requires thar i¢ be done only at\napplication shutdown time. We need more control than tha, Order of destruction is\nvery imporcant in a game in that some subsystems must be shut down and destroyed\nbefore others. Furthermore, what if we want to shut dewn only part of the game while\nit's still running? Doing so is impossible wich this solution.",
      "content_length": 2255,
      "extraction_method": "OCR"
    },
    {
      "page_number": 36,
      "chapter": null,
      "content": "ao E Section 1 Programming Techniques\n\nA Better Way\n\nAll we're really after ts che ability te crack a singleton, and for chat whar we need is a\n\npointer to it. Whar if we were to do something like this:\n\nClaas Texturawgr\n\n{\nStatic TextureMgr™ mg_Singleton;\npublic:\nTextureligr( void ) { ms_Singleton = this; /*...\"/ J\n-Téxtureligr{ void ) { ms_Singleten = 0; f*.. 8h)\nfe con\nTextureligré GetGingleton( void ) { return { ‘ms Singleton }; 4\nhi\n\nAdd a few assertions for safety purposes, and this solurion would work! We can\nnow construct and destroy a Texturewgr wherever we like, and accessing the singleran\nis as simple as calling Texturelgr::GatSingleton(). However, this solution is still a\nlittle inconvenient, given that the same code (to track the singleton pointer) needs to\nbe added to every singleton class.\n\nAn Even Better Way\n\nA more generic solution is to use cemplates to automatically define the singlecon\npointer and do the work of setting it, querying it, and clearing it, It can also check\n(through assert()) to make sure thar we arent accidentally instantiating more chan\none. Best of all, we can get all chis functionalicy for free just by deriving from this sim-\nple little class:\n\nfinclude <cassert>\n\ntenplate <typename T> class Singleton\n\n{\n\nStatic T* ns_Singleton;\npublic:\n\nSingleton( void }\n\nif\n\naseert( ima Singletan };\nint offset = (imt)(T*)1 = (int)(Singleton <T=*)(1T*\")1;\nms Singleton = (T*){{int}this + offset);\n\nbi\n=fingleton( wold |\n{ assert{ ms_Singleton }; as_Singleton = 0; }\nstatic Th GerSingleton! void }\n{ s8eert( me_Singleton }; return [ *na_Singletan j: }\netatic T* GetSingletonFtr( woid )",
      "content_length": 1628,
      "extraction_method": "OCR"
    },
    {
      "page_number": 37,
      "chapter": null,
      "content": "1.3 An Automatic Singlaton Utility a9\n\n{ return { m&_Singleton }; }\ni\n\ntenplate <typenane T= T* Singleton “T+: ims_Singleton = oO:\n\n‘To convert any class into a singleton, you only need to do these three easy steps:\n\nPublicly derive your class wyGlass from Singleton <MyClass>,\n\nMake sure that you're constructing an instance of MyClass somewhere in che sy\ntem before using ic. How you instantiate it doesn’t matter. You can let che cam-\npiler worry about it by making it a global or local static, or you can worry about\nit yourself via new and delete through an owner class. Regardless of how and\nwhen you construct the instance, it will get tracked and could be used as a single-\nton through a common interface by che rest of the system.\n\n. Call MyClass: :GetSingleton() to use the object fram anywhere in che system. If\n\nyou'te lazy like me, you cam #define g MyClass te be MyClass: :GetSingleton(}\nand treat it exactly like a global object for notational convenience.\n\nHere is a sample usage of the class:\n\nclase Textureligr : public Singleton <TextureMgr>\n\nhs\nTextura* GetTexture( const char* name };\ntiger\n\nhi\n\nfdetine g_Vexturevgr Textureligr; sGatSingLetent }\n\nvoid SonmeFunction( woid }\n\n{\nTexture* stone = Textureigr: GetSingleton().GetTexture( \"stonei\" 3;\nTexture* woods = 9 Textureligr.GetTexturel \"woods\" );\nTipess\n\n}\n\nThe Singleton class's only purpose in life is to automatically register and unregis-\n\nterany instance of its derived (uyClass) type as it is constructed and destroyed. We're\nderiving MyClass from Singleton <wyCless> purely to inherit this convenient func-\ntionality. This doesnt affect the size of the class in any way; it only adds some auto-\nmatic function calls.\n\nSo how does this work? All che important work is done in che Singleton con-\n\nstructar, where it figures out the relative address of the derived instance and stores the\nresult in the singleton poinrer (ns_singieton). Nove that the derived class could be\nderiving from more than just the Singleton, in which case “this” from MyClass might\nbe different from the Singleton “this.” The solution is to take a nonexistent object sit-\nHing at address 0x1 in memory, cast it to both rypes, and see the difference. This dit:",
      "content_length": 2213,
      "extraction_method": "OCR"
    },
    {
      "page_number": 38,
      "chapter": null,
      "content": "a0 Section 1 Programming Techniques\n\nference will effectively be che distance berween Singleton <MyClass> and its derived\ntype MyClass, which it can use co calculate che singleton pointer.\n\nReferences\n\nMevers, Scot, Wore 2fectiee C++, Addison-Wesley Publishing Go.. 19945.",
      "content_length": 272,
      "extraction_method": "OCR"
    },
    {
      "page_number": 39,
      "chapter": null,
      "content": "Using the STL in Game\nProgramming\n\nJames Boer\n\nIn 1997, Cre was officially standardized, ending a nine-year process thar not only\ndefined the official language specifications but also gave C++ programmers a massive\nnew set of tools in the form of the standard C++ library. A large portion of this library\nisthe Standard Template Library of STL. The STL is a collection of container foollec-\ntions of dara) classes, ranging from vectors to balanced binary trees, In addition to the\nbasic containers, the STL provides a massive assortment of algorithms thar can oper-\nate on those basic containers.\n\n‘common concern is whether using STL will slow dewn your code. The truth of\nthe matter is that the STL was designed with speed as a foremost priority. For\ninstance, vectors do ne bounds cheeking, and iterators are never validated before\nattempting to access a container. The net result is thar, for example, STL vectors can\nproduce code with performance equivalent to that of a simple dynamically allocated\naray. Other containers fare just as well when put under the performance microscope.\nThe STL was designed for high-efficiency (4+ applications, Don't lose sleep about\n\nusing them extensively in your code.\n\nSTL Types and Terminology\n\nThe STL is a large and somewhat complex portion of the Standard C++ library. Using\nthe STL effectively requires the understanding of the basic components and how they\nwork together\n\nContainers\n\nSTL containers represent the classic data abstractions and organization schemes such\nas vectors, lists, quewes, and maps. However, we should make a few distinctions\nbetween certain types of containers and how they are implemented.\n\nThe $TL containers’ vector, list, and deque (pronounced “deck”) are implicte dara\ntypes that both describe an abstract data type and imply a specific method of imple-\n\n|",
      "content_length": 1832,
      "extraction_method": "OCR"
    },
    {
      "page_number": 40,
      "chapter": null,
      "content": "a2 Section Programming Techniques\n\nmentation. A wecter is, of course, a dynamically resizable array. The Ji is imple-\nmented as a double-linked lise, A aegue, or double-ended queue, is implemented in a\nmanner that allows amortized constant time insertion or deletion of elements ar either\nend of a randomly accessible array-type structure, Deques are also known as sequence\ncontdiners because they store ordered secs of data, meaning that the order in which you\ninsert the data affects the order in which chey are stored.\n\nContainers such as stack, queue, and priority_queue are slightly higher-level\nabstractions. They describe a conmainer’s behavior but allow for different cypes of\nunderlying implementations. For example, a queue mighe be implemented using a\nvector, list, or deque inrernally. These are known as container adapters. Container\nadapters, because they rely on sequence coneainers as their underlying data, also fall\ninto that caregory as well.\n\nOther containers, such as a map, set, multimap, or multiser, are all implemented\ninternally as red-black trees (balanced binary trees) bur offer different container\nbehaviors. These are also known as astoctativr containers because the dara inserted inta\nthem is ordered based on a certain sorting criteria,\n\nHterators\n\nSterators can be thought of as pointers to elemencs in the containers, and indeed the\nSTL even uses pointer notation for traversal and aceess to container data. For\ninstance, the ++ operater moves the iterator to the mexe clement in a container, much\nthe way a pointer to an clement in an array can be incremented. In addition, like\npointers, the actual data can be accessed by dereferencing che iterator using the *\noperator.\n\nAlgorithms\n\nUnlike what you might expect, alporttbmr designed to operate on STL classes do not\ncome in the form of member functions of che container classes. Instead, they exist in\nthe form of stand-alone functions that operare on iterators, Why did the designers of\nSTL choose this seemingly ani-OOP design paradigm?\n\nBy separating the data from the algorithms, the designers dramatically reduced\nthe number of combinations of specialized algorithms. Since each container has simi-\nlar types of iterators, cach algorithm had to be written only once instead of once for\neach container, The downside is chat there are sometimes less than obvious side effects\nar suboptimal solutions. In most cases, however, specialized member functions are all\nyeu heed to perform most basic operarions on your containers,\n\nSTL Concepts\n\nA few basic concepts are important to working with the STL. First, it is importane to\nunderstand the methods used to determine ranges when working with a container,\nTeo methods common to all containers begin() and and(), rerurn the full range of",
      "content_length": 2776,
      "extraction_method": "OCR"
    },
    {
      "page_number": 41,
      "chapter": null,
      "content": "1.4 Using the STL in Game Programming 43\n\nthe container. As you can sec in Figure 1.4.1, negin() rewrns the first element in che\ncontainer, but end() returns the position depond ote dave nalie element.\n\nThiete are several advancages ro Organizing the ranges in this manner. First, spe-\nclal-case coding for empry lists is eliminated. Second, iterating through containers has\na simple ending criteria: continue as long ax end() is not reached, The disadvantages\nof chis sysrem are that it is somewhat less intuitive, and reverse iteration requires spe-\ncial members and iterators.\n\nIt obviously becomes important to remember not to dereference an inerator that\nis pointing at end(). Such behavior is undefined.\n\nWhen you use functions specifying a range, functions in STL usually take as\nparameters two iterarors, one specifying the beginning element and one specifying the\nend element. To pair effectively with beging) and end(}, these functions assume an\ninclusion of the first clement specified and exclusion of the last clement specified.\nMathematically, che following notation usually designates this sort of range-\n\nrange [begin...end)\n\nThere is another aspect of the STL design of which you should be aware, STL\ncontainers pass Information by value, not by reference. This means that when dealing\nwith small dara types, ir is acceptable co allow the container to make a copy of the\ndata. With larger dara structures or classes, it becomes advantageous vo pass in point-\ners to these objects or structs, Ocherwise, every insertion or access results in a copy\nconstructor being called.\n\nWectors\n\nOTL vectors are essentially resizable arrays. Nove that although the formal C++ stan-\ndard does not specify what underlying dara saructures are to be used far containers,\nthe performance and interface requiremencs leave litle ambiguity as to how they will\nbe implemented in practice, Thus, all versions of STL will likely be very similar, with\n\nonly minor variations in implementarion details,\n\nContainer\nfeel ukest tied [Feed es pees\nbegin() end)\nbegin() points to chad) points lo position\nfirst sf Setertes beyond last element\n\nFIGURE 1.4.1. ondé) points after che lasr valid clement.",
      "content_length": 2186,
      "extraction_method": "OCR"
    },
    {
      "page_number": 42,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\nVectors behave alrost identically to standard C arrays, with one major excepuion:\nthey are dynamically resizable. However, it is important to understand the nature of\nthis resizing.\n\nVectors are implemented as arrays that periodically need to reallocate memory\nand transfer dara to a new array. This means two things for developers. First, a vector\ncan allocare more memory than ir currently needs, due to the requirement chat it\nmight be expected to grow at any time. Second, adding an element to che end of a\nvector is described as comstanr sme—it is important to remember that this means\namortized comtant time. In other words, same grow functions can require a substantial\namount of resources as they allocate new memory, copy the existing array inte this\nnew block, and delete the old memory, but they do not require chese exera resources\nevery time, Depending on implementation, a vector can allocace twice its current alla-\neated memory when it mins out of buffer space.\n\nfe is also evitical chat you understand when a vector reallocates memory, since\ndoing so invalidates any iterators currently pointing to elements in the vector. Let's\nexamine the functions to help more precisely manage a vector’s internal memory, alter\nviewing the eode-\n\nFinglude <vector>\nHinglude <iostrean>\n\nusing nanespace std:\n\nif Typedeft tha container and iterator names for better\nii readability\n\ntypeadet vectersint> Int¥ector:;\n\ntypede? IntVector::iterator IntVectIter:\n\nvoid maint}\n\n{\nif €reate a vector object of integers\nIntVector co;\nif Reserve room for 10 integere\nc.reserved 10);\n\nif Fill the vector with 3 different elements\nc.push_back(3);\n\nc.push back(S9):\n\nc push back (42);\n\n({ How loop and print owt all the element values\nfor(InmtVactItor itor = c.begin(}; iter |= e-end({)j +-itor)\ncout << “alament valua = \" << (*iter) << ondl:\n\nff Since the elements have been crested, we can access or\nae replace them jpust like A formal array.\n\ne(0] = 12;\n\nef] = 3ce",
      "content_length": 1990,
      "extraction_method": "OCR"
    },
    {
      "page_number": 43,
      "chapter": null,
      "content": "1.4 Using the STL in Game Programming 45\n\nc[2] = 944;\nTor(int 2 = 0; d = e.eivedys i++)\ncout =< “elenent value = \" << ci] << endl;\n\n}\n\nThis example shows most of the basic principles you need to know to stare using\nSTL containers. Notice at the cop of the listing the inclusion of the appropriate\nheader files for this program. In addition, note the usage of namespace std. Like all\nportions of the C++ library, che STL is part of the eta namespace and so roquires you\nto declare such in your program.\n\nNexr, we sce typedets for the type of container and iterator we want te use in the\nprogram. This is a very common practice: it nor only makes the code easier to read,\nbut it becomes easier to change the underlying dara structure, if desired, (We'll see\nhow easy that is next.)\n\nThe next section of code creares the vector container object v and proceeds to call\na vector-only function char reserves 10 integers’ worth of memory. The code proceeds\nto push_back() 3 integers onto the back of the vector. Since we have preallocared well\nover this amount of memory, no additional memory allocation is required.\n\nThere are a few routines chat you mighe find helpful when you want to closely\nmonitor and control the allocation of your vector's memory. As shown, you can\nreserve a bulfer in the vector by calling reserve() and passing a size parameter. This\nvalue can he retrieved by calling capacity(). If capacity()=-reserve() and another\nclement is inserted into the array, a memory allocation will rake place and all current\nirerarors will be invalidated. In order co determine the maximum amount of memory\nthat can be allocated for a single vector, use the sax_size() function,\n\nThe push_front(}, push_back(), pop_froet(), and pop_back() functions are\ncommon to all basic ordered containers (vector, list, and deque). These functions\nobviously add and remove elements ftom the frome and back of the container. Due co\nthe implementation of a vector, you want to aveid push front() or pop_front() on\nthese types of containers, if possible, due to the Oy'n! performance, but they are avail-\nable far use if you absolutely need them.\n\nThe final portion of sample code demonstrates one of che most commonly used\ncomponents of STL usage: the iteration loop. We use a for loop with an iterator\ndetermining the current position. The initial position is set eo begin(), and the itera\ntor increments with the prefix ++ operator until the iterator equals ena(}, ar which\npaint the exit condition of the loop is satisfied. Every container with an accesible\niterator can be looped through in this manner.\n\nSince the iterator is the only item keeping track of che current position in the vec-\n(Of, WE must use It to extract any information we want. We can see that in keeping\nwith the notion of a pointer, we simply dereference the iterator to access the data.\n\nAfter the standard iteration loop, we see an example of a vector in use like a nypi-\neal array. It is important to note that array subscripting cannot be used to insert ele-\nments into a liste—only to access existing elements.",
      "content_length": 3075,
      "extraction_method": "OCR"
    },
    {
      "page_number": 44,
      "chapter": null,
      "content": "46 Section 1 Programming Techniques\n\nLists\n\nThe STL dir is perhaps the most widely used of the basic STL structures. Ir is imple-\nmented as a doubly linked list, so any insertion and deletion of elements is done in\ntrac constant time. The tradeoff for this capabiliry is the loss of random access that\nthe vector and deque allow,\n\nOne beaury of using STL containers is the consistent naming conventions and\nmethods used throughout the library. Once you learn che basics of manipulating one\ntype of container, you csentially know how to use them all.\n\nUsing a list is even simpler than using a vector. The push front(} and\nputh_back() functions work exactly as you would expect. Iterating through the list\nalso works exactly as we saw in the vector example. In this code, we see many of the\nsame techniques used tn che vector class:\n\nWinclude <list>\nfinclode <iostream\n\nusing namespace std:\n\nclass Foo\n{\npublic:\nFoo(int 1) { m_iData = i: }\nvoid SetDatafint i) { miata = i: }\nint GetData/) { return m_idata; }\nprivate:\nint m_iData;\nti\n\nif TypedeT tha containér and iterator names for better\nfi readability\n\ntypadet list<Foa*= Foalist;\n\ntypedet Foolist::iterator FooListitor:\n\nvoid main)\n\n{\nff Create a list container of integers\nFoolast ¢;\n\n{/ Fall the last with 3 different elements\nCc. push_back(new Foo{i}):\nc.push_back(new Foo(2));\nc.puech_back(new Foo(a) ji\n\nff Tterator through the list\nTfor(FooListItor itor = c.begin(); Lter '= c.end(}:}\n\n1f((*itor)-*Gerbatal) == 2)\nff} dengnstrates proper method of remoying an\nff elenent trom the @iddle of the list.\n\ndolete (*itor);",
      "content_length": 1575,
      "extraction_method": "OCR"
    },
    {
      "page_number": 45,
      "chapter": null,
      "content": "1.4 Using the STL in Game Programming ay\n\nitor = c.arase( itor):\n\n}\n\nelse\n++itor:\n\nt\n\nff Make Sure to delete all the objects, since the list\nif gestructor will mot do this automatically for you\nTor(Faolistiter itor? = c.begin(}; dter2 |= c.endi);\n++itorZ])\ndelete [*itor2);\n}\n\nWe see in this example the same basic type of container manipulation, bur we\nhave added the wrinkle of using user-defined objects instead of built-in dara cypes,\n‘This is 2 much more common usage scenario, so we cxamine how it differs in practice\nfrom inserting data by value.\n\nSTL containers do not operate on the data you pass into chem. Rather, they make\ncopies of che data they receive and distribute, In order to negate the cost of copying\nlarge data structures in memory, you'll want to pass pointers to larger, dynamically\nallocated objects, Nacurally, our objects are ridiculously small for example purposes,\nbur they could conceivably be large enough oo seriously affect performance if we\ncopied a large number of them.\n\nThere are a few things to remember when working with pointers to dynamically\nallocated structs or objecss. First, and perhaps most obviously, is that you are respon-\nsible for freeing any allocated memory when you are finished with the objects. Since\nthe container has no idea what eype of data might be used, there is no way for the con-\ntainer to automatically deallocate memory for you.\n\nSecond, and perhaps less obvious, is that many operations appear to fail beeause\nthey are operating direcdy on the object or struct pointers instead of on the objects or\nstructs themselves. Take the list's sort {) function, for example. It operaces by using\nthe < operator co determine value and sort accordingly. Even ifa proper operator is\ndesigned for class Foa, the list still sorts on the actual value of che pointer, mor by the\nvalue of the data in the object.\n\nIt therefore becomes necessary to design your own compare operator that derefer-\nences the pointers before comparing them, See the sample code in the article\n“Resource and Memory Management,” by James Boer, to sec how this comparison\ncan easily be done.\n\nThe third “gotcha” is appropriate to all pointer manipulation routines but alsa\nbears mentioning in che context of STL. When copying containers, remember that\nonly the pointers are being copied, noc the objects. If you create duplicate pointers, it\ncould become extremely difficult to know which ebjects to delete. There are only ovo\nsolutions to this problem: Use smart pointers with your objects or avoid STI. routines\nand algorithms that copy elemencs from container to container.",
      "content_length": 2604,
      "extraction_method": "OCR"
    },
    {
      "page_number": 46,
      "chapter": null,
      "content": "&\n\nDeques\n\nSection 1 Programming Techniques\n\nYou should ako be wary of removing an element from a list while iterating\nthrough che list. Since removing an element co which you are currencly pointing\ninvalidates the itcrater, you must be sure to make proper use of the erase() function's\nreturn value, which retrieves the next valid position in the container, By assigning this\nreturn value wo the old inerator, we essentially skip ahead of the invalidated position.\nHowever, this leaves us with another problem. Since we've already incremented the\niterator to the next position, we run into rouble when the for loop tries co increment\nitagain at the end of the loop. To solve this problem, we remove the increment oper-\nator from che body of the tor loop and place it conditionally inside che loop itself,\nincrementing only when an clement is nor erasecl\n\nIt is often preferable to use algorithms to crase elements from a container instead\nof inerating through them manually. Algorithms such as renove_it() perform the\nsame operation safely and efficiently. Unfortunately, a complete listing and deserip-\ntion of the provided algorithms (and how to create your own) could fill up an entire\nbook, so recommend the resources listed at the end of this article for further srudy.\n\nDegues, or double-ended queues, are designed for situations in which inserting and\nremoving elements from either end of the container must be performed, bur inserting\nand removing elements from the middle of the container is not required (or doesn't\nhave to occur often). Like vecrors, deques can perform insertions and removals at the\nfront and back of the container in amortized constant time, and inserting or deleting\nelements from the middle is somewhat slaw. Deques also allow random access, but\nbecause of the slightly more complex nature of the internal data of a deque, which is\narranged in a linked series of memory blocks, random access is not quite as efficient as\nwith vectors, Unlike vectors, though, there is no mechanism in place for determining\nexactly when additional memory allocations will take place.\n\n#Wincluds <deque>\nFinclids <lostrean>\n\nusing manespace std;\n\nif Typedef the container and iterator names for better\nJ] readability\n\nTypadat deqgue<int> IntDeque;\n\ntypedat [ntBeque: i reverse iterator IntdequeAl ter;\n\nvoid main(}\n\n{\nji Graate a daque container of intagers\nInttaque ¢;\n\nif Fill the deque with 3 different slements\nc.push_ frent(ai;\nc.push front(2);",
      "content_length": 2463,
      "extraction_method": "OCR"
    },
    {
      "page_number": 47,
      "chapter": null,
      "content": "1.4 Using the STL in Game Programming 49\n\n©, push front {i};\ne.push back(3);\ne.push back(2);\nd.push back(i);\n\nif Cycle BACKWARD through the list - special iteraters and\n\nIf notation is necessary to do this.\n\nfor(intDequeAltor riter = c.rbagin(}; ritor [= ¢.rend{);\n++ritar)]\nGout = \"Walue = \" =< {*riter) << endl:\n\nff Prenove the first and last elements\npop Trest();\nc.pop back i);\n\ni! Atteséing elements directly - if needed renenber to\nif check to seo the dequa is net enpty. AGGESsing non-\nff existent elements will lead to undefined behaviar;\nif probably an access violation\n\nif(ic.amety(})\n{\n\ncout << \"Front = \" << ¢.front{) << endl:\ncout << “Back = \" << ¢.back{} << endl;\nI\n}\n\nWe see in the preceding listing the familiar code of STL usage, but with a few\nmew cwises this time. First, lee’s introduce the reverse iterator. You mipht notice that all\nour iterations up to this point have been in the positive direction. Although bidirec-\ntional iterators de exist, it often is much simpler to create a dedicated reverse iterator\nand utilize it a5 you use the standard iterator.\n\nThe reason we need a reverse ineraror i¢ that because of che bounding conditions\nof a container (illustrated in Figure 1.4.1), we cant simply iterate backward and\nexpect to be able to check for the same exit conditions (iter != bagin(}). This\nwould leave the first element in a container out of che iteration loop. Instead, we uti-\nlize a reverse inerator combined with the rbegin() and rend() functions. These func-\nHons work exaetly like their forward-looking cousins, but rbegin{) actually accesses\nthe last element, whereas rend() points to a position im frant of the firse valid entry.\nThis exactly mirrors the forward versions of chese functions. Because the reverse iter-\nator travels backward when the increment operator is applied, you can use the exact\nsame syntax for looping through all elements in a conrainer.\n\nIn this example, we also incoduce che opposites of push_front() and push back({),\npop_tront() and pop_back(}. These functions simply remove an clement from the\nfront or back of a container, respectively, Note thar the value of the clement is not\nretumed. You must we two more functions we introduce in this example to access the\nfront or back elements: tront() and back(). These fictions retum the value of\nthe front or back element in the container. In the example, we check co ensure that\nthe coneainer is not empry using the enpty{) function before trying to aecess these",
      "content_length": 2482,
      "extraction_method": "OCR"
    },
    {
      "page_number": 48,
      "chapter": null,
      "content": "5o : Section 1 Programming Techniques\n\nelements. Accessing clemenes in an empty list resules in “undefined behavior,” which\nyou can expect to probably result in some sort of access violation; pap _front() and\npop_back()simply are “no-ops\" when performed on an empty container.\n\nSTL tmapr are perhaps the most complex (relatively speaking) of the basic containers to\nuse and perhaps the mose versarile, Here we examine maps instead of the other trce-\nbased structures: sets, multisets, and multimaps. Learning the fandamentals of maps\nallows you to easily use che other container types, so we leave char research up to you,\n\nThe map is essentially a walue-pairing container. Two arbitrary types of dara are\npaired as a key/value structure and inserted into the container. Looking up che value\nvia the key then can occur in O¢1og n) time. Although tot quite as efficiene as a hash\ntable, the difference is often negligible and has the advantage of sorting the data dur-\ntng insertion. This process allows iteration of completely sorted data, which is a ben-\neficial consequence of the method of storage (a balanced binary tree, otherwise known\nas a red-black tree)\n\nepragma warning (disable: 47B6)\nFinglude map>\n\n#include <iostream>\n\n#inglude <string>\n\n#include <algorithm>\n\nUsing namespace std;\n\nff This Tunetion abject allows us to compare map containers\ntemplate <clase F, class §>\nclass value equals\n\nprivate:\n& second:\npublic:\nValue_@quals(const $4 s) : second]s)\n{}\nbool opérator(} (pairsconst F, S> ales)\n{ return elem.second == second; }\n\nff Typédef tha container and iterater names for betrar\nif readability\n\ntypedef mapeint, string» isllap;\n\ntypede? isMap::value type iaValType;\n\ntypedet isMap: iterator isWapltor;\n\nvoid main)\n{\n\nisiiap cj",
      "content_length": 1747,
      "extraction_method": "OCR"
    },
    {
      "page_number": 49,
      "chapter": null,
      "content": "1.4 Using the STL in Game Programming Es\n\nI! Insert key / value pairs\nc.insert(isvalType(ido, “One Hundred\") ):\nC.ingert(isvaltype(a, \"Three\" ));\nc.ingert(isValType(150, “One Hundred Fifty\");\nc.ingert(isValType(99, \"Winery Nine\")):\n\n{/ display all the keys and values\n\nTor(isMaplter iter = c.begin(}; iter != ¢.end(); +41tor}\nout << \"Key = \"<< (*iter). first << \", Value = *\n“¢ (\"itor).secomd << endl;\n\nff You can also atcess the map like an ageociative array\nSout << “Key 3 displays value * << c[S].costr() << endl;\n\nff Or insert like this as well\ne123] = “One Hundred Twenty Three’:\n\nif Find and remove a specific element based on tha key\nfelaaltor pos = c.find(i23);\nif(pos f= ¢.end())\nif erasing an lament invalidates any iterators\ni} pointing to it. Calling pos++ now would result in\nJi undgtined behavior,\nc-praseaipos) |\n\nff Find and remove an element based on the value\nPos = find_iffe.bepin(), c.endi), value equals\n“int, string=(\"Ninety Ning\"}};3\nif(pos != c.end(}}\n©.orase (pos);\n\nff Tf you must remove elentents while iterating through\nff the list...\nfor{isMapitor itr = c.begin(); itr = c.and(}; }\n\ni\nif(itr- second == \"Three™)\nG.arase(itres):\nelse\n+eitr;\n}\n\n}\n\nWere introduced to a new intermediare dara type in this example, the nalie_rype,\nwhich represents the key/data pair representing every element im the container. For\nconvenience, we ve typedef ed this type along with che other usual types,\n\nInserting combined key/data values uses the insert() function like any other\ncontainer, with the only difference being that you must insert type nap::value type.\nThe map sorts every entry as it is inserted, so at any given time the container is always\nsorted by keys. We can see this as we iterate through the map and display all the keys\nand their associated values.\n\nAccessing keys and data through iterators means an additional scruccure ta mavi-\ngate through. Dereferencing the iteracor revurns the value_type structure, which has",
      "content_length": 1949,
      "extraction_method": "OCR"
    },
    {
      "page_number": 50,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\nowo data members: first and second. Accessing first gives you the key value; accessing\nsccond gives you the dara value.\n\nIn addition to access through iterators, maps also provide ranclom access via their\nkey values, The map acts like an associative (or sparse) array. Elements can be accessed\nor inserted using the index() operator, Caution must be used when using this opera-\ntor, however. IF you attempt to access an element with an index that does not yet exist,\nthe element is created with a default constructor and ts inserted into the map. This\nmight not be the intended behavior and so is something co watch out for.\n\nMoving. on, we see 2 simple method of finding an element based on the key using\nthe find() function. Since che keys are sorted, this function performs in O(log 1)\ntime.\n\nIf we want to find am clement based on the value, we must do a bit more work. At\nbest, this work will be performed in linear time, since the data is sorted on the key\nrather than the value, The solution to this problem gives us our first look at generic\nSTL algorithms. We use the tind_if() algorithm for this particular problem. The\nfunction requires three parameters: an iterator telling where to begin, am ieraror\ntelling when to stop, and a function telling when the algorithm should return a true\nvalue. The iterators are self-explanatory, but the function abject, or functor, requires\nseme further elaboration.\n\nIn STL, classes with overloaded function operators (did you even know you could\ndo char?) are used in place of functions. This replacement enables both encapsulated\nand type-safe solutions to generic programming problems. The function object pro-\nvided in this example simply compares the second value in a walue_pair and returns\nthe result, Initializing the objece with the result we want to search against provides a\nclean and completely encapsulared solution. Note thar for most solutions, $TL pro-\nvides ready-to-use funesion objects chat you can simply plug into your code. Sec a\ncomprehensive STL book for a listing of different algorithms and function objects\navailable to use.\n\nThe previous paragraph describes the preferred method of searching for values in\na container, but if you must iterate chrough and remove elements manually ina map,\nwe also show you the proper way to do that. Removing elements while iterating\nthrough a map poses a special problem because for speed reasons, the designers of\nSTL neglected to have the erase() function return the value of the next valid posi-\ntion, as other containers do. Unfortunately, because of this failure, we cannot use the\nsimple method of removing elements, as shown in our second code snippet. Instead,\nwe have co resort to a bic of wickery to make sure we don't invalidate our iterator,\n\nIn this example, instead of incrementing the iterator inside the for loop, we do it\ninside the body in a conditional manner, Notice thar when an element must Le\nerased, we post-increment the iterator when passing it 2% the parameter to erase().\nbur ifan element doesn't need to be erased, we perform the standard pre-increment\noperator instead. Because of the order in which the operations occur, this method\nallows safe ineration without having 00 feSOrT tO UsIneE Temporary iterators. Unfortu:",
      "content_length": 3293,
      "extraction_method": "OCR"
    },
    {
      "page_number": 51,
      "chapter": null,
      "content": "1.4 Using the STL in Game Programming Bs\n\nnately, the necessity of this sort of coding creates far more possibility of bugey code\nthan if the designers had just sacrificed a bit of speed in the erase() function, With\nany luck, the standards commitcee will consider revising this function in che furure to\navoid these types of kludgy workarounds.\n\nThis might be a good time to answer a question you might want vo ask, namely,\n“Why do you always use the pre-increment operator in your iteration loop?”\n\nThe answer is efficiency, The post-increment operator must retum a copy of its\nold value, so ir might require the use af a temporary object. The owo solutions work\nthe same way, but unless chere’s a specific reason to use the post-increment (or post-\ndecrement) operator, as in the previous example, you should prefer che pre-increment\nand pre-decrement operators.\n\nStacks, Queues, and Priority Queues\n\nWe lump together stacks, queues, and priority queues because using them is simple\nenough that they require line additional explanation. These containers are really\nexamples of conteiner adapters because they are implemented as restricted interfaces\non top of existing containers.\n\nStacks.\n\nThe STL stack class provides thie primary members—pusht{ }, pop, }, and top¢}—for\nadding and removing elements from the container, These member functions respec-\ntively push an element on the stack, pop ir off the stack, or retrieve the top element.\nTo check the current stare of the stack, size() and empty{} are provided,\n\nThe stack is implemented as a deque by default, but it allows you to change the\nimplementation in the constructor.\n\nff Implenents a stack with deque aa the underlying\nif container type.\natack<int> cr\n\nff? Tnplements a stack with a vector as the underlying\ni! container type.\nStacksint, veetortint> > cr\n\nNote that using a vector might noc be as poor a choice as ir seems, because\npush{), pep(}.and top() actually map to push_back{), pop_back(), and back). Any\ncontainer that supports these functions can be used as the underlying implementation\nfor the stack class, Notice that in the second line of code in the preceding example, we\nmake sure to put a space between the cwo greater-than operators, Otherwise, they\nwould be incorrectly parsed as a single stream operator, >>.\n\nIt is important to alsa lenow that the stack class, like many STL containers,\nprefers speed to safery. Thus, the class assumes that when you call pop() or top(), a\nvalid element actually exists. It is therefore importanc ro always remember to use",
      "content_length": 2542,
      "extraction_method": "OCR"
    },
    {
      "page_number": 52,
      "chapter": null,
      "content": "fa | Section 1 Programming Techniques\n\nsize() of empty() to verify thar a stack is not empry before performing these opera-\nTOs on it. Queuss and priority queues work in the same manmer, so che <ame warn-\nings apply to these containers as well.\n\nGusues\n\nThe quewe class works much like the stack class except that elements are pushed onto\nthe back and popped off che fone. The following members are defined for the queuc\nclass for element manipulation: push(}, pop{), front{}, back(). backi) refers to the\nlocation in which elements are inserted, and freat() refers to the location from which\nelemenss are removed.\n\nLike the stack class, the queue also defines size(} and empty) to manage the\nsize. As with the stack class, you can specify a container other than the default deque\nto be used as the underlying implementation. Unlike stack, a vector used with a deque\nmakes a poor choice duc to the bad performance when inserting elements at the front\nofa vector. However, a list might make sense in some situations.\n\nPriority Queue\n\nThe prierity quewe works identically to a queue but differs in ome important respect:\nall inserted elements are immediatehy sorted in descending order based on a compari-\nson using the < (less-rhan) operator. Because of the sorting functionality, an addirional\n\nir parameter ts offered in the constructor, allowing you te override the defaule <\noperator with your own function. This ability could come in especially handy if you\nare inserting pointers to objects instead of passing in che objects by value. Avoiding\nsorting the queue based on the value of che pointers requires writing a functor class\nthat calls the < operator after first dereferencing the pointers. There is an example of\nthis functor in the article “Resource and Memory Management,” with code sample\nprovided.\n\nSummary\n\n———\nThe STL is a powerful new tool available for C++ programmers. By understanding\nboth ics strengths and irs limitarions, you can make the most of the features now avail-\nable without compromising the speed or integrity of your code.\n\nEnure books have been written explaining how to use the STL. It is therefore\nobviously impossible to think thar chis article could de justice to the broad function-\nality that exists in this library. Ifyou want to fully utilize che power of STL, there is no\nsubstitute fora goed reference book. Several excellent tutorials and references are\nlisted in the following References sectian.",
      "content_length": 2444,
      "extraction_method": "OCR"
    },
    {
      "page_number": 53,
      "chapter": null,
      "content": "1.4 Using the STL in Game Programming 55\n\nReferences\n\n[Nicolai9] Josuctis, Nicolai M., The C++ Standard Librag-A Tatorial and Reference,\nAddison Wesley Longman, Inc, 1999.\n\n[Srroustrup97) Stroustrup, Bjarne, Te C++ Programming Language, third edition,\nAddison Wesley Longman, Inc, 1997,\n\n[Breymann93) Breymann, Ulrich, Designing Components with she Ca STL, Addison\nWesley Longman, Inc., 1°98,",
      "content_length": 392,
      "extraction_method": "OCR"
    },
    {
      "page_number": 54,
      "chapter": null,
      "content": "A Generic Function-Binding\nInterface\n\nScott Bilas\n\nSeripting engines and nenwork Messaging have an Important requirement in com-\nmon: They must be able to interface with the game's functionalicy in a type-safe, effi-\ncient, and convenient way. This article provides a method for exporting functions and\nthen binding to them dynamically ar run time. It does so withour sacrificing run time\nspeed of convenience.\n\nRequirements\n\nThe basic requirement for our scripting engine is that we can call a function and pos-\nsibly pass it parameters. For this task, we need to know the function's name, its loca-\ntien in memory, and che paramerers it takes. The types for these parameters must be\ntypes that we support direcoly in the scripting engine as part of che language. Let's\nSune we support bool, float, int, string, and void.\n\nThe basic requiremenc for our network remote procedure calls (RPCs) is chat we\nean call a function on a remote machine and possibly pass it parameters. Given that\nour machines will probably be running the code ar different memory addresses, we\ncant pass function pointers over the network and must instead convert them into a\ntoken that both sides recopnize, For this token, we use a serial ID that can be con-\nverted back and forth to an actual function poincer very quickly. In addition, we need\nto know how to recognize strings and memory pointers in the parameters so thar the\ndata they point to can be packed at the end of the RPC: chunk for handoff to the ner-\nwork transport.\n\nFor convenience, we should be able to simply call an RPC-capable function wirh-\nout having to do any explicit parameter packing from the caller's code. If the call is\nmeant for another machine, the called function should automatically Sem 11s para-\nmeters and serial ID to the network transport, then recum immediately, If meaner for\nlocal execution, it would just directly execute the code. The dispatcher on the remore\nmachine would look up functions based on the serial 1D and then call them directly\nafter resolving to a function pointer:",
      "content_length": 2050,
      "extraction_method": "OCR"
    },
    {
      "page_number": 55,
      "chapter": null,
      "content": "15 A Generic Funection-Binding Interface 57\n\neS ese\n\nPlatform Concerns\n———$—$—————\nThis is a good place to paint out char the sample code provided with this article is very\nspecific toa particular platform: Visual C++ 6.0 run ning on an x86 version of Win32.\nIn particular:\n\n1. There's a little bit of assembly code in here thar is obviously x86 specific.\n\n2. The name mangling and unmangling and how calling conventions work is spe=\ncific to Visual C++ 6.0.\n\n3. 1 use the specific way that Win32 image (DLL/EXE) expons work.\n\nfit the very least, the conceprs if nor the implementation are still portable co other\nplatforms. All che x86 assembly code can be converted to any other instruction ser,\nalthough you need knowledge of the calling conventions of that platform for ix wm\nwork, Dynamic link libraries (DLLs) are hardly unique to Win32; all this article\nneeds is a table thar maps exported function names to memory addresses, Finally, you\nshould be able to figure out how other compilers (especially open source compilers\nsuch as GCC) mangle and unmangle names.\n\nAttempt #1\n\nLer's get back to the cask ar hand. We are trying to find a way to export game func-\ntionaliry in a gemeric way so thar it can be called from seripes or passed over the net-\nwork as RPCs. Here is a really simple solution:\n\nvoid Fool void }:\n\nvoid Bari void }:\ni ecarir\n\nenum @Funotion\nFUNCTION_FoO,\nFUNCTION BAR,\n\nPipettes\nhe\n\nftruot Function\ntypedat void (*Prec}{ vodd J;\nconst char* @_Mame;\nProc © Proc;\nFunction m_Funetian;\n\nhs\n\nFumetion g Funetions[]) =\n\nq\n\n{ \"Foo\", Foo, FUNCTION_FOD, +,\n{ “Bar\", Bar, FUNGTION_BAR, +},",
      "content_length": 1606,
      "extraction_method": "OCR"
    },
    {
      "page_number": 56,
      "chapter": null,
      "content": "56. Section 1 Programming Techniques\n\nUF erates\nhi\n\nThe eFunetion enumeration provides a serialized list of unique IDs for all avail-\nable functions, The Function structure maps a text name onto a function poincer and\nunique ID. Finally, the g_Functions array is the set of all published functions in the\nsystem. Our example function exports are, of course, Foo and Bar.\n\nOur imaginary scripting engine can search through the g_Funcetions array when\nits compiling a script to resolve function calls by name and then call che procedure\ndirectly ance it is found. Flopefully, this lookup would be done through an index for\nspeed. Our imaginary network-messaging system could convert function calls into\ntheir eFunction IDs and use chose [Ds to resolve the RPC on the other machine. It's\neasy and simple.\n\nThis solution would work fairly well but suffers from a critical drawhack: all\nfunctions must be the same—they must all take ne parameters and return veid. We\ncould change che Function: :Froc rype so thar the functions could ar lease return a\nvalue and take some parameters. However, this is not an acceptable solution, because\nits highly unlikely that all published functions will have identical signatures. Besides\nthat, its a very inconvenient limitation, considering the large and varied function sets\nrequired of modern games.\n\n(One way co work around this problem is to cast parameters back and forth from\ntheir real types to the common types required by Function::Proc. We could, for\nexample, have cach function pass two or three unsigned integers and pack our real\nparametets into them. This is a common and efficient technique useel by application\nprogramming interfaces (APIs) for callbacks such as window procedures. However, it's\nunsafe and can't be supported very well by a general-purpose scripting language. Ir\nwould also be impossible co figure out which of the generic parameters are pointers, a\nflaw that makes passing the parameters over the network for RPCs very difficulc.\nHacks are on the horizon. Let's wry something else.\n\nAttempt #2\ncic el i a kg ered ee yy\n\nA.common partial fix to the problems of Attempt #1 is wo provide a package class char\nsiores the parameters in an internal buffer and provides add and excrect methods to\nserialize data in and our of the object:\n\nStruct Parameters\n\nste: ivector «unsigned char> m_Data;\n\nbool ExtractSool (¢ woid }:\naint ExtractInt ( wold 9;\nfinat ExtractFloat ({ wold }:\n\nconst char* ExtractString! wold }:",
      "content_length": 2475,
      "extraction_method": "OCR"
    },
    {
      "page_number": 57,
      "chapter": null,
      "content": "1.4 A Generic Function-Binding Interface\n\nig\n\nvoid AddBool { bool };\n\nWold AddInt { amt 4};\n\nWold AddFloat { flaat J;\n\nveld AdGString( const char® j:\nhi\n\nvoid Foo( Parameters& params }\nint param = parass-ExtractInt (1:\n\nfloat param? = parans-ExtractFloat/);\nff Use parami, parang...\n\n}\nveid Bar( Paraneters& params 13\nAga\n\nnun GFunetion\n\nFUNGTION_ FOO,\nFuNGT TOM_BAR,\nhi\n\nstruct Function\ntypedef void (*Proc){ Paremetars& };\n\nStditetring m_Nane;\n\nProce m_Proc;\n\naFunction m_Function;\nHi\n\nFunction g_Funetions|] =\n\n{ \"Foo\", Foo, FUNCTION_FOO, },\n{ \"Bar\", Bar, FUNCTION_BAR, 4,\nfe eee\nhi\n\nNow we can pass generic parameters to any function—a big improvement! This\nmethod, however, has its own set of drawbacks, some of which ir shares with the first\nathem pr.\n\nFirst, this solution is inherently nontype-safe and dangerous because of its\nadd/extract functions, The C++ compiler cannot check the types at compile time\nbecause it doesn't know whar's supposed to go into a Parameters object; by its very\ndefinition, it can hold anything. The best we can do is provide some basic run-time\nchecking by storing a type each time an Add method is called and then checking those\ntypes from the called function cach time an Extract method is called. This isn't very\nefficient and can be error-prone. Furthermore, any time the function paramerers\nchange, every call to that function must be searched for and updated to match. The\ncompiler can't detect changes like this, and the manual search-and-replace function is",
      "content_length": 1503,
      "extraction_method": "OCR"
    },
    {
      "page_number": 58,
      "chapter": null,
      "content": "60 Section 1 Programming Techniques\n\nanother error-prone process, Missing ome changed call by accident could introduce\nlarent and difficult-to-find bugs.\n\nCalling functions in this way is also tedious and inefficient. The add/exnract\nprocess adds a lot of memory copying and verification overhead. In also has serious\nengineering time overhead. A simple function can no longer be added vo an export\nlist; it must now change its function signature and have a prologue chat converts a\nParameters object into local variables. Likewise, callers must consorwen the Parana -\nters object co begin with, although this requirement can be made a little easier\nthrough some clever cemplate work. Still, there must be a better way.\n\nHalf of the Solution\n\nLet's ssart at the end and work back to the beginning for the solution, What we're\nreally looking for here is a function specification table that gives us everything we\nneed to know about how to call a particular finction in a completely generic way. We\nneed to be able co set up the stack with a chunk of memory (ie., push che parame-\nters), jump directly co the function for the call, and then retrieve the return value co\npass back to che original caller. Por this task, we need to know the function's name,\nlocation in memory, renurn type, parameter types, and calling convention:\n\nif funetion specification\nstruct Function\n{\n{J simple variable spec\nenun eVarType\n\nVAR_WOID, VAR_BOOL, VAH_INT, VAA_FLOAT, VAR_STRING,\nhi\n\niJ possible calling conventions\nenum eCallType\n\nCALL CDECL, CALL_FASTCALL, GALL_STOGALL, GALL_THISGALL,\n}3\n\ntypedef std:ivector ~eVarType* Paranvec;\n\nStd: tetring m_Hane;\n\nvoid\" m_Prac;\n\nungzigned int m Serialip;\n\neVarType m_Returntype;\n\nParaavec n_FParantypes;\n\neCallType n_CallType;\ni\n\nTYpedeat ald: i vector <Function= Functionvedc;\n\n/} the global cet of specifications for exported functions\nFunctionVec g Functions;",
      "content_length": 1888,
      "extraction_method": "OCR"
    },
    {
      "page_number": 59,
      "chapter": null,
      "content": "14 A Generic Function-Binding Interface 61\n\nAssume for the moment that we have a way to fill g Funetions with specifications\n\nfor all our exported functions (I'll explain how to do thar a little later). Now, how can\nwe use this information to actually call functions? First we must know how our plar-\nform's various calling conventions work,\n\nCalling Conventions\ner\nYou can check your compiler’s documentation co see how its calling conventions\nwork, On Visual C++ for x86 Win32, all function calls have certain things in com-\nmon:\n\nThe stack grows downward, and all parameters are pushed from right to left. In\neffect, parameters go from left to right on the stack for increasing memory\naddresses.\n\n- The stack pointer (esp) always points to the lowest memory address of the stack,\n\nwhich unfortunarely has the name of “top.” It must be dword (4-byte) aligned, so\neach parameter pushed must be likewise aligned to adword. The push instruction\ndecrements esp first, chen stores the data. The Pop instruction loads data first,\nthen increments esp.\n\n- Parameters passed by value are pushed on the stack in their entirety. Doulsles (8-\n\nbyte) and user-defined types are just copied onto the stack. The memory\naddresses contained by references and pointers are directly pushed onto the stack.\n\n- Simple non-Aloat reruen values such as integers and pointers are stored in the eax\n\nregister. Etght-byte suructures are recurned in edx and eax as a pair. Floats and\ndoubles are returned through the FPU in sto. Retum values for user-defined\ntypes have their addresses pushed onto the stack last, but they will also be\nreturmed in eax,\n\nHere are the treo calling conventions that we'll be slipporting:\n\n_edecl. The caller cleans wp the stack, meaning chat it is responsible for pop-\nping its own arguments off the stack after the call completes. This convention is\nrequired for variable argument functions because the called function doesn't nec-\nessarily have the information it needs to pop the correct number of arguments.\nThis is the default calling convention for static and giobal functions in € and\nC+4.\n\n—Sstdeall. The called function cleans up the stack. This is the standard conven-\ntion used for Win32 API calls, probably because ir is more efficient in terms of\nclient code size.\n\nSupport for the other three calling conventions (_tasteall and the neo this-\n\nall variants) is beyond the scope of this article, but it could be worth looking into\nand supporting, depencling on the application.",
      "content_length": 2494,
      "extraction_method": "OCR"
    },
    {
      "page_number": 60,
      "chapter": null,
      "content": "62 Section 1 Programming Techniques\n\nNow we have enough information to do generic function calls with these ovo\nconventions. We also need a function to retrieve a floating-point value from the FFUs\nSTO register (as is convention) co be stored in a generic return value. Here are some\n\nfunctions that do the dirty work:\nDWORD (all edeci{ const void‘ args, size_t sz, OWRD func }\n1\nCAD re: ff here's our raturn value...\n__ am\n{\nmov ECx, Sz fi gat size of buffer\nmov 854, args ff get buffer\nSub bsp, #ox ff allocate stack space\nmov edi, ¢sp ff start of destination stack frame\nshr ocx, 2 if make it dwords\nrep powsd ff copy parars to real stack\ncall [fine] ff call thea function\nmv ro, ax if save tha return value\nadd 84f, 42 ff restore the stack pointer\n}\nreturn ({ re }:\n}\nWORD Call stdeall( const wold* arge, aize_t sz, O@OAD func }\n{\nCwoAo re; ff fere's our return value...\n50\n{\nmov CK, Sz ff get size af buffer\nmov O51, args ff get buffer\nsub) 6OSp, ocx {f allocate stack space\nmov oi, asp {f start of destination stack frame\nshir Ge“, 2 if Bake it dwords\nrap oo mowsd if copy it\ncall [func] ff call tha function\nmov Tc, gam ff save tha return value\n}\nreturn { re ji\n}\n_Gecispeac { maked ) DWORD GetSTo( woaid 4\n{\nCADAD Ti ff temp var\n__#5m\n{\ntstp dword ptr [fT] Ii} pop STo inte f\nmoy eax, dward ptr [f] // copy inte pax\nrat Ii done\n}\n}\n\nNow, given a function's address and some parameters stored in a memory buffer,\nwe can calla function in an almost completehy generic way.",
      "content_length": 1478,
      "extraction_method": "OCR"
    },
    {
      "page_number": 61,
      "chapter": null,
      "content": "1.5 A Genoric Funection-Binding Interface ; 63\n\nCalling the Function\n\nBefore making the actual call, our client subsystem (scripting engine, network RPCs,\nete) needs to doa little preliminary work. First it looks wp the instance of the Func-\ntion structure within g Funetions that corresponds to che function it will be calling.\nFor the scripting engine, we want to verify that the function's specification matches\nup with what we're expecting: Check and convert any parameters if necessary, or give\nan error if its a mismarch. This procedure could be expensive and should be done\nduring the seript compilation phase, and not in real time.\n\nLooking up the Function instance for network RPCs isa little more complicated.\nA good way to set chis up is ta intercept the call fom within the function thar is des-\ntined to be called over the network. Look in g Functions for the Function instance\nwith the highest o_Proc value thar is less than the current instruction pointer (eip) to\nfigure owt which funcrian is currently being called. Here is an example:\n\n—Heelspec { naked } DWOAD Getler void }\n\n{\n__ S50\n{\nHOV €4x, daord ptr [esp]\nreat\n}\n}\n\nff sample APG able ftunetion\nvoid MetFaa( bool sand, int i}\n{\nff FindFunction() should look in g Functions for highest “a_Proc'\nff [ese than *ip\" and return it\nState Const Function* sFunction = FindFunction( GetEIF() TF\nif ({ send }\n{\nff AouteFunction(} should pack up the Parameters and send the\nff PeQuest aver the network.\nRouteFunction{ sFunction, (BYTE*)asend + 4 1;\nreturn:\n\n}\n\nff... normal @xecution of Methoo\nprintt( “i = Sain\", 2 pz\n}\n\nThe next step is to construct the parameter buffer ro pass to che function. Fora\nScripting engine based on a virtual machine, this is easy; all our parameters are already\non a dword-aligned virtual stack, We can simply take the address of the start of the\nparameters and pass it along. For network RPCs, it will be a litcle more difficult. We\ncant pass pointers generically over the network, but we can make a special case for\nsirings, s0 analyze the m_ParasTypes for VAR_STAING types and append the contents af\nthe string to the end of the buffer thar gets sent to the network transport. On the",
      "content_length": 2181,
      "extraction_method": "OCR"
    },
    {
      "page_number": 62,
      "chapter": null,
      "content": "6a _ Section 1 Programming Techniques\n\nreceiving end, resolve the pointers to point to the appended data, and then use the\nstart of the chunk as the beginning of the parameter buffer.\n\nNow thar we have the Function instance and our parameter buffer, we call either\nCall_edeol() or Call_stdcall(), depending on n_CallType, passing in the parameter\nbuffer and m_ Proc. Then we can either use the recurn value or call GetsTo() co ger ic if\nm_ReturnType is a float or double. Thar’ all there is co calling a function generically!\n\nCompleting the Solution\n\nUntil now we've been assuming that the g_Functions array has already been set up.\nLet's go back and fill in this hole now, There are several ways co fill out the g_Func-\ntions array. Perhaps the easiest to implement bur least safe to use is co apply macros\nof a function to set it up:\n\nfloat Foo{ int, const char* |;\nint Bar( void j);\n\nvoid SatupFunctionexporta( void |\n\n{\n\n{\nFunction function;\nfunction .m_Name = \"Foo\"}\nfunction.m Prac = Fes\nfunction.g Serdalio 9 = g Functione.siza();\nfunction. AeturnType = Function. avarType: :WAR_FLOAT;\nfunction. Paramtypes . push_back{ Fumction.eVarType::VAR_INT };\nfunction.n_ParasTypes . push _back( Function, eVarType:-VAR_STAIMG };\nfunction. mGallType = Function. eGallType::GALL COeci;\n@ Functions.push_back( function );\n\nI\n\n{\nFunction tunction;\nfunetion. m Mane = \"Bar\";\nfunction mi_Proc = Bar;\nfunction.m SarisilIp = g Functions.size();\nfunetion.© Returnlype = Fumetion.eVarType: :VAA_INT;\nfunction.m_Calltype = Function.eCallType: iCALL_CDEGL;\ng Functions.push back function };\n\n}\n\ni\n\nThis example is illustrative but not exactly optimal. It could be improved with\nsome helper functions and macros to make it easier to add new functions to the table.\nHowever, it will always be unsafe and inconvenient. Adding a new function te the table",
      "content_length": 1837,
      "extraction_method": "OCR"
    },
    {
      "page_number": 63,
      "chapter": null,
      "content": "1.4 A Generic Function-Binding Interface 65\n\nmeans that someone has co write some code that specifies its rypes, name, and calling\nconvention. (Changing a function (adding 2 parameter, for example) without updating\nthe table could ineraduce some nasty and hard-to-debug problems. It isa locof work to\nkeep the function specifications in sync with the actual function prototypes.\n\nWe need 2 way to build this table automatically and safely climinate these prob-\nlems. Fortunately, the C++ compiler already has all the information we need. While\nparsing the function's protorype, the compiler builds an internal representarion of the\nfunction—its return type, parameters, calling convention, and so on—cxactly whar is\nrequired to eenstruct a function specification! Unfortunately, we dont have access to\nthis information from within the code, and besides, all char information gets thrown\naway when the linker constructs the final EXE, We could probably find a way DO use\nthe PDB (debug symbols database) co query for whar we need, but we can't ship\ndebug symbols with the game. Besides, we wouldn't have an easy way to tell which\nfunctions are for export and which aren't.\n\nCombining the export table functionalicy of a Win32 image file with the C++\nlanguages name-mangling faciliey gives us the informacion we require. IF we tag a\nfunction for export using dhe __daclspec( dllexport } keywords, thar function's\nname and address will appear in the EXE (or DLL) export table, In addition, because\nthis is a (C++ application, those names will be mangled to support type safety and\noverloaded name resolution, Mangled names are encoded with all the information we\nrequire, so all we need is to decode che names into a form we can understand and then\nuse that to build the Function encry co add to g Functions.\n\nThe name-mangling format is completely implementation specific and undocu-\nmented, and it even changes from release to release of Visual Ces, sa attempting to\nreverse-chginesr it is probably not a goed idea, In's also Linnecessary; Microsoft\nexported a name-unmangling function called UnDecorateSymbolNane() fram borh\nImageHIp.dil and DbgHelp.dil that does exactly this. So if we were co cake our Foot}\nFunction from the last sample and DLL-expart it, the Entry 7FooRavAMHPADEZ would\nappear in the EXE's exporr table. If we unmangle the name, here's whar we get back:\nfloat _edecl Foo(int,char const =). Now this is something we can easily parse\nand convert to a Function entry for addition to our 9 Funetions table.\n\nSo now our procedure for building g Functions is:\n\n1. Tterare over all entries in the EXE's export table, and retrieve cach function's\naddress and mangled name.\n2, Unmangle each name to get a function protetype in text form.\n3. Parse che function protorype en retrieve name, type, and calling comvencion infor-\nMa thor.\n4. Store the results in a new entry within g Functions. Repeat for cach export.\nIterating over the exports to get the function addresses and mangled names\nrequires knowledge of the binary format of Win32 Portable Executable (PE) forrat\nfiles. A specification for this format is available from the Microsoft Developer Net-",
      "content_length": 3166,
      "extraction_method": "OCR"
    },
    {
      "page_number": 64,
      "chapter": null,
      "content": "66 Section 1 Programming Techniques\n\n—— EEE\n\nwork Library (hop://msdn.microsoft.com). Search for the ~.edara” section within the\nlibrary entry for the Microsoft Portable Executable and Common Object File Formar\n\nSpecification to find the structure of a Win32 export table.\n\n‘There's one final lictle detail. The entries in the export table point wa jump table,\nwhich in tum points to the actual functions. This detail isn’t important if all you're\ninterested in is binding to functions and calling them generically. However, if you\nneed to be able to do a reverse lookup and convert eip from within the called function\nto find its Function instance (required for RPCs, as described eatlier), you need vo get\nthe actual address of the function for comparison, noc the address of che enery in che\njump table. This is easy enough: Dereference the address given by the DLL export\nentry to find the jump table entry. The first byte will be ox&9 (jmp), followed by a 4-\nbyte offset to the actual entry point of your function. ‘Take the address given by the\nDLL export entry, add 5 for the full jmp instruction, add che 4-byee offset, and this\nwill be the address of the entry point of pour funcuion. This address can then be used\nfor reverse lookup to find the Function instance from within g_Funetions.\n\nConclusion\n\nWe now have everything we need co call functions in a completely generic way. In\norder to publish a function in the system and allow other subsystems such as script-\ning and necwork RECs co bind to it, we simply tag it with declspec( dllexport }\n(this verbose tag is best wrapped in a macro to reduce clutter). At run time, the\nfunction-binding publisher iterates over the Win32 export table and extracts name,\ntype, and calling convention information from cach entry, Other subsystems can\nlool up functions by memory address, name, or serial ID and call them generically\nusing Call_edeel() or Call_stdeall(}.\n\nThis seems like quire a bit more work wo implement than mecessary, and for\nsmaller projects with small export sets, it probably is. Larger projects, on the other\nhand, will probably be changing constantly. The good news is that, once the basic\nwork is done, adding new functions co the system is as simple as tagging them for\nexport, and chey'll immediately be available. This process more than pays for itself\nand is a powerful ability to give any engineer on your team. When combined with a\ngeneral-purpose scripting engine, the process can be turned into a useful debugging\ntool as well as serving the content-specific needs for which it was originally wricten.\n\nIn the interests of space and simplicity, we have left out many of this article's fea-\ntures. The generic function-binding concept can be taken much further in a variety of\nways. It ean easily be enhanced to include support for pointers and references, variable\narguinent functions, and passing more than just strings over a network. User-defined\ntypes could be supported for RPC packaging through a serialization interface char can\nbe detected and called directly when post-processing RPC parameter buffers for out-\nbound network buffers. In addition, support for calling class member functions is a\nvery useful tool and can be easily added. Finally, one fearure thac might of might not",
      "content_length": 3275,
      "extraction_method": "OCR"
    },
    {
      "page_number": 65,
      "chapter": null,
      "content": "1.5 A Generic Function-Binding Interface 67\n\nbe necessary isa coal char will post-process an EXE, stripping off the exports table and\nconverting it into a native data formar for direct import into g Functions. This tool\ncould be necessary either for SECUMIY teatans (to prevent cheating. perhaps) ar to\nmake it unnecessary to ship ObgHalp.dll with the game.\n\nReferences\nee\n\nMicrosoft Developer Network Library, http:!/msdn.microsoft.com.",
      "content_length": 437,
      "extraction_method": "OCR"
    },
    {
      "page_number": 66,
      "chapter": null,
      "content": "1.6\n\nA Generic Handle-Based\nResource Manager\n\nScott Bilas\n\nAll computer applications are databases. They spend most of their time juggling data\nresources—creating, desroying, caching. modifying, querying, saving, and restoring\nobjects of various types. Games typically contain multiple rypes of databases, each of\nwhich is generally hard-coded for each different case, wo keep things speedy, Some\nexamples of game databases are file systems, texcure managers, font managers, and\nfame actor managers. On top of those, there is a wide variety of domain-specific dara-\nbases thar completely depend on the game's genre and content.\n\nAvresource database that's built into all C++ games is the basic object memory man-\nager. A programmes calls new to construct a new abject and passes ins pointer around\nso thar other objects can pass it messages. When the object is no longer needed, some-\nbody deletes it, and its resources ane retumed mo the system. This method works very\nwell in general, bur it breaks down when we have to worry about shared resources.\nThis is where we need a more specialized databace,\n\nLet's use a fone abject for our example. Ar minimum, the font consists of a bit-\nmap and a set of specifications, such as che XY (or £64 locations of its character cells,\nso the graphics system can render it to the screen. Such an object is fairly heavy duty\nin terms of memory usage and creation time. Different systems in the game, such as\nthe development console and a text control within the GUI, want to use fone objects,\nbur we can't have each system creating its own local copy of the font objece, Obvi-\nously, that would be slow and consume a lot of memory. To solve this problem, we\nneed to come up with a way to share font objects. Qur solution is called che Fontigr\nand features methods thar get pointers to fonts, loading them on the fly and caching\nthem until they are no longer needed. The FontMgr is made available from a global\nlocation (possibly as a singleton; see the article “An Automatic Singlecon Utilicy”) and\nis responsible for all che fone objects in the system,\n\nWhat we're really talking about here is a specialized database. The Fontwgr is\nresponsible for juggling font resources and, now that it’s considered an API. suddenly\ntakes on additional responsibilities as the central clearinghouse for fonts. Whar if\nsomeone tells the Fontégr to delete a font to free Up resources, but some systems in",
      "content_length": 2428,
      "extraction_method": "OCR"
    },
    {
      "page_number": 67,
      "chapter": null,
      "content": "1.6 A Generic Handle-Based Resource Manager 69\n\nthe game still have pointers to it? How do we guarantee safery of the system without\nsacrificing performance? Will we he copy-pasting this code again (with slight tweaks)\nwhen it comes time to build che MousePointertigr? This article presents a simple, safe,\ngeneric, and efficient way to manage controlled resource objects.\n\nThe Method\n\na\nThe job of a resource manager is to create resources on demand, hand them our ro\nanyone who asks, and then eventually delete them. Handing out those resources as\nsimple pointers is certainly easy and convenient, bur it’s not a very safe way to do ic.\nPointers can “dangle”; one part of the system can tell the resource manager to delete a\nresource, which then immediately invalidates all ocher outstanding pointers. There's\nno good way to prevent the dangling pointer problem from happening, and the only\nway we would find our that someone was attempting to dereference a deleted abject is\nwhen the game crashes. The problem is that, with pointers, there's no way to Imew\nhow many references are outstanding, given thae cients can copy the pointers as\nmany times as they like without telling the manager abeut it.\n\nAnother problem is that the underlying data organization cant change with\npointers. Any reallocation of butters immediately invalidates all outstanding pointers.\nThis becomes especially important when you are saving the game to disk. Pointers\ncant be saved ro disk, hecause the next time the game ts loaded, system memory will\nprobably be configured differently or you could even be on a completely different\nmachine. The pointers must be converted into a form that can be restored, which will\nprobably be an offset or a unique identifier of some sor, Working around this prob-\nlem ist't exactly crivial and can require a lot of work to support in client code.\n\nSo it's plainly not a good idea for a safe and flexible resource manager to be hared-\ning out pointers. Rather than using pointers or attempting to write some kind of\nsuper-intelligenc, overly complicated “smart pointer,” we can add one layer of abstrac-\ntion and use handles instead, putting the burden on the manager class. Handles are an\nancient programming concept that APIs have been using with great success for\ndecades. An example of a handle is the HANDLE type returned by the GreateFile: ) call\nin Win32ss file system. A file handle, representing an open file system object, is cre-\nated through the GreateFile;) call, passed to other functions such as AeadFile(} and\nSetFilePointer{) for manipulation, and then finally closed off with CloseHandle().\nAttempting to call those functions with an invalid or dosed handle does not cause a\nerash; instead, ir returns an ester code, This method is efficient, safe, and easy to\nunderstand.\n\nHandles almost always fir into a single CPU register for efficient storage in col-\nIcctions and passing as parameters to functions, They can be easily checked for valid-\niry and provide a level of indirection chat allows the underlying data organization to\nchange withour invalidating any outstanding handles. This has significance advantages\nover passing around pointers, Handles can also be easily saved to disk, because the",
      "content_length": 3234,
      "extraction_method": "OCR"
    },
    {
      "page_number": 68,
      "chapter": null,
      "content": "To Section 1 Programming Techniques\n\ndara stmuctures they refer co can be reconstructed in the same order on a game restore.\nThis facility allews che handles ta be stored directly, with no conversions Necessary,\nbecause they are already natively in unique identifier form.\n\nThe Handle Class\n\nA fast and safe way to represent handles is to use an unsigned integer composed of pwo\nbitfield components (this class appears in Listing 1.6.1). The first component\n(=_EIndex) is 2 unique identifier for fase dereferencing inte the handle manager's data-\nbase, The handle manager can use this number however it likes, bu perhaps the most\nefficient use is as a simple index into an std::vactor. The second component\n(= Magic) is a “magic number” that can be used to validate the handle. Upon derefer-\nencing, the handle manager can check to make sure that the magic number compo-\nnent of the handle matches up with its corresponding entry in the database.\n\nThe Handle class is very simple and really doesnt do much except manage the\nmagic number. Upen calling Init(), the handle is given the next magic number,\nwhich automatically increments and wraps around, if necessary. Nowe chat che magic\nnumber is not intended to be a GUID. Its purpose is 00 serve asa very simple and fast\nvalidity check, and it relies on the high improbability of a condition arising where ane\nobject happens to have the same index and magic number (via wrapping) as anocher.\nThe magic number of zero is reserved for the “null handle\" where che handle’s data is\nzero, The default Handle constructor secs itself to null, a stare that returns true on an\nIsWull() query. This is convenicot to use for am erpor condition; a function that cre-\nates an object and retums a handle to it can simply return a null handle co indicate\nthat an error occurred.\n\nIn most ways, the Handle class acts as a read-only unsigned inceger. It's not\nintended to be modified after being created, although it can safely be assigned back to\nnull to reset it. Morice that Handle is a parameterized class, raking a TAG rype co fully\ndefine it. The template parameter Tag doesn't do anything except differentiate among\ntypes of handles; an object of type TAG is never used anywhere in the system. The\nmotivation here is oype safety. With Handle mot parameterized, a handle meant for\none type of resource could be passed to a function expecting a handle to a different\ntype of resource, withour a complaint from the compiler. So to keep things safe, we\ncreate a new handle type, taking any unique symbol and using it for the parameter.\nThe TAS type can really be anything so long as ic is unique across Handle types, but it’s\nconvenient co define an empty struct and use thar in the typedef for a handle, like this\ntexture handle example:\n\nstruct tagTexture {\ntypedef Handle <tagTexture> HTexture;\n\nNow we need a handle manager thar is responsible for acquiring, dereferencing,\nand releasing objeces (via handles) for a higher-level owner.",
      "content_length": 2975,
      "extraction_method": "OCR"
    },
    {
      "page_number": 69,
      "chapter": null,
      "content": "1.6 A Generic Handle-Based Resource Manager Fi |\npei $$\n\nThe HandleMogr Class\n\nThe Handlelige class is a parameterized type composed of three main elements: a data\nstore, a Magic number store, and a free list (this class appears in Listing 1.6.2). The\ndata store is simply a vector (or any other randomly accessible collection) of objects of\ntype OATA. The DATA type, the first nype paramerer for Handleugr, should be a very’\nsimple class thar contains context information about the resource that it controls. For\nexample, in a Handlevigr thar manages files, che DATA type would probably have only\nthe file handle and the name of the file:\n\nstruct FileEntry\n{\n\nStd:cstring m_Filetane;\n\nHANDLE f_FileHandle; // OS file handle\nIi\n\nstruct tagFile { 4};\ntypedef Haridle <tagFile> HFile;\ntypedef HandleMgr <Filefntry, HFile> FileHandleugr;:\n\nThis simple handle manager maintains a set of context objects that correspond ta\nall the open files char it knows abour. The FileHandlewgr class will probably nor be\nused directly by clients bue will instead be owned by another class (call it Fitengr)\nthar handles the abstraction and knows about the problem domain (thar is, what DATA\nis supposed to represent). This class might look something like this:\n\nclass FileMgr\nFileHandleMgr m_Mgr;\n\npublic;\nHFile OpenFile ( const char* mane );\nbool ResdFile { HFile file, woid* gut, Bize t bytes ):\nbool CloseFile( HFile fila };\n\nie face\nhi\n\nUpon calling any of these methods, Filewgr aske its m_lgr to dereference the han-\ndle to get at the actual Filemntry object. After verifying that the dereference suc-\nceeded (ic will Gil on an invalid handle}, it chen perlorms the operarion.\n\nFor our Hendletige class, cach handle references cxactly one elemenc within the\nobject store, plus irs corresponding clement in the magic number store. Dereferencing\nthe handles to ger at the actual FileEntry object is as simple as using the m_Index\ncomponent of the handle as an index into the object store (a very fast operation).\n\nWhen dereferencing the handle, the code also checks the m_ Magic component\nagainst the same index in the magic number store to make sure the handle is valid. As\nhandles are freed and reacquired, corresponding entries in the magic number store are",
      "content_length": 2246,
      "extraction_method": "OCR"
    },
    {
      "page_number": 70,
      "chapter": null,
      "content": "72 : Section 1 Programming Techniques:\n\nupdated with the new handle magic numbers. This process nearly guarancees chat\n“dangling” handles on released objects won't refer to unexpected objects when the\nslors are Filled by a later handle acquisition bur instead simply fail to work and return\nan error code. Obviously, the magic number store always has the same number of ele-\nmenes at the object store.\n\nAs objects are released, the handle manager adds the indices of the slots they\noccupy to the free list. This saves ic the trouble of needing to search through the\nobject store to find an open soc, which results in a tasty O(n} complexity for new han-\ndle acquisition. It’s imporrant co note that the DATA type is not your rypical C++ class.\nIt shouldn't have constructors and destructors that do anything important, such as\nacquire and release local resources. Objects contained within che object store are con-\nstructed, destroyed, and copied as the vector class sees fir. Nowe chat the std::string\nused in the sample FileEntry is “simple” enough for our meeds; it’s reference-counted,\nwhich minimizes the impact of its constructors and destructors and makes it nearly\nfree for vector to copy.\n\n‘When asked to acquire an object from the store, we'll likely cnd up reusing an\nobject that has already been constructed but is no longer in use, as indicated by its\nentry in the free list. This object needs its members reinitialized before it can be used,\nbecause it won't have had the constructor call co set ix up. When an object is freed\nfrom the store, it is noe destroyed; instead, it has irs index added co the free list and as\nsuch needs its resourees manually freed. These minor limitations arise fram che fact\nthar were embedding our OATA type directly in vector, rather than using poincers and\ncreating and destroying the objects with new and delete for each handle acquisition\nand release. The major advantage here is speed, in char the objects dont have to be\ncompletely brought up and shut down cach ume. To make things more convenient,\nthe initialize/shutdown code can be moved into member functions for casy callback\nby the HandleMgr owner.\n\nThe amount of handle validation necessary could depend on the application and\ncould even be chosen through an additional templare parameter for HandleNgr. For\nexample, the rest for an invalid handle might be found unnecessary and could be\nremoved (although the debug assertion should always remain), For a more robust sys-\ntem in which error handling is important, the cade could, upon detecting an invalid\nhandle, set an error condition and chen abort the function call.\n\nSample Usage\n\nListing 1.6.3 provides a sample texture manager class. ‘This class allows clients po ask\nthe manager for textures by name and constructs them on demand. Ic automatically\nunloads the textures on deletion and provides a ser of query functions to use the tex-\ntures. The textures are indexed by name for speedy lookup to make sure thar the same\ntexture is not addedd to the store rece. Ir would he a simple exercise to add reference",
      "content_length": 3073,
      "extraction_method": "OCR"
    },
    {
      "page_number": 71,
      "chapter": null,
      "content": "1.6 A Generic Handle-Based Resource Manager 73\n\ncounting 60 ehis example co make ir safer, replacing DeleteTexture() with Release-\nTextured).\n\nFor another (larger) sample of file handle usage, see the sample code for my GDC\n\n2000) talk, fer Sell! Loading? Derigning an Efficient File System, available aniline at\nwenw.anoeo-scormby peel.\n\nNotes\n\nee\n\nThe Handietigr class is very simple and is meanc ro illustrate some bade concepts, but\nican be expanded in a number of ways, either with the existing Handleligr or separare\nclasses:\n\nCreate a Handletigr that works better with larger DATA objects, holding them indi-\nrectly through pointers. Ir should also allow hiding of the data strucrure to\nclients.\n\nAdd automatic reference counting as standard functionality, rather than leaving it\nthe responsibilicy af the owner of che Handlemgr.\n\nAdd support for constant-time iteration over the potentially sparse object stare by\nembedding a linked list within ies elemens. Use $TL-style iteraror naming and\noperation for consistency.\n\nMany databases, such as a font manager or texture manager, likely require indexes\nto acoess objects by name co retrieve handles. Build this requirement in as a stan-\ndard feature of as a separate (derivative) class.\n\nThe Handlotgr system is especially effective when combined with che singleton\npattera (see the article “An Automatic Singleton Utility” elsewhere in this book).\nMany of a game's databases are naturally singletons.\n\nTake the singleton patcern a litle further and make the Tag type of Handle actu-\nally be the type that it corresponds to within the Mandlewgr. Then the Handle\ncould have an operator -> that dereferences itself inte a TAG by direcsly accessing\nthe singleton that manages it,\n\nSave-game functionaliry should be fairly casy wo add, but it is necessarily specific\nto your games architecture. The handles can be saved our directly; just make sure\nthat the Handiewgr stores the indexes for its objects along with the object dara,\nand on restore, all handles will remain valid.\n\nListing 1.6.1\nae\n\nfincluda =cassert>\n\ntemplate <typenane TAG\nclass Handle\n\nuniar\n\n{",
      "content_length": 2115,
      "extraction_method": "OCR"
    },
    {
      "page_number": 72,
      "chapter": null,
      "content": "Té\n\nSection 1 Programming Techniques\n\nenum\n\n}/ i288 to use for bit fields\nWAX BITS INDEX = 16,\nWAX BITS MAGIC = 16,\n\ni} sizes to compare against for asserting dereferences\nWAX INDEX = ( 1 << MAX BITS INDEX) - 1,\nWAX MAGIC = (| 1 << MAX BITS WAGIC) - 1,\n\nhi\nstrinct\n{ -\nunsigned m_Index : MAX_BITS_INDES; // index inte resource\narray\nunsigned m_Wagic ; MAX_BITS_MAGIG; // magic number to check\nhi\nunsigned int m_Handle;\nhi\npublic:\n\nif Lifetine.\n\nHandlo( void ) : m_Handle; o) { }\n\nyoid Enit( unsigned int index j;\n\nif Query.\n\nunsigned int Getindex ( void ) const { return (| mIndex 4}; 4}\nunsigned int GatWagic ({ void ] const { return ( -m Magic 4}; }\nunsigned int GetHandle{ void ) const { return {| m_Handle }; }\nbood [sNull 8 { void ) const { return ( Im Handle }; }\n\noperator unsigned int { void } const { return { mHandle }; }\n\nhi\n\ntenplate <typenanme TAG>\nvoid Handle <TAGe 3: Imit( unsigned int index }\n\n{\n\nassert( IsNull{) }; ff don't allow reassignment\nassert( index <= MAX INDEX }; Ji verify range\n\nStatic unsignad int &_AutolWagic = 0;\nif ({ ++5_AUTOMagic > WAX_MAGIC }\n\n1\n\ns AutoNagic = 1; ff 0 is used for “null handle\"\n\nI\n\nm_Index = index:\nmM Magic = 8 AutoWagic:\n\n}\n\ntemplate <typenane TAG=",
      "content_length": 1205,
      "extraction_method": "OCR"
    },
    {
      "page_number": 73,
      "chapter": null,
      "content": "1.6 A Generic Handice-Based Resource Manager Té\n\ninline bool operator i= ( Handle <TAG 1, Handle <TAG> r )\n{ Féeturn { 1.GetHandle() != r.GetHandle() jp; }\n\ntemplate <typename TAG\ninline bool operator == [ Handle <TAG= 1, Handle <TAg> r j\n{ return ( l.Gethandle() == r.GetHandleal) ); 3\n\nListing 1.6.2\nge\n\nfincliaé@ <vector>\n#inclidé <cassart>\n\ntemplate <typaname DATA, typaname HANDLE>\nclass Handleugr\n\n{\nprivate:\ni} private types\ntypede?t stdi:vwecter <DATA> UserVvec:\ntypedet stdiivector <unsigned int» Magiovec;\ntypedef std::vector <unsigned int™ Freeved;\ni? private data\nWserVec mo _Userbata; ff data we're going to get io\nMagicVec m_WagicNunbers; // corresponding agic numbers\nFreevec _FreeSlots: ff keeps track of free slots in tha db\npublic:\n\nff Litetime.\n\nHandleWgor( vaid ) { 4}\n-HandleaWgr([ void } { 4}\n\ni/ Handle methods.\n\nff aequisi tion\nDATA* Acquire! HANDLER handle }+\nWold Release( HANDLE handle };\n\nif Gereferencing\nDATA Dereference( HANDLE handle }:\nconst OATA\" Dereference HAWDLE handle } const:\n\n{i other query\nunsigned int GetWeedHandleGeunt( void | const\n{ return ( m_Magichumbers.size{) - m_FreeSlots.size() ); }\nbool HastsedHandles| void ) const\n{ return ( |1GetUsedHandleGount() ); 3\nhi\n\ntemplate “typename DATA, typename HANDLE=\nDATA\" Handleligr <DATA, HANDLE> :: Acquire, HANOLES handle ]\n\nIi if free list 45 empty, aod a new one otherwise vee first one four",
      "content_length": 1386,
      "extraction_method": "OCR"
    },
    {
      "page_number": 74,
      "chapter": null,
      "content": "76\n\n}\n\nSection 1 Programming Techniques\n\nunsigned int index;\nif { m_FreeSlots.empty() 5\n\n{\nindéx - m_Magichumjers.size()+\nhandle. Initt index j;\nn_Userbata.push_back( DATA) };\nn_Wagichunbers.push_back{ handle.GetWagic,) };\n}\nelge\n{\nindex = m_Freeslots.back( );\nhandle. Inmit( index };\nm_Freeslots, pop back();\nm_Magichiabers[ index ] = handle.GetMagic(}:\n}\n\nreturn { n_Userbata.begin() + index J;\n\nTenplate <typename DATA, typename HASOLE>\nvoid Haridletgr <DATA, HANDLE» :: Release HANDLE handle }\n\n{\n\n}\n\nI) which ono?\nungkigned int index = handle GetIndgex();\n\n! i gake sure it's valid\nassert( index < m Userbata.size|) };\nassert( @_Magichumbars| index | == handla.GetMagial) );\n\nff ok remove Gt - tag as unused and add to free list\nm_Magiclumbers[ indax ] = 0;\nm_FreeSlots.push back( index };\n\ntenplate <typaname DATA, typenene HANDLE>\ninline DATA* HandleMgr <DATA, HANOLE>\n:: Dereference( HANDLE handle }\n\n{\n\n}\n\nif { handle.Tshull() ) return ¢ oO 413\n\nif check handle validity - 3 this check can be removed for apeed\nif it you can assume all handle references are always valid.\nunsigned int index = handle.GetIndex();\nif { ¢ index >= n_Userfata.sizel) }\n\n|| ¢ m_Magichenbers[ index ] I= handle.GetWagic() } }\n\n{\nff fa good! invalid handle == client programming error\nagsert( O 33\nreturn ( O 9;\n\n}\n\nreturn { m_UserData.begin() + index M3\n\ntemplate <typiname: DATA, Typenem HANDLE>",
      "content_length": 1382,
      "extraction_method": "OCR"
    },
    {
      "page_number": 75,
      "chapter": null,
      "content": "1.6 A Generic Handle-Based Resource Manager TT\n\noe\n\ninline const DATA* Handleligr <DATA, HANDLE>\n=> Derefterence, HANDLE handle } const\n{\n\nff this lazy cast is ok - non-const version does not modify anything\ntypedeat Handlemgr <DATA, HANDLE» ThisType;\nreturn [ COMET_¢ast <Thislype*> { this ):>Dereferencel haadle } V3\n\nListing 1.6.3\neo eet a\n\n#include <vector>\n#include <nap>\n#Hinclude <cassert>\n\nff so. [ platform-specific surface handle type hare |\ntypedef LPDIRECTORAWSURFACET Ostandle;\n\nSTFUCT taglenture { 4:\ntypadat Handle <tagTexture> HTexture;\n\nGlass Textureldge\n{\n\nff Texturo object data and db.\nstruct Texture\n\n{\ntypecat sid: ivecter <Oshandle> Handlevec;\n\nStdisstring © Mam: fy) tor receastruction\nHnsignead int m_Width; ff mip 0 width\nunsigned int m_Héight; ff mip 1 width\nHandlaVec m_Handles; If handles te mip surfaces\nOsHandle GetOsHandle( unsigned int mip }) sonst\n{\nassert({ mip =< m_Handles.sizal) };\nreturn { &_Handlas[ mip ] 3};\nI\n\nbool Load { const stdi:string& mame j;\nvoid Unload{ void };\nhi\n\ntypedet Hanilelgr <Texture, Hlaxture= HTexturemMgr;\nff Index by mame ante db.\n\nif case-ingensitive string conparison predicate\nstruct istring_Less\n{\nbool operator () ( const stdrratring& 1, const std::string& r }\nconst\n{ return ( i:stricmp( Lie _str(}, r.c_str{} } <0}; }",
      "content_length": 1288,
      "extraction_method": "OCR"
    },
    {
      "page_number": 76,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\nhe\n\ntypade? Stdscmap <sto:sstring, Hlexture, istring_less » Manelndax;\ntypedef std:cpair <NameIndex::iterater, bool> NaneIndexInser thc;\n\nif Private data.\n\nHléxtureligr n_Textures;\nHaneIndex n_Nameaindex;\n\npublic:\nif Lifeting.\n\nTextureligr{ wold ) { #* ... TF }\n-Textureligr{ woid ji\n\nif Texture management.\n\nHTexture GetTexture | const char* name };\nvoid DeleteTexturel HTexture tex };\n\nii Texture query.\n\nconst std:istrings GetName( HTexture Wtex ) const\n{ return { m_Texturos.Bereferance( htex }->m_Nane };  }\nint GetWidth{ HTéexture Atex } const\n{ return { @Textures.Dereference( htex j->m@ Width }; 3\nint GatHeight{ HTexture htex } const\n{ return | mTextures-Dereference! htex }->m Height |; }\nDsHandle GetTexture( Texture htex, unsigned int mip = @ ) const\n{ return | @Textures-Dereterencal Ntex }->GetOsHandle( mip ) }:\n\njoo eee\nfan\n\nTextureuigr i: =Textureiigr( woid }\ni\nff release ell our remaining textures before we go\nNamIndex: iiterater i, began = m NameIndex.begin(}, and =\nm Nanelndex.end( ps\nTor {| a = begin ; i != end = ++i )\n{\n\nI\n\nB_Textures.Deraterence( i-*secend )->Unload(};\n}\n\nHiaxture Textureligr => GetTaxture( const char* name )\n{\nff insert {find\nNameIndexIngerthe co =\nm_Nanaindex. insert, stdiinake_pair{ mane, HTexture() ) 1;\nif { re.sacond }\nq\nff this is a new ingartion\nTéxture® tex = n_Textures.Acguire( fe.tirst->second };",
      "content_length": 1389,
      "extraction_method": "OCR"
    },
    {
      "page_number": 77,
      "chapter": null,
      "content": "1.6 A Generic Handle-Based Resource Manager Ta\n\nif { Itex->Load( re.first->first ) }\n\nDeleteTexture{ re.tirst->second };\nro.first->second = HTexture();\n\n}\n}\nreturn | ce.tirst->4econd 4;\n}\nvoid TexturaMgr ©: DeleteTexture( HTexture htex }\n{\nTexture* tax = m_Textureas.Dereference( htex );\nif ( tem 120 }\n{\nif delete from indax\nm_Manelndex.erase( om NaeeIndex.tind| tex->n_Name } }\"\nif delete fro db\ntex-=Unload ( );\nn_Textures Release, htex 4;\n}\n}\nbool Texturelgr::Toxture :: Loasd( const Sta: strings name }\n{\nn_Wame = name;\nff... | load texture fram file system, return false on failure |\nreturn { true /* or false on error *s }3\n}\n\nvoid TextureMigr::Textura =: Unload( void }\n\nm Mane.erase|};\nff... [ free up mip surfaces ]\nm_Handles clear);\n\nReferences\nnso sicems\n\n[Bilas00] Bilas, Score, GDC 2000 Talk, Jes Still Losdling? Designing an Efficienr File\nSytem, available online at wrww.aa.nec/-seottb/edc/.\nMeyers, Scott, More Efftertie Cr+, Addison-Wesley Longman, Inc, , 195.",
      "content_length": 978,
      "extraction_method": "OCR"
    },
    {
      "page_number": 78,
      "chapter": null,
      "content": "1.7\n\nResource and Memory\nManagement\n\nJames Boer\n\nComputer and video games, more than any other type of software, often require han-\ndling vast amounts of media resources such as graphics, sound effects, music, video,\nmodels, animation, and other types of memory-hogging data. Dealing with this large\namount of data while maintaining a relatively reasonable memory footprint is not a\ncrivial task. In this article we examine the workings of a simple resource manager and\ndiscuss how it might be both used and extended in real-world applications.\n\nFirst, lets clearly define our problem and how we expect to solve it. Within a\ngiven time in which it is not acceptable to display a loading sereen or break the action,\nwe expect to use more data in our game than we can hold in memory at one time. It\nis also assumed thar we have a medium from which we can dynamically load our data\nwhile the game is playing, On console systems, this would most likely be a CD or\nDVD type of device, whereas on the PC ir is probably the hard drive.\n\n‘Our solution entails creating resource objects that are able to automatically load,\ndiscard, and reload their data based on usage patterns. We will also create a manager\nte coordinate the available resources and control access wo the resource objects. This\nwill be accomplished through the use of handles, which are essentially just unique\nidentification numbers.\n\nThe Resource Class\nrrr\n\nTo begin with, let's examine the base resource class:\nClass §49e8esourca\nable:\nann PriorityTypa\n: AES_LOW_PRIORITY - oO,\nAES MED PRIORITY,\n\nAES HIGH PRIORITY\n};",
      "content_length": 1580,
      "extraction_method": "OCR"
    },
    {
      "page_number": 79,
      "chapter": null,
      "content": "1.7 Resource and Memory Management a1\n\nBasehesource() { Clear(}; }\nvirtual -Basehesource(}) { Destroy{}; }\n\ni! Claars the elass data\nvirtual woid Claar();\n\nfi Greate and destroy functions. Note that the Create)\n\ni} Tunetion of the derived class does not have to exactly\n‘/ match the base class. No assumptions are fade regarding\ni? Parameters.\n\nvirtual baal Createg) { roturn false; }\n\nvirtual vodd Destrayt) {}\n\nff Dispote and racreate aust be able te diseard and then\n\nff completely racraate the data contained in the class with\nif 0 additional paranetars\n\nVirtual bool Aacreate(} = O;\n\nVirtual void Dispose() = Oo;\n\n/f GatSize() must raturn the size of the data inside the\nif clase, and [sDisposed(} lets the manager know if tha\nif data exists.\n\nvirtual size_t GetSize() - 0;\n\nvirtual bool Tsfieposed() = 0;\n\nff These functions set the paranetara by which the sorting\nff operator determines in what ordar resources ara\nif discarded\ninline void SetPriority(PriorityType priority}\n{ @_Priority = priority; }\ninling PriorityType GetPriority) }\n{ return mPriority; }\n\ninline void SetReferancecount (WinNT nGount)\n{ #lnhefCount = ntaunt; }\ninline UINT Getheferencetount( }\n{ Feturn minfefGount; }\ninline bool Tslerked( }\n{ feturn (m_nitetCount > 0) Ff true : false; 3\n\ninling void SetLastAceess(time t LastAccass)\n{ @_LastAccess = LastAccess: }\n\ninling time_t GatLastaccess()\n{ return m_LastAceess: }\n\nfi The less-than operator defines how resources get\nff sorted tor discarding.\nvirtual bool operatar <= (Basehesouree& containar):\n\nprotected:\nPriocityTypea  m_Priority;\nWINT _nRetGount;\ntine_t m_Lastéccess;",
      "content_length": 1606,
      "extraction_method": "OCR"
    },
    {
      "page_number": 80,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\nThe Basefesource class acts as a template from which other resource container\nclasses must be derived. Several member functions must be overridden by any base\nelass and are critical co how the system works.\n\nle ts expected thar che initial Greate() function will load some amount of\nresource data from disk or even from another location in memory, Ir is critical for the\nclass to retain the necessary data in order to repeat this operation as many times as\nnecessary in the Recreate() function. This may mean, for example, storing the path\nand file information of a bitmap to he loaded. The application must overnde the Dis -\nposa() and Recreate() functions in order co allow the resource manager to swap the\nresource in and out of memory as it sees fit. Keep in mind that only che most signifi-\ncant portion of the resource (c.¢., the bitmap data, the sound buffer, and the like} ,\nnot athe class dara, must be swapped our.\n\nGetsize() and IsDisposed() are two more functions thar must be overridden\nproperty for the system ta work, GetSizel) is fairly intuitive. The function should\nreturn the size of the data that can currently be swapped out. If the dara has already\nbeen swapped our, the function should return a size of zero. Technically, you could\ncalculate the actual size of the abject by including all che other data members, bur in\nall practicality, this method is really not worth the effort. IsDispased(} must return\ntre if the dara has heen discarded and false if ir has rot, The class makes ne LIT p=\ntons about how you can determine this stare. It is up to the derived class eo provide\nany necessary data members to keep crack of this state, if needed. Often simply check-\ning to see if'a pointer is null works instead of adding a data member.\n\nA oumber of other data access funceions provide access no the data members\nn_Priority, a_nRefCount, and m_LastAccess. The first, =_Priority, is an enumera-\ntion defining the general priority of a resource (high, medium, low). High-priority\nitems tend to stay in memory longer, and low-priority items should be swapped our\nfirst, The function m_nftefCount indicates the number of times the resource has heen\nlocked. We examine chis function a bit later. The n_LastAccess function is the time at\nwhich the resource was last accessed.\n\n‘The less-than operator ( < ) ts what determines the priority of sorting resources\n\nfor discarding. The default function looks like this:\n\nbool Baschesource::operatar < (Sasehesourcea container)\n\nif(GetPriority() <= container .GetPriority{})\nraturn true:\n\nelse if(GetPrigrity() > sontainer.GetPriority())\nreturn false:\n\nelse\n\nif(m_LastAccess =< container.GetLastAccess/))\nreturn true:\n\nGlse if(m_LastAccess » container. GetLastéccess( }}\nreturn Talse;\n\nBlse\n\n{",
      "content_length": 2788,
      "extraction_method": "OCR"
    },
    {
      "page_number": 81,
      "chapter": null,
      "content": "1.7 Resource and Memory Management\n\nif Resource 83\n\nif (GetSize() < conteiner.GetSize[})\nreturn trugy\nelse\nreturn false;\n}\n\nreturn talee;\n\n}\n\nYou can see from this function thar rescuirees are sorted firse by priority, then by\naccess time, and last, by size, Although a rarher primitive algorithm, it works surpris-\ningly well for many situations. If you require a different or more sophisticated algo-\nrithm, you can cither modify the base code or supply a new sorting operator in the\nderived class.\n\nThe Resource Manager Class\n\nThe other half of the managed resource problem is supplying a manager thar can\norganize all the stored resources, provide access on demand, and handle the dynamic\ndisposal and reallocation of resources to stay within a memory budget. Let's examine\nthe ResWanager class to see how ic works:\n\nclase AesWanager\n\ni\n\npublic:\nReslanager ( } { Glear(j; }\nvirtual —-ResWanager{} { Oestroy(); 4\n\nvoid CGlear[};\n\nbool Create (WINT nlaxSirey ;\nWOid Destroy):\n\ni! Aesourcea map iteration\n\nse joss oo\n\nff Access functions for cycling through each item. Giving\nff direct aceess te the map or iterater causes a stack\nif pointer fault if you access the map across a dll\nii Boundary, but it's satg threugh the wrappers.\ninling void Gotabegin( }\n{ m_CurrentResaurce = m_Aesourceilap begin): }\ninling BaseResource* GetCurrenthesourcel }\n{ return (*n_Currenthesource).secand;  }\ninline bool GotoNext(]\n{ s_CurrentRhesource++; return [sValid(); }\ninline bool IsValid)\n{ return (m_Currenthasource I= f_Resourcellap.end())\n¥ true : false; }",
      "content_length": 1547,
      "extraction_method": "OCR"
    },
    {
      "page_number": 82,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\nUD newness pele SSS ey eee eee nenne ene\n\ni! General resource access\n\nf/ Allows the resource manager to pre-reservea an amount of\n// menory 60 an ingarted regaurce does not axceed the\n\nff maxinum allowed manory\n\nbool Reservellemory(size_t nile):\n\nff Tf you pass in the address of a resource handle, the\nff Resource Manager will provide a unique handle for you.\nbool InsertResource(/RHANDLE* rhiiniquelD,\n\nHasehesouree™ phesource) ;\n\nbool InsertResource(RHANOLE rhuniqueDd,\n\nBasaiesource* plesource) ;\n\nif AaMives anh abject completely from the manager.\nbool RemoveResource(Basehosource® pResource);\nbool AemoveResource (RHANOLE rhUniquelD);\n\nfi Destroys an object and deallocates it's memory\nbool DestroyAesource (BaseResqurce* pResource);\nbool Destroyiesource (AHANDLE rhlniquelb) ;\n\nfi Using Gethesource tells the manager that you are about\nff to gocess the object. It the reseuree has been\n\nfi disposed, it will be recraated before it has been\n\ni? returned.\n\nBasehesource® Gethasource (RHANDLE mhliquelol;\n\nff Locking thé resource ensures that the resqurce does mor\nff get managed by the Resource Manager. You can use this\nff to ensure that & Surface does not get swapped out, for\nff instance. The fesouree containa a reference count\n\nif to ensure that numerous locks can be safely made.\nBaseAesource\" Lock(RHMWOLE rhUniquelD):\n\nif Unlocking the object lets the resource manager know\n\nff That you fa longer need exclusive access. When all\n\nfi locks have been released (the reference count is 0), the\ni! gb]86t is considered safe for management again and can\ni! Da Swapped out at the manager’s discretion, The object\nff can be referenced either by handle or by the object's\n\ni} pointer,\n\nint Unleek{RHANOLE rhUniquelb) ;\n\nint Unlock (BaseResqurce\" phesource);\n\nff Retrieve the stored handle based on a podnter to the\n{i resource. Note that\n\nff Pesoureée. Note that it's aséuaed that thare are no\n{f duplicate pointers, as it will return the first match\nff found.\n\nAKANDLE FindhesourceHandle(fesehesource\" pAesourca):",
      "content_length": 2052,
      "extraction_method": "OCR"
    },
    {
      "page_number": 83,
      "chapter": null,
      "content": "1.7 Resource and Memary Management 85\n\npretected:\n\nff Internal funetiong\n\ninline void AddMemory(UINT nilgam}\n\n{ S_NGurrentlsedilenory += nMgm;\ninline vold Resovellenory(UINT nMem)\ni @_nGurrentligeddenory -= nMem; +\nWINNT GatMexthesHandle[ }\n\n{i raturo —-irhiNestRestandle; }\n\nff This suet be called shen you wish the manager to check\nJif for discardable resources, Resources will only be\n\ni} swapped out if the maximum allowable limit has been\n\nff reached, and it will discard then from lowest\n\nJf to highest priority, determined by tha resource class's\nff < opetater. Function will fail if requested aenmory\n\nJ/ cannot be freed.\n\nbool CheckFordverallocation():\n\nprotected:\nAHANOLE m_rhhexthoesbandle:\nWIT m_nCurrentWisecvenory:\nWIT m_nilaxinueMemory ;\nfesWapT ter m_Currenthasource:\nAesiap m_Aesourcevap;\n\nhi\n\nThe heart of the resource manager ts che data member m_ResourceMap. This is an\nSTL map, which means that every unique resource handle (which is simply an\nunsigned int) is paired with a pointer ro a resource object.\n\nHandles can either be pre-assigned (perhaps hard-coded or read from script files)\nor dynamically assigned by che resource manager itself. Keep in mind that the current\nimplementation is very primitive, It simply starts at dhe maximum value for handles\nues start relatively low, This method gives you several billion handle values before you\nrun out of room. If you plan to use that many resources, you'll want to implement a\nmore sophisticated handle distribution scheme.\n\nOnce the resource manager object has called the create() function and passed in\nthe target memory limit, the manager is ready to use. Simply call the Insertae-\nsource() function vo insert resources into the manager. Ifyou pats in the address of a\nhandle instead of passing it by value, the function fills in the value for you, In the\ncumple program. we created a factory class that automatically allocanes, creates, and\nthen inserts the resource object into the manager.\n\nIt is important to understand one ching about the resource manager. When you\nspecify the memory target, the InsertResource() function allows che memory target\nto be briefly exceeded by the amount of the current resource. The manager then\nSW2ps OE resources until the currently used memory is lower chan che threshold spec:\nified. Although this method may be acceptable if your resources are allocating out of\ni common memory pool or you are working in an environment with true viral",
      "content_length": 2454,
      "extraction_method": "OCR"
    },
    {
      "page_number": 84,
      "chapter": null,
      "content": "BE Section 1 Programming Techniques\n\nmemory, it could create problems if you are working with fixed amounts of special-\ned memory, such as audio or texture memory.\n\nRequesting the manager to reserve an amount of memory for the resourec you are\nabout to load can solve the problem. This function, called Reservewenory(}, takes a\nstandard sf2¢_fype parameter. The function remurns true if it can free up che requested\namount of memory. After this function successfully returns, you can chen call\nInsarthecourea(). Most likely, the ReserveMenory() function would be called in che\nresource clases Greate() function alter loading some sort of resource header informa-\ntion, which would probably inform how much memory needs to be allocated to hold\nthe entire resource. Once the memory is reserved by the resource manager, the Gre-\nate() function can finish the daca loading and insert the resource into the manager.\nIn order te optimize this process, you might want co pre-load chis information and\nstore it in a globally accessible cable.\n\nHow Handles Work\nee\nThis system uses handles in order to prevent clients from directly manipulating\nobjects, which allows the manager the freedom to swap our resourees as it sees fit. In\norder te gain access to a resource, the client must call a member function and pass in\nthe handle in order to get back a pointer to the resource. Here's how it looks:\n\nSoneResdurce* pes = (Senchesource* jresngr.Gethesource (hiestHandle);\nif (i pRes)\nreturn Error;\n\nff the resource can now be safely used before any other calls are\n‘J made to the manager\n\nIt is important to remember that the resource pointer must be considered valid\nonly until another call to the resource manager is made. Accessing another resource\ncould cause the resource manager to swap out the resource you were previously access-\ning. You will most likely want to put asserts in your resource class's code to ensure that\ntheir member functions are not called if the resource has been disposed.\n\nIf for any reason you do want to get and hold onte a pointer to a resource, there\nisa mechaniom in place to do so: the Lock() function, Locking a resource increments\nthe reference count on the object, which prevents the resource manager from dispos-\ning of the object uncil the resource has been unlocked with, of course, che function\nValock(). [cis important to remember to eventually unlock objects you've locked, or\nthe resource manager assumes that it is noc allowed to dispose of the resource when\nthe program closes, and memory leaks could ensue. Since the resource manager hus\nevery resource indexed, it properly disposes of all resources automatically when its\ndestructor is called.",
      "content_length": 2682,
      "extraction_method": "OCR"
    },
    {
      "page_number": 85,
      "chapter": null,
      "content": "1.7 Resource and Memory Management ay\n\nPossible Extensions and Modifications\n\nThe use of a resource manager is extremely beneficial in managing large amounts of\nresources effectively. Although there is a slight increase in difficulry when accessing\nresources, this difficuley is offset by the simplicity of automatic memory management.\n\nTf your application's entire cata set is already indexed in che resource manager, a\npre-caching system could be implemented by using esting functionality. Ta load a\nresource that has been determined a candidate for pre-caching, you should access che\nreiguiree using the GetResource() function and raise the priority level. This method\nforces any swapped data in those resources ro be reloaded and made ready for direct\naccess ad well as discourages further swapping because of the heightened priority. For\na resource that is no longer needed, simply lower che priority level in the resource, and\nit ts automatically discarded when more memory is needed for other data.\n\nIn addition to these enhancemences, clients might want to build in more compre-\nhensive reporting functions. A feedback loop could be created to repert on resources\nthat are being discarded more than average, and the priority could be adjusted te min-\nimize these sorts of problems. By effectively secting priority levels, perhaps even\ndynamically, clients can dramatically improve the performance of the manager.\n\nOther techniques you might want to ery are featured in a related article in this\nbook, “A tseneric Handle-Based Resource Manager,\" by Scott Bilas. Rather than\nusing the manager as a virtual memory system, this mesqurce manager instead Focuses\non techniques such as using templates and more intelligent, type-safe handles.\n\nConclusion\n\nAs the amount of data concent chat modern games must manipulate grows, the tech-\nniques for dealing with such vast quantities af data must also evolve. Creating an\neffective and efficient resource manager can help streamline the development process\nby allowing programmers co worry less about memory constraints and memory leaks,\nat the same time providing a powerful tool for monitoring resource usage.",
      "content_length": 2160,
      "extraction_method": "OCR"
    },
    {
      "page_number": 86,
      "chapter": null,
      "content": "1.8\n\nFast Data Load Trick\n\nJohn Olsen\n\nOne of the constant challenges with game programming is to make things fast.\nWhenever you leave someone staring ata screen waiting, you break the flow of infor-\nmation and risk losing that player. One critical clement is che cime it takes to load\ndara files into memory. With larger and larger game levels, you end up with longer\nand longer load times, Here is a trick char can be used to reduce your load times.\n\nPreprocess Your Data\n\nOne of the most important things you can do to your level dara is to preprocess as much\nas you possibly can. This can be done either with a stand-alone utility program, such as\na separate level editor used to edit your in-game dara, or within the game itself during\ndevelopment by enabling custom data-packing code for development builds. P've used\nboth methods, even on different portions of the same game, with good results.\n\nFor the ultimate in fast dara load times, you need to prepfocess your data into che\nfinal format it will tale within the game. With a bit of planning, you can lay our your\nC++ classes of © structures in a way thar makes chem good candidates for high-speed\nloading. Any data to be saved must be a non-static member variable, and no poinrers\nshould be saved. in the dara file.\n\nIfyou need pointers in your data, be sure to never use them before seating them\nup properly after loading, since the data saved out in the pointer member is almast\ncertain to contain bad dara when it is reloaded. Another possible option is te replace\npointers with a handle or index number of some sort. See the article “A Generic Han-\ndle-Based Resource Manager,” by Scott Bilas, for details.\n\nSince C++ uses virtual function tables, you should make sure to nor use any vir-\ntual fnctions ir your class, or i¢ will end up calling into seemingly random memory\nlocations when you overwrite your table with stale dara, If you want to play ic really\nsafe, you can experiment with making all your accessor functions static, guarantecing\n\nthey wont show up in your dara.",
      "content_length": 2044,
      "extraction_method": "OCR"
    },
    {
      "page_number": 87,
      "chapter": null,
      "content": "1.8 Fast Data Load Trick ao\n\nSave Your Data\n\nOnce your dara is all filled into structures, either in-game or in a stand-alone prepro-\ncesing tool, you can write that data out to disk. For C++, you can use your this\npointer and sizeot() for the class. Far C, just use the structure pointer and sizeof {)\nfor the structure. Be sure mor te use sizeo? (this) or you will get the size of the pointer\nrather than the size of the structure. This size is the size of the non-static member data\nfor your class, along with any padding built into the class by che compiler.\n\nIdeally, you have nested all your necessary dara into one parent block holding all\nthe others, so you can load everything in one large read. You have to break things up\ninte multiple saves and loads if you are using anything bur ene continuous section of\n\nThe following example code shows how this might be done in C+4, with the\ngame data class having member Functions to perform che loading and saving, Please\nforgive the odd mixture of C++ classes with C file handling. If you're enough of a\npurisc to be bothered by it, [im sure it’s easy for you to change to your preferred\nmethod:\n\nFinclude <stdio.h>\nclass Gamobata\n{\n\npublic:\n\nbool Save(char *filetame) +\n\nbool Load(char *fileNam=):\n\nbool BuTTeredload(enar *fileiame) ;\n\n// Add accessors to get to your game data.\nprivate:\n\n!/ Only open one file at @ tina.\n\nstatic FILE *fileDescriptor:\n\n// Game data goes hare.\n\nint dataliO00); // Aaplace this with your data format.\nIs\n\nbool GamaData::Savalchar *fileNane]\n\nfileDascriptor = fopan(filetiang, “wb\"};\n\nif(filebescrigtoar)\n\n{\nfwrite( this, sizeof (Gamefata), 1, fileDescripter):\nTelose(fileDeseriptor) ;\nfi Report success eriting the file.\nreturn TAUE:\n\nI\n\nglee\nfi Regort an error eriting the file.\nreturn FALSE;\n\nI",
      "content_length": 1783,
      "extraction_method": "OCR"
    },
    {
      "page_number": 88,
      "chapter": null,
      "content": "a Section 1 Programming Techniques\n\nLoad Your Data the Simple Way\n\nSaving the data as described previously makes it really easy to get the data back into\nyour application later when you load the desired level. Just read che data back int the\ngame, into the same structure or class you wrote it from:\n\nbio] GantData: :Load(char *filehanec)\n\n{\nff Open the Tile for reading.\nfilefescriptor = fopen(fileNana, \"rb*):\nif(fileDescriptor)\n\nfread(this, sizeof(Gamelata), 1, filebesoriptar);\nfelose(fileDescriptor);\n\nif Heport suctess reading the file.\n\nreturn TRUE:\n\nalse\nff Aeport an error reading the file,\nreturn FALSE:\n\n}\n}\n\nLoad Your Data More Safely\n\nThere is at least one really important thing co watch eur for on certain console gaming\nhardware. Some systems always read our to the end ef the current sector on a disk. For\nexample, the Sony PlayStation loads data from CD-ROM in multiples of 2,048 bytes,\nThis means that if you read dara directly into your struccure, you stomp on whatever is\nin memory after that structure if it isn't some multiple of 2,048 bytes in length.\n\nTo avoid this memory stomp, you need to have a temporary buffer large enough\nto hold the dara file padded out to a 2K boundary. Should you be reading several files,\ndont allocate and free a buffer cach time. Instead, get the largest buffer size, allocate\nthe buffer once, and reuse it for all reads. Free ie after all the reads are completed.\nOnly the simpler single-read method is shown here.\n\nIf you are using a system with very tight memory, you might have already mapped\nout your entire memory usage and avoided dynamic memory all tegether. In that\ncase, you need te find 2 buffer somewhere in memory that is mot in use at the time\nyou need to read data files, Use thar as your temporary buffer instead of using the\ndynamic memory allocation shown below:\n\nff Ghack your hardware to sea what site of blocks it reads.\n‘f/f Put that value inte this define.\nfdetine AEAD GRANULARITY Doda\n\nbool Gasebata: ButferedLoad(char *fileName)\n{",
      "content_length": 2011,
      "extraction_method": "OCR"
    },
    {
      "page_number": 89,
      "chapter": null,
      "content": "1.8 Fast Data Load Trick a1\n\nf/f Make sure there 23 room in the reed buffer.\n\nfi This could be made saaller to natch the\n\nff known read size by making it a multiple of the\n\ni} HEAD GRANULARITY, but this way is a bit faster.\n\nchar “tempButfer = new char[sizeot(GameaData) + READ GRANULARITY];\nif(ltampsutter)\n\n{\n\nii Gould not allocate the buffer.\nJ? Return an eeror code.\nreturn FALSE:\n\nI\n\nfileDescriptor = fopen(fileName, \"rb\"};\n\nif (filebeseriptar)\n\n{\nTread tempiutfor, sizaot(Ganebata), 1, fileDescriptor):\nfelose( filebescripter):\nmamepy (this, tenpBuffar, sizeof (Ganebata) jj\ndelete tenphutfer;\nff HEpOrt Success reading the file.\nreturn TRUE;\n\n}\n\nalse\n\n{\ndelete tenpbutfer;\nff Aepert an error reading the file,\nreturn FALSE:\n\n}\n\n}\n\nNow you are well on your way to highly optimized level loads. By preprocessing\nyour dara, you save the CPU time used to convert data into a usable formar, and you\ncompress the amount of data te be read. The best optimizations are chose win/win sit-\nmations im which che resule is both smaller and fever",
      "content_length": 1040,
      "extraction_method": "OCR"
    },
    {
      "page_number": 90,
      "chapter": null,
      "content": "1.9\n\nFrame-Based Memory\nAllocation\n\nSteven Ranck\n\nThis article presents a simple and extremely fast memory allocation system that pre-\nvents memory from heeoming fragmented between game levels. It can be used for a\nwide range of game modules during level-loading time. In addition, the system is\nextremely fast at both allocating and de-allocating memory and can be used on any\ntype of plarform, from console to PC to areade,\n\nThe Ghallenges of Conventional\nMemory Allocation\n\nOne problem with standard memory allecation systems chat include malloc() and\nnew is thar memory can become fragmented and result in deteriorated game perfor-\nmance and the possibility of insufficiently large memory blocks available. When an\napplication requests a block of memory, sophisticated operating systems, such as\nUNIX and Microsoft Windows, employ advanced memory management systems that\ncan logically rearrange physical chunks of memory vo create the requested contizuous\nmemory block, But this rearrangement comes at the cost of CPU cycles that the game\ncould ordinarily have used. With game consoles, where the operating system is little\nmore than a tiny set of slimmed-dewn library functions, there is no such sophisticared\nmemory manager.\n\nIntroduction to Frame-Based Memory\n\nAsolution to these challenges of conventional memory allocation is framre-hased meni\nary. Frame-based memory eliminates memory fragmencation and is very fast. How-\never, it is not useful as a general-purpose memory allocation system like nallec() and\nnew. Framte-based memory is best suited for game and level initialization modules.\nAs shown in Figure 1.9.1, frame-based memory works like a stack. Ar initializa-\ntion time, the game allocares a single memory block from the operating system, which",
      "content_length": 1766,
      "extraction_method": "OCR"
    },
    {
      "page_number": 91,
      "chapter": null,
      "content": "1.4 Frame-Based Memory Allocation aa\n\nBiol\n\naa Lozer Heep\nFetes Pooeter\n\n§— Bere ow emery)\n\nFIGURE 1.9.1. Frame-based MMcMory Tepresentarian.\n\nwill be used and managed by the frame memory system. This memory block is allo-\ncated only once throughout the lifetime of the game and is released back to the oper-\nating system just before the game terminares. In Figure 1.9.1, che entire block\ndenoted by Memory Block is used by the frame memory system. From the memory\nblock's pointer, we compute the Base and Cap memory pointers, optionally aligning\nthem toa memory boundary thar firs the specific system the application was designed\nto run on. The Base pointer points to the lowest aligned memory address in our\nMemory Block, and the Cap pointer points to the next higher-aligned memory\naddress just outside the top of our Memory Block (as seen by the placement of the\narrow in Figure 1.9.1). The Memory Block, the Base pointer, and the Cap pointer\nremain constant throughout the life of che game. Finally, che Lower Heap Frame and\nUpper Heap Frame pointers are set equal co the Base and Cap pointers, respectively.\nWell see later how these two pointers change as allocations and de-allocations are\nmade during the course of the game. The following code initializes the frame memory\nsysteani:\n\ntypedef unsigned char w8;\ntypedef unsigned int wint;\n\nfdetine ALIGMUP( nAddress, mBytes } ( ({(uint}mAdoress)] + \\\n(nbytes)-1) & (=({nBytes}-1)) }\n\nstatic int _niyteAlignmeant; // Menory alignment in bytes\n\nstatic uf “_pMemoryHlock} ff Walue returned by malloc()\nStatic ud *_apBaseAndCap[2]; // [O)=8ase pointer, [1]=-Cap pointer\nStatic wa *_apFrane[2]; ff [O]=Lowar Trame pointer, [1)=Upper\n\nff frame pointer",
      "content_length": 1701,
      "extraction_method": "OCR"
    },
    {
      "page_number": 92,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\nif Must be called exactly once at game initialization time,\n\nif nRyteAlignment must be a power-of-2,\n\nif Returns 0 if successful, or 1 if an error securred.\n\nant InitFramaMemrysystem( int nSizelnbytes, int n8yteAlignment } {\nif Make sure nSizeinbytes 15 a multiple of nbyteAlignnent:\nnsizelngytes © ALTGNUP( nSizelnbytas, nbytedlignment };\n\nif First allocate our Memory Bleck:\n_plamoryalock = (u8 *jmalloc( nSizealnBytes +\nnbytedlignnent };\n\nif( _pMenorySlack == 0 } {\nff et engugh mamory. Retura error flag:\nreturn 1;\n\n}\nhy tetlignmant = nbyteAlignment;\n\n{/ Set up Base pointer:\niplasetndCap[ Oo) = (wh *)ALTGNUP/ pitenoryelock,\nnByteAlignment 33\n\nff! Set op Gap pointer:\n_aphaseandGap[1] = (ua *)ALIGNUP( _pliemoryBlock +\nnSizeinbytes, nbyteAlignnent 4;\n\nff Finally, initialize the Lower and Upper tram pointers:\n_apFrane(] = _apiasesndtap(o];\n_apFrame[1] = _aphaseAndCap] 1);\n\nff Successtull\nreturn 0;\n\n}\nTo shut down the frame memory system:\n\nvoid ShutdoemFrameMemorysysten( void ) {\nfrea{ _pilenoryBleck };\n\nExactly once during game initialization, a call is made to InitfraneMemorysys-\ntem(}, passing in the total number of bytes co be managed by the frame memory sys-\ntem and the byte alignment. All allocations made through the fame memory systern\nmaintain the byte alignment. Note that the ALIGNUP() macro requires hac the nBytes\nparameter be a power of 2\n\nAt this point, che frame memory system is ready to use. It maintains two individ-\ntal heaps: the Lower Heap allocates upward, and the Upper Heap allocates down-\nward, as shown in Figure 1.9.1. It is completely up to the game how it wants co utilize\neach heap. For example, the Upper Heap could be used to store 3D geometry data\nand the Lower Heap used for sound dara. In this example, independent allocations\nmade by the geometry and sound modules would not fragment memory, because the\nowo beans ane physically separated.",
      "content_length": 1922,
      "extraction_method": "OCR"
    },
    {
      "page_number": 93,
      "chapter": null,
      "content": "1.9 Frame-Based Memory Allocation 85\n\nAllocating and Releasing Memory\n\nFrame memory allocation works like a stack. A call is made co che system, requesting a\nchunk of memory from one of the two heaps. If the lower heap is specified, dhe Lower\nHeap Frame pointer is bumped up by the amount allocated, and its value por vo the\nmedification is retusned. The Lower Heap Frame pointer always points to the next\navailable byte of memory: If, on the other hand, the upper heap is specified, the Upper\nHeap Frame pointer is bumped alow by the amount allocated, and the new value is\nreturned. This is because the Upper Heap Frame pointer always points co the last allo-\ncated byte af memory. If the two frame peinters cross cach other, there isn't enough\nmemory to satisty the request. The following function performs the allocation:\n\ni! Aeturns a pointer ta the base of tha menory block,\n\n/f ar returns 0 af there was insufficient nenory.\n\nff H@apNum 1s thé heap number: O-lower, 1=upper.\n\nwold “AllocrraneMemary( int nBytes, int nkeaphun } g\nui \"piliem;\n\nff First, align the requested size:\nniytes = ALIGNUP( naytes, _nByteAliqnment 5\n\nff Check for available manary:\n\naf( _apFrane[O)+nBytes > apFramefi] } {\nHt Insufficient mamary:\nreturn Oo;\n\n}\n‘f Now perform the manory allocation:\n\nif( nHeaplum } {\nMf Allecating from upper heap, down:\n\nApFrame|1) -= niytes;\nPuen = apFranefi]:\n\n} else {\nff Allagating tron lewer heap, up:\n\npllam = _aprrame[ do);\n_apFramne[O] +° n@ytes;\n\nreturn (void *)pWen;\n\n}\n\nThis function performs frame-based memory allocation very quickly, Since frame\nmemory is allocated like a stack, ic must be de-allocated the same way. This is where\nframes are introduced. A frame is a handle that che game retrieves from the memary\nsystem and is used to free memory. Memory can be freed only by using a frame. A\nframe acts as a bookmark within the pages of memory allocared by the system. When",
      "content_length": 1902,
      "extraction_method": "OCR"
    },
    {
      "page_number": 94,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\na frame is freed, all memory allocated since the frame was obtained is freed. Figure\n1.9.2 demonstrates the use of a frame.\n\nIn Figure 1.9.2, (b) and (c) show two individual memory allocations being made\nvia the AllocFrametermory() function. In (dj, the game obtains a frame from the\nmemary system, The frame is simply a handle that the game will later wse to free\nmemory In (e) and (f), the game allocates another two blocks of memory. In (g), the\n\nFrame\nOEGGE\n\n(a) Ince (h) Firm Ce) Secu (d) From\nBaap 2 meory memory ebomed hy\nOper aisciticn sade abomizon toe ge\n\nmenary\nalison pode\n\nFIGURE 1.9.2. Memory allocation and release.",
      "content_length": 664,
      "extraction_method": "OCR"
    },
    {
      "page_number": 95,
      "chapter": null,
      "content": "19 Frame-Based Memory Allocation a7\n\ngame wants to release all memory allocated since the frame was obtained, The follow-\ning function obrains a frame for either the upper or lower heaps:\n\ntypadet struct {\nWB \"pFrane;\nint nHgapNun;\n} Frane_t;\n\nff Returns & Frame handle which can be used to\nff later release nengry allocated henceforth.\n‘f nHeaphum 23 the heap number: O=lower, t=upper.\nFrame_t GetFrame( int nHeaplun ) {\n\nFrame t Frame;\n\nFrame.pFrane = _apFrane[nteapNum);\nFrame. nitapNum = nteapltues\n\nretura Frane;\n\n‘To the memory system, a frame is a copy of the specified heap number and ies\ncurrent frame pointer. But to che game, it's simply a handle, Frama_t. To release\nmemory, we implement the following function:\n\nvoid ReleaseFrame( Frame_t Frame } 4\n_apFrane[ Frame .nheaplun] = Frame.pFrame:\n\nThe game calls AeleaseFrane() to release all memory allocated since the time\nthat Frame was obtained by GetFrame(}. There is no limit to che number of simulta-\nneous frames the game can allocate, provided thar the frames are released in che order\nopposite of that in which they were obtained. However, the memory system doesn't\nrequire that frames be released. For example, if Frame 1, Frame 2, and Frame 3 are\nobtained, ic is valid to release Frame 3 and then Frame 1, provided thar Frame 2 is\nnever released.\n\nHaving two independent heaps has several advantages. Consider our previous\ncxample of the upper heap being used to store 31D) geometry, and the lower heap being\nused ta store sound dar. Suppose thar allocations between the cwo heaps were made\nas follows: 3D block allocated, sound block allocated, another 3D block allocared,\nanother sound block allocated. When the 3D memory is freed (boch blocks), unused\nmemory holes are not created and fragmentation is prevented. The largest chunk of\navailable memory is always equal eo the toral size of the free heap. Likewise, the langest\nchunk of available memory in the lower heap is always identical to che largest chunk\nof available memory in the upper heap.",
      "content_length": 2021,
      "extraction_method": "OCR"
    },
    {
      "page_number": 96,
      "chapter": null,
      "content": "58 Section 1 Programming Techniques\n\na\n\nExample\n\nConsider the following application example:\nFdefing HEAPHUM i fs Arbitrary. We'll use the upper heap [1}.\n\nextern int GatOojectSizal conet char *pszObjectName };\nextern int LoadFromDisk( eenst char \"psrObjecthane,\nvoid “ploadAddress }:\n\nStatic void “_p0bjecti; J! Where our Coptar object will be laaded.\nStatic void “_p0iject2; // Where our RobbarGar objact will be loaded.\n/7 Loads the CapCar and RobberGar objects from disk inte\nJ) _HEAPHLM.\nIf Aeterns 0 if successful, or 1 af not successful.\nint LoadGerdbjects( veid j {\n\nFrama t Frame:\n\ni} Get a frame handle:\nFrame = GetFrame{ HEAPHUM );\n\nif Attenpt ta load the CopGar object:\n\nPie jecti = LoadiyObject! “CopCar\" 1:\n\nif({ pOsjecti == 0 } {\nff Object couldn't be loaded. Release memory:\nReleaseFrane( Frame jj\nreturn 1;\n\n}\n\nji Attempt to load the AobberGar object:\n_plbject2 = LoadWyObject( “Robbertar™ 1;\nif( pObject? == o } {\nJf Giject couldn't be loaded. Release memory:\nReleaseFrane( Frame }:\nreturn 1;\n\n}\n\nfi Objects loaded ok. Kaap the menory around:\nreturn 0;\n\n}\n\nff Allocates memory fron HEAPNUM and loads tha specified object\nif trem disk inte the allocated memory. Returns a pointer to tha\nff object if successful, of 0 if not successful.\nwoid *Load¥yObject( conet char *psz0njectName } {\n\nint n0ojectSiza;:\n\nWold “pObject:\n\nnObjectsize = GdetlbjectSize! psrdbjecthame };\nif( nOdjectSiza == 0 ) {\n\nif Trouble getting object size;\n\nreturn 0;",
      "content_length": 1454,
      "extraction_method": "OCR"
    },
    {
      "page_number": 97,
      "chapter": null,
      "content": "1.9 Frame-Based Memory Allocation oo\n\npObject = AllocFramoMenory | nobjectSize, HEAPNWUM };\nif{ pObjact == 0 ) 4\n\nff Insufficient memory:\n\nréturn oO:\n}\n\nif( LoacFromDisk( pazOojecthame, pObject pid\n/f Trawble loading object from disk:\nreturn oO;\n\nff Object loaded successfully:\nreturn pObject;\n}\n\nIn the preceding example, the function LoadGarQbjects() gets a frame but\nreleases it only if there was a problem while loading the objects. If both objects loaded\nwithout issue, the frame is not released and the function recums with the memory\nintact. [rs possible char a higher-level function obrained its own frame encapsulating\nall object-loading functions in addition to Load¢arOsjects(). When it comes Time to\nfree all object memory, the higher-level function simply calls ReleasaFrame() with\nthe frame it had obtained.\n\nConclusion\n\nSS\nSince frame-based memory works like a stack, it is imperative that frames are released\nin the order opposite of that in which they were obtained: otherwise, memory cor-\nruption can occur. Detecting violations of this condition is simple. Consider this\nreplacement function for releasing a frame:\n\nvold Aaleaseframe| Frane_t Frame } {\nff Ghack validity if releasing in Lower heap [O}:\nABEert( Frame.nHeepium==1 | |\n(uint)Frame.pFrane<=(uint) apFrame[o] I;\n\nff Check validity if releasing in upper heap (1):\nassert( Framé.obeaptun==0 ||\n(uint) Frame. pFrame>=(uint)_apFrame[1] 4;\n\nii Release frase:\n_SpFrane[ Frame .nteaplum] = Frana .pFraime:\n\n}\n\n‘This code detects arempts to release frames in che incorrect order in debug builds\nof the game. Further assertions could be added to detect additional validity problems\nwith the parameters.\n\nOne final point worth noting is chat for pame platforms with multiple indepen-\ndent types of memory (main, sound, rexure, geometry, and so forth), a frame-based\nmemory system could easily be implemented for each memory type and then linked",
      "content_length": 1915,
      "extraction_method": "OCR"
    },
    {
      "page_number": 98,
      "chapter": null,
      "content": "Section 1 Pregramming Techniques\n\ntogether to provide a master frame, Recall the preceding example. Suppose thar Load -\nFromBisk() loaded geometry, textures, and sound for the specified model. The geom-\netry is to be placed in system memory, the textures into texture memory, and sound\ninto sound memory. In this case, there would be three independent frame memory\nsystems linked nopether by a master frame:\n\ntypedet struct {\n\nFrame t SyamenFrame; i! System memory Fram\nFreane_t TéexmenF rane; J} Texture mesory Frame\nFrene t SoundnenFrame; i! Sound semory Fram\n\n} HasterFrame t+;",
      "content_length": 580,
      "extraction_method": "OCR"
    },
    {
      "page_number": 99,
      "chapter": null,
      "content": "1.10\n\nSimple, Fast Bit Arrays\n\nAndrew Kirmse\n\nWe love bitwise operations because they are fast and they pack data efficiently, but we\nhate them because they are error-prone and depend on the machine's ward size. What\nwe really wane is an abstraction of bitwise operations char gives us all the benefies but\nhides che unpleasanc details,\n\nOverview\n\n————\nThe three (C++ classes in this article implement arrays of bits. The base class, BitArray,\nisa simple one-dimensional array of bits. Its subelass pitarray2D is a cwo-dimensional\narray of bits, and the Teogdtarray subclass is an array of integer elements whose values\ncan range from © to 3. Each of the classes can be manipulated through English-\nlanguage methods or, alternatively, chrough familiar operators, The classes feature clear\nsyntax, portabilicy, range checking, correct use of const, and high performance.\n\nThe C++ Standard Templare Library (STL) includes a one-dimensional armay of\nbits in the header bit set. Although feature-rich, many implementations ane cryptic at\nbest and difficult co extend or modify (for a sample implementation, sec [SGI98]).\nSome STL implementations alsa depend on parts of the C++ standard such as mem-\nber templates and namespaces that are missing from some compilers. The implemen-\ntations in this article are straightforward and easy to integrate with existing code.\nThey also provide additional features thar are useful for game development.\n\nArray of Bits\nee\n\nThe base class Bitarray acts just like a normal C++ array af bools, although you are of\ncourse free to interpret the bits as integers with values of O and 1. The bits are stored\nin a buffer of longs in an endian-independent manner. Syntactically, you can crear a\nBitArray as similar to a regular C++ array, with the added benefic of dynamic array\nbounds and additional operators. For example, you can do the following:\n\nBitArray bits(num_bits), other bits (nun bits);\nbits ..Clear():\n\n101",
      "content_length": 1946,
      "extraction_method": "OCR"
    },
    {
      "page_number": 100,
      "chapter": null,
      "content": "102 Section 1 Programming Techniques\n\nbits[10] = true:\nif ({bits & other _bits).AlMBitsFalse()) {}\n\nThe class implements the standard birwise operators 4, |, -, 4=, |=, “=, and -. It\ndoes not implement shift operations.\n\nIn the interest of high performance, a BitArray is not initialized with any particu-\nlar value when it is created, The Clear() method sets all bits co Glse. As a further opti-\nmization, small BitArrays chart can fic inside a machine word do moe allocate any\nadditional memory. This males che class useful for even small sets of flags. This syntax:\n\nflags[FLAG INDEX] = true:\n\nis Clearer than che tradicional:\n\nflags |= 1 << FLAG_INDEX:\n\nBitArray and the other classes call assert when an array index is out of bounds.\nIn real-time games, this is generally preferable co throwing an exception, as the STL\ndoes, due to the overhead associated with exceptions.\n\nThe array subscripr operaror in BitArray is implemented with a useful C++ pat-\ntem known a¢ a precy elas. (See [Meyers95] for more information about proxy\nClasses.) The proxy class 8itProxy represents a single bit in the Bitarray. In the\nexpression:\n\nalidj = true;\n\nwe assign to the BitProxy of JO) using operatore, while in the expression:\n\nbool val = afio];\n\nwe merely read che value of a bit via the bool operator, The 8itProxy class allows us\nte delay evaluation of rhe expression a//0! until we know che context in which ic is\nused (reading or writing). This is a very handy erick char is also used in che ocher bit\narray classes.\n\nWore that the BitProxy object must be returned by value, so it might incur the\ncost of instantiating and deleting a temporary object. In normal circumstances, where\nthe bit value is immediately read or assigned co, che compiler is able to optimize away\nthis temporary object.\n\nOther Arrays\n\nBitarray20 is a two-dimensional analog of BitArray. For the most part, it behaves\njust like any other two-dimensional array:\n\nBitarray20 bats(10, 20};\nbits[S)(4] = true;",
      "content_length": 1977,
      "extraction_method": "OCR"
    },
    {
      "page_number": 101,
      "chapter": null,
      "content": "1.10 Simple, Fast Bit Arrays 103\n\nNote that the array subscript operator for Bitarray2D returns an ArrayProxy, which\nisa proxy class representing a single row of the array. ArrayProxy itself has a subseript\noperator thar returns a proxy fora particular bir in the aray. These mechanics are nec-\nessary to allow the familiar C++ double-subscripting syntax.\n\nBitarray2D intentionally does mot creat iss subscripted clements as one-\ndimensional 8itarrays:\n\nbits2d[S)] = bit array; ff illegal!\nbits2d[5].FlipAllSits.); ff illegal)\n\nAlthough it’s certainly possible to allow such operations, ir would complicate the\nArrayProxy class considerably, and these uses are comparatively rare.\n\nBitArrayed is implemented asa single BitArray chat concains as many bits as the\ntwo-dimensional array. Because itarray2D does not have the same public interface\nas BitArray, it inherics from BitArray via private. Like BitArray, all of i functions\nare short and inlined.\n\n‘The final class, TwoBitarray, provides an array of rwo-bir values, (Arrays with\nmore bits per clement are easy extensions vo this class.) The implementazion is an\nalmost trivial use of a Sitarray with owice as many elements as the Tee@itarray.\n\nthough extremely simple, this class is a convenient way to pack stare information\ninto a minimum of space,\n\nApplication\n\nEven such tradicional low-level C conseructs as bit arrays can benefit fom implemen-\ntation in C++. The C++ code is easier ro read and understand for a performance cost\nthar is almost always negligible. For games, this means less time spent developing and\ndebugging code thar is necessary for many applications,\n\nIf you use these classes in major dara senactures in a game (e.z,, state bits attached\nto each cell in a cwo-dimensional array of tiles}, ic might be useful to add operators a\nread and write the array to a stream. IF you do, be careful no Pay attention to endian-\nness When dealing with che array’s contents, if portability is important.\n\nThe sample code includes a vest program thar illuscrares usage of these bit array\n\nReferences\nee\n[SGI98) StGI, “STL header bit set.” available online ar wwwsel.coml Technology!\nSTLibinser, 19798,\n[Mevers95] Meyers, Scom, Jone Effective Cr+, Addison-Wesley Longman, Inc., 1995,",
      "content_length": 2248,
      "extraction_method": "OCR"
    },
    {
      "page_number": 102,
      "chapter": null,
      "content": "1.11\n\nA Network Protocol for Online\nGames\n\nAndrew Kirmse\n\nMost encryption schemes assume that a trusted sender and a trusted recipienc want to\ncommunicate over an unerusted channel It seems absurd to suggest char che sender\ncould deliberately try to fool the recipient, yet this is exactly the problem facing\ndesigners of online games. Some players cannot be trusted, and worse, chey have com-\nplete access to the encryption algorithm and all communicarions via the client exe-\ncurable. Under such circumstances we cannot hope to provide completely secure\ncommunications, bur we can make the attacker's job more trouble chan i's worth.\nThis article presents some practical techniques for building an application-level com-\nmunications protocol for online games.\n\nDefinitions\n\n104\n\nProtocol design is most interesting in client/server pames, where one of more untrusted\nliens communicare with a trosted central server. (Cheating is cermainly also a problem\nin peer-to-peer games, but because no enuity is crusted in such games, the situation is\nhopeless.) The consequences of cheating in a clieno/server game is high because the\nserver, 26 the only trusted entity, maintains che game state and verifies all cient com-\nmands. When the game state is persistent, a single successtul cheat can destabilize a\ngame invelving thousands of players.\n\nWe consider protocol security features in a client/server system. The client and\nserver communicate by sending packets over a necwork channel, which might be reli-\nable (typically TCP) or unreliable (UDP). Although clients can also communicate\ndirectly with each other, perhaps for chat or voice, we assume that any data that need\nto be secured are sent only between a clienc and che server.\n\nEach packet contains two pars: the Aeader, containing administrative informa-\ntion, and the payload, containing the actual dara we want to communicate. The goal\nof the neework protocol is to deliver the sender's original payload ta the recipient. Any\nmodifications to the sender's sequence of payloads should be detected. We deal only",
      "content_length": 2068,
      "extraction_method": "OCR"
    },
    {
      "page_number": 103,
      "chapter": null,
      "content": "1.11 A Network Protece! for Online Games 105\n\nwith delivery of the payload, leaving the details of packer ordering and reliabiliry co\nlower levels in the protocol stack,\n\nPacket Tampering\n\nMost protocol hackers are casual: they change bytes in a packet and sce what hap-\npens, The first line of defense against such atracks is a simple checksum. A checksum\nis a short number produced by combining every byte of the packet. The sender com-\nputes the checksum of the packet and sends both the packet and the checksum to the\nrecipicnoe. ‘The recipient takes the packer and recomputes its checksum: if the com-\nputed checksum doesn't match the checksum fom the sender, the packet is corrupt\nand should be rejected. It's important to include the entire packet, including the\nheader, in the checksum computation, so that the recipient can devect changes to the\nheader as well as che payload.\n\nA perfect checksum computation would produce a different value if any byte of\nthe packet were changed to any other value. A perfect checksum would be too long to\nbe useful, of course, bue hash functions have the same design poal and make excellent\nchecksums. Particularly useful are one-way hash functions, which scramble their\ninput to the extent that reconstructing any part of the input from the hash value is\nimpossible for practical purposes. The MID5 algorithm is well tested, publiely avail-\nable, and fast enough for use in games. A public domain implementation is available\nonline [Plumb],\n\n‘There are two weaknesses in this simple checksum mechanism. First, because the\nclient cxecutable contains the checksum computation code, am actacker can reverse\nengineer the checksum algorithm, and then compute valid checksums for any mes-\nsage. Second, an attacker can capture valid packets and resend them larer, an attack\n\nknown as packer replay,\n\nPacket Replay\n\nIna packet relay attack, a malicious user captures a packer from the client (prpically\nusing a packer sniffer), and chen sends it multiple times. A common tactic is to use\npacket replay co perform commands faster chan the game allows, even if there are tim-\ning checks in the cliene. For example. a client might use a timer to send a certain com-\nmand to the server at most ance per second, no marter how’ frequently the player\nissues the command. Using packer replay. a single user might issue the same com-\nmand hundreds of times per second.\n\nA system designer might my to stop this particular atrack by putting a similar\nonce-per-second timer check on the server as well. In the face of widely variable net-\nwork latency, however, this defense is impractical, Although it detects most packet\nreplay attacks, varying network delays can make packets bunch together by the time",
      "content_length": 2731,
      "extraction_method": "OCR"
    },
    {
      "page_number": 104,
      "chapter": null,
      "content": "Section 1 Pregramming Techniques\n\nthey reach the server, causing legal command sequences to be rejecoed. We certainly\ndo not want our security scheme to mark law-abiding players as cheaters.\n\nTo guard apainst packer replay, cach packet should conrain some stare informa-\ntion, 0 that even packers With identical payloads have difterenc bir Paltrerms, Sarre:\nthing as simple as a number that increments with each sent packer would do, although\nthat scheme is too easy for an attacker to figure out. A better answer is to use a state\nmachine to produce successive identifying numbers for successive packers. A fast and\nreasonably complicated method is a linear congruential random number generator of\nthe type cypically found in system libraries. Such generators operate as follows:\n\nState = (State + a) * 6\n\nwhere @ and 4 are carefully chosen integers. (For a discussion of this generator, sec\n[Rnuch98].)\n\nThe sender and recipient cach keep a linear congrucntial random number gener-\nator for cheir connections. When sending a packet, the sender produces a random\nnumber and adds it ta the packer, simultaneously stepping its random number gener-\nator. ‘The receiver checks the random number in the incoming packet against its gen-\nerator, if che numbers dont match, the packer has been tampered with. If the\nnumbers do match, the receiver steps its random number generator to prepare for the\nnext packer.\n\nThere are two complications with this scheme. The first is how the sender and\nreceiver initially synchronize their state machines, They could each start their state\nmachines with the same fixed seed, bur then the initial stream of packets would\nalways have the same bit patterns and thus would be vulnerable to analysis. Instead,\nthe server can initialize its stare machine with randomly generated seed values and\nsend these to the client in its first message.\n\nThe second complication is how to keep the state machines synchronized during\ncommunication, On a reliable connection, packets are never lost, so synchronization\nis guaranteed. When packets are dropped or reordered, however, the sicuation\nbecomes more complicated. Ifa message is lost, the sender's state machine will have\nadvanced one more step than che receiver's; subsequent packers will be rejected, even\nthough they are legitimate. A simple solution is co rely on a true sequence number\nsent with each packer (most games include this number with messages anyway, to\nprovide a reliable connection over an unreliable cansport). Given a sequence number,\nthe receiver can determine how many times to step its state machine ro catch up to the\ncurrent packet. [f the application allows out-of-order delivery, the old state of the stare\nmachine will have to be stored for use when an out-of-order packer arrives later.\n\n‘The rand function provided with most run-time libraries is inappropriate for use\na a Hate machine because of its low precision (many implementations have only 15\nbits) and its obvious choice as a source of random numbers. A fact, high-quality ran-\ndom number implementation is given in [Booth].",
      "content_length": 3082,
      "extraction_method": "OCR"
    },
    {
      "page_number": 105,
      "chapter": null,
      "content": "1.11 ANetwork Protocol for Online Games 107\n\nAdditional Techniques\n\nIdeally, two packers with identical payloads should show as lire correlation in their\nbit patterns as possible, to frustrate analysis of the payload. An eisy way to remove all\ncorrelation between two sees of data is to combine them with a sequence of random\nbits, using the exclusive-or (KOR) operator. Assuming the previously described\npacket replay defense, che sender and receiver already have synchronized random\nnumber generators. Thus, the sender can generate a sequence of random numbers for\ncach packet and NOK these into the packer payload; the reeciver generaces the same\nsequence of numbers and retrieves the original payload in the same Way.\n\nEven the fact that two packers have the same length can give an attacker a clue\nthar the packets encode similar dara. To further frustrate autacks, each packer can con-\ntain a variable amount of random “junk” data, meant only to vary the length of the\npacker. The length of the junk dara is determined by yet another synchronized state\nmachine. The sender checks its stare machine to determine how much junk to gener-\nate and inserts that number of random bytes into an ourgoing packer. The receiver\nsimply ignores che junk data, Increasing the ammount of junk data helps to further hide\nthe payload bur costs additional bandwidth, In typical applications in which band-\nwidth is limited, the average length of junk data should be made small compared to\nthe average payload size.\n\nReverse Engineering\n\nThe hardest problem to address, and ultimately the downfall of any scheme to stop\nprotocol tampering, is that the client contains the entire encryption algorithm and\nthus can always be reverse engineered. Some steps you can take to make reverse engi-\nneering harder are as follows:\n\n* Remove all symbols and debugging information ftom any code released to the\npublic,\n\n* Dont isolate buffer encryption and decryption in their own functions: instead,\ncombine these with some other necwork code, This is one area in which it can be\nworthwhile co trade maintainability for security.\n\n* Compute “magic numbers” {such as initialization seeds) at run time instead of\nplacing their values directhy in the executable,\n\n* Include a good encryption scheme in every version of the client, even early betas.\nIf any client version lacks encryprion, a user can record a stream of unencrypted\npackets from one client and then use knowledge of the packet payload to help\nbreak the encryption in a larer version.\n\n* Remember thar your goal is to make cheating prohibitively expensive, not impos-\nsible.",
      "content_length": 2610,
      "extraction_method": "OCR"
    },
    {
      "page_number": 106,
      "chapter": null,
      "content": "108 Section? Programming Techniques\n\nImplementation\n\nThe implementation included with this article includes a ‘C++ class SecureTransport\nthar uses all the previously described techniques ..A Securetransport object encapsu-\nlates a two-way connection between a sender and a recipient. For each direction, the\nobject maintains four linear congruential random number gencrators as protacol state\nmachines, These are initialized to static values, with the understanding that the server\nwould send random seeds in its first message to the client. The class uses the stare\nmachines as follows:\n\n1. It MORs the length field at the start of che header. (This is unnecessary if the\nunderlying protocol provides a packet length as in UDP)\n\n2. A message sequence number is used to prevent packet replay.\n\n3. It determines the length of junk data in each packer.\n\n4. It generates random bits to XOR the payload.\n\nA separate random number generator is used to gemerace che actual junk dara.\nDuring debugging, it is usefiel to set che junk data to a known constant value.\n\nReferences\n\n[Booth97] Booth, Rick, Juwer Loops, Addison-Wesley Developers Press, 1997,\n\n[Knuth98] Kauth, Donald, The Art of Computer Programming. Volume 2: Sensinn-\nmerical Algorithens, third edition, Addison-Wesley Longman, Inc., 1998.\n\n[Plumb93] Plumb, Colin, “md5.c,available online ar hmp://src.openresources.com/\ndebian/see/admin/HTML/S/rpm_2_4.12.orig%20rpm-2.4.12%201ib%20md5.\n«hem, 1993.",
      "content_length": 1454,
      "extraction_method": "OCR"
    },
    {
      "page_number": 107,
      "chapter": null,
      "content": "1.12\n\nsqueezing More Out of Assert\n\nSteve Rabin\n\nAlmost everybody uses assert, but not everybody is getting the most out of it. This\narticle contains seven cool lite tricks that can be used to squeeze more functionality\nout of assert. If you're already familiar with assert, skip down to “Assert Trick #1.\"\nOrherwise, read on ...\n\nThe Basics of Assert\n\n—— Sa\nEvery programmer should religiously use the assert macro. The assert macro is a\nsimple, painless way to double-check your assumptions, and it will save you every\nume. By giving the assert macro a condition to evaluate, you're asserting thar this\ncondition should be TRUE. Ifthe condition evaluares co FALSE, assert brings up a\ndialog box telling you thar a problem has occurred, You can then choose to ignore the\nassert and continue executing your code, abort the program, ot break directly into\nthe code where the assert failed.\n\nThe assert macro lets you program defensively. IF you know a pointer should be\nNULL, you should assert thar it is NULL. By making assert a habit in your code,\nyou'll catch mistakes before they have a chance to bite you.\n\nVector normalization is an example of an important place to use asserts. In the\nfollowing function, three assumptions must be met for the code co execune without\nwreaking havoc, The sre and dit vector pointers must both be valid, and the length af\nthe sre vector must not be zera.\n\n#include sassart.h>\nvoid Vectoriormalize! Veo\" sre, Vac* dat j\n{\n\nfloat length:\n\naisert( sre l= 0 }; if Gheck that the sre veetor is not HULL\nansert( dat I= 0 ); if Gheck that the dst veeter is not NULL\n\nLangth = sqrt( (8ré->x\"sre->x) + (sre->y*src->y) +\n(sre->2*ere->F) jj\n\n109",
      "content_length": 1671,
      "extraction_method": "OCR"
    },
    {
      "page_number": 108,
      "chapter": null,
      "content": "110 Section 1 Programming Techniques\n\nassert( length t= 0 ); Ii! Check that the length is nagt zero\nfi (to aveid dividing by zera)\n\nd6t->% = 6ro->%e / length:\ndst-sy = sre-sy / langith;\ndSt->2 = sre->z / langth;\n\n}\n\nSince the VectorNormalize function needs to be blazingly fast, we cant afford to\nwaste time checking the assumptions in release builds, However, while the game is in\ndevelopment, we need to be aware of any problems that come up. Thar’s where\nassert makes a lot of sense. The aesert macro doesn't get compiled in release builds,\nso assumptions can be tested during development and automatically removed when\ncompiled in release. This allows you to sprinkle asserts throughout your code with-\nout worrying about removing them before your game ships.\n\nSince the assert macro is nor compiled under release builds, its incredibly\nimportant that you dont change the stare of your program within the assert. As a\nrule, don't call functions or alter any variables inside ir. The result would be behavior\nthar differs between your debug and release versions, which could be disastrous.\n\nWhy not just puc permanent error checlang inside the VectorNormalize func-\ntion? This function is so low level that it doesn't have a clue how co remedy any prob-\nlems. Hopefully (cross your fingers), cvery piece of code char calls VactorNormalize\nchecks for these assumptions because it can direcely deal with problems. Ifa piece of\ncode fails to check those assumptions, the assert will be triggered inside vectermor-\nmalize, anda programmer can then know to fix the actual code char caused the error.\n\nAssert Trick #1: Embed More Information\n\nOne of the drawbacks of che traditional assert macro is that it doesnt cell you much\ninformation. [Fassert(sre t~ 0) fails, it brings up the suring “sre f= 0\" in the assert\ndialog box. Unforrunarely, this doesn't give you much to go on. Unless you're running\nthe game from your debugger, it's not very clear whar the problem is. One technique\nis to embed more information inside your condition. Consider the following vec-\ntorNormalize function:\n\nFinctluda <assert.h>\nvoid VectorNermalize( Veco\" src, Vac* det ]\ni\n\nfloat length;\n\nagsert( are l= 0 && “VectorNormalize: src vector pointer 4% NULL\" 4;\naaeert( gat t= 0 Bk “Vectoriormalize: dst vector pointer is NULL\" 4;\nLengen = sqrt, (Sre->x\"sre->x) + (sre-sy*are-ry) * tsre->z\"sre->z) J;\n\nassert( length §'= 0 && “VectorNormalize: sre vector is zero length\" };",
      "content_length": 2450,
      "extraction_method": "OCR"
    },
    {
      "page_number": 109,
      "chapter": null,
      "content": "1.12 Squeezlng More Out of Assert 411\n\nG6t-=\" — sro-3e / Langen;\n\nF\nget->y = ere-sy / Langth:\ndat-*2 = sré-sz / length:\n\nWhen the first assert fails in this onde, the assert box displays the sting “src\n'= 0 Sh “VectorNormalizea: sre veeter pointer is NULL\"*. Even if your besters are\nrunning the game, they can tell you the function name where the assert failed, along\nwith the reason,\n\nAssert Trick #2: Embed Even More Information\nSe ee ht iat bee beeline inf\n\nSometimes programmers simply type assert (0) if the program exceution reaches an\nugly spot. You can pull the same trick of inserting a descriptive string simply by megan\ning the string to make it false. For example:\n\nSfeert, 6 WectorNoraalize: The code should newer get here\" hz\n\nThis line accomplishes the same thing as assert (0) while also giving you some\ngrear debugging information.\n\nAssert Trick #3: Make It Less Awkward\n\n‘The first wo cricks can be combined in seconds by writing a simple macro. This\nmacro takes two arguments, the first being the condition to evaluate and the second\nbeing the descriptive siring. This mimics the first owo cicks bur makes it easier to\ntype and read:\n\nWdefing Accert(a,b} assert( a 4& b }\n\nThe following ewe lines use che new macro:\n\nassert{ are t= 0, “VectorNorm@alize: src vector pointer is NULL* li\nassert( 0, “VectorNormalize: The code should never get here\" ):;\n\nAssert Trick #4: Write Your Own\n\nEventually cveryone should use an assert macro that’s been truly customized. The\nidea is to write your own aseert dialog box code so that you can have more control\nover adding feapures,\n\nA very annoying problem of the standard C assert is thac it breaks into the\ndebugger in the file assert.c—not che line in your program where the assert appears,\nBy writing your own assert macro, the debugger breaks directly to the assert linc\nthat you typed. ‘This avoids the needless step of backtracking up the stack ro get to the\nspot you're actually interested in, The following is an example of a custom assert\nmacro:",
      "content_length": 2013,
      "extraction_method": "OCR"
    },
    {
      "page_number": 110,
      "chapter": null,
      "content": "112 Section 1 Programming Techniques\n\nWit defined, DEsuUG }\nextern bool CustensssertFunctiont bool, chars, int, char® );\n\nedafing Aseert( exp, description } 4\nif( CustomAssertFunction( (int)(exp), description, _ LINE_,\\\nfats | as\n{ 35m { int 3} } /ithis will causa the debugger to break hare\n\nfolse\nMdetine Assert( exp, description }\nPandit\n\nThe above macro calls GustanAssertFunction, which you have vo write yourself.\nGustomiseertFunction should bring up a dialog box stating the assert information\nand allow the user to either continue or break. IF the user chooses wo break, Custem-\nAssertFunction should retum TRUE, and the debugeer will break on the Assert\nlime (thac’s whac the int 9 instruction does on the PC), Otherwise, the function\nshould return FALSE, and the program will continue executing.\n\nAssert Trick #5: This One Is Priceless\n\nOnce you have a custom assert macro, you can add an “Ignore Always” option to\nyour assert dialog box. This is an amazing fearure thar lets you ignore an assert once\nand have it remember to never bother you again. It’s particularly useful when an\nassert is failing every frame, bur you still wane to run your game without clicking\nthrough a million asserts. To implement this feature, each assert keeps track of\nwhether it should be ignored and purposely suppresses itself if it should fail in the\nfucure.\n\nPractically, the way to implement “Ignore Always” is to place a static boolean\nwithin the assert macro. This boolean then remembers whether the assert is to be\nignored. Initially, the boolean is set to FALSE, When the code execures, it checks this\nboolean before it even evaluates the assert condition. If the boolean is FALSE, it calls\nthe GustomAssertFunction with the pointer to the boolean as an argument. If the\nassert condition fails and the user selects “Ignore Always” in the assert dialog box,\nit then sets the boolean vo TRUE. The following is the code for the macro:\n\n#if defined( DEBUG }\nextern bool CustonAssertFunction{ bool, char*, int, char\", bool\" };\n\nWdetine ASsert{ exp, daseription } |\n{ Static bool ipnoraAlways = false; 4\nif( tignoreAlwaya ) { 4\nif{ Custom4esertFunction( {int} (exp), deseription, |\n— LINE _, _ FILE, dignoredAlways } ] ) 4\n{ _asm { int 3} 4} 4\nyA\n}",
      "content_length": 2241,
      "extraction_method": "OCR"
    },
    {
      "page_number": 111,
      "chapter": null,
      "content": "1.42 Squeezing More Out of Assert 113\n\n#elee\n#dafine Assert({ exp, dasoription }\nFondit\n\nAssert Trick #6: Only Hf You're Totally Hard-Core\n————— OOOO\n\n‘There's a nagging problem with assert chat shows up clearly in the VactorNormalize\nsample function. The problem is thar the source of the error is not inside VeetorNor-\nmalize. I'he true error is in the function that called vectorNormalize, which narrows\nit down to only several hundred routines! If this type of assert fails without the\ndebugger running, the assert is virtually useless, Surprisingly, this is a common situ-\natbon, since testers rarely run games from the debugger.\n\n‘The simple solution is to provide stack information inside the assert dialog box!\nJohn Robbins, a writer for Microsoft Systems Journal, coined rhe name superaseert to\ndescribe this implementation. In his column “BueSlayer,” he worked our a Windows-\nspecific example, complete with source, which can be used as a reference [Rob-\nbins99).\n\nAssert Trick #7: Make It Easier—Copy and Paste\nee\n\nIts really cool when a simple trick makes work a lot easier. This trick falls into that\ncategory. Ifthe assert provides cons of great debugging information such as the stack,\nwhy not make it really easy for testers to pass it along?\n\nIn the Windows environment, you can have a burton on the assert dialog box\nthat copies the information to the clipboard! With a few simple mouse clicks, anyone\ncan easily copy and paste the assert into an e-mail or bug report. This simple, pow-\nerful idea will help your resters convey accurate, meaningful information back to pro-\ngrammers.\n\nThe following code copies an arbitrary string into the clipboard. You'll want co\nalter it slightly and pur it inside your CustomAssertFuncticn,\n\nif( Opentlipboard, MULL } }\n{\n\nHGLOGAL Alem;\nchar szAssert[ 256];\nchar *pWen:\n\nSpraintt( szAssert, “Put assert info here\" ie\nhillem = GlobalAlloc GHND|GNEM_DDESHARE, atrlen( szAgsert }41 43\n\nif( hMam ) {\nPifan = (char \")Globaliock( hitgm 4;\nstrcpy( pen, szAsgert };\nGloballinlock( hWam };",
      "content_length": 2036,
      "extraction_method": "OCR"
    },
    {
      "page_number": 112,
      "chapter": null,
      "content": "114 : Section 1 Programming Techniques\n\nEmptyClipbaard ):\nSatelipboarddatal CF_TEXT, hMem );\nI\n\nClosetlipboard! );\n\nReferences\n\n[McConnell$3] Metconnell, Steve, Caste Complere, Microsoft Press, 1995,\n\n[Rebbins00) Robbins, John, Debugging Applications, Microsoft Press, 20000.\n\n[Rebbins$9] Robbins, John, Micros? Seren Journal: BugSlayer, available online at\nwww. microsoft.com/msj/defaulttop.aspipage=/msj/0299/bugslayer/bugslayer029\nStop-hom (code available at weew,microsoft.com/msj/0299code/FebSBugSlayer\nap), February 1959.\n\n[Saltzman?9] Salzman, Marc. Game Design: Secrets of the Sager, Brady Publishing,\n1999.",
      "content_length": 615,
      "extraction_method": "OCR"
    },
    {
      "page_number": 113,
      "chapter": null,
      "content": "1.13\n\nStats: Real-Time Statistics\nand In-Game Debugging\n\nJohn Olsen\n\nEveryone spends more time debugging than they would really like to. This huge time\nsink has led to the development of a system I call Stats, a real-time debugging and\ndata-cditing system. This system can make life for you, che programmer, easier\nthrough simplified debugging and data tracking in a live system as it executes on the\ntarget platform. This technology has been used on commercial products for both PCs\nand consoles. The name is derived from the word staristics hecausc the original inspi-\nration for the idea was the display of numeric statistics from within a game solely for\nthe purpose of debugping.\n\nThe tool set described here is fairly simple to implement, highly extensible, and\nhighly applicable to many facets of game software design and testing. Chis means that\nit is easy for you to customize to your particular needs, which often vary from one\nproject to the nex\n\nWhy: A Need-Driven Technology\n\nBoth PC and console systems have problems with debugging full-screen, real-time\napplications. On the PC, you must resort co network-based debugging, multisereen\nsystems, or the ability to pop between windowed and full-screen mode during the\ndebugging sesion. Sometimes the debugging environment docs not allow access to\nsome or all of the data while the system is running, and hitting a breakpoint at the\nwrong point in a real-time loop can lock up your system. In the case of video game\nconsoles (referred to simply as consoles hereafter), you have no keyboard, so something\nlike a drop-down winclow fora command-line interface, such as is often used by firse-\nperson shooters, is pretty much outas a debugging toal. We are trying oo fix the shore-\ncomings of debugging environments, bur it would also be nice to have a way to\nreduce the edin/compilefrun loop a bit.\n\nEvery programmer who has worked with a real-time loop is sure ro have war sto-\nries of the nasty bug that took forever to find. Sometimes the code runs differently\n\n4115",
      "content_length": 2027,
      "extraction_method": "OCR"
    },
    {
      "page_number": 114,
      "chapter": null,
      "content": "116\n\nSection 1 Programming Techniques\n\nwhen you single-step through it. Sometimes you need ro debug a live network game\nto reproduce a problem, or better yet, debug both ends of a network game at once.\n\nConsoles have the added difficulry of having a limited path back to mass storage,\nif the path exists at all. (On some console development systems, it is possible to access\nthe development PC file system vo read and write files, but once you go to CD or car-\nmidge, the data path back to the PC prows very restricted. About the only option left\nis to stere data onto memory cards, then read the memory cards on a development\nsystem that has access to a PC file system.\n\nConsole game systems, and embedded systems in general, have some problems\nthe PC crowd may not run into, The debuggers for console systems have been petting\nbetter over time, bur there is still a great deal of room for improvement. Furthermore,\nnot a lot of debugging can be done once you burn your game onto a CD.\n\nAt some point, almost every project has puc a frame-rate counter on the screen or\ndisplayed some other sort of data from a live system. Other common items thar are\nhard to get at with a debugger but are easy co crack in a live system are the polyersn\ncount, culling efficiency, and general execution times based on the content of che\nviewport. It makes you want to build a system for displaying arbitrary lists of num-\nbers, It certainly gor under my skin, and eventually | did something abour ir.\n\nThe idea of an in-game display can be expanded to include editing of the data,\nwhich can help in a number of ways. First, debuggers don't typically ler you rcad and\nwrite data files. Second, with an in-game editor, whether keyboard of controller\nbased, you can edir the actual game dara as you run the game. Third, che edited data\ncan be loaded and saved on a PC or console development system.\n\nHow: An Evolutionary Process\n\nThe code included in this chapter evolved over the years from a simple displayed list\nof numbers that could noc be edited to a list of cexr labels and read-only numbers,\nultimately to the current version, which includes multiple pages of dara that can be\nedited while the game is running, The text-based display is simply an overlay dis-\nplayed on cop of the garne itself,\n\nFor many projects, it has worked our co be a lot easier no use an editable version\nof Stats rather than cheat codes. Stars can be used to toggle particular features on and\noff, and a set of related features can all be displayed together on a single page. With\nthis setup, you can get to some really detailed dara on system behavior while the sys-\ntem is still running.\n\nConsoles, with their debugging drawbacks, can benefit particularly well from an\nadditional method of debugging that does not rely on the tool set provided by the\n\nconsole manufacturer,",
      "content_length": 2840,
      "extraction_method": "OCR"
    },
    {
      "page_number": 115,
      "chapter": null,
      "content": "1.413 Stats: Real-Time Statistics and In-Game Debugging 117\n\nWhat: A C++ Class-based System\n\nTo start, the full code: for each class and its member functions ean be found on the\nbook's accompanying CD-ROM. You might want to refer to it as you go through the\nfollowing material.\n\nAsmilar implementation of this Stars system took less than a week to desipn as a\nC++ class using a common Star base class and derived types for each displayed data\ntype. The system consists of a base Stat class, which is the container for everything,\nand separace pages, which each contain a number of entries.\n\n‘There is a tradeoff with the way you end up printing Stats to the screen. If you\npur your printing code in the derived Stat class, ic is less portable, but you can do\ninteresting things such as having a Stat thar is rendered as a bar graph. If you simply\nhave the Stats fill in a string to be dumped to the display device, as in the provided\nsample, you have a highly portable implementation that can be used more easily for\ncross-platform developmen.\n\nThe base of the system is a class chat holds a linked list of pages and some other\ninformation that needs ro be global to the Stats system. An Initialize() function\ntakes the place of the constructor because it is a fully static class that may nor have an\ninstance created, resulting in no call to a constructor. The base system has a Print{}\nfunction that calls the Print() function for the current page.\n\nThe Windows-based sample code also has keyboard input processing, which\ntakes an array of boolean key states as input. The array is built by tracking wa_KEYDOWN\nand W_KEYUP messages from Windows in the eventt-procesing loop of the program.\nOn a console, you pass in an array containing the coneroller state. With each pass\nthrough the real-time loop, both the CheckInput(} and Prant() functions need ro be\ncalled. Pages are added automatically by having their constructor call the base\nAgsPage(), since itis simpler to not make the programmer remember to do it for each\npage he or she adds.\n\nThe initialization is needed simply to guarantee that the base isn't pointing at ran-\ndom cata that would be interpreted as a page. Ir also sets up the limits for how many\nlines belong on a full sereen.\n\nEach page in the linked list owned by the base class contains zero or more entries,\nOne of these pages is always the current page, whether it is displayed or hidden.\nEntries are added to pages using che common entry parent class. The constroctors for\nentries automatically call the AgdEntry() function, similarly co the way the page con-\nstructor calls AddFaget 4-\n\nEach page contains a linked list of enrries. The entry constructor is used to set up\nthe initial state of the Stat, including the page on which it appears, a cext Label, and\nthe relative prioricy of the entry (which can be thought of asa line number). Denved\ntypes also have an inittal value, should the derived pepe need to be initialized with a\nparticular value. The virtual functions of the default class cstatentry are to be over-",
      "content_length": 3048,
      "extraction_method": "OCR"
    },
    {
      "page_number": 116,
      "chapter": null,
      "content": "Section 1 Programming Techniques\n\nfidden in cach derived class so that the parent system can access each Stat type\nthrough a common interface.\n\nAdding a new class is dane by copying one of the classes derived from ¢Statentry\nto a new class name, renaming it, and adding an appropriate variable w hold the\nvalue. Once that is done, you need to rewrite parts of the member functions to match\nthe new data type.\n\nThe actual data stored ina Stat varies based on the Stat type and is included in the\nderived Stat classes. Fach data type has its own Print() function co replace the base\nelass virtual function. This function is very useful because che base class can then po\nthrough a list of generic Stat pointers and tell cach to print without having to worry\nabout whar type it is. Navigation is also simplified by basing all Stats on a common\nparent class. Using the parent type as a generic Stat pointer helps keep things orga-\nnized and under control. With multiple pages and each page having a current item to\nkeep track of, it can get a bit confusing otherwise,\n\nOne typical use for Stats is converting fixed-point statistics to printable floating\npoint equivalent values. Stats can be a bit of a processor pig on large pages, but it can\nsave a great deal of development time. The value 1.75 is casier to read than 5G and\nhaving to mentally divide by 32 to get the floating-point equivalent of a certain six-bit\nfixed-point number.\n\nAdding Stars to an application requires three things:\n\n. Call ¢StatBase:: Initializes) at startup.\n\n- Call GStatBase::CheckInput() each pass through the real-time loop to update\nthe Stats keyboard state or the concroller stare on a console.\n\n3. Call cStatéase: :Print() alter rendering the screen to display the Stats on top of\n\nyour real-time image.\n\nfd\n\nImplementation time for a new Seat type varies depending on complexity, but a\nsimple numeric type can be added in under 10 minutes. A type using enumerations,\nVectors, Matrices, ar something more complex takes longer but is preety straighefor-\nward as well.\n\nA derived Stat type in the sample code called a cStatIatetr deserves a litle bit of\nextra explaining because of iss slightly difference inverface and the interesting things\nyou can do with it. The value stored in the Star is a pointer to an integer. When it is\nprinted, the value of the integer being pointed ar is shown. This feavure allows you to\ndeclare a Stat and have it automatically updare the displayed value as ie changes\ninstead of having to set che value of the Star im each frame. It also allows you to\ndirectly edit the value of the number being pointed to, one of the more powerful\nadvantages of this system. You have direct access ca a variable within your running\ncode by adding just one line of debug code to declare an instance of a Stat.\n\n‘Typical execution time for running a similarly designed implementation of Stats\non a Sony PlayStation has been under 2 milliseconds per frame, with enough Stats\nbeing displayed to cover che entire screen. For reference, one frame ar 30 frames per",
      "content_length": 3055,
      "extraction_method": "OCR"
    },
    {
      "page_number": 117,
      "chapter": null,
      "content": "1.13 Stats: Heal-Time Statistics and In-Game Debugging ; 119\n\nsecond takes 33.3ms, so Stars uses less chan 69 of the processor when showing a full\npage of data. Since you obviously want to compile withour Stats for your release build,\nthis ime is given back to che rest of the program when development nears completion.\nThe percentage of processing time used on a PC citle should be quire a bis smaller.\n\nOne word of warming on this implementation of Stats, It isn't designed to work\nwith pages and entries appearing and vanishing. All page and entry instances should\nbe declared static. It isn't too hard to change it over to allow for dynamic creation and\ndeletion of Stacs, but having static Stars has always been sufficient, so the extra effort\nwas never put into it, You can change the classes to enforce this current behavior by\nbuilding destructors into each function with an assert chat halts che program when ir\ndiscovers a Stat being destroyed duc to its going out of scope.\n\nWhere: Applicability\n\nOne readily apparent use of Stats is for user interface protoryping, where you want co\nset up your screen flow without having real screens available yer. A typical menu can\nbe set up in a few minutes, allowing you ro bypass unfinished user interface code. You\nhave much less wo design, since the cext-hased interface is already implemented in\nStats. Sumply write your bypass Stars, and you are off and running again instead of\nwaiting for someone else to finish some critical chunk of code.\n\nYou could incorporate Stats into a racing title for in-game editing of direction\nand path indicators, Stars can be set up to tigger loading, moving, and saving the\ndirection markers while the game is running, It's also been used previously to edit Al\ncapabilities and to load and save several kinds of dara files, including the batch pro-\ncasing of script files into memory dumps of a class. (See the article Fast Data Load\n‘Trick’ for derails.) It can also be used to trigger the export of frame caloularion time\nbased on world position to build charts that indicate high load areas,\n\nStars also give a convenient way to jump to arbitrary levels within a game. There\nare any number of things you might want to override or curn on and off while the\ngame is running! Some examples are highlighting collisions, tweaking camera behavior,\nindicating player speed, setting environmencal lighting, and so on. It greatly simplifies\nthe life of the modeler if ir is possible to edic che camera offsets and field of view in the\napplication as well. Then those numbers can be easily plugged into modcling software\nence instead of looping through the build-test-build-test sequence a dozen times.\n\nSummary\n\nOn che projects [ have worked on in which we have wsed the Stats system, it has saved\na great deal of time, nor only for the software designers but also for art and level\ndesigners. Stats is an easy way to add a debug incerface to an application, whether for\nPC or console. It's even pretty easy to retrofit Starts into an existing application, should\nyou be halfway through development when you find that brick-wall bug that stops\n\nyou in your tracks.",
      "content_length": 3148,
      "extraction_method": "OCR"
    },
    {
      "page_number": 118,
      "chapter": null,
      "content": "1.14\n\nReal-Time In-Game Profiling\n\nSteve Rabin\n\nProfiling code is a routine step in most software development, but it's an even more\ncrucial step in games, Since games are constantly pushing the envelope, they need to\nbe frequently monitored for hot spots or stupid mistakes that can hog down the frame\nrate. When che frame rate curns south, the source of the problem could be anyone's\nguess uncil a real measurement is taken. Was it the Al code char was tweaked last\nnight, or was it the collision detection code that was altered this morning? Or even\nworse, it could be an area of code thar hasn't been touched for weeks that's now inter-\nacting badly with some new dara. The only way co know is to profile it.\n\n‘This article shows you how to add profiling code directly inside your game. Not\nonly will you be able to quickly find the hot sports in your code, but in addition, any-\nene— other programmers, producers, designers, artists, and testers—can pop this\ninformation on screen. This information makes profiling an accessible wool char ulti-\nmately helps fine-tune your code and find bugs. For example, if the frame rate tanks\nevery time a big fire-fight occurs, is it the complexity of the graphics or the collision\nlogic thar’s responsible? When profiling is at your fingertips, a simple press of a button\ncan cell you the answer.\n\nSome people are adamant abeut not profiling their code until they're close to\nbeing finished with a module. “Why should I worry about speed when I’m still crying\nto make it work?” they reason. Although there is some cruth to this thought, irs\ninvaluable to be able co see haw your code is actually performing. Many cimes I've\nprofiled a module in the middle of development only to discover thar the function I\nthought was being called all the time never goc called or gor called cwice as much,\nObviously, this is a cool chat can help debugging at any point in development.\n\nGetting Down to Specifics\n\n120\n\nThis real-time profiler allows you t monitor any spot or segment of code you're inter-\nested in. It works by calling a function at the beginning and at the end of the area you\nwant to profile, Each sample, consisting of a Profilefegin and a Profilecnd, is iden-\nwified with a unique name that you choose. Using the supplied code, you wrap Pro:\nFiloBogin( “InsertSampleNamgHere\" ) and ProfileEnd( “InsartSenpleNaneHere\" )",
      "content_length": 2368,
      "extraction_method": "OCR"
    },
    {
      "page_number": 119,
      "chapter": null,
      "content": "1.14 Real-Time In-Game Profiling 424\n\naround the code you want to look ar. Irs impertane to note chat the string names\nneed to match exactly (asserts carch any cases where they don‘).\n\nThe Overhead of Profiling\n\nOverall, the profiler takes a negligible amount of time to keep wack of your samples,\nespecially since you're going to watch only a handful of spots ara time. Unfortunately,\ndisplaying the results on screen probably hurts your frame rate a little, depending on\nhow it is implemented and how much text is displayed. If your on-screen text is badly\nimplemented (or not implemented at all), you could always represent ir graphically\non screen or ler the data accumulate and dump it to a tex: file. Furthermore, as with\nany debugging code, you can always wrap it so that it doesn't compile when building\na release version. However, until you get close to shipping, you definirely wane oo be\nable to activate the profiler in your optimized builds.\n\nSince the monitoring does take some amount of time, don't monitor very small,\nsimple snippets of code, especially if they are executed hundreds of times a frame. The\nmonitoring takes more time than the code fragment and causes it te look worse than\nit really is. An example is monitoring a function such as VectorNormalize() char is\ncalled hundreds of times a frame. The profiler accurately rells you how many times it\nis called, bur the timing information is useless. In this case, resort to using a profes-\nsional profiler.\n\nIts important co note thar this real-time profiler shouldn't replace a traditional\nprofiler. A real profiler can give you benefits that can’t he duplicated using this tech-\nnique. Rather, this real-time profiler should augment the profiling thar you'd nor-\nmally do. Think of this profiler as a quick-and-diry way to find our useful\ninformation. When youre ready for Very accurate Measurements, switch wo a profes-\nsional profiler.\n\nWhat Will the Profiler Tell You?\n\n‘This profiler gives you the following information at the end of each frame. You'll mast\nlikely want to have this information printed to rhe screen or some other output\ndevice. This article won't help you render the on-screen text (refer to the article “The\nText Utilicy Library,” by Dante ‘Treglia H, in this book), but it gives che following\nimportant clata:\n\n1. Unique name of the sample poing\n\n2. Average, minimum, and maximum percentages of frame time spent on that\n\nsample\n3. Number of times the sample was called per frame\n4. Relationship of this sample point to other sample points (parent/child)\n\nThe profiler tries to be smart about samples and keep track of parent/child rela-\nHonships. For example, if you sample the main loop of your game and the graphics\ndraw routine that’s inside che main loop, the parent/child relationship is taken into\nconsideration. The results shown in Table 1.14.1 are displayed.",
      "content_length": 2868,
      "extraction_method": "OCR"
    },
    {
      "page_number": 120,
      "chapter": null,
      "content": "Séction 1 Programming Techniques\nTable 1.14.1 Sample Results |\n\nAve | Min | Max | # | Profile Mame\n14.3: | 11.8 | 34.9 | 1 | Madn Game Loop\na5.7 | 65.1 |] 88.1 |] 1 | Graphics Draw Routine\n\nHere are some observations about the results shown in Table 1,14,1;\n\nI. The Graphics Draw Routine accounts for 85.796 of the frame rare.\n\n2. Everything other than the Graphics Draw Routine accounts for 14.3% of the\nframe rate.\n\n3. The Graphics Draw Routine is called inside che Main Game Loop (noted by the\nindentation).\n\n4. The Main Game Loop should take 100% of che frame time, bursince the Graph-\nics Draw Routine is being profiled inside of the Main Game Loop, it’s subtracted,\n\n3. The Main Game Loop spikes with 34,99, whereas its average is a low 14.3%,\nindicating that some code within the Main Game Loop is periodically hogging\nthe frame time. Pechaps it's the Al code or physics code; add more samples to the\nprofiler to find our.\n\n6. The Main Game Loop and the Graphics Draw Routine are both called once per\nframe (noted under the # column),\n\nAfter adding more profiler samples to better identify the spiking problem, the\nresults shown in Table 1.14.2 might resule.\n\nTable 1.14.2 Sample Results fl\nAve | Hin | Max | # | Profile Mane\n2.4) | 1.8 | 2.6 | 1 | Main Gane Loop\n2.2 | 1-5 | 2.3 | 1 | Game Object Update\nP68 [9 6.5] 27.4 | ae | AI Update\na] 0.8 | Tad | 1 | Gollision Detection\n1-0 | o.5 | 124 -| 1] Physics\nBS.7 | 65.7 | a8.1 | 1 | Graphics Draw Rowtine\n\nFrom the results shown in Table 1.14.2, we can see chae chere are 32 calls to the\nAl Update sample (probably 32 game objects thar require Al). The Al Uplate is\nClearly the sample thar’s spiking, with 27.4% on some frames. There must be some\ncode inside the Al Update thar is periodically called. Perhaps che work thar the onde\ndoes can he spread over several frames so that the frame rate doesn't hiccup anymore.\nContinue to add profile samples uncil the exact segment of code is identified. Track-\ning down problems with che profiler is thar easy.",
      "content_length": 2011,
      "extraction_method": "OCR"
    },
    {
      "page_number": 121,
      "chapter": null,
      "content": "1.14 Real-Time In-Game Profiling 123\n\nAdding Profiler Calls\nSS\nAs mentioned earlier, you must wrap the code you want to profile with Profile@egin\nand Profileénd. You should always wrap the main loop of your program and then call\nFrotilabumpoutputTosetter as the last thing in your game loop. ProfileDumpOutput -\nToButter formats the profile information into a text buffer so that you can display it\nto the screen somewhere inside the main loop. The following is an example of a prop-\nerly wrapped game loop:\nVoid main {\n\nJiinitialization Code Here\nProtileInit(); //¥ou must ¢all this batore the main loop\n\nwhile( IExitGane } {\nProtilebegin( “Main Loop\" };\n\nReadinput();\nUpdatedameLagie( );\n\nProtileBegin{ \"Graphics Draw Routine\" }:\n\nRandarscene| 3\n\nRanderProfileTexthutter(); //Dutput profile text fran last\nif Tram\n\nFrofileEnd( “Graphics Draw Aowtine* };\n\nProfileEnd({ “Main Loop\" };\n\nProfileDump output ToBbutter( }: ffiaffer will be drawn next\nff Trane\n\nProfiler Implementation\ni et a ee ee\n\nOn a given frame, each profile sample needs the following information:\n\ntypada? atrut {\n\nbool bValid; J/Whether this data is walid\n\nuint iProfileingatances; fff of tines ProfileBegin called\n\nint itpenProtilas: f/f of tises Proftilefegin wio\nProfileind\n\nChar szNane [256]; {fame of sample\n\ntloat fStartTina; ffTHe current open profile start tine\n\nTloat fAéccumulator: FP AlT samples this frame added\ntogether\n\nTlost fChildren$ampleTine; f/Time taken by all children\n\nwint LNunParents; HiNuaber of profile parents\n\n} Profilesanple;\n\nOver many frames, we need to keep history information on samples taken. The\nfollowing information will be stored over the long term:",
      "content_length": 1658,
      "extraction_method": "OCR"
    },
    {
      "page_number": 122,
      "chapter": null,
      "content": "124 Section 1) Programming Techniques\n\ntypedef struct {\n\nbool bValid; iiWhether the data is valid\n\nchar szName[256)]; //Name of the sample\n\nTloat TAve; ffAverage time per frame (percentage)\nTLloat Twin; {{iindmum time per frame (percentage)\nTtloat TWax; /iMaxinum time per frame (percentage)\n\n} FrotilaSamplekistory;\n\nPor simplicity and speed, pre-allocate an array of ProfileSample(s) and Profile-\nSanplekistory (2). Pre-allocating the data makes it so we don't take a hit on allocating\nand destroying memory every time a sample is taken, Before any samples are taken,\ncall Profiletnit co initialize both arrays and record the start time.\n\n‘Two functions are used for referring to time: GetTime and GetElapsedtime. Get -\nTine should return system time in seconds (at the exact time it’s called). GetELapsed-\nTame should return the amount of time passed since the last frame (calculated by\ni/current_frane_ rate).\n\nfdefine WUM_PROFILE SauiPLes 50\n\nProftilesample g_samples[NUM_PROFILE_ SAMPLES];\nProfilesampledistery g_history[NUM_PAOFILE SavPLes);\nfloat g startProfile = o.07:\n\nfloat g_endProfile = o.of:\n\nvoid ProfileInit({ vodd }\nL\n\nuint i;\nfor( 1-0; 1<NUM_PROFILE SAWPLES; i++ } {\ng_sanples|i)].bVvalid = false;\n\ng@_histery|2)]-bVvalid = false;\nI\n\ng_startPrafile = GetTime(};\n\nDetails on ProfileBegin\n\nWe're now ready to record a sample, so let's look at the function ProfileBegin in List-\ning 1.14.1. When this function is called, it first needs to check whether or not a sam-\nple by the same name exists. If it finds one, it means that this sample has been called\nbefore on this frame. In that case, we want (to increment i0penProfiles, increment\niFrofileinstances, and mark the tStertTime.\n\nThe variable i0pen?rofiles is incremented by ProfilaBegin and decremented\nby ProfileEnd. In effect, it keeps track of how many profile samples have begun and\nnot ended. Note thar this implementation does not deal properly with recursive calls\n\nfa sample begun more than once before being ended). For that reason, there is an\naesert char carche: this condinan.",
      "content_length": 2057,
      "extraction_method": "OCR"
    },
    {
      "page_number": 123,
      "chapter": null,
      "content": "1.14 Real-Time In-Game Profiling 125\n\nThe variable iProtileinstances is incremented by ProfileSegin in order to\ncount how many times the sample has been called on a frame. As you might remem-\nber, this is one of the key pieces of information thar is displayed in the ourpur. IF the\nsample has never been called this frame, the code finds a sample in the array char isi't\nbeing used and initializes it.\n\nDetails on ProfileEnd\n\nAlthough Prefilesegin is faisly straightforward, the real work is done in Profileend.\nThis is the function that tallies che results and properly accounts for parent/child rela-\nGonships.\n\nThe first step in Protileend is to find che sample in the array, Once the sample is\nfound, the end time is recorded and the variable iOpenProtiles is decremenced. Then\nthe code loops chrough all samples, counting how many open samples currently exist\n(parents) and remembering the index of the most recently opened one (the immedi-\nate parent}. The number of parents is then recorded in inumParents. If there weas a\nparent, the sample time is noted in the immediate parent's structure (to be subtracted\nfrom its sample time larer).\n\nSince this sample might be opened again on this frame, chis sample time is saved\nin the Accumulator so that another sample can use tStartTine. Listing 1.14,2 shows\nthe Profilefnd function.\n\nDetails on Processing the Profiling Data\n\nAll thar’s left is to process, format, and dump the data into a text buffer. This is done\nat the very end of the main game loop in the function ProfiledumpoutputTaBetfer.\nListing 1.14.3 shows this function. Nore that two functions, CleartaxtBuffer and\nPutTextiuffer, are used for outputting the text to the buffer. You have to supply these\nfunctions. PutTextautter puts the text string you give it into a vertically scrolling\nbuffer so chat each successive call inserts the new text suring at the end of the last one.\nClearTextButter simply clears the vertical scrolling buffer.\n\n‘Two other functions, StereProfileIndistory and GetProftileFronHistory, are\nalso referenced, Both are outlined in Listing 1.14.4. These functions help keep crack\nof the average, minimum, and maximum frame rare percentages foreach sample. By\ncalling StereProtilelniistory, YOu are averaging the current measurement with\nevery sample taken in the past. Then GetProtileFromMistory recrieves the new aver-\nages for you to display.\n\nFurther Enhancements\n\nAs you probably realized, this profiler is written completely in C (except for the C++\ncommenting style). By converting it to C++, irs possible to eliminate the need for the",
      "content_length": 2582,
      "extraction_method": "OCR"
    },
    {
      "page_number": 124,
      "chapter": null,
      "content": "126\n\nSection 1 Programming Techniques\n\nProfiietnd funcion. The cick is ro exploit Class constructors and destructors. Care-\nfully examine the following code, which profiles the tor loap:\n\nProtileinstance profile ingtance{ \"Timing tha For Loop\" 1:\n\nfar( int 120; i<ib000; ivr );\n}\n\nIn the code, a Profilelnstance abject is declared and initialized with a cescrip-\ntive string. When its constructor is called, the string is recorded along with the system\ntime. This information is then saved to global dara structure much like the Profilo-\nBegin funcrion.\n\nSince the objece profile_instance is within the curly brackets, ir is destroyed\nwhen program execution leaves that scope. Therefore, the destructor is called imme-\ndiately after the for loop. The destructor records the system time and saves the infor-\nmation to the global dara structure, exactly as the Profileend function does.\n\nSince the profiling line is now a little more awkward, we can streamline it by writ-\ning a simple macro:\n\ndefine Profile(a) Protilelnstance profile_instance(a)\n\nThe profiling example with the macro looks like this:\n\nProfile( “Timing tha For Loop\" 3\n\nfor( int 250; i=10000: i++ ):\nI\n\nThe beauty of this enhancement is that the profiling code now occupies a single\nline. Even better, it doesn't require a rerminating statement containing a perfectly\nmatching string. Profiling has never been so easy!\n\nPutting It All Together\n\nAmazingly enough, it decent tke much to put together a fairly competent profiler,\nSimply realizing it is practical is the hardest part, On the CD thar accompanies this\nbook, you'll find the completely implemented profiler. In no time, this line profiler\nwill become one of your most important debugging pools.\n\nListing 1.14.1: ProfileBegin\n\nvoid Profilefegin( char* nane }\n4\nvint i =o;\n\nwhile( a <= NUM_PROFILE SAMPLES £4 g sanples[i].bvalid =-- trug ) {",
      "content_length": 1865,
      "extraction_method": "OCR"
    },
    {
      "page_number": 125,
      "chapter": null,
      "content": "1.14 Real-Time In-Game Profiling\n\nif( stromp( g_samples[i].szName, nang } == 0 } {\n‘fFound the sample\ng_Samples[i]-idpenrrofiless+:\ng_samples[i).iProfileinatances++;\nO_samples[i).fStartTime = 0SGetTinet};\n\n127\n\nBSsarti g sénples/ij.iopenProafiles == 1); //max 1 open at once\n\nreturn;\n\nitt:\n\nif( i >= NUM_PAOFILE SAMPLES ) {\nassert( [\"Excgeded Max Available Profile Samples® 4;\nretura;\n\n}\n\nstrepy( @ samples[i),szNane, name };\ng_sanples[i).bvalid = TRUE:\ng_sanples[i].i0penProfiles = 1;\ng_sanples[i].iProfileinstances = 1;\ng_samples[i]-fAccumulatoer = o.of:\ng_samples[i]-fStartTine = GetTine();\ng_samples[i)-?¢hildrenSaspleTine = o.or;\n\nListing 1.14.2: ProfileEnd\ni tee a tilt a\n\nWold Profiletnd( char* name }\n\n4\n\nuint 2 = @;\nUiNt hunFarents = Oo:\n\nwhile( i < NUM_PROFILE SAMPLES £8 g samples(i].bvalio == true )\n\n{\nif{ Stremp( g_sanples[ij].szName, name } == 0 }\n{ f/Found tha sanple\nuint inner = Oo;\nint parent = -1;\nfloat tindTime = GetTima{):\ng_sanmples[i].idpentrofilas—:\n\nPiGount 212 parants and find the inmediate parent\nwhilal 9 Samples[inner].bValid == true ) {\nif{ 9 fanples[inner).i0penProfiles = 0 }\n\ni ffFound 4 parent (any apen profiles are parents)\n\nUna rent sss;\n\nif( parant <9 )\n\nqi ffieplace invalid parent (index)\nparéot = inner:\n\nI\n\nelse if( g_sanples[inner] .fStartTime ==\n\ng_sanples[parent).fStartTime }\n\n{ /fReplace with mare immediate parent\nparent = inner:",
      "content_length": 1380,
      "extraction_method": "OCR"
    },
    {
      "page_number": 126,
      "chapter": null,
      "content": "128 Section 1 Programming Techniques\n\n}\n}\ninneres;\n\n}\n\nffRemenber the current number of parents of the sample\nQ_Sanples[i] iNusParénts = numParants:\n\nif( parent >= 0 }\n{ J/fRecard this time in téhildrenSampleTine (add it in)\ng_sanples[parent) .tthildrenSanpleTime += fEndTime —\nog sanples[i].TitartTime;\n}\n\nifSave sanple time in accumulator\n§_Samples[i)-fAccunulator += fEndTine =\ng_senples[i].?StartTime:\nreturn;\n}\nLes;\n\n}\n\nListing 1.14.3: ProfileDumpOutputToBuffer\n\nveld ProfileQumpoutputTobutter( void j\n\n{\nuint i = g;\np_endFrofile = GetTine/);\nClearTextauttert }3\nPutTeNtBatfer( \" Ave + Min : Wax :  # > Profile Neame\\n\" 3;\nPutTentBuffer( \"---------------------eeeeessece|n® j?\n\nwhile( i < NUM_PROFILE SAMPLES && g samples{ij]-bvalid == TRUE If\nuint indent = oO:\nfloat sampleTime, percentTime, aveTime, minTima, maxTime:\nchar line[259], mane[—256], indentedName[256]:\nchar ave[i6], min[16), max[16), num[i6]:\n\nitd 9 sanples[ij.i0penProfiles « o ) {\nassert( I *Profile€nd() called without a ProfileBegin()\" $;\n}\nelse if{ g_sanples[i].i0penProfiles > 0 } {\nassert | *ProtileBegin() called without a Profileind()* };\n}\n\nsampleTime = 9 samples[i).fAccenulator —\ng_Samples [4]. fChildrenSanpletTine;:\n\npercentTime = ( sampleTine { (g_endrrofile - g startProfile } }\n* 100.0f:\n\naveTine = mintine = saxTina = percentTime:",
      "content_length": 1318,
      "extraction_method": "OCR"
    },
    {
      "page_number": 127,
      "chapter": null,
      "content": "1.14 Real-Time In-Gamo Profiling 129\n\n//Add new measurement inte the history and get ave, min, and nax\nStoreProfilelndistory( g sanples[i].sziana, percentTime };\nSatProtilefromistory{ G_sanples[i].seNane, kaveTime,\n\nEninTime, kmaxTine );\n\nifFormat the data\n\nsprintt( ave, “33.1T\", avoTine iG\n\nSprint®{ min, “23.1f\", minTine };\n\nSpraintt( max, \"33.1%\", maxTime };\n\nsprintf, mun, \"Sad\", g_sanples[i).iProtileInstances i\n\nBircpy( indantedNane, g_samples[i].szName hs\n\nfor indent=o; indent<g_samples[i].iNumParents; indente+ id\neprintt( mame, \" 4&5\", indentedMama Vi\nStrepy( IndentedNanc, name };\n\nSPrintf (ling, \"95s 2 MSs : bSe : Sas : Ssin\", ave, min, max,\nnun, indentedName) ;\n\nFPutTextButfer{ Line }; f{Send the line te text buffer\nitt;\n}\n{ ff Reset sanplee for next trans\nunit a;\nfor( i=0; T<NUML_PROFILE SAMPLES; i++ } {\ng_sanples[i].bValid = FALSE;\nQ_StartProfvile = GetTimel):\n}\n\nListing 1.14.4: StoreProfilelnHistory and\n\nGetProfileFromHistory\n= SSS\nwold Stararrotilelnkistery( chars name, T32 percent }\n4\nuint i = 0;\nfloat oldhatio;\nfloat newAatio = p,\nift nowhatio > 1,o¢\nmhewhatio = 1.04;\n\nST * GetElapsedTime(};\n}\n\n{\noldkatio = 1.0f - nawFraction;\n\nwhile( i < NUM_PROFILE SAMPLES 44 g history[i].tvalida == TRUE If\nif{ stremp( g_history[i].szNane, name } == 9 }\n{ /iFound the sanple\ng_history[i].fave = (g_history[i].fAve*olonatio) +\n(Percent *newRatio j=\nif percent < g_history[i)].7Min } {\ng_history[i].TWin = parcent;\n}",
      "content_length": 1432,
      "extraction_method": "OCR"
    },
    {
      "page_number": 128,
      "chapter": null,
      "content": "130 Section 1 Programming Techniques\n\na eee\n\nelse {\ng_histery[i]-fiin = (p_history[i].fWin*oldAatio}) +\n(percent*newhatio):\n}\n\nif{ percent > g_history[ij.fWax } {\ng_history[i]-fitax = percent;\n\nelse {\n\ng_history[i] tax = (gp hdatory[i].fWax*aldfatio}) +\n(percent\"newhatio};\n\nreturn;\n\ni++;\n}\nif(t i= MU PROFILE SAMPLES }\n{ ffAdd ta history\nstrepy( g_history[i].szMane, nama j;\nghistory[i].bValid = TRUE:\n\ng_history[d),.fAve = g history[i].TWin = g history|i]-fitax =\npercent;\n\nelse {\nBSeert( i*Exceeded Max Available Profile Samples!*);\n}\nI\n\nvoid GeatProfilerromistory( char™ name, f22\" ave, f32\"* min, ta2* max }\n|\n\nuint 1 = 0;\nuhile( i «= NUU_PAOFILE_SAMPLES &4& g hastory[i)-bValid == TAVE } {\nif({ strcemp( g history[i].szWame, mane } == oO j\n{ //Found the sanple\n*ave = g history[i].fAve:\n\"min = g history[i].tilin:\n‘max = g history[i] .filax:\nreturn;\n}\n\nber;\n\n\"ave = “nin = “max = 0.07;\n\nI\n\nReterences\n\n[Abrash97] Abrash, Michael, Michse! Abrasts Graphics Programming Black Book, The\nCoriolis Group, 1997,\n\n[McConnell93) McConnell, Steve, Cade Complete, Microsoft Press, 1993.\n\n[Meyers95) Meyers, Scott, More Effective C++, Addison-Wesley Longman, Inc.,\n1996,",
      "content_length": 1164,
      "extraction_method": "OCR"
    },
    {
      "page_number": 129,
      "chapter": null,
      "content": "2.0\n\nPredictable Random Numbers\n\nGuy W. Lecky-Thompson\n\nA large proportion of the success of a game in today’s marketplace depends on a suffi-\nciently detailed backdrop against which the game action can take place. Not only\nthat, bur the backdrop could also take an active role in the interaction berween player\nand game. In search of this elusive mix, the traditional approach has been ro simply\nhand-craft level data and store it in a relatively complex and space-consuming level\nfile, to be replayed in real time.\n\nOccasionally, however, the cepth of some games falls below the expectations of\nthe audience, This disappointment is caused by the fact that the game is sometimes\nsimply net big enough; onee the bates have been fought and the blood spilled, the\nplayer is left with something of an anticlimax.\n\nEven with huge resources at their disposal. game designers often run out of che\nspace needed to distribute a large and complex game, especially when the images used\nfor rendering are photorealistic and the sound awesome, with thumping music and\nsampled explosions. These are important ingredients, but designers might often feel,\nrightly, that they are sacrificing something in return. This is especially evident in\nresource-limited environments such as we find in the handheld and console market.\n\nOnc example of a huge and complex game is Elite. This fame was originally writ-\nten by David Braben and lan Bell for the BBC Model B computer in 1980, Ir has\nsince been ported to all home computer formats and is still as widely played now as in\nits heyday. The original game ran on a machine with 32KB of memory (16KB ROM\nand 16KB RAM), bur it still boasted a depth of play that has yer to be matched: near-\ninfinite planets, each with names and individual characteristics,\n\nThis article is a study of'a technique that can be used co provide the depth of play\nthat the audience deserves, even in limited-resource environments, such as that faced\nby the original Elite, without sacrificing any of the other viral ingredients thar make\nup the perfect game.\n\nPredictable Random Numbers\n\nThe underlying principle of this technique is that, to provide the illusion of infinity in\na game universe, we need to satisfy nwo conditions of resolution. These we can term\n\n1343",
      "content_length": 2274,
      "extraction_method": "OCR"
    },
    {
      "page_number": 130,
      "chapter": null,
      "content": "Section 2 Pdathematics\n\nmacre-infteite and micre-infreite, The first relates to the size of the universe in ques-\ntion, of the number of discrete entities. The second condition indicates the level of\ndetail that cach object supports, We shall see in the course of this article how both of\nthese conditions can be achieved using the same underlying technique.\n\nTo avoid the storage of vast quantities of level data that will mever satisfy che reso-\nlution requirements we have identifed, we need to be able to generate che universe in\nreal time, from the point of view of the player. Not only that, bur this universe must\nalso have the same appearance each time the game is restarted or played on a different\nplatform or machine.\n\nIn order to simplify the issue slightly, we can assume that exch object in the uni-\nverse is expressed by its placement within the universe and a sec of properties chat\nindicate how ic is to appear to the player. Each object can also interact with the player,\nwhich we discuss later in the article.\n\nBy way of example, let us consider as game universe a simplified model of our\nown. That ts, we have a container object, the Galery, which contains a number of\nStars. At game time, we would like to populace che Galaxy with Stars in a fashion char\nis both repeatable (it always “looks” the same from the player's perspective) and con-\ntains cnough planets to provide a reasonable illusion of infiniry.\n\nTo achieve chis poal, we construct a series of Star objects and set the placement\nanribures of each one such chae they exise ac given points within the Galaxy. Consider\nthat the placement aceributes consist of an x and ay coordinate, and it is obvious that\nwe need co generate values oo plaice in these holders. This is where the predictable ran-\ndom number sequences are used; we can use a series of generated random numbers to\nprovide us with coordinares for each of the Stars.\n\nThe simplest approach is provided by the ANSI C specifications and gives us the\n\nfollowing two functions:\n\nrand [seed)\nrand}\n\nEvery tite We feed a bist [ats tla af numbers, We need a Dwoe ste operation. The\nfirst seeds the generator with a given value, which is used to propagate che sequence.\nThe same sequence is generated every time we seed with the same value. Thus the\nseqjuence is repeatable, but we do mot need to store it anywhere, because it can be cre-\nated on the fly, Thus we can generate a near-infinite galaxy entirely in game time,\nreducing our static storage requirements beyond measure.\n\nThe following is very simple pseudocode showing this concept in action for a\ngiven Galaxy of limited size. Assuming a possible grid of 100 x 100, we have 10,000\npossible spaces into which we can place Stars. Notice that the seeding is performed\nence and once only per sequence of numbers; in the following case, we are seeding on\n\ngalaxy number 1:\n\nsrand (1)\nfor galaxy_x = 1 to 100",
      "content_length": 2899,
      "extraction_method": "OCR"
    },
    {
      "page_number": 131,
      "chapter": null,
      "content": "2.0 Predictable Random Numbers 135\n\nfor galaxy y = 1 to 100\nprobability = rand{) % i100\nif probability > 70 then\nuniverse (galaxy x,galaxy y}) = star\nalsa\nuniverse (galaxy_x, galaxy_y}) = no_star\n\nObservant readers might have nociced a possible drawback: we still need to store\nthe location of each Star somewhere, which requires about 10,000 bytes of space in\nreal time, This size would never have fir inside a machine with IGKB of RAM. Even\nif it could, it i nor scalable, crn by a factor of LO,\n\nTherefore, we should refine the technique a litle. From the preceding example,\nwe see that there is a 70% chance of a Star EXISINE at a given points, y. The number\nthar determines this percentage is created from a seeded sequence based on the simple\nseed 1. Given thar we would like a near-infinite population, it makes more sense to\nperform this calcularion on an as-needed basis, as in the following code:\n\nint StarAt (int nGalaxy, int nX, int nv}\nint x, ¥, MReturn:\n\nBrand (mGalaxy) ;\nTor (y = 0) yo s= mv; yet}\n1\n\nFor (x = 0; x <= mW; x44)\nnieturn = rand() % MAXIMUM VALUE;\n\n}\nreturn sheturn;\n\nAlternative Algorithms\n\n——\nMany and varied chaotic and semi-chaotic algorithms give rise to the kind of behav-\nior thar we use here. This is not a mathemarics paper, and some of the advanced alga-\nmithms that could be used require more processing power than is available,\nconsidering all the other operations that are being performed during game play, so we\nshall restrict ourselves to the discussion of a simple approach,\n\nThis approach can be represented by che following pseudocode:\n\nChass two large integers, Geni and Genz, such that one\nig double the other\n\nCheest a seed value that is between 1 and tha smaller\nof the Large integers\n\nChoose a value Max that represents the highest nurber\nthat is te be returned",
      "content_length": 1813,
      "extraction_method": "OCR"
    },
    {
      "page_number": 132,
      "chapter": null,
      "content": "136 Section2 Mathematics\n\nFor each iteration,\n\nWultiply Geni by the seed, and add Gonz\n\nThe new s#éd is renainder of this value diwided by Max\nReturn s6@ed as the random value\n\nThis code works by first taking a repeatable sequence of numbers, which follow a\npattern with a given starting point (a multiplication and addition) and then breaks\nthe pattern by taking the remainder of a division. This result is then used to begin a\nnew sequence with the same base equation. In this way, a fairly random sequence is\nbuilt up. The source code for this sequence follows. This is taken from the Psreudoran-\ndom class, whose source code is provided on the accompanying CD.\n\nPaeudofandomizer: i:Pseudofandomizer(unsigned long uldeni,\nunsigned long ulSeed,\nunsigned long ulMax)\n\n{\nthis-=ulGent = ulGeni:\nthis-=ulGen? = ulGenl * 2;\nthis--ulSeed = ulead;\nthis-=ulMax = ulWax:\n\n}\n\nunsigned long Pssudehandomizer: :Pseudohandon j\n{\nunsigned long ulNewSeed;\nUliewSeed = (this->ulGeni * this->yu1Seed) = this->ulgen2;\n\ni 7 Use seadulo aperator to ensure = ulllax\nUlfiewSeed = ulMewSeed & this->uliax;\n\nthis--ulséed = ulNewSeed;\nreturn this->ulSeed;\n\nThere is one final limitation. The largest number that can be generated using this\nsystem is 4.294,967,295. It follows from the previous algorithmic description that the\nsequence begins to repeat itself after the 4,294,967,295th iteration. This is a limita-\ntion of che dara ype used, a 32-bit unsigned integer. If greater numbers are required,\nir is necessary co move oo a difference representation.\n\nAlgorithms for Infinite Universes\n\nSo far, we have seen how we can decide on the existence of a game feature ata given\nlocanon, We have sacisfied half our bricl chat of macro-infinite resolution, Mow it is\ntime to tum our attention to the use of pseudo-random numbers on the features and\ndetail of the game objects: micro-infinite resolution.",
      "content_length": 1878,
      "extraction_method": "OCR"
    },
    {
      "page_number": 133,
      "chapter": null,
      "content": "2.0 Predictable Random Numbers 137\n\nIn essence, micro-infinite resolution is all about zooming in on a point and sccing:\nwhat we find there. To take our current example, we might say that cach Sear is\norbited by zero or more Planets. These Planets orbit at a certain distance from the\nstar, They have other characteristics we examine later; specifying their location is\nenough for now.\n\nIn order to specify these items, we mighr choose to add an attribute to our Star\nclass which gives the number of Planets, and calculate this. The following code extract\nshows how we can calculare an atoribure of our Star class, che number of Planets:\n\nf* Taken from header file *!\n\nclass star {\nprivate :\n\nint x_position, y_position;:\nint number_of planets;\n\npublic :\nVoid SethumberttPlanets( |:\n\nhe\n/* Taken from implementation file */\n\nveid star: :SetNunberOtPlanetsd) {\nPeeudorandom-+seed(this->x_position + (this->x position\n* this->y position);\nThis->nunber_of planets = PSCudorandom-*generate() % 20;\n\nWe have skipped into a slighty higher gear with this code, some of which bears\nexphining. First, we are seedling on a unique value for che Star, based on the position\ngiven by the x and y coondinate propertics of the Star object, This means chat for each\nStar, we can generare values that are seeded for thar particular object. Thus we reduce\nthe probability of having two identical Star objects in circulation.\n\n4 second point to note is chat we have taken the modulo of the generated num-\nber in order to limit the number of planets chat may orbit this Star. ‘To introduce more\nrealism {and hence, a larger micro-infinite resolution), chis code could be adapred\nbased on other attzibutes of the Star, such as size, intensity, or proximity,\n\nArmed with this information, we can now consider how we might use a similar\ntechnique thar will enable us to generate a distance value for a given planer. As noed,\nthe important starting point is the seed thar is used to determine the features of the\nobject. Bearing in mind that the seed should be unique to each possible planer, we\ntrust somehow incorporate the position of the parent Sear as well as chat of the Planet.\nThe following code extract shows a possible approach:\n\n!* Taken from header file \"s",
      "content_length": 2244,
      "extraction_method": "OCR"
    },
    {
      "page_number": 134,
      "chapter": null,
      "content": "Section 2 Mathematics\n\nclass planet {\nprivate =\n\nint distance fram star;\npublic :\nWoid SeibistanceFronstar(int planet_number,\nint star_x_position, int star_y position);\n\n}\n/* Taken from implementation file */\n\nYoid planet::SetDistancaFronSter (int planet_sumber\nint star_x position,\nint ater_y positian) {\n\npseudorandom-=seed(planat_nunber + (Star_x_pasition +\n(star_«_position * this->star_y_position) \\);\nthis=->distance_from_star = pseudorandon->genarate(} & 20;\n\n}\n\nSo, we have cHectively “zoomed in” from Universe to Star oo Planet, as far as spec-\niffing positions is concerned. To complete the backdrop (and our discussion of\nmicro-intinite resolution), we should start to add properties using more sequences of\npredictable random numbers.\n\nThe key vo chis next stage is the ability te isolate for a given object in the universe\na set of artributes that describe the object. After we have done that, it is necessary to\ndecide on the representation of these aceributes, given that a constant stream of ran-\ndom numbers is available.\n\nEach of these attributes may in itself be an objece (as Planet is to Galaxy is to\nUniverse), with properties of is own char can be set in a similar way, by seeding on a\nunique reference. For the next example, we shall ascume that we require a map of the\nPlanet object and thar this map is represented by a simple gid into which we can\nplace other objects. The whole code for che Universe, Galaxy, Planet, and Map\nobjects is contained on the CD that accompanies this book. The pseudocode might\nlook like this:\n\nfi Dating the map size (side x sida)\nhap->9rid side = pseuderandon-+generate() % 100\n\nff Plate an abject on the map for a given position x,y\nPSeuGOrandon->Seed { (tap=>grid sida * wi + x)\nRap-»grid square(x,¥) = pseudorandom->generate(}) % 2\n\n(The modulo value 2 could be taken to mean that 0 is water and 1 is land, for\n\nexample.)",
      "content_length": 1881,
      "extraction_method": "OCR"
    },
    {
      "page_number": 135,
      "chapter": null,
      "content": "20 Predictable Randeam Numbers 138\n\nIn the preceding examples, che seeding has been omitted, As can be seen from the\nsupplicd code examples, the seed is gcncrated on an object-by-object basis ar instanti-\nation of the object. In fact, the supplied code also stores a number of acrribures used\nto generare the seed. which have been omitted here for che sake of brevity.\n\nIt can be proven from watching the ANSI srand and rand functions working\ntogether thar there is more to choosing the seed chan first meets the eye. Earlier, we\nproposed:\n\nerand (x_position + (x dimension * y position))\n\nwhere the generator is seeded on the unique reference generated for che point (x, y}\nbased on the dimension of the target container. However, repeated runs using srand\nand rand show thar this method produces a result that is far from chaotic. (See the\narticle “Real-Time Realistic Terrain Generation,” which contains a figure shawing a\npattern that is a result of using ehis technique with the ANSI generator.)\n\nThe CD that accompanies this book contains the entire code for che Pseudoran-\ndom class, but the following algorithm, which can be used for seeding the generator\nproperly using just the ANSI functions or used along with the Pseudorandom class\ninself, is warth repeating here:\n\nsrand (y_ position)\n* = x position\nwhile x > O\n\nrand}\nLt Te\n\nThe next call to rand yields the required number, which can be considered the\nfirst in the ensuing sequence,\n\nConclusion and Future Developments\n\nIn this article, we have seen how we can use macro- and micra-infinite resolution\ntechniques, propagated by sequences of pseudo-random numbers, seeded ona unique\nobject reference. These techniques enable us to create near-infinite fame universes\nwithin the constraints of a limited-resource environment, by run-time generation,\n\nDevelopers may choose to use this information “as is” or enhance it further. For\nexample, events can also be approached in the same way, seeded on the play history, or\nin real ume. This technique would ensure that if a fire occurred at a tavern at a given\npoint in time (possibly in connection with actions made by a player), we could pre-\ndict when it would happen and thus ensure that it took place at the same time in each\nBame sossion.\n\nThe key to stecessful use of predictable random numbers lies in the judicious use\nof the seed in parallel with the object properties and play state,",
      "content_length": 2404,
      "extraction_method": "OCR"
    },
    {
      "page_number": 136,
      "chapter": null,
      "content": "140 Section? Mathematics\n\nReferences\n\nLecky-Thompson, Guy W., “Algorithms for an [nfinite Universe,” Gannascutn, avail-\nable online ay www.pamasutra.com/ feacunes! 1999091 7/infinite_O1.hem, Septem\nber 17, 1999: contains a detailed discussion of the effects that can be achieved\nusing this technique.",
      "content_length": 300,
      "extraction_method": "OCR"
    },
    {
      "page_number": 137,
      "chapter": null,
      "content": "2.1\n\nInterpolation Methods\n\nJohn Olsen\n\nHave you ever wanted to have your program move samething from ene location to\nanother gradually over time? There are dozens of ways to do thar, with varying\ndegrees of flexibiliry and varying CPU requirements. Four of these methods are dis-\ncussed in this article, giving details on how each method behaves:\n\n* Frame-rate-dependenc ease-out using floating-point mach\n* Frame-rate-dependent ease-out using integer math\n\n* Frame-rate-independent linear interpolation\n\n* Prame-rate-independent case-in and ease-out\n\nAll these methods share some common ground. You start ara specific poinr, you\nwant to be at some other point, and you might er might not have a time limir in mind\nfor how long it should rake to get there. The source and destination could be any\nnumeric value or combination of values. For instance, they could be a temperarure,\naltitude, 3D position, a direction or velocity vector, or any number of things. The\ninterpolation is meant simply to take you from one value to another along a smooth\npath of some sort.\n\nShould you want to perform these interpolarion methods on a vector, for instance,\nyou apply the algorithm to each component of the vector separarely.\n\nFrame-Rate-Dependent Ease-Out Using Floating-\n\nPoint Math\n\nee\nThis method behaves in a frame-rate-dependent manner, so it behaves differently if\ncalled ar 10 frames per second than it does ar, for instance, 20 frames per second. This\nmeans that you want to use this method only if accuracy is not your prime concer,\n\nThe concept behind this method is that you want to compute a weighted average\n\nof the current value and the desired value, with a heavier weight on the current value.\nThis can be done with Equation 2.1.1. The new x value equals x,, the original value,\nmaultiplied by a weighting factor, added co che final destinarion x value. The sum is\ndivided by the total weights to properly preserve the scale. The resulting x is used as x,\nfor the next pass through the equation.\n\n141",
      "content_length": 2009,
      "extraction_method": "OCR"
    },
    {
      "page_number": 138,
      "chapter": null,
      "content": "Section 2 Mathematics\n\nx = (x, * (teighe = 1) + 2,9 | weighs (21.1)\n\nThe weight must be a value greater than one to get the expected behavior from\nthis equation. Higher weights make it take longer to reach the desired position. This\ngenerates a smooth curve, as shown in Figure 2.1.1, which shows how the value\nchanges rapidly ar first, then settles toward the destination value as it approaches,\nwhich is called ease-ove,\n\nThe sample C++ class that can be used for floating-point ease-our interpolation is\nnamed GEasedutOividelnterpolation and can be found in Listing 2.1.1. You call\nSetup() when you are beginning an interpolation, passing in your starting and ending\nvalues anc a scale factor that controls how quickly che interpolation occurs. With each\npass through your real-time loop, you call Interpolate() to do che work, then call\nGetValue() to reteve the current interpolated value. Inccrpolare rewurns TAVE when\nthe interpolated value is no longer changing, indicating you are as close as you are\ngoing to get to the target. With this floating-poine code, it could rake a very long time\nto reach a steady stare.\n\nFrame-Rate-Dependent Ease-Out Using Integer Math\n\nThis method is very CPU friendly because ir uses no division. This method is more\nimportance on console systems or older hardware with limited floating-point support.\nIt works fast but has some restrictions on flexibility, even: compared with the previous\nmethod.\n\nGf Bb\n\nherd lions\n\nFIGURE 2.1.1. Floating-point casc-our.",
      "content_length": 1497,
      "extraction_method": "OCR"
    },
    {
      "page_number": 139,
      "chapter": null,
      "content": "2.1 Interpolation Methods 143\nee\n\nThe process of building a weighted average using integer math has some interest-\ning side cffects. The rate of change tends to stick at specific levels during the interpo-\nlation, and you are likely to never quite reach the destination point due to round-off\nerrors. Equation 2.1.2 shows che modifications used. The values for (2\"— 1) and ware\nthings you want to hard code for speed, which gives a form similar to Equation 2.1.3,\nwhere “>=\" represents a shift operaror, as in the C language. The computations have\nsome difficultics with round-off, as shown in Figure 2.1.2, which is much less smooth\ncompared with Figure 2.1.1 and the floating-point method.\n\nx={x,*{2\"—]j)+ x) >> 8 (2.1.2)\n\nx=(x* 7+ x) => 4 (2.1.45)\n\nEven with the less-than-smooth curve, this method is very useful for larger values.\nIr tends ta work well with fixed-point math, where some number of bits in your inte-\nger value is defined to be the fractional portion. For instance, a 32-bit number may be\nthought of as 20 bits for the integer portion and 12 bits for the fractional portion. To\nconvert from the integer representation to the fixed-point representation in that case,\nyou divide by 4,096, Increasing the scale in thar way allows for much smoother\nbehavior, resulting in a curve more similar co the one shown in Figure 2.1_1-\n\nListing 2.1.2 contains a sample C++ class called CeaseQutShift Interpolation\nthat can be wed for integer-based case-out interpolation. You call setup) when you\n\nFIGURE 2.1.2. Integer ease-cut.",
      "content_length": 1536,
      "extraction_method": "OCR"
    },
    {
      "page_number": 140,
      "chapter": null,
      "content": "144 Section2 Mathematics\n\nare beginning an interpolation, passing in your starting and ending values and a shift\nfactor that controls how quickly the interpolation occurs, With each pass through\nyour real-time loop, you call Interpelate() to do the work, then call Getvalue() to\nretrieve the current interpolared value, Interpolate() reruns TRUE when the interpo-\nlated value is no longer changing, indicating you are as close as you are going to get to\nthe target. With the integér-based code, this will likely happen before you actually\nreach the desired target.\n\nFrame-Rate-Independent Linear Interpolation\n\nIn the case of a linear interpolation, you want to compute an ideal velocity at the\nbeginning of the move and simply apply thar velocity each frame. This method gives\na straight line when charted, as shown in Figure 2.1.3. A bit of entry-level physics\nshows how to get that velociry in Equation 2.14. If you are measuring x in feet and ¢\nin seconds, that gives you a velocity in feet per second.\n\nv= (xp—ax) le (2.1.4)\n\nNext you need to apply thar velociry co each frame. To do this properly so chae it\nis frame-rate independent, you need to know how long the frame took. Once you\nhave thar time per frame, you can caleulare the change in position, using the already\ncomputed velocity, and add it co che original valuc, as shown in Equation 2.1.5. Ifyou\ntake a shoreut and calculate che velocity as distance per frame instead of distance per\nsecond, you lose the frame-rate-independent fearure but can gain a litde time by\navoiding the multiply in Equarion 2.1.5.\n\nxex,tt,*p (2.1.5)\n\nThe sample (++ class thar can be used for linear interpolation in Listing 2.1.3 is\ncalled CLineariInterpolation. You call Setup() when you are beginning an interpola-\nHon, passing in the starting and ending values and how long you want it to take to pet\nthere, With each pass through your real-time loop, you call Interpolate;) with che\nlength of time you want eo process, chen call GetValue (} to retrieve the current inter-\npolated valuc. Interpolate returns TAVE when the specified time has expired and you\nare at the desired target point.\n\nFrame-Rate-Independent Ease-in and Ease-Out\nsaa ee\n\nNow were getting co the point where a lire more background in physics comes in\nhandy: In order to produce a proper ease-in and ease-out, we need to begin with a zero\nvelocity, speed up ara constant acceleration ro same maximum velocity at the halfway\npoint, then slow back down to be ar a zero velocity as we arrive at the destinarion\npoint. This process is shown in Figure 2.1.4,",
      "content_length": 2571,
      "extraction_method": "OCR"
    },
    {
      "page_number": 141,
      "chapter": null,
      "content": "21\n\nInterpolation Methods 145\n\nfoenb=\n\nherntions\nFIGURE 2.1.3. Linear interpolacion,\n\nThe first step is to calculase che acceleration required. The acceleration is simply\ninverted for the second half of the wip. Any physics rext should give you the necessary\nmath, shown in Equation 2.1.6. We need to solve this equation for acceleration. We\nWA tO Start at zero velocicy, with x representing the average of the start and end\npoints rather than the final destination, which gives Equation 2.1.7.\n\nex tug toa (2.1.6)\n\nc= 2258! (2.1.7)\nt\n\nnce the acceleration is known, you need to apply chat acceleration to cach\nframe. This method is similar to the way it was done in the linear interpolation in that\nyou must take the time per frame inno account. To start, che velocity is zero. At each\nframe, it is determined whether you are in the first or second half of the trip so you\nknow whether co accelerate or decelerace. The velocity is incremenred or decremented\nby some amount using Equation 2.1.8, then the velocity is applied co the PAPSItiom, as\nshawn in Equation 2.1.5, the same as in che lincar interpolation version buc with a\nvelocity that changes each frame. This velocity should be very near zero by the time\nyou expect to be ar the destination point, but it might not be an exact match due ro\nroundoff errors,\n\nv=p tat (2.1.8)",
      "content_length": 1333,
      "extraction_method": "OCR"
    },
    {
      "page_number": 142,
      "chapter": null,
      "content": "Section 2 Mathematics\n\nAcca\n\nerations\nFIGURE 2.1.4. Fsse-tn and ease-out,\n\nThe final sample C++ class for chis article is in Listing 2.1.4 and is one thar can be\nused for case-in and ease-our interpolation, named CEaseInOut Interpolation. The\ninterface is identical to che linear interpolation clas, which makes it convenient to\nswap one out for the other when testing. You call Setup() when you are beginning an\ninterpolation, passing in che starting and ending values and how long you want it to\ntake to gee there. With each pass through your real-time loop, you call Interpolate(}\nwith the length of time you want to process, then call GetValue()} to retrieve the cur-\nrent interpolated valuc.\n\nDanger Zone\n\nThere are some things that you need to be very careful with as you apply interpolarion\nin various portions of your software. Angles are problematic, since the naive version of\nthe algorithm would tell you that the angle halfway benween an angle of 1°and 359°\ni 180°, when the proper answer might be 0°, depending on how you wane the inter-\npolation to behave. You need to be careful to assure that your numbers are in the\nproper ranges before interpolating angles, quaternions, or any values for which chere\nare multiple ways to show the same value.\n\nFurthermore, when referring to the sample code, you will likely want to take che\nideas shown in the code and optimize them to meet your specific needs rather than\n\nuse the code as it is,",
      "content_length": 1448,
      "extraction_method": "OCR"
    },
    {
      "page_number": 143,
      "chapter": null,
      "content": "2.1 Interpolation Methods 147\n\nListing 2.1.1: CEaseOutDividelnterpolation\n\nDefinition\n$$\n\nclass CEaseQutDividelnterpolation : CEasedutShittintarpolation\n\n{\npoblic-\nbool Setup(float from, fleat to, float divisor)\n\nif(diviser <= oO)\n\n{\n}\n\n_Walue = from:\ntarget = tor\ndivisor = divisor;\nreturn trues;\n\nreturn false;\n\n}\nbool Interpolate() // Note: Not time dependent.\ni\nTicat oldVvalue = value;\nif(_divisor > 0)\ni\nValue = (value * {_diviser-1,.0T) +\n_target)/ divisor;\n}\nff Not likely to be true very often.\nreturn (_valué -= gldvalue};\n}\nTloat GetValue}\n{\nreturn value;\n}\nprivate:\n\nfloat value;\nficat _target:\nTioat divisor:\n\nListing 2.1.2: CEaseOutShiftinterpolation\n\nDefinition\nSs\nclass CEasefutShiftInterpolation\n{\npublic:\nbool Setup(int from, int te, int shitt)\n\nif(shitt <= 0)\n{\n\n}\n\n_value = from;\ntarget = to;\nshift = shift;\n\nreturn false;",
      "content_length": 842,
      "extraction_method": "OCR"
    },
    {
      "page_number": 144,
      "chapter": null,
      "content": "146. Section? Mathematica\n\nreturn true;\n\n}\nbol Interpolate() J / Mote: Hot time dependant.\n{\nint oldVvalue = value;\nif({_shift > 0)\n{\nvalue = (_Valuea = ((1 =< shift} = 1) +\ntarget) => shift:\n}\nff lots more likely to ba tru than with float version.\nreturn {value == oldValue);\n}\nint GetValue(}\n{\nreturn value:\n}\nprivate:\n\nint value;\nInt target;\nint shift;\n\nListing 2.1.3: CLinearinterpolation Definition\n\nclass ClinéariInterpolation\n\ni\npublic:\nbool Setup(tloat from, float to, float tise]\n{\nif(ting = 0)\n{\nreturn false:\n}\n_fenainingTime = tine:\n_value = from:\nStep = (to-from}/tine; // Calculate distance per second.\nPreturn true;\n}\nHf Agtuen TRUE when the target has been reached or passed.\nbool Interpolata(float deltaTime)\n{\n_emainingTine -= deltaTine;:\n_valug += _steptdeltaTing;\nreturn (_remainingTime <= o};\nI\nfloat GetValuel}\n{\nreturn value;\n}\nprivate:\n\nfloat walue;\nfloat step;\nfloat _remainingTine;",
      "content_length": 907,
      "extraction_method": "OCR"
    },
    {
      "page_number": 145,
      "chapter": null,
      "content": "2.1 Interpolation Methods 149\n\nListing 2.1.4: CEaseinOutinterpolation Definition\ncs\n\nClaas CEaselingutinterpolation\n\n{\npublic:\nbool Setup(tloaat fron, float to, float tine)\n{\nif(time <= oO}\n{\nreturn false;\n}\nvalue = from;\n_target = to;\n_apeed = 0.04;\nff derived fren w=x0 + wot = a'¢eq/o\nacceleration = (to-from)/(tine*tima/4):\n_remainingTime = totelTime = tine;\nreturn true;\n}\nbool Interpolate(fleat deltaTime)\n{\n_remainingTime -= deltatine;\n1T(_remainingling < _totalTiae/z)\n{\nfi Deéeleration\nSpeed «= acceleration * deltaTime;:\n|\nalse\nff Acceleration\nSpeed += acceleration \" deltaTime;\n}\nValue 4 _speod*deltatine;\nreturn (_PémainingTime <= oO);\n}\nfloat GatValue[)\n{\nreturn value;\n}\nprivate:\nfioat value:\n\nTloat target;\n\nTloat _remniningTime;:\nTlaat totalTime:\nTloat speed;\n\nTioat acceleration:",
      "content_length": 796,
      "extraction_method": "OCR"
    },
    {
      "page_number": 146,
      "chapter": null,
      "content": "2.2\n\nIntegrating the Equations of\nRigid Body Motion\n\nMiguel Gomez\n\nThis article is intended as a nutorial on the theory and practice of simulating rigid\nbody motion. The Newton-Euler equations of motion are derived, and some simple\nnumerical integration methods are given. The reader is assumed to have caken col-\nlege-level introductory courses in classical mechanics, linear algebra, calculus, vector\nanalysis, and differential equation theory.\n\nKinematics: Translation and Rotation\n\n150\n\nIn order to derive che differential cquations that describe the motion of a rigid body,\nwe need to lay some groundwork. First off, let's give ourselves a fixed coondinare frame\nwith respect to which all our dynamic variables can be specified. By a fixed coordinate\nframe, we mean three linearly independent veetors (the basis) and a reference position\n(the origin) that is nor translating or rotating (an inertial frame). Let's be easy on our-\nselves and use mutually orthogonal unit vectors for our basis (an orthonormal basis).\nWe call this fixed frame the world frame, ar world space. Any point in space can be\nspecified with respect to this coordinate frame by three numbers, as shown in Figure\n22.1.\n\nAn independent piece of mantez the volume of which is negligible is called a par-\nfacie. When the volume of a piece of matter becomes significant, it is called a dudy.\nThe amount of matter in a particle or a body is its mass, and the amount of mass per\nunit volume is its density. In general, a body can have any shape and even deform aver\nume. If the matter inside a body is distributed unevenly, it has mom-wnifarne density.\nNo marrer how a body's mass is distributed, at any instane in time there is a point in\nspace that is the center of wna of the body, r_. The position af the center of mass is\ncalculared with a weighted sum of every mass element, m,, in the body:\n\not oh ¥ cm,\n\n> m M\n\na",
      "content_length": 1891,
      "extraction_method": "OCR"
    },
    {
      "page_number": 147,
      "chapter": null,
      "content": "2.2 Integrating the Equations of Rigid Body Motien 151\n\nx\nFIGURE 2.2.1. The vector © extends from che oripin, ©), no the poine P.\nWhen mass is continuously disribured chroughour its volume, this sum becomes\nthe integral:\nJrpwiav  [rp@)av\n\nIn this case, cach mass element is caleulated by multiplying a volume element 4”\nby a three-dimensional density function py)\n\nm, = pra.\n\nIt is helpful to associate a focal coordinate frame with a body, For our purposes,\nthe best choice for the origin is r_.. which we can take to mean the position of the\nbody. Qurormhonormal basis R = {R°, R', R*) corresponds to the local X, Yand 2 axes\nof the body (Figure 2.2.2).\n\nXx\nFIGURE 2.2.2. The vectors R°, R!, Ro define the x, y, and 2 aves of the local body frame.",
      "content_length": 749,
      "extraction_method": "OCR"
    },
    {
      "page_number": 148,
      "chapter": null,
      "content": "Section 2 Mathematics\n\nIr is also convenient co think of R®, R!, and Re? as the colurans of a matrix R, oo\nthac:\n\nsts\nR=|R RR\nRene,\n\nThis makes it easy to transform a vector from a body's local space to world space, and\nWOE VETS:\nView = Ry and vi = Riva {since R’ = RO for an\northonormal basis)\nTransforming a poinc is just as easy:\nKerid = Rist + fim AMI Niner = PY (erie — oe)\nIf at time # a body's position is r,, and at time #, its position is r, (Figure 2.2.3),\n\nthen its aecnge eeloctty between # and % was:\n\nhor Ac\nv_=——=—.\nfF Ar\nAs we sample che crajectory at smaller and smaller time intervals, we approximate:\nthe Jnsantancous velocity of the particle, which is the true velocity of the particle at\nany time, f, and is equal to the derivative of its position with respect to time:\n\noo Ar\nv=ln—=—.\nare Ar dt\n\nSimilarly, if its velocity changes from one instant to another, it is said to be accel-\nerating, given by:\n\nIn addition to translation, a body can undergo rotation, The amount of rotation\nthe body experiences per unit time is called its angular velocity (also called rotational\npelocitp), piven by:\n\ni a]\nlim — = @,\nfra Ag\n\nwhere dO is a very small rotation (in radians) and @ is the angular velociry about che\ncenter of mass",
      "content_length": 1243,
      "extraction_method": "OCR"
    },
    {
      "page_number": 149,
      "chapter": null,
      "content": "22 Integrating the Equations of Rigid Body Motion 163\n\nx\nFIGURE 2.2.3. A body moves from rf, toe) over a time Ar= 6-4.\n\nRepresenting a finite rotation with a vector is kind of a cheat, Strictly speaking,\nfinite rotations, no matter how small, cannot be considered vectors because they are\nnot commataer. This means that if a body were rotated abour the first axis by the\nfirst angle, then rotated abour the second axis by the second angle, it would nor neces-\nsarily achieve the same orientation as if the operations had been reversed. On the\nother hand, infinctesmal rotations (if you believe in them) are not order dependent,\nso they can be considered vectors. This is why angular velocity can be choughe of as a\nvector [(Chow5).\n\nIfa vector r is rotating ata constant angular velociry, then its time derivative with\nrespect to the feed world frame is:\n\nIfthe length of r is mar changing, chen the derivative simplifies to:\n\nar\n\n—= 0x r.\n\nalt\n\nUsing this relationship, the time derivacive of Ris:\nGu\ndt\n\nwhere the antisymmoecric matrix:\n\n=aR,\n\n0 -a, a,\no=|o, 0 -w,\n—O ge | 0",
      "content_length": 1076,
      "extraction_method": "OCR"
    },
    {
      "page_number": 150,
      "chapter": null,
      "content": "154 Section 2 Mathematics\ntakes the place of the cross product [Baraff)7a].\n\nDynamics: Forces and Torques\n\nNewton's first law of motion states that a body remains stationary or maintains a con-\nstant velocity unless acted on by an external force. This is also known as the law of\nconservation of fincar momentum, The linear momentum vector, p, of a body is cal-\nculated by multiplying irs velacicy, v, by its mass, se:\n\np> #F¥.\n\nThe rate of change of momennum with TeSPece te time is equal co che sum of all\nthe forces (the mer force) on this bevel:\n\n= in eae\nF.. me F, FF me er ma\n\nWhen a body is moving relative to a point of reference and its motion is not\ndirectly coward or away from thar point, it is said to have angular mortennint with\nrespect to thar point. The angular momentum vecwor, L, is defined as the cross prod-\nuct of the position vector rand the linear momentum vector p. The vecsor L is there-\nfore orthogonal to both rand p (see Figure 2.2.4).\n\nWhen a force acts to change angular momentum, it is said to cause a tongue. The\ntime derivative of the angular momentum is equal to the net torque on the body:\n\nL=rxp\n\nx\n\nFIGURE 2.2.4. Angular momencum, L, is orthogonal to both rand P-",
      "content_length": 1201,
      "extraction_method": "OCR"
    },
    {
      "page_number": 151,
      "chapter": null,
      "content": "2.2 Integrating the Equations of Rigid Body Motion 155\n\nSpecial Properties of Rigid Bodies\n\nIf every element of mamer in a beady is unable co cranslate or rotate with respect to\nevery other element of macter within that body, this object is called (oddly enough) a\nriga éody. (True rignd bodies don't exist in nature; every body, no marrer how stiff,\ndeforms somewhat when disturbed or when rotating. Deformation rediscribures mass\nand changes the inertia tensor, complicating motion even further.)\n\nRigid bodies have a couple properties thar make their motion easier te deal with,\none of which is that cheir center of mass is fixed. When a gid body is rotating, every\nlinde piece of mass, mi, within it has angular momentum with respect wo the center of\nmass, r.. The body's coral angular momencum {in world space) about its center of\nmass is the sum of all chese infinitesimal parts:\n\nie vs p=) 5 x (my)\n\nwhere r; (also in world space) is the vector from r,, to m7. Since the velocity of nm; is\n\ngiven by:\n¥, 2a x 4,\nWe Can write:\n\nee ¥ or, x(oxr)= -¥ mr, * (rx wo) = —¥ mora,\n\nwhere\nto Fy\ni S| 0 7\n—F Fr 0\n\nSubstituting and multiplying through gives:\n\n* q\nAn, i +r ) Sh My TT\non 2 I\nL.. = ¥ TT le mt Ue + ri, TN le\n2 i\n=F MTFs i (r + r)\n\nDime; +m) S-mzrs, as\n= » hit. T yy mi (rs, +) ¥ —my,7, .\n>» FTF, Fe, ¥ SHIFT 3m, ir — 5)\n\n‘This symmetric matrix of sums is called the svertia tener, 1, where:",
      "content_length": 1400,
      "extraction_method": "OCR"
    },
    {
      "page_number": 152,
      "chapter": null,
      "content": "Section 2 WMathamatles\n\nat Le\nfend ote\ni pee\n\nThe diagonal elements are called the moments of inertia, and the off-diagonal ele-\nments are called the preduct af inertia. For rigid bodies with continuously distabuted\nmass, the sums can be converted to the integrals:\n\nI, = lim Smibg +12) = | 3 +P )pwdv,\nmpl\n\n1, = lim} -mz,7, =—[nr,podv,\na mel x ul 1 =P\n\nand so on. The angular momentum about the center of mass can now be given in\nterms of the inertia tensor:\n\nL._ = Ia.\n\nThe fact that to this point, the vector ¢ has been specitied with respect to world\ncoordinares implies chat the inertia tensor depends on the body's orientation and must\nbe recalculated every time the body rotates. However, we can avoid having to reevalu-\nate the invegrals after every rotation by aiagomalizing the inertia tensor. Diagonalization\nof a matrix involves changing to a basis in which all the off-diagonal elements become\nzero, This basis is unique and consists of the eigensectors of the matrix. The diagonal\nelements with respect to this basis are called the eigenmalues of the matrix,\n\nIn general, the eigenvalues and eigenvectors of a mawrix are not necessarily unique\nor even real. Fortunately, the eigenvalues and eigenvectors of a symmetric matrix are\nalways real and mutually orthogonal [Lang87]. The normalized cigenvectors of the\ninertia censor are called the principal axe of the rigid body, and the eigenvalues are\ncalled the principal momenss of inertia. With respect to a body's principal axes, the\n\ninertia tener reduces Tor\n\ni. o--0\nI =|0 vee ot\no oOo f\n\nand the integrals simplify to:\nTae = [Jf > + eG ys zhdedneds\nf= if (x? + 2\")plx, y, zldedydz\nTa, = [ff G2 + yee, », hdd",
      "content_length": 1675,
      "extraction_method": "OCR"
    },
    {
      "page_number": 153,
      "chapter": null,
      "content": "2-2 Integrating the Equations of Rigid Body Motion : 157\n\nwhere x, ¥ and 2 are in the body's local frame. For rigid bodies, these integrals need to\nbe calculated only once, and the inertia tensor in world space is given by:\n1=RI,R* [Baraff97al.\n\nThe inverse of 1 is simply:\n\n-1 _ ln\nI =RI,R,\nwhere:\ndeers\nAes\nI = peg\nfe\nWe hee\nf\n\nIris often accurate enough to approximare the principal moments of inertia for a\nrigid body with those of a rectangular box of constant density, Luckily, the principal\naxes of a box are parallel to its edges, so the principal moments of inertia turn our to\n\nbee:\n\nf\n\nMe M 2 Moos\n= = To +di)f,. = 7p te +a°), and J = ia: +7),\nwhere @,. 4, and d, are the bax dimensions in x, y, and z, respectively [Baraff7a]. For\namore complete discussion on calculating ineria tensors of irregularly shaped bodies,\nsec [Mirtich 6].\n\nIn order to calculate the rotational motion of a rigid body, we need to know how\nangular velocity changes with respect co time. Ditterentiating the original relationship\nof angular velocity and angular momencum, we get:\n\nd. a al ao dia\nNL. = — = — (ia) = —w+lI— = I i—.,\n=e =, la) Pik ae a x (le) + 5 [Baraf97b]\nwhich ultimately gives:\n@ -1[n,,- ox 0a)\nar\n\nWe can now stare the differential equations thar describe the translational and\nrotational motion of a rigid body. The translational motion of the center of mass fol-\nlows the relarionships:",
      "content_length": 1394,
      "extraction_method": "OCR"
    },
    {
      "page_number": 154,
      "chapter": null,
      "content": "158. Section? Mathematics\n\nar\nee\nat\nareal\nar it ard\nand the rotational motion is described by-\nce = aR\nds\nat)\n\nFa r[n.. — x (a)\n\nTogether, these equations are known as the Newton-Fuler equations of rigid boaly\nmotion. Now that we have these equations, ler's explore some simple methods for inte-\ngrating them.\n\nIntegrating the Equations of Motion\n\nGiven an initial position, rp, the next position of the body, r,, can be approximated\nthrough che relation:\n\nar =\n= ee\n\nalt Ar\nSolving for ©, gives:\nt= ty, + vet.\nThis method, known as Euler inteenaian, is the simplest method for integrating\n\nsolutions to initial value problems. The same technique can be used co integrate che\nremaining dynamic variables:\n\nvy —'¥— te As\n\nR, =R,+a°R,Ar\n\na, =m, + rr, - wx (Lea) |e\n\nUnfortunately, integrating orientation in this way introduces error, and R must\nbe re-orthogonalized every frame. Furthermore, for high angular velocities, this inte-\n\nBradion is very inaccurate. A better way te integrate orientation is to find a rotation\n“vector” by multiplying the angular velocity by the time step:",
      "content_length": 1082,
      "extraction_method": "OCR"
    },
    {
      "page_number": 155,
      "chapter": null,
      "content": "22 Integrating the Equations of Rigid Body Motion 155\n\nAG = a,Ar\nThe angle through which co rotate the basis is:\na= |Ad,\nand the axis abour which to rotate the basis is:\nAg\nAs\nThe basis R. can chen be rotated by multiplying it by the matrix:\n\n5\n\n1-2y' +2\") 2xy— 2 Jez + Ly\nM, =| 2y+2m 1=2x' +2\") 292 =I\n2az — Dy dye t+ 2or 1 — 2x7 + 97)\n\nwhere s = cos($), and (x, y, z) = a sin($), $0 that R, = MLR, [Ware 2000).\nIf orientation is stored as a unit quaternion, q, then:\n\n4!\nar 3 4\n\nwhere @ is the pure quaternion @i + aj + ode The orientation can now be inte-\ngrated with the formula:\n\nl\nTi Peete\n\nIt ts important to normalize q after each step to prevenc “drift” in the solurion\n[Baralf97a].\n\nAlthough the Euler method is the simplest way to integrate differential equations,\nit is alse ehe least accurate and least stable. [f the angular velocity pets too high, the\nangular velocity grows exponentially to infinity. A simple hack co keep the solution\nfrom exploding is to multiply the angular velocicy by a scale factor nor much less than\n1 (maybe 0.999) every frame. This method works, bur it has the unforrunare effect of\nslowing the rotation ro a stop. For discussions of more advanced integration tech-\nniques, see [Derrick7), [Gerald99), and [Flairer?3].\n\nReferences\n\n[Baraff97a] Baraff, David, “An Introduction to Physically Based Modeling: Rigid\nBody Simulation 1—Unconstrained Rigid Body Dynamics,” available online at\nweew,.cs,cmuedu!-baralfipbm/pbm_brml, 1997.",
      "content_length": 1471,
      "extraction_method": "OCR"
    },
    {
      "page_number": 156,
      "chapter": null,
      "content": "Section2 Mathematics\n\n[BarahS7b] Barat, Dravid, “An Ineroduction to Physically Based Modeling: Rigid\nBody Simulation [I—Nonpenevation Constraints,” available online at\nwow. cr.cmuedu!-baraffipbm/pbo_heml, 197.\n\n[Chee)5] Chow, Tai L., Clesiea! Mechanter, John Wiley & Sons, Inc. 1995.\n\n[Decrick®7] Derrick, William R., and Grossman, Stanley 1,4 First Cowrse in Duffer-\nential Equations with Applications, third edition, West Publishing Company,\n1987.\n\n[Gerald99] Gerald, Curtis F. and Wheatley, Patrick ©, Applied Nionerical Analysis,\nsixth edition, Addison Wesley Langman, Inc., 1999.\n\n[Hairer)3] Hairer, E., Norsest, $8. P, and Wanner, G., Solving Ordinary Differential\nEquation: [: Nonsiff Problems, second edition, Springer-Verlag, 1993.\n\n[Lang87] Lang, Serge, Linear Algeéra, third edition, Springer-Verlag, 1987-\n\n[Mirtich96) Mirtich, Brian, “Fast and Accurate Computation of Polyhedral Mass\nProperties,” Journal of Graphics Took (vol. 1, no. 2): pp. 31-50, 1996.\n\n[Warr2000) Warr, Alan, 3.0 Computer Graphic, third edition, Addison-Wesley, 2000,",
      "content_length": 1051,
      "extraction_method": "OCR"
    },
    {
      "page_number": 157,
      "chapter": null,
      "content": "2.3\n\nPolynomial Approximations to\nTrigonometric Functions\n\nEddie Edwards\n\nThe way we approach specific problems changes as hardware evolves. Take, for examn-\nple, the trigonomerric finctions sine, cosine, and arctangent. It used to be thar we\nwould never even dream of calculating these on che fly; we would use a table lookup.\nUsing a table has its drawbacks—quantization errors being che main problem—Ivut it\nis very fast. Or at least, ir used to be.\n\nThese days, CPU speed seems to be increasing much faster than RAM speed.\n‘True random acces is particularly slow, since many types of RAM are optimized for\n¢ache line refills rather chan individual word accesses (RDDRAM being a case in point).\nMeanwhile, the time it rakes a CPU to do a floating-point multiply has gone down\nfrom more than 10 cycles to just 1 cycle in some archirecuures. Now that the CPL is\nso much Faster than the RAM, it makes sense to reassess our assumptions about table\nlookups. We can generally doa lot of calculation in the time it takes to access a single\nmemory location, and these calculations do not suffer from quantization errors to\nanything near the same degree. Maybe we should consider calculating values for sine\nand cosine rather than just looking them wp ina table.\n\nThis proposal raises the very interesting question, “Hew?” The ubiquitous solu-\ntion co calculating complex functions is through polynomial approximation; we find\na polynomial that approximates che function we wane. We then stuff our value of x\ninto this polynomial and out pops an approximare value for the function, Since mul-\nplies are so cheap these days, this looks like a very fast way to evaluate the function.\nIn che first part of this article, | describe in some detail how polynomial approxima-\ntions work and how co manipulate polynomials ro your own ends.\n\nThe problem of calculating che function is now transformed into the problem of\nfinding a geod polynomial to use as an approximation. This is a search for a ser of\n“magic” numbers—the polynomial coefficients—that give good results.\n\nThe best-known method for obtaining these numbers is to look at the Taylor\nseries for the function, The Yaylor series is an infinite polynomial char is equivalent to\nthe function (for some range of x). If we truncate the Taylor series, we pet a finite\n\n161",
      "content_length": 2315,
      "extraction_method": "OCR"
    },
    {
      "page_number": 158,
      "chapter": null,
      "content": "162 Section? Mathematics\n\n——— ————— eS\n\npolynomial, which we assume to be a good approximation to the function. Larer in\nthis article we demonstrate how Taylor series work and discuss their limirarions.\n\nThere are alternatives to the Taylor series method char are nor so well known. The\nmain thrust of this article is to explain one technique, the Lagrange series, which has\nsome very specific advantages over the Taylor series. The Lagrange series is capable of\nentirely removing certain errors in the approximation and on average gives results that\nare Many times more accurate.\n\nPolynomials\n\nA palynomial is simply a sum of powers of a variable Gx}, cach multiplied by a coeffi\n\ncient. The stanclard way to write a polynomial is as follows:\nafO) + aff + af2) x + a(3)\"x\"x\"e + ... afaf*por(xd)\n\nThe numbers a// are called the coefficients: of the polynomial. The number ais the\ndegree of che polynomial. We can demonstrate chese elements in C++:\n\nfloat Poly::Evaluate(float =}\n\n{\nfloat powx = 1;\nfloat sim = oO:\n\nfor (int n= 0; n <= d: nt+]\n\nSum += a[n] * pown;\npom A= ee\n\n}\n\nreturn Sun;\n\n}\n\nThis is the most obvious and straightforward way to cvaluate the polynomial with\na program, although many alternative methods exist. These alternatives rely on fac-\ntorizing the polynomial in some way, I do not recommend the alternative methods,\nfor two reasons:\n\n1. Factorizing often leads to a divide per factor, which means your coefficients are\nsusceptible to rounding errors (especially in single-precision fMoating point).\n\n2. Calculating using factoring has a critical path containing all the multiplies. Calcu-\nlating the simple way has a critical path containing just onc mulriply and one add,\nso the simple method pipelines much better on CPUs where chis ix important.\nFor instance, one alternative method that requires no divides is this factorization:\nafO] + x\"(aft] + <af2} + x*a[3] ...))\n\nThis method is evaluated in C++ code like this:",
      "content_length": 1944,
      "extraction_method": "OCR"
    },
    {
      "page_number": 159,
      "chapter": null,
      "content": "23 Polynomial Approximations to Trigonometric Functions 183\n\nfloat Poly::Evaluate(float x)\n{\nfloat sum = afd];\nfor {int a= gd — 1; n= 07 ne]\n\nSim = sum * x # ajn];\n\n}\n\nreturn SLM;\n\n}\n\nNote that each iteration multiplies against the resules of the previous iteration, sa\nthe loop cannot be broken down and pipelined. This method does have the advantage\nthat only one accumulator register is required, so it might be a good choice for che\nx86 architecture's scalar FPU.\n\nDomain and Range\n\nThe domain ofa function is the area over which it can be called. The range is the\nrange of values it returns, over its domain. You might think thar the domain of one af\nthese polynomials is infinite. Not so!\n\nWhen we look at the evaluation of the polynomial, we see it is the sum of terms\nof the form:\n\nain] “ports, m1)\n\nEach of these terms must itself be a floating-point number, so each one must be in the\nrange of a floac, which is approximately 0 to 24127 (ignoring sign, and assuming\nIEEE single-precision format).\n\nIfwe take the base-2 logarithm of this polynomial, we gel:\n\nlog 2(afn] * powtx,n)) = log2fain]) + 2 * lope) < 127\n\nwhich gives us a series of inequalities thar Jog 2(x) must obey. Quite clearly, this is not\ninfinite! For instance, if che degree of the polynomial is 10 and the value of all the\ncocflicienss is 1, we have:\n\ndog Noe) =z 12, F\n\ngiving an effective domain on x of 6000 co +6000.\n\nThe range of a function is often well known. For instanec, the range of sine is\n—1.0 to +10. The range of other functions is infinite; for instance, tangent gets larger\nand larger as its argument approaches 90 degrees.\n\nWe now come to a classic numerical accuracy problem. Suppose we want to cal-\nculate sin(6000.0) with a 10th degree polynomial.From the domain analysis, we\nknow that the floating-point terms will become very lazee—up to just under\n2*127—but we know that the final result is berween —1,0 and +1.0. The final resule",
      "content_length": 1933,
      "extraction_method": "OCR"
    },
    {
      "page_number": 160,
      "chapter": null,
      "content": "164\n\nSection2 Mathematics\n\ncomes from the final sequence of additions, and since cach number added is very\nLarge, they must all jst cancel out to give the small numbers expected.\n\nUnfortunately, the single-precision floating-point format stores only 23 bits of\nprecision, which means thar for numbers as large as 24127, there is no precision at all\nin the range 0.0 no 1.0. In fact, che lowest bit has value 24104! So we can expect to\nhave errors of the order of 24100 in a value thar is of the order 1.0, which is as ood\nas saying we have no idea whar the answer is (In fact, it is like saying, “Although I\nknow my keyboard is on my desk, my calculations tell me it is acmually on a small\nplanet somewhere in the vicinity of Betelgeuse.”)\n\nTr turns out that this is nota problem for sine and cosine, since they are periadic\nfunctions, fyou need tm know sf(6000.0), you can subtract 2\"pi repeatedly uneil it is\nina better range (=pr to +7) and then apply the polynomial. A fast way co do this is\n\nat Feullonws:\n\nMultiply che value of x by 65536/2\" pt.\n\n(Cast + to an integer.\n\nShift it left 16 bics (on a 32-bir processor).\n\nShift it night 16 bits, arichmerically (to estend che sign).\n(Cast » back ro flaat.\n\nMultiply che value of x by 2*90/65536,\n\nPr a a pd\n\nThis method gives the correct value of x berween —pi and +p, with 16 bits of resalu-\ntion.\n\nYou may wane to work exclusively in the number system obtained after Step 3,\nwhere all the significant bits are art the top of a machine word. This format is a fixed-\npoint format representing the number of cums, with 32 bits of fraction and 0 bits of\ninteger, 30 if you add owo angles together you ger the expected result wichour any\nmodulus operation (in effect, the finite word length of the computer does the modu-\nlus operation for you).\n\nThis unit of measure is called a renatien, alchough in my experience every com-\npany gives the unit a difference name, chosen as the most confusing term posible!\nSince the number is che number of rotations, stored as an unsigned 32-bit fraction in\nfixed point, the name nfwtion socms to be the most suitable.\n\nIt is usually most efficient to convert between radians and rotations only when\nyou need to use radians and vo use rotations the rest of the time.\n\nChanging the Domain\n\nThe preceding example shows how we can change the units oF Our function. Far\ninstance, the sine function cakes radians, hut by pre-multiplying by 2*p2/65536, we\ncan make it cake notations as a signed 16-bit fraction (5.15, 1:0:15).\n\nWe can, in fact, change the units of our function intrinsically by changing the\npolynomial coclicicnts. Suppose we have a function that takes radians, but we want\nit to take degrees. We could juse do the following:",
      "content_length": 2723,
      "extraction_method": "OCR"
    },
    {
      "page_number": 161,
      "chapter": null,
      "content": "ee] Polynomial Approximations to Tigonemetric Functions 1645\n\nTisat mult = (2.0 * pa) | 360.0:\nreturn SinePoly::Evaluate(x * mult};\n\nOr we could rewrite Evaluate:\nfloat Poly: :Evaluate(float x)\n{\n\nfloat mult = (2.0 * pi) f 360.0;\nfloat powe = 1;\n\nfloat pownult = 1;\n\nfloat sum = O;\n\nfor (int n= OF; n <= d: net]\n{\nSUR += a[f] \" pows * powult;:\npow *= x;\nprMult “= mult;\nI\n}\n\nNow here’s che trick: We replace cach af) with afi} * pournult according to this\ncode, and then we can use the original code to evaluate the function with the new\nunits. So we do the following:\n\nvoid Poly: :Changelmits(float old_units, float new unite)\n{\n\nfloat mult = old_units / new_units;\n\nfloat powmult = i:\n\nfar (int mn = O; m <= ds mtt+}\n{\na[nj] *= pownult;\npommel? \"= quit;\nI\n}\n\nThis method, of course, works only if mew_ smite is not zero.\n\nBe very careful using this technique. If the new range is coo high (and 360 prob-\nably is), we get the same exponent problems we looked at in che last section. This\nmethod cannot be used to create a polynomial that directly takes signed 16-bir frac-\ntional rotation values, since the evaluation will overflow. However, it can be used ra\nchange a polynomial’s range slightly. by a factor of up to around 4.0, depending on\nthe polynormial’s degree.\n\nWe can also add am offset into the domain, but this process is much more\ninvolved. It involves substiruting the value (x + off) into the polynomial in place of x,\n\nPor instance, substimuing (x + 2) for x in the polynomial (‘J + x) gives (7 +\n(x+2)\"(x+2)), which simplifies to (7 + ¢\"x + x%x). Therefore, che value of poly atx =\nfis 10, which is the value of the old poly arx = J + 2 = 3, This replacement is tedious\nif done by hand; the methed offsetdomain() on the CD thar accompanies this book\ncan be used to do it mechanically,",
      "content_length": 1802,
      "extraction_method": "OCR"
    },
    {
      "page_number": 162,
      "chapter": null,
      "content": "Section? Mathematics\n\nTf you do want to change the domain, we recommend you simply do it to x by\nhand before inveking the polynomial evaluation method. This method adds ane or\nwo cycles wo che evaluation, but it is highly robust and very easy.\n\nChanging the Range\n\nCompared with the domain, the range is casy 00 deal with, and the resulrs are just\nwhat you expect. To change the ourpur units of a polynomial, simply multiply each\ncoefficient by the factor, as follows:\n\nwoid Poly: -ChanpeQutputUnits (float old_units, float new_units)\nfloat mult = new_units | ald units;\nfor (int on = OF no ds nee}\n: a[n] \"= mult;\nI\nThis solution works, since:\nproce \"(afO) + af + af) ete +.) = mised a /0] © monde taf 1] + mnultaf2] xe\" +...\nTo offset the output, simply add the offset to aff), since:\noffer + afO} + aff fx +... = (offer + afOl) » afl] x + ...\n\nSo, you can change the range of a polynomial incrinsieally and at zero cost to the\nfinal evaluation procedure.\n\nEven and Odd Polynomials\n\nWhen you come to manipulating polynomials on che computer, you will find thar\nmany coefficients become very small—e.g., 1.546 \" 24-80. You may well ask, “Is chis\nthe comect coefficient, or should the coefficient actually be zero?” The answer ro this\nquestion comes from the analysis of even and odd polynomials.\n\nAn even function is one where:\n\nft-s) = fit)\nThat is, its graph is symmetric abour che line x = 0. An odd fimction is one where:\nfi-x) = =f)\n\nThar is, its graph is anti-symmetric. In crigonemetry, sine is an odd function, and\nCOSINE fs ain even function.\nNor all functions are cither even or odd. For instance, fy + J) is neither.",
      "content_length": 1628,
      "extraction_method": "OCR"
    },
    {
      "page_number": 163,
      "chapter": null,
      "content": "foi Polynomial Approximations to Trigenometric Functions 167\n\nA polynomial is made up of swms of che functions 1, x, x\", x%x\"x, etc. Each one\nof these basic functions is either odd or even.\n\nPele EVEN\nx=—(—x) & ODD\nxr = (xx) & EVEN\n\nas = Or) ODD\n50:\nafn i EVEN ifn i EVEN, and ODD ifn ODD\n\nIt should be reasonably clear that if 2 polynomial conrains all even powers of x,\nthe polynomial itself is even, and that if it contains all odd powers of x, the polyno-\nmial itself is odd. (This is where the terms even and eda come from in the first place.)\nIfa polynomial contains some odd powers and some even powers, it is neither even\nmor coded\n\nNow the important point: If a polynomial approximares an even function, the\npolynomial itself should be even. It's no use if your polynomial says that sin‘) does\nnot equal —sim(—), because ir does!\n\n[f you can cell by analysis that a coeficient should be zero (even if a program tells\nyou the coefficient is 1.546 * 24-80), you should set it to zero. This is the correct\nvalue, and the bogus non-zero enefficient is the result of floating-point rounding\ncmors, Leaving the incorrect value in could lead to unexpected results.\n\nThis implies that if the function is even, aj] is zero whenever m is odd; if the\nfunction is ode, an) is zero whenever nis even. IF you have a supposed polynomial\napproximation to sim(x) thar has 2/2/, mot zero, you know the approximation is\nwrong.\n\nTaylor Serles\n\nThe Taylor series has its roots in a very simple procedure we can use to copy polyno-\nmuals, which is based on the simple mathematical operations of evaluation and differ-\nentiation. We have seen evaluation already; mow we must look at differentiation.\nFortunately, differenciacion of polynomials ts quite straightforward.\n\nWhen we differentiate a polynomial, we get-\n\nafl} + af2]*2\"x + a [3] 3x + afd] axe +. + afd “a “poww(sc, =I)\n\nEach cocthicienc is multiplied by its power, and then the power is reduced by one.\nThis process can be deseribed as a method:\n\nvoid Poly: Differentiate}",
      "content_length": 2019,
      "extraction_method": "OCR"
    },
    {
      "page_number": 164,
      "chapter": null,
      "content": "168 Section 2 Mathematics\n\nfor [int © = 13 mn <= dj n++)\na[fa-1] = alm) * a;\nafd) = 4;\n\nif (d > 0) d--s\n}\n\nNote that the derivative of the polynomial «/0/ (degree zero} is 0 (also degree\nzero), which explains the “special case” lines of code in the preceding example.\nLet's differentiate again, which gives:\n\naf2]*2 + af3P°3 2% + aféP FF +...\n\nEach time we differentiate, the degree of the polynomial goes down by one. Now\nlook at a/r//O! at cach stage. (Here, the first array subscript denotes che number of\ndifferentiations, starting with zero differentiations):\n\nafO/f0} = aft]\n\naf Ij{O} = aff]\naf2i[0} = 2*a{2}\nafSfo} = 3°2\"a/3}\naf4}{0} = 4°3°*2*a[4]\nafm} [0] = nf * ain]\n\nEach coefficient is rotated in curn into 2/@!, and multiplied by x.\n\nWe can obtain a/t/ from the polynomial object by calling Evaluate (0); by calling\nDitferantiate(), we can rotace cach coefficient into «/0). So, by calling both func-\ntions, we can take the polynomial apart:\n\nwoid Poly::CopyPoly(Poly* p)\n{\nfloat nfact = 1;\n\nd= 0;\na[O] = p->Evaluate(0);\np->Differentiate(};\n\nwhile (ip->Isfero())\nne\ninfact *= di;\nafd] = p->Evaluate(o) / afact;\np->Differentiate():\n}\nI\n\nIszero() ts the function that tells us if the polynomial is zero everywhere (ic.,\nEvaluate(x) = 0 for all x}:",
      "content_length": 1257,
      "extraction_method": "OCR"
    },
    {
      "page_number": 165,
      "chapter": null,
      "content": "2.3 Polynomial Approximations te Trigonometric Functions 168\n\nbool Poly; iiszero{)\n\nreturn ({d == 0) && [a0] == o));\n\nThe important thing to note here is that we created the new polynomial from the\nold polynomial only through its operations IsZera(), Evaluate(), and Ditferenti-\nate().We never directly asked for cither the polynomial’s degree or for any of its cock-\nficients.\n\nThis point is interesting because in mathemarics these three operations make\nsense for a vastly wider class of objects chan just polynomials. This wider class is rech-\nnically known as infinitely differentiable functions and includes all the functions with\nwhich you are most likely to be familiar. In fact, only strange functions such as true\nfractals and the Dirac delta function (which contains an infinity at x=0) give prob\nlems in practice. The other chiss of functions thar give problems are those with\ndiscontinuities or sharp corness (which are equivalent to discontinuities in the differ-\nentidted function), but we look at some ways to deal with chese functions later.\n\nIn ebject-oriented terminology, the class Poly is itself a subclass of Dif ferantiable-\nFunction, which has virnual methods IsZero(), Evaluate(}, and Differentiatat }.\n\nThis is how Taylor series are caloulated—or racher, how the subset of Taylor series\ncalled “Taylor series expanded about x = 0” is calculated. The following function cal-\nculates Taylor series in their full glory;\n\nwold Poly: :WakeTayLlorseries(DitferentiableFunction® f, float pt}\n\ni\nfloat nfect = 1;\n\nd = 0;\na[O] = f-*Evaluate(pt);\nf--Ditterentiate(};\n\nmhile (it->Iszera())\n{\ndee;\nnfact “= d\na[d] = f->Evaluate(pt) | ntact:\nF->Differentiatal yi\n}\n\nOf fsetOomain (pt);\n}\n\nThis function calculates the series for ffx — pt) and then offsets the domain to\nmatch. You may ask why you would use valucs of pr other than 0. The answer is thar\nsome functions have no well-defined value at x = ( (e.g., Jc is not defined there), so\nwe move away from that specific poine to prevent problems with infinities.",
      "content_length": 2026,
      "extraction_method": "OCR"
    },
    {
      "page_number": 166,
      "chapter": null,
      "content": "170 ; Section 2 Mathematics\n\nEzample: Sine and Cosine\n\nThe derivative of sine is eosine, and the derivative of cosine is sine, so we cam use\nfunction poinrers no define the class TrigFunction thar behaves like these nwo:\n\nGlass Trigfunction : public OitferentiableFunction\n{\npublic:\nTrigFunctiont} { fptr = sing sign = 1; }\n\nbaal [szero() { return false; }\nFloat Evaluate(tioat x) { return Sign * float(fptri(doubleqxy)); J\nFloat Bifferentiate(}\n\nif {(fptr == sin)\nfptr = c05;\n\nelse\n\n{\nfptr = sin;\nSign = -sign;\n}\n}\n\nprivate:\n\ndouble (*fptr) (double); // stdlib math function sin or cos\nFloat sign; if sign of function —1 or +1\n\nhi\n\nLinfortunarely, although the MakeTaylorSeries function accepes an object of this\nclass, it never recurs, because the derivative never becomes zero. Houston, we have a\nproblera!\n\nThere are several ways around this dilermma:\n\n1. Specify the maximum degree of the polynomial thar wakeTaylorSeries will\nreturn.\n\n2. Specify the minimum coefficient value. Since the enefficients are probably\"\ngoing to get smaller and smaller, since a! gets larger and larger, we can terminate\nthe routine once the last coefficient is tere small,\n\nThe frst way is guaranteed to work; the second way might still fail. Why? Because\nthe coefficients might mer get smaller and smaller. The mathematical analysis of this\nconcept is beyond the scope of this article, bur you can rest assured that mast functions\nyou will deal with wilf have coefficients that per smaller and smaller, Nevertheless, you\nshould always set a large limit on the degree, just in case.",
      "content_length": 1566,
      "extraction_method": "OCR"
    },
    {
      "page_number": 167,
      "chapter": null,
      "content": "2.3 Polynomial Approximations to Trigonometric Functions afi\n\nTruncated Taylor Series\n\nThe Taylor series for sine was a polynomial of infinite degree. Which is a shame,\nbecause we can only evaluare (or even store) a polynomial of finite degree. In fact, for\na game, a small degree is quite desirable.\n\nWhen we truncate the series, an error is introduced (aver and above the usual\nHoating-point error) because the terms we ignore do make a contribution wo the final\nresult. It can be shown chat the error impresses as x increases, which is another good\nreason to limit che domain of your polynomial.\n\nYou can analyze the error mathematically, if you like, bur we won't go into the\ndetails here. The best thing to do in reality is practical experiments:\n\n1. Sample the errors in your estimate, using the double-precision sin) and cos)\nfunctions to compare. Get the average and maximum absolute errors. Asa rule of\nthumb, get the error below J /p, where p is che number of pixels diagonally across\nthe screen. For console games ar G40 480), pis around 200; for PC games ar\n1,280 x 1,024 or abore, pcan be more than | G00.\n\n2. Serup a large, slowly rotating sprite thar fills the screen. Use your sine function tw\nrotate it, Watch for artifacts such as jerkiness or expanding and shrinking in size,\nIgnore the harsh jibing of those who say, “Ooh, you can rotate a sprite!” in a sar-\nCastic tone.\n\nFor single-precision float and for a range —pi!2 to +pé!2, taking the first five coef-\nficients of sin and cos works well. This method is also quite fase on current hard-\nware—indeed, one current vector FPU chip actually implements his series on-chip in\nmicrocode. However, it is something of a pain to use this range, since it requires same\nrather tedious manipulations of the angle before the series can be used—a fact thar\nthe designers of the hardware seem co have missed,\n\nIf you extend the five-coefficient series for sine and cosine to —pi and +i, you get\nan error of around | part in 300. The unfortunate thing is that you get the following\n\nwalwes:\ncafé) = a0\nsin(pi) = 003\n\nsin(—pi) =—0.003 fobviansly, sitce site ix adel)\n\nThis problem shows up in the rotating-sprite test as a “jerk” when the angle passes\nfrom +pi to —p2. The erroris 1 part in 300, but this is doubled across the boundary, so\nthe rotation vector jumps from y = 0,003 ro y= +0.003—a jump of 0.006. Ic is cer-\ntainly noticeable at 410 x 480.\n\nWith the Taylor series, there is nothing we can do to fix this problem excepe\nincrease the degree of the polynomial. However, there is more to polynomial approx-\nimation than just the Taylor sezies,",
      "content_length": 2612,
      "extraction_method": "OCR"
    },
    {
      "page_number": 168,
      "chapter": null,
      "content": "1 72 Section 2? Mathematics\n\nLagrange Series\n\nThe Lagrange series is my name for a type of approximation series derived using\nLagrange’s formula. Unlike the Taylor scries, there is not one single Lagrange series for\na given function. There is instead a whole family of series, from which we choose\nbased on which results we want co be exacely correct and which results we allow to\nwander from the correct value.\n\nFor instance, we can say that we require sin to be exactly correce for the well-\n\nknown points:\n\nsin(—pi) = 0.00000\nsin(—pil2) = — 1.00000\n\nan(O) = CLooogG\nsin(pa2) = J.00000\nsin(pi) = @.OO00R\n\nIf our approximation were exactly correct for these points, we would know that:\n\nlL. The size of the object would not grow when it wat rotated 90, 180, or 270\ndegrees. It would exacely match the original size.\n\nThe sin function would pass through © as it crossed the 360-depree boundary,\nwould therefore remain concinwous ar that point, and would cherefore exhibir no\njerkiness,\n\n[+\n\nA theorem proved by Lagrange states thar for any given V points there is a unique\n(NOJ)th degree polynomial that passes exacey chrough all che points. If we calculace\nthis polynomial, we have an approximation thar has the properties listecl.\n\nSuppose we want to find a Srh-degree polynomial for sine. We need this polyno-\nmial to be unique, so we must choose 10 points at which sine must be exacthy correct.\n‘This is unfortunate, since we want to have a spmmentical point distribution aboutx =\n0. With one point ac x = 0, we must have an odd number of points to achieve the\ngoal. If we put an extra point on one side, we couldn't guarantee that it would be\nmatched on the other side,\n\n‘To get an odd number of points, we use a 10th-degree polynomial. Fortunately,\nwe know that sine ts odd, so we know thar 2/0] = 0, so the 10th-degree polynomial\nis the same as the Sth-degree one,\n\nThere are many choices of poines (infinitely many!). so we choose points ar well-\nknown values. You could instead choose points that are evenly diseribured. The only\ncritical points are at =1 30 and +180 degrees, since chese points ensure continuity over\nthe boundary and hence mo jerkiness.\n\nNotice that by choosing points, we assume no prior knowledge of our function.\nWe dont assume, for instance, that it can be differentiated. This can be a useful fea-\nture if, for instance, we want co approximare a sampled waveform wing a polyne-\nmial—bur it cin also be a big problem, since we can miss importanc “Fearures” of the",
      "content_length": 2495,
      "extraction_method": "OCR"
    },
    {
      "page_number": 169,
      "chapter": null,
      "content": "23 Polynomial Approximations to Trigonometric Functions 4173\n\nfunction graph. ‘The message here is, make sure you know whar your function looks\nlike (in other words, graph it} before you choose your data points.\n\nCalculating the Lagrange Series\n\nThe Lagrange series is obtained as a sum of polynomials—a different polynomial for\neach point.In this exposition, our daca points are x/f/, ..., xfeff, and the desired fumc-\ntion values at these points are y/O/, —, pied].\n\nFirst, consider the simple polynomials:\n\n(or — xen)\n\nEach polynomial is first degree, and there are (ae!) of them in total, The mh palyne-\nmial is zero when x = xfm/ and non-zero for all other values of x.\n\nUwe multiply all these polynomials together, we gee a polynomial of degree\n(@+1).This polynomial evaluates to zero at every data point, since one of its factors is\ngeno at that point. For instance, ic is zero at x/2) because ome of ies Factors is fe — aff).\n\nNow, if we instead multiply aif due ome of the polynomials together, we get a paly-\nnomial of degree @ that ewaluanes to zero at each dara point exveps for the one we mined\nour. This is because it does net have a factor (x —xj/nj) for che data point xf. The\nvalue at that data point is given by substituting x/r/ for x in the product polynomial;\n\ncfr] = Cefvm] — xf) (slap — xf t})._.oeen] — xcfm— 1) cfm] — xfime+ 1 ])...oefm — xfadt)\n\nThe next step is co multiply the product polynomial by y/m//c/m/, a process called\nformalization. The result is a new polynomial thar is equal to yim ac dara point x[m/\nbut is equal to 0 at every other data point. (Nore thar multiplying the polynomial by\nyim [ef] ts equivalent to changing the output unirs by chat factor, as discussed car-\nlier}\n\nThis concept gives us the bu ilding block for che Lagrange series. To gt the\nLagrange series itself, we need to generate all (@2J) of these polynomials and then add\nthem all together. Ar each data point «nj, all bur one of the polynomials evaluates to\nzero, Whereas the other one evaluates to piny. Wre have therefore conswucted a poly-\nnomial that is equal ro p/n/ at each point x/i/, as desired.\n\nPor example, suppase we have the simple three-point case:\n\nxfof=s =]\nxfij=0\nyif=2\nxf] a J\nyl2]=4\n\nThe simple polynomials are (x—x/OJ), (x —x/1)), and ( —x/2/), which are equal to (x\n+ 2), (e— 0) and fx — J). Let's look at dara point x/6/, We multiply all the simple\npolynomials except (x — x/0)/) together, which gives:",
      "content_length": 2438,
      "extraction_method": "OCR"
    },
    {
      "page_number": 170,
      "chapter": null,
      "content": "eee Secticn 2a Matiemnas\n\n&—O) \"(e-I=x—x\nWe evaluate this at x/@!, which gives:\nefo} =—J*y_—(¢rj=2\n\nWe want 7/0/ to be 4, so we multiply this polynomial by 4/2 «= 2 (changing che\nOutput units), piving:\n\neee —\nNow we inser x/0/), <fI}. and xf2/ to check chis our:\n\nxfOf = —7 22-1) 7-1) — 24) = 4\nafif-022°00-20=0\nxf2f—e F22°F2 —271=0\n\nSo we do indeed have zero at all the data points except the first, where the value ts 4,\nas expected.\n\nCompleting the work for the other ewo points gives the following polynomials\nfor cach dara point:\n\nxO): 2°\" — 2%\nxfi]:2— 2x\"\napap: 2 ee 2%\n\nYou can check thar each polynomial is equal to y/n/ at its own dara paint, and zero at\nthe others.\nFinally, we add these three polynomials together, which gives:\n\nxy a De 2 Pee et Pe a oe et 2\n\nYou can quickly check that this polynomial matches the dara at every point\n\nThe member function YakeaLagrangeseries() on the CD char accompanies this\nbeok does the hard work, so you don't have to. [t can be very tedious constructing a\nShearer Lagrange series by hand!\n\nNote that there are errors in the results from WakeLagrangeSeries( )—normal floar-\ning-point errors, as you would expect. The calculations are very complex and they iter-\nate, so errors build up. If you are making a Lagrange series that must be cither even of\nodd, make sure you ignore the values of any odd or even cocfhcients that have to be\nzero. You can do this by calling the member functions ForceOdd() or Forcefven().\n\nComparison with Taylor Serles\n\nFor a 9th-order sine and 10ch-order cosine, we have already seen che continuicy prob-\nlem at the 360-degree boundary. The Lagrange series does not have chis problem. In\ngeneral, the Lagrange series gives you much finer control over the fearures of your\napproximation, such as continuity and specific values that must be correct.",
      "content_length": 1825,
      "extraction_method": "OCR"
    },
    {
      "page_number": 171,
      "chapter": null,
      "content": "2.4 Polynemial Approximations to Triganometric Functions 175\n\nThe program on the CD (main.cpp) does 2 comparison of average and maximum\nabsolute errors over the range —pi to +pi. The difference is quite pronounced. The\nTaylor series exhibits a maximum error of 1 part in 150, with an average error of 1\nparc in 1,500. Compare thac with the Lagrange series, which has a maximum error af\n1 part in 11,000 and an average erpor of only 1 pare in 77000. (Note thar these errors\nwere measured in double-precision eating point.)\n\nThe Taylor series is an exact march for a function, provided you take infinitely\nmany terms. [he Lagrange series is intrinsically limited by the number of data points\ntaken. This fact seems ro imply thar the Taylor series is the better approximation, but\nthese data prove otherwise. In this case, the Lagrange series has a steiner error one-\nseventh the size of the Taylor series’ avensge error!\n\nA Note on Humbera\n\nWhen you are dealing with exact numbers in floating-poinr norarion, the output of\nprintf() quite often doesn't cut i; it only prints a few decimal places, and floating.\npeint numbers are noc decimal-based (which means that a decimal rendition is at best\nan approximation vo the floaring-poinc value). In the Print(} member fanction of the\nPoly class, you can print our the coefficients as hexadecimal values. ‘This enpures thar,\nwhen you move the numbers into your own code, chey are exactly what they were\norginally. Ir can be somewhat painful to do this in C++, bur one trick involving\nunions in Print() can be used the other way around to get the floating-point num-\nbers from the hexadecimal form,\n\nNore also thar to get the best out of this code, you should define the Number class\nto be double, even if you are going to use single precision in your game, You can sim-\nply convert to float when you print the coefficienes.\n\nDealing with Discontinulties\n\nDiscontinuitics arise in practice fairly often, and neither Taylor nor Lagrange series\nhandle them very well. Polynomials are always smooth, eo the discontinuities become\nsmoothed our, which may not be desirable. Fortunately, it is usually quire easy to\nwork around these problems.\n\n©ne familiar discontinuous function is the tangent function. Ar +/— 90 degrees,\nthe tangent function pecs to infinicy and chen jumps to negative infinicy. This dis-\ncontinuity can be dealt with in owo fundamental ways. First, you can simply calculate\ntangent as sine divided by cosine. This method avoids the problem entirely (as long as\nyou do a divide-by-zero check!). Second, you can restrict the range of your tangent\nfunction to be just the range over which it is continuous—Le., from —90 to +90\ndegrees. Por the Lagrange series, chis means taking points only from inside chis range.\n\nIfyou have a function that has a step-like discontinuity, you can often remave the\ndiscontinuity by subtracting a step function. This gives a continuous function, which\nean be approximated using Taylor or Lagrange methods. You then add the step func-",
      "content_length": 3021,
      "extraction_method": "OCR"
    },
    {
      "page_number": 172,
      "chapter": null,
      "content": "Section 2 Mathematics\n\ntien back in to get back to the original function. If instead your function has a sharp\npeak, it will be smoothed out by the polnomial, bur you can often subtract a trian-\ngular function before approximating, to again yield a smooth function.\n\nThese heuristics are all based on simple adjustments of the basic algorithm vo deal\nwith special cases. This is an area in which you can exercise your creativicy to deal with\nwhatever comes your way.\n\nConclusion\n\nIn this article, we have taken a quick tour of some quite basic mathematics and\nseen some very important results. We have seen how polynomials can be manipulated\nin various ways and how they can be copied without direct access to the coefficients.\nFrom these methods, we discovered Taylor series. We then found Taylor series to be\nsomewhat inadequate for many applications and saw a powerful alternative in\nLagrange series.\n\nNeither the Taylor series mor the Lagrange series are all chings ta all people, If you\nuse these numerical recipes in your own code, I urge you to do the experiments and\nlook at the results. Make sure your code always works as you expect, and watch out for\ndiscontinuities in the original function.\n\nWith that caveat, you now have che machinery to approximate a wide range of\nfunctions. Use it wisely!",
      "content_length": 1306,
      "extraction_method": "OCR"
    },
    {
      "page_number": 173,
      "chapter": null,
      "content": "2.4\n\nUsing Implicit Euler\nIntegration for Numerical\nStability\n\nMiquel Gomez\n\nChoosing a method of integrating initial value problems is an important patt of writ-\ning an interactive application. Due to its case of implemencarion, explicit Euler inte-\ngration seems co be the integration method of choice. Unfortunately, this method\nsuffers from the problem of fstabrlizy in which errors build exponentially and che\nsolution quickly becomes infinite. This article describes the feplicit Euler method, an\nefficient and highly stable integrator. Two examples are used to illustrate this tech-\nnique: exponential decay and the damped spring equation, Finally, difficulties in\nderiving implicit solutions are discussed. We assume the reader is familiar with calcu-\nlus, classical mechanics, and differential equation theory.\n\nIntegrating Initial Value Problems and Stability\na a al at tL tl\n\nInitial value problems are simply differential equations with initial conditions. For\nsome equations, an analytic solution can be found and used to calculate the trajectory\nof a body. In most cases, however, no analytic form exists, and the solution must be\nintegrated numerically,\n\nThete are many different approaches tm numerical integration, and the method of\nchoice depends on the requirement of the application. In some systems and under\ncertun conditions, errors in the solution propagate exponentially and the solution\napproaches infinity. This situation is called imbilim and the method of integration\nis said co have become wareette under these conditions. For example, you might\nmodel the suspension system of a car as damped springs attached to a rigid body. If\nthe springs are made too stiff for the time step, the integrated solution becomes unsta-\nble and quickly heeomes infinite.\n\nOne way to improve stability is co subdivide the time step. A better way wo\nimprove stability isto use a Runge-Kutca method, or something similar, without sub-\ndividing the time step; however, even these methods become unstable ar some point.\n\niff",
      "content_length": 2031,
      "extraction_method": "OCR"
    },
    {
      "page_number": 174,
      "chapter": null,
      "content": "176 Section 2 Mathematics\nThis is why we seck a simple, efficient method that guarantees stability regardless of\n\nthe equation paramecess or the time-step size,\n\nThe Explicit Euler Method\nAs a first example, let's take che initial value problem:\n\nar\nThe analytic solution is:\n\nxz] = xf\"\n\nEvaluating the exponential function for every dara poinc is simple and exact, buc it\nis extremely imeflicient. Most CPUs take about 30 cycles ro evaluate elementary func-\ntions in hardware. If the CPU must emulate this process in software, you're out of luck!\n\nFortunately, there are more efficient ways to evaluate the solution. We can use a\nfinite difference approximation of the first derivacive:\n\nCees! el\nae ge\n\nwhere x, is the solution after a time step Az. Solving for x, we get:\nax\n\nxy = on aa igh Ar.\nait\n\nWhe derivative is evaluated atx, we get:\nx, = xy — Axpdit = x, (1 — Ar),\n\nThis approach is known as the explicit Euler integration methed. With only one\nsubtraction and two multiplies, even a fixed-point processor could handle this method.\n\nAlthough the explicit Euler method is very efficient, it is nor very stable. We can\ndemonstrate this instability wich the following argument: Since che solution is an\nexponential function, it must decay to zero over time, implying thar\n\nx, 3S %,-\nSubstituting and solving gives the relationship:\nbar S 2.\n\nSo if f= 1 and Ar=2, then x, =—x,, and the solution is stable, although not very accu-\nrate. If this condition is not met, x quickly becomes infinite, and the object whose",
      "content_length": 1521,
      "extraction_method": "OCR"
    },
    {
      "page_number": 175,
      "chapter": null,
      "content": "24 Using Implicit Euler Integration for Numerical Stability 178\n\nmotion youre simulating disappears. As mentioned, the Euler method can be made\nmore stable by simply decreasing che ime step, requiring the calculation of more data\npoints. Flowever, if & is made too large, subdivision of the time step may become pro-\nhibitively expensive.\n\nThe Implicit Euler Method\n\nThe method deseribed is an explicit method because it relics solely on previous values\nof the solution to caloulare the derivative. The implicic Euler method, on the other\nhand, evaluates the derivarive ar x; instead of x, (Figure 2.4.1), giving:\n\n= Xp & (be, Ar.\nSolving for x; gives:\n= Sept\n(1 + 4Az)\nSubstituting this into ghe stability condition pives:\nOs br\n\nsaa\n\n‘This is significanr. We've found a simple, efficient method chat is stable, no mat-\nter how large & or Ag get! [Hainer]\n\n(a) (b)\n\nxy HY\n\nng +o\n\nFIGURE 2.4.1. The explicit Euler method evaluaces che derivative at x (a), whereas the\nimplicit Euler method evaluates the derivative ar x, (bh).\n\nLet's look ata more complicated example. Imagine a mass mm is artached to a fixed\nanchor by a spring char gives & Newtons per meter push or pull when the mast ix not\nat its equilibrium position. Let's also assume there is some force thar is negatively pro-\nportional to its velocity by some constant 6, causing the system to lose energy. If we\nset the equilibrium position to be at the origin (x,, = 0), then the differencial equation\nthat describes this motion is:\n\ndx oer fe;\nae ar\n\noi",
      "content_length": 1515,
      "extraction_method": "OCR"
    },
    {
      "page_number": 176,
      "chapter": null,
      "content": "Section 2 Mathematics\n\nsubject co che inicial conditions:\n\nx{0) = x,,\nx(0) = o(0} =o.\n\nSolving for the second derivative, we get:\n\nae = =f)\" x — sa ae bs\nar® at 2a\n\nwhere we've subsrinured @ = (£ and A= ay for simplicity. IF the condition oF >\nAC is met, the solution is: \\\n\nxe) = xye * cos{ eae] [Chow].\n\nThis second-order differential equation can be rewritten as a system of cwo firse-\nonder differential equations, giving:\n\n= 7\n\n= -w'x — Ay,\n\na. | & |B\n\nEvaluating the derivatives at x, and 2, pives:\nx, = Xp) + 0,4,\nVv, = vy — Ox, = Ay,.\nFinally, solving for », gives:\n2, = — eo\" gle\n; 1+AAr+ (core)\n\nwhich is stable for all positive values of & 4, and Az (see Figure 2.4.2).\n\nKi od PR uy\n———\n\nFIGURE 2.4.2. A mass mis attached vo a spring with a constant. The damping is negatively\nproportional to velociry,",
      "content_length": 813,
      "extraction_method": "OCR"
    },
    {
      "page_number": 177,
      "chapter": null,
      "content": "24 Using Implicht Eulor Integration for Numerical Stability 181\n\nInaccuracy\n\nThe implicit Euler method is noc as accurare as its explicit counterpart. Even without\ndamping, the solution slowly loses all irs energy. In most applications, we are more\nconcemed with the effect than its accuracy, so this is usually net a problem, bur it is\nsomething to keep in mined,\n\nFinding Implicit Solutions\n\nFinding an implicit evaluator for x, ix not always easy. For instance, if the spring force\nis proportional to x, instead of x, we get a quadratic relationship for x). For systems in\nwhich it is impossible to solve for x,, numerical root finding such as Newton's method\nmay be required [(Gerald99]. Such cases make an implicic integraror impractical for\nreal-time applications.\n\nConclusion\n\nThe implicit Euler method is definitely something to keep in mind when stability\nbecomes an issue. There are many other types of implicit methods that could suit dif-\nferent meeds. For a more in-depth discussions, see [Gerald99], [Hairer96], and\n[Hairer93}.\n\nReferences\n\n[Chow95] Chow, Tai L., Clauiea! Mechorics, John Wiley & Sons, Inc., 1995.\n[Denick§7] Derrick, William R., and Grossman, Stanley L, Fire Conese i Difer-\nential Equations with Applications, third edition, West Publishing Co., 1987-\n[Gerald99)] Gerald, Curtis FE, and Wheatley, Patrick ©, Applied Numerical! Arsalysis,\nsixth edition, Addison Wesley Longman, Inc., 1999.\n\n[Hairer93) Hatrer, E., Norsett, 5. B, and Wanner, G., Solving Ordinary Differential\nEquations [: Nonstiff Probleme, second edition, Springer-Verlag, 1993.\n\n[Hairer96)] Hairer, E., and Wanner, G., Solving Ordinary Differential Equations LH:\nSaif and Differential-Algebraic Problems, second edition, Springer-Verlag, 1996.",
      "content_length": 1743,
      "extraction_method": "OCR"
    },
    {
      "page_number": 178,
      "chapter": null,
      "content": "2.5\n\nWavelets: Theory and\nCompression\n\nLoic Le Chevalier\n\nWe generally associate wavelets with a compression method. But the word suveders\ncovers atonce a mathematical cheory, a compresion method, and a data analysis cool.\nThis is a powerful paradigm that has many applications.\n\nThe Principle\n\nWhatever the wavelet application (compression, analysis, etc.), the point of departure\nis a group of M values: scalar or vector. From these NV values, we build a cree such as\nthe one shown in Figure 2.5.1, At each level of the cree, we calculate che average of\ntwo values, which becomes the value of the next level, The tree obtained is a binary\nmee with N{N+ 12 nodes, corresponding to the respective averages. One built, this\ntree cam be used to factor che initial values. Nore thar factoring is noe compressing.\nFactoring enables us co keep all the information in reduced form, whereas compres-\nsion causes a loss of information, The basic principle of wavelets is thus a reversible\nprinciple: At any time, we can go back ro the initial values without losing informa:\ntion.\n\nTo the tree that we've built, we add new values on the branches correspondi ng to\nthe difference berween the two extremities of the branch—i.e., che distances that sep\narate two values, linked by one branch and differing by one level. As shown in Figure\n2.5.2, the magnitudes leaving from a rede are opposite, because the average value is\nequidistanc from the two values, (For cxample, the average of 2 and 8 is 5, which is at\na distance of —3 from 2 and of 43 from 8.)\n\nFor the moment, there is no factoring. On the contrary, the scructure has grown\nfrom one vector of NV values co a cree of AYfNe 22 walues for che nodes, plus\n(N+ [2 —I values for the branches! The next step thus consists of choosing a tree\nlevel—ie., a factoring level, , between 1 and dogs. A level is thus composed of node\nvalues and the lower branches that grow from it (see Figure 2.5.3).\n\nOnce the factoring level, p, has been chosen, we obtain the level p compressed\nvalues, with O<pelog.N, by sequentially calculating levels 1 chrough p, inclusive (sce",
      "content_length": 2103,
      "extraction_method": "OCR"
    },
    {
      "page_number": 179,
      "chapter": null,
      "content": "2.5 Wavelets: Theory and Compression 183\n\niF\n—\noes (a, +4,)/2 Se\npane |\nNevalues our, Ze = —'¥ a;\nTh =\na\na (ity y hat) {2\na Nal wf\n\nty\n\nfag, NV levels\n\nFIGURE 2.5.1. Building the wee.\n\na, =(o, +a, )/'2+ta,—a,)/2\na = [at +a,)/2+l4, —2,)/2 |\n—\n\n#, = (a, +4,)/2—a, ,\n\n#,=(u, +4,)/2td,, and\nHay_,-4,,)/2 d,,=(a,—4,)/2\n\n= a\n\nyy.\n\nFIGURE 2.6.2. Calculating distances.\n\ndog 5M\na,\n(4, +4;)/2 +.\nbs oe ,\ncae an wet\n\nFIGURE 2.5.3. Choosing factoring level.",
      "content_length": 446,
      "extraction_method": "OCR"
    },
    {
      "page_number": 180,
      "chapter": null,
      "content": "184\n\nSection? Mathematics\n\ncocficiemt foros\n\n| aj\n\n((2, +2,)/2,¢,,)\n\nCa ran Renan\n\nyy (cm + aty)/ Body 2-4)\n\nLevel I Lewel 2\n(Initial values) (Comprcied values)\n\nFIGURE 2.5.4. Compressed values.\n\nFigure 2.5.4). We thus have a principle that doer nor lose information, the Eimear cost of\nwhich is a function of NV.\n\nOnce factored, we restore the initial values by reversing che operation. This resi-\nnution operation has, itself, a finewr cast in N, It is important w note that to restore the\ninitial values from a level p, we must maintain this level's scale factors as well as all che\ndetail coefficients fom levels 1 through p, inclusive.\n\nAn Example\n\nImagine, for example, a linearly coded image having, to simplify, a resolution of 4 pix-\nes by 4 pixels in 16 shades of gray. The initial values are thus a scalar vector of 16 val-\nwes between O and 15, Figure 2.5.5 shows the tree associated with this image.\n\n‘Thus, if we choose factoring level 3, we keep the couple of scale factors (6, 10)\nand all the detail coefficients from levels 3, 2, 1, and 0, Note that level 0 never has\nscale coefficients: They are all implicitly null.\n\n[fwe now wane co return to the 16 initial values, we calculate the level 2 scale fac-\ntors by adding or subrracting level 3 coefficients, and se on, until we rerun to che\nlewel O Geter, which are the initial valees,\n\nApplications\n\nThe preceding construction principle is exactly the one that is used by image pyra-\nmids for mipmaps, which, in fact, represenc the waveler compression method. These\nwavelets are also called Haar waveles. They are very well suited for eating discrete",
      "content_length": 1617,
      "extraction_method": "OCR"
    },
    {
      "page_number": 181,
      "chapter": null,
      "content": "2.5 Wavelets: Theory and Compression 165\n\nFIGURE 2.5.5. An example cree.\n\nvalues, such as scalar vectors about which we, theoretically, know nothing. Bur many\nother kinds of wavelets are useful for treating continuous or other functions. The the-\nory behind these other wavelets closely follows the previously described principle.\n\nWavelets have many applications. The first and most well known is image com-\nfresion. Compression and decompression by wavelets requires an additional phase,\nhowever, compared with the above principle. The preceding principle is lossless; in\nother words, the entire image can be recomposed precisely from any level. Bue this is\nof no interest to us in compression, so we can secrifice values co lose che least informa-\ntion possible, By thus minimizing error, we obtain very impressive resules. For cxam-\nple, an image of a few hundred kilobytes can be compressed co only a few kilobytes\nwith very little perceptible loss. Simply put, areas of little derail are highly com-\npressed, while those of greater details are less compressed. Visually, chen, the loss of\ninformation is barely perceptible. Figure 2.5.6 is an cxample of a compression rate of\n116: The original image is 6.25MB, compared with 53KB for the compressed image.\n\nAnother well-known application of wavelets is dat analysis, an alternative to\nFourier transforms for aperiodic functions. We can also cite multiresolution produe-\nHon of images or 31) models enabling one to adjust the level of details of an image\n(infinite zoom, etc.) ora 3D model (LOD, subdivision, etc.).",
      "content_length": 1570,
      "extraction_method": "OCR"
    },
    {
      "page_number": 182,
      "chapter": null,
      "content": "FIGURE 2.5.6. An comple oF image compression.\n\nReferences\n\nAn Introdiction to Wirvelers, Institute of Electrical and Electronics Engineers, available\nonline at www.amara_com/TEFEwave/IEEF wavelet. html.\nThe Wavelet Organization meta-sire, available online at wwew.wavelet.org.",
      "content_length": 276,
      "extraction_method": "OCR"
    },
    {
      "page_number": 183,
      "chapter": null,
      "content": "Interactive Simulation of\nWater Surfaces\n\nMique! Gomez\n\nWith ever-increasing computing power, simulating realistic outdoor environments in\nreal time is finally becoming possible. Dynamic water is one ching that can add\ntremendous aesthetic appeal to any ourdoor game scene, This article describes a sim-\nple, efficient approach for simularing realistic wave motion over water surfaces. Using\na central difference approximation of che two-dimensional wave equation, you can\nsimulate the horizontal motion of water with only a few arithmetic operations per\npoint. Briel discussions of other approaches are given as well. Physically based models\nfor buoyancy and drag are also described. Finally, implementation and optimization\nideas for the rendering process are discussed,\n\nThe Wave Equation in Two Dimensions\n\nA water surface can be though of as a tightly stretched clastic membrane in which\ngravity can be ignored, As infinicesimal sections are displaced, their direct neighbors\ncaert linear “spring” forces (surfer tension) to minimize the space between them.\nSince horizontal forces are equalized, particles move in only the z-direction. The ver-\ncal position with respect to time and space can be described with the partial differ-\n\nential equation:\ndz Y oz ds\nSe ee eee\nae ie” ay\"\n\nwhere ¢ is the speed at which waves travel across the surface. If the boundary candi-\ntions are Jomegeneous (ie, the edges don't move up and dewn) and the initial z-veloc-\nity of the surface is zero, the general solution for a square x J. section of warer is:\n\n187",
      "content_length": 1552,
      "extraction_method": "OCR"
    },
    {
      "page_number": 184,
      "chapter": null,
      "content": "1B\n\nSection 2 Mathematics.\n\npsp A. sn =) inl \"coco,\nir 2\nn= 7 a (ex) + (xy)\nThe cocfticients A_, are found by evaluating the integrals:\n\nHee Zip [, fl=.y) sin = sin =\n\nwhere fix, y) is che initial shape of the water surface [Trim0). If the surface is mod-\neled as an evenly spaced grid of z-values (a Acight field), as in Figure 2.6.1, the preced-\ning integrals become diserete and can be evaluated with the Fart Fourier Tamar\n(FFT) algorsein [Press92].\n\n2(x, ye]\n\nP| be\n\nE= A(N-f)\n\n21 N-1\n\nFIGURE 2.6.1. An fx J height field wich WV poinds along each side is used 20 approximaze\nthe water surlace.\n\nWe could approximate a solution by evaluating only the significanc terms of the\nseries, bur even though this approach is straightlorward and stable, ir is ery inefhi-\nclenr. On most CPUs, a single evaluation of a trigonometric function takes around 30\neyeles. Dropping all but the first three modes along x and y requires evaluating nine\nsinusoidal functions per point per time step, which is prohibitively expensive for large\ngtids in interactive applications. This major drawback should motivate us to find a\nmore cfficient numerical solution.\n\nUsing central differences to approximate the partial derivatives gives:\n\nzy = 22) + ak : aha) ee tein + 535 85)\n— fii gel’ sei\nAz? be\n\nThe value 24, is the height of the #, jth grid position at time m. The values =\"j and\n2% are the heights at times #) = % —Arand ¢, = % + Av, respectively. Solving for zy}\ngives:",
      "content_length": 1459,
      "extraction_method": "OCR"
    },
    {
      "page_number": 185,
      "chapter": null,
      "content": "26 Interactive Simulation of Water Surfaces 1688\n\n24 3 rt be\n+i cr n ] dec he =o\nry = i (za, Fy FEF zo) + 2 - re if = jim\n\nThis relationship simply says thar the motion z,, is influenced only by its nearest\nneighbors (Figure 2.6.2). Since the grid spacing is constant, the reciprocal of /* can be\npre-calculated, leaving only multiplies, adds, and subtracts. Furthermore, if edocs not\nvary benween cells, all coefficients can be pre-calculaned, and successive z-values can be\ncalculated with only two multiplies and five adds! (And if you're really cheap, you can\nmake #* = 20A@, climinating the middle term. This approach restricts either ¢ or A,\ndepending on the application.)\n\nAr first glance, it might seem necessary to store three separate grids for the =\nvalues at times ¢), f, and 3; however, if 2°! is replaced with z~/ in place, only ewo\nends are necessary. Ac the end of the pass, the memory pointers to the 2**’ and 2* val-\nues are swapped, Ar the next iteration, che 2\" has become 2\", and 2\"*! has become 2\".\nThis code snippet shows how this space-saving trick can be implemented:\n\ni/precalculate coefficients\n\nconst float A = (e*dtfhp\"(e'dtyny\nconst float B = 2— 45a:\n\nlog 4, 4;\n\nffedges aré unchanged\n\nTor( i=1 3 i4N-1 5 dt }\nfort j=1 3 J<N-1 7 jaa)\n{\n\nffintegratea, replacing z[n-1) with z[n#1] in place\n\nE1[a}(i) = A*¢ zli-1) 03] + 2la+1) fi] + zlagf{j-1) * =lailli+i] }\n+ B*z[i][]] — 2ifi}[i;\n\n/fapply damping coefficients\n\nZI(AN(i] *= dLantjl;\n\nI\n\ni/swap polnters\nSwap z-phata, zi.pbata 4;\n\nZij+t\n\nHl wy Zissj\nijt\n\nFIGURE 2.6.2. The horizontal movement of the point z, is influenced only by its nearest\nneigh boss:",
      "content_length": 1632,
      "extraction_method": "OCR"
    },
    {
      "page_number": 186,
      "chapter": null,
      "content": "7190 Section 2 Mathematics\n\nBoundary Conditions: Islands and Shorelines\n\nin nature, bodies of water are usually not square. Rivers, lakes, and oceans have inreg-\nular shorelines of varying slope, and islands might exist within these bodies of water as\nwell, Ifthe bank is very steep or even vertical, waves reflect off the shoreline with very\nlittle energy loss, whereas if the bank is genely sloped, a wave might have a very weak\nreflection or none at all. If che waves do not come in straight, chey reflect off ar an\nangle,\n\nThese effects ean be simulated by scaling the 2**! value by a local damping coeffi-\ncient, @,; [see the preceding code snippet). A coefficient of 1 allows free movement of\nthe height value without any energy loss, whereas a coefficient of 0 restricts all move-\nment of the water at that location. If these coefficients are distributed and scaled\naccording to the terrain features, waves react to the shoreline more naturally. For\ncxample, if the bank is steep, the damping coefficients should make a quick transition\nFrom 1 (water) to 0 (land). On the other hand, if the bank is gently sloped, the damp-\ning coefficients should make a gradual transition from 1 to 0. In practice, it is usually\nbetter to use damping coefficients thar are slightly less chan 1 in wet cells to produce\na litde energy loss. Otherwise, wave motion continues indefinitely,\n\nImplementation Issues\n\nInstability\nThe previously described integration method is called an expliat method because it\nwees only previous and currenc values of z;; to evaluate 2\"*! IF the condition:\n\ncar\n\n=\n\nha | =\n\nis mot met, the integration method becomes anche and successive z-valucs grow\nexponentially.\n\nAn implicit method, on the other hand, can he used to guarantee stability.\nUnfortunately, finding a solution implicicly involves solving sets of simultaneous\nequations for z\"*'. For more in-depth discussions of implicit integration methods,\nsee [Crerald 99], [Hairer93)], and [Hairer96].\n\nParallel Processing\n\nAlthough some processors have single-instruction, multiple-data (SIMD) instructions\nthat evaluate several floating-point values in parallel, memory alignment requirements\ncan decrease the efficiency {or even prohibit the use) of these instructions for inte-\ngrating a solution. Processors that can operate on four single-precision floating-point\nnumbers in parallel usually require 16-byte alignment, so rows must be padded if Nis\nnot a power of 2. Regardless, some memory accesses are unaligned (Figure 2.6.5).\nEven if che CPU allows unaligned memory accesses, a penaley is usually incurred.",
      "content_length": 2590,
      "extraction_method": "OCR"
    },
    {
      "page_number": 187,
      "chapter": null,
      "content": "26 Interactive Simuletion of Water Surfaces 181\n\nFIGURE 2.6.3. Eves though the rows of the grid are padded to ensure 16-byte alignment,\nsome dara accesics ane not aligned.\n\nInteracting with the Surface\n\nSplashes\n\nSplashes can be creared by instantaneously displacing one or several z-values at a par-\nticular location, As the solution progresses, waves radiate from this location. This con-\ncept illustrates another advantage over explicitly evaluating che general solution: If\nany discontinuity in 2{f) occurs, new values for 4, must be computed with a ciscrete\nFourier transform.\n\nBuoyant Objects\n\nWhat good is water if things can't float on cop if ir? Objects flaar because heir overall\ndensity is less than thar of che surrounding water. The force of buoyancy on an object\nis equal to the weight of the water displaced by thar object. This force is actually in the\ndirection of the pressure gradient, but in most cases, the direction normal to the water\nsutface is appropriate.\n\nIfthe shape of the hull is approximated as a set of discrete points, normals, and\narea patches (Figure 2.6.4), the force of buoyancy can be calculated by performing a\nvolume integral over the submerged portion. The volume of water displaced by asec-\ntien of the hull is:\n\nAV, = SA, (far zs Pine Pitee\n\nwhere 2, i the bilinearly interpolated water height at py (Bilinear interpolation is\nrecommended, since other methods might produce primary or first order discontinu-\nities. It is also probably the most efficient interpolation method far a regular grid.)\nThe buoyant force ac this position is:",
      "content_length": 1578,
      "extraction_method": "OCR"
    },
    {
      "page_number": 188,
      "chapter": null,
      "content": "Section 2 Mathematics\n\nand the torque is simply:\nN,=1, * F,.\n\nwhere ©; is the vector from che center of mass to py. The total force and porque are cal-\nculared by summing the contributions from each hull vertex. Remember also that\nonly the swéemerged portions contribute to the buoyancy.\n\no\n\nFIGURE 2.6.4. The shape of the buoyane object is approximated with a set of poine, p,\ndistributed “evenly” over its surface, Also stored are the unit surface normals, i, and che\nlocal area patches, Ady.\n\nThe number of poincs needed depends on the shape of the object and the level of\naccuracy desired. A cube mighc need around 20 or 30 points, whereas a tree with\nbranches mighe need hundreds of points to behave realistically.\n\nA vector normal to any parameterized, right-hand-oriented, chree-dimensional\nsurface can be calculated with the formula:\n\n39{u;0) Beis)\nae Cen aaE Spa [Davis 1]\n\nIf we think of and y as our paramerers, the water surface can be described by the\nVEcror:\n\nApproximating the first derivatives with central differences gives:\n\naS Eis TZ y-1y\na 1, ————> b\nthe 2h\n\nos F | 0 | Se i+! 7 By i\ndy a a",
      "content_length": 1110,
      "extraction_method": "OCR"
    },
    {
      "page_number": 189,
      "chapter": null,
      "content": "2.6 Interactive Simulation of Water Surfaces 193.\n\nThe normal al the Ath grid location is then:\n\n_ | Sry FE Fa\nn,, =|—- ae  _\n2 an\n\nScaling this vector by 24 does not change its direction, so an equally valid normal is;\na= le. — Eis Ep. ~ jer 2h\n\nwhich must then be socmalized.\nTo keep the object from sliding over the surface like a surfboard, a drag force can\nalso be calculated by summing contributions from each vertex:\n\nE,.. = ear = 3 Bf ce = (v.. +H x nf\nThe velocity term v,,., is the velocity of the hull redarive to the water at x, So if, in\n\naddition to height values, a chree-dimensional velocity is associated with every grid\nlocation (a pecrer eld), the current carries floating objects.\n\nRendering\n\nAll chis theory is preat, bur if you can't see it, what's the poinc? The following are some\nideas on implementing and optimizing the rendering process.\n\nEnvironment Mapping\n\nWhen drawing water, you can use alphe blending to give the appearance of trans-\nparency. In onder to draw alpha-blended triangles properly, however, you must draw\nthe ones farthest from the viewer first, without the help of the 7-buffer. Furthermore,\ndouble blending occurs whenever a triangle is visible chrough another.\n\nIn reality, lighr doesn’t pase straight through water It bends as it poes from one\nindex of refraction to another. Water also reflects light from its su rrourudlings, These\neffects can be achieved with exsironment mapping. Environment mapping a water sur-\nface involves reflecting and refracting rays of light from the eye and intersecting them\nwith an environment map surface to calculate a texture coordinate [Figure 2.6.5].\nEach onangle is then texture mapped with these coordinanes.\n\nT cannot emphasize how incredible refraction mapping leoks if dane well; you\nhave co see it co believe it. With reflection only, water appears too metallic, like liquid\nmercury. See [War2000) for more environment-mapping techniques and related for-\nmulas.\n\nAlthough environment mapping gives stunning visual results, using it on a large\nscale may not be feasible without hardware support due to computation requirements.\nThe results are iM pressive enough, however, ves justify a scaled-down softacure imple-\n\nmentation,",
      "content_length": 2218,
      "extraction_method": "OCR"
    },
    {
      "page_number": 190,
      "chapter": null,
      "content": "184 Section? Mathematics\n\nfenore space\n\nFIGURE 2.6.5. Bouncing rays from the eye (camera) position to the environment map\nBenerars a texture coordinate (x. e) for each verten,\n\nLevel of Detail Management\n\nRendering distant portions of the height field at lower resolutions can give cremen-\ndous speed increases without significantly decreasing visual quality. Care must be\ntaken, however, to ensure char vertex normals along LOD transitions march. Other-\nwise, discontinuities are visible in environment mapping and lighting. For an elegant\nadaptive quadtree approach to terrain LOD management, see [Ulrich2000].\n\nReferences\n\n[Davis#1] Davis, Harry FE, and Snider, Arthur David, fureduction to Vector Anahyis,\nsixth edition. William C. Brown Publishers, 1991,\n\n[Gerald99) Gerald, Curtis FE, and Wheatley, Patrick O., Applied Numerical Analysis,\nsixth edition. Addison Wesley Longman, Inc., 1999.\n\n[Hairer93] Hairer, E., Norsent, $. BR, and Wanner, G., Solving Ordinary Differencial\nEquations {: Nonsilf Problems, second edition, Springer-Verlag, 1993.\n\n[Hairer$6) Hairer, E., and Wanner, G., Solving Ordinary Differential Equations fT:\nSniff and Differensial-Alecéraic Problems, second edition, Springer-Verlag, 1996.\n\n[Press92] Press, William H., Teukolsky, Saul A., Vereerling, William T., and Flannery,\nBrian P, Nesmerieal Recipes in C second edition, The Press Syndicate of the Uni-\nversity of Cambridge, 1992,\n\n[Trim?0] Trim, D.W., Appited Perel Diferennial Equations, PWS-Kent, 1990.\n\n[Uirich2000) Ulrich, Thacher, “Continuous LOD Tensin Meshing Using Adaptive Quad-\ntrees,” Cumann, available online at www.gamasurrs.com/fearures!2000228/\nulrich_OL-him, 2000,\n\n[Watr2000) Wart, Alan, 3D Comparer Graphic, chird edition Addison-Wesley, 2000.",
      "content_length": 1746,
      "extraction_method": "OCR"
    },
    {
      "page_number": 191,
      "chapter": null,
      "content": "2.7\n\nQuaternions for Game\nProgramming\n\nJan Svarovsky\n\nQuaternions are useful for representing and processing 3D rotations of points, Appli-\ncations include skeletal animation, inverse kinematics, and, generally, any 3D physics\nand graphics engine. This artiele is organized by first explaining enough abour quater-\nnions for you to be able to use them in your 3D game. Ir then gradually reaches\ndeeper into their mathematical basis.\n\nTreat Quaternions as Matrix Replacements\n\nYou can use quaremions in a game as a straight drop-in réplacemenc for rotation\nmatrices. They can describe any rotation around any axis in 3D space. They take less\nspace, four numbers rather than nine, and many operations such as multiplication are\ncheaper. Some operations such as interpolation berween quaternions are also more\nvisually pleasing. Ar points when you need a matrix (such as to rorare a vector), yOu\ncan easily convert quaternions to rotation matrixes and back again.\n\nff a black-box quaternion type that can replace 3x3 matrices\nclass Quaternion\n{\nprivate:\n\nTloat x, ¥, Z, wif! These will be explained later\npualic:\n\nQueternion Inverse(] canst:\nhi\n\nGuaternian quaternion_from_matrix(MateLxaa mat }:\nMatrixd3 matrix _from_quaternion(Quaternion &quat):\nQuaternion interpolate(duaternion 4a, Quaternion &b, float b_amt);\nQuaternion operator *(duaternion &a, Guaternion 4b):\n\nSome other functions exist chat would be more difficult on produce for matrices:\n\nVectord Quaternion: :AxisOffotation(}) sonst;\nTloat Guaternion::AngledfRotation() const;\nff rotation that will get you fram vo to wi\nQuaternion AotationArc(Vectors vO, Vectors v1):\n\n195",
      "content_length": 1633,
      "extraction_method": "OCR"
    },
    {
      "page_number": 192,
      "chapter": null,
      "content": "A typical use of quaternions is to store all your matrices (such as orientations of\nbones for an animating character) as quaternions. All the matrix multiplicarions are\nreplaced with quaternion calculations, and only ac the end of the pipeline, where vec-\ntors must be rotated into world space or onto the screen, de you turn the quaternions\ninto matrices.\n\nThree-by-chree retation matrices can be represenced directly by quaternions. A\nquatermion and a translation vector can represent 4 * 4 matrices that encode a rota-\ntion and cranslation,\n\nWhy Not Just Use Euler Angles?\n\nQuaternions do not suffer from gimbal lock. With a three-angle (roll, pitch, yaw) sys-\ntem, there are always certain orientations in which there is no simple change to the\nthree values to represent a simple local rotation, You often sce this roration having\n“pitched up\" 90 degrees when you are trying wo specify a local yaw left or right.\n\nWhat Do X, Y, Z, and W Represent?\n\nThe four numbers in the quaternion, often denoted (x, yz, w), have some physical\nsignificance, If we consider all rotation matrixes to represent a rotation of an angle @\nabout an axis. 4 (A), Fy, 2), shown in Figure 2.7.1, the quaternion Q will be:\n\nFIGURE 2.7.1. Rotation of angle 6 abour axis,",
      "content_length": 1248,
      "extraction_method": "OCR"
    },
    {
      "page_number": 193,
      "chapter": null,
      "content": "27 Quatermions for Game Programming 187\n\nQ=(GX_ st Kp 12, o)\n\nsasin (f/f 2}\ncao (8/2)\n\n‘This leads to ovo things: It is easy CO extract the angle of rotation (see the method\nmentioned previously) as being twice the inverse cosine of the w term. It is similarly\neasy to extract the axis of rotation.\n\nNote that cwo quaternions represent each rotation matrix. Ifa general rotation is\ndefined by an axis and an angle, each rotation will have an equivalent with the oppo-\nsite angle and the opposite axis of rotation. In quaternion terms, you can make the Os\nof the two quatcrnions different by 2x (or 360 degrees). Since the terms are in (8 / 2),\nthis adds m inside the sin and cos terms:\n\nrent (Of + 70) = —rrn (oe)\ncos ff +7) = oer ee)\n\nThis can lead to problems in interpolation, where two quite numerically different\nquaternions represent very similar rotations. ‘The fixes for this “gotcha” can be seen as\nextra tests inside the implementation of any quaternion library.\n\nFrom What Math Is This Derived?\n\nThe quaternions we use here are a subset of general quatemions. General quaternions\nare an extension of complex numbers. Complex numbers are defined in terms of i, the\nsquare root of —] (which cannot be represented by a “conventional” number):\n\ni™p=—f\n\nAlthough # is different from “real” numbers, we can include it in expressions like\nany other variable, with the magic property being thar its square is —1. Any multiple\nof fand areal number must be left in terms of %, making a “complex” number (a + bi}\nfor some g and #. For example, multiplication of pwo complex numbers:\n\n(a+ bi) \"fe + dt) = ate + adi + etl + bd\n\n=e — bal + fat + thle\n\nQuaternions extend the concept of a square root of -1 to have three square POOLS\nof -1, being £ j, and &\n\n#*g=-]\njtje-l\nk*k=—]\n\nMultiplication of pairs of these clements together behaves much like the cross\nproducts of the usual three axes in 31D space:\n\ne*joj*i=k\n\nF “b=—6 “I =f",
      "content_length": 1928,
      "extraction_method": "OCR"
    },
    {
      "page_number": 194,
      "chapter": null,
      "content": "Section 2 Mathematics\n\nk* peop *k =}\nWhar this all means is that quaternions are defined, similazly to complex mum-\nbers, in terms of a real number and an 4 jf, and #& term. Because #, 7, and & behave so\n\nmuch like axes, quatermions are sometimes written as a vector (here v) amd a sealar (5)\nor asa vector of their four ceems.\n\ngewexityjeck\ngq = ise] where s = wand p = /x y zi\ngz-ixyew! note scalar “se” at the end\nAddition and muldplication of quaternions are defined in the obvious way, Much\nlike multiplication of “normal” complex numbers, the result of multiplication is\nanother quaternion:\n192 = (t)+x;1 +7 J +2, A) fey + xt +a} + = &)\n= fy €y— xp Xz— Fy Fr — Ey 5z) +\n(Vp Zp — yp Sy + Cy Xp t Cp Kah et\n(By Xp — 5) p+ Cy a + Cp Yad f+\n(Ky ¥e— Xp Fe + fy Zy+ cy a) ik\nA lot of symmetry can be seen in this example, which is made more obvious in\nthe condensed notation:\n\nGr Fx = (ty + wy) (iz + Uy)\n\nwhere 2+ fis the dot product and a # is the cross product.\nA few other definitions are useful. The norm of a tjuaternion is:\n\nNig) = 22 + phe t+ we?\nThe conjugate of a quaternion can be thought of in ewo ways:\n\nq’ = x—y— wf\ni\nThe multiplicative inverse of the quaternion:\nHg = g* / Nig)\nThe subset of quarernions we use for representing rotarions is the sec of unit\n\nquaternions, where [gl = J, or x? + y? + 2° + w? = J2, These have the property that\ntheir inverse is equal to their conjugate.\n\nHow Do Quaternions Represent Rotations?\n\nThe rotation of a vector P [x y x] by the unit quaternion gis done by creating the\n“pure” quaternion p and the conjugate of g:",
      "content_length": 1568,
      "extraction_method": "OCR"
    },
    {
      "page_number": 195,
      "chapter": null,
      "content": "2.7 Quatemions for Game Programming 186\n\npaxieyjrzé pure means ne scalar term, w= 0\nKori?) =g pq\"\n\nThere is some derivation to do to see that this works, Rather than bulldozing\nthrough it here, we summarize: You consider rotaring the vector P by an angle @ about\nan axis. A. Using geometry, you can work through che math, expanding everything out\nuntil eventually some terms in co?(@) and sir(8) cum up. These can be rurned inte\neen 28) and sin(20) terms, and very soon you end up with a formula thar looks a lot\nlike the quaternion multiplication worked through previously [Glassner0]_\n\nThis representation of rotations can be used to convert the quatemnion inte a rota-\nHon matric A retion matrix can be seen as che rotation of the unit matrix by a quater-\nnion, where the unit 3% 3 matrix is che three vectors (1, 0, 0), (0, 1, 0), and (0,0, 1,\nA4 4 romoon marrix is equivalence to the 3 * 3 case bur with an cota row and col-\numn appended where the extra terms are 0, exeept for the bottom right, which is 1.\n\nReferences\n\n[Glassner90)] Glassner et al, Graphics Genus, Academic Press, 1990.\n[Downs] Downs, Laura, “Using Quaternians to Represent Rocation,” Available\nonline at heep://hetp.cs.berkeley.edu/-laura/es] 84/quar/quarernion. html.",
      "content_length": 1243,
      "extraction_method": "OCR"
    },
    {
      "page_number": 196,
      "chapter": null,
      "content": "2.8\n\nMatrix-Quaternion\nConversions\n\nJason Shanke!\n\nQuarerions are convenient for representing 3D rotations. Quaternion multiplica-\ntion is faster than matrix multiplication, and quaternion interpolation generates\nsmooth animations. But matrices have their uses, too. In particular, matrices are\npreferable to quiatermions for performing vertex transformation. In addition, mast 3D\nAPIs store their rotations in matrix form.\n\nThis article demonstrates quaternion-to-matrix and Matrie-to-guatemion eon-\nversions. We use both four-dimensional veeter and veceor!scalar nomenclature to rep-\nresent quaternions. Thar is:\n\nq = [epee] = [av]\n\nwhere v = (xz) isa three-dimensional vector and wis a scalar.\nWe alto use , g and g” to designate quaternions. q' and g” are distiner from q\nand should not be confused with the first- and second-order derivatives of g.\n\nQuaternion Rotations\n\nLet gq = [ev] = [oos(8),usin(@)) be a quaternion where u is a unit vector. Let qely'y']\nbe a quaternion (nor necessarily unit) representing a pointe in three-dimensional\nhomogeneous space.\n\nThe operation gq”! rotates about axis u by 20. Proof is provided by [Shoe-\nmale 4],\n\nQuaternion-to-Matrix Conversion\n\nTo convert the quaternion g into an equivalent rotation mamrix, we must express\nqq q°! as a matrix operation.",
      "content_length": 1294,
      "extraction_method": "OCR"
    },
    {
      "page_number": 197,
      "chapter": null,
      "content": "2.6 Matrix-Quaternion Conversions\n\nQuarerion multiplication takes the form:\nqo = Leaw][rersw) = [ae !—wev', vw & ree + er ¥]\nwhere @ is the vector cross product and © is the vector dot product,\nThis expands to [x Uy\" 3a] such thar:\nXm ye’ — ay! + ee + ce\"\nyo = ay — xa + uy + pte’\n=z\" = xy — yn + geht + nr’\nwe = fee — sae\" — yp = ee\"\n\n‘This expansion can be expressed as a matrix multiplication:\n\nPag == ¥ xix\noH gots AN id\n=F x w sie\n\n<x —F EF wir\n\nThe multiplication g” = gq expands to:\nxs ypEe-—zyswhy ecw\nysek—xE + wy + ype\nEf =K)—yh + wes zy\nnr” = ww —xe—yy— EE\n\nwoof —y xix\nPe ah ay Pte\n= ft\n\nyocx ow zfs of\n\n—— oF =x a\nPor a quaternion g = [wv], gq! = [1 —¥] Mig).\nJVilg) = reste tet = 1 for unit (ustemions, 50 q! = [uty—¥]_\nSubstituting g = q7! in &, yields:\n\ni es\n\nLit toot) ee pad\nlek\n\nT",
      "content_length": 799,
      "extraction_method": "OCR"
    },
    {
      "page_number": 198,
      "chapter": null,
      "content": "202 Section 2 Mathematics\n\nThe matrix equivalent of the operation gg! can be found by concatenating L,\nancl Rare\nMeL; -\nw—oy x | [we yx\n\nS wex y zou xy\njx £ yx wr\n\n—x—y-zeur| |x y zy\nweet yet Pipe) Dey exe) 0\n2(xyeme) wexteptig? Dye wer) o\n2Gez—un) — Dipeeue) wettest o\n0 0 0 Pa ae\n\nx7 ep 7+e 2+ 1, so Mf simplifies to:\n\nI-2(y*+27) 2bqewe) 2 my saz)\n2ixytwz) 127427) 2lyo—nex)\n2ixe—wy) = yee wc) 1—2le*+y*)\n\nth o 0\n\ni — si —\n\nMatrix-to-Quaternion Conversion\n\nThe relationship between a rotation matrix and the components of its corresponding\nquatemuion is given as fin the previous statements.\nProm J, we can derive the following six relations:\n\n1. Mya + Mz = xy\n2 My + My, = dyz\n3, Mya + My) = dex\n4. Mj, = My, = 40x\n3. Ma) = M3 = day\n6, Af. — My, = 4we\n\nFrom these relations, ir is clear chat if you know one component, yOu can com-\npute the other three by division. Since any but not all of che components can be zero,\nwe want ta determine which component has the prearest absolute value and use ir to\ncalculate the other components. The largest component of a unit quaternion has an\nabsolure value of at lease 4.\n\nSolving for Ww\n\nThe trace of a matrix is che sum of the diagonal components. ‘To determine |id, we\nstart by calculating the mace of che matrix JM. For the manrix M, the trace is:",
      "content_length": 1296,
      "extraction_method": "OCR"
    },
    {
      "page_number": 199,
      "chapter": null,
      "content": "2.8 Matrix-Quatemion Conversions 203\n\nTr=4- ditty *ex7) = all = (x+y tee\" })\n\nRecall that a unit quatemion q = [w,v] = [cos(6),v'sin(0)] where v'= (x72) isa\nunit vector, We can therefore express the trace of Af as;\n\nTr = 4(1 — (x\"*+y\"*+27)sin(6))\n\nSince (xlyiz) is a unit vector, x@+y7+27 = 1,\nThe trace of M reduces to:\n\nTr = 4(1 —sin*(0)) = 4e0s\"(B) = 47\n\nor:\n| = Tr?/2\nSo, if Tr 1, we plug dn = +2Tr'* into cquations 4, 5, and 6 and solve for x »\nand =:\n\nx= (May —Mgs)(2Tr!\"?\nye Wa, — AM, 3)/2Te\"?\n\nNote that it doesn't mater whether we use the positive or negative root of Tr as\nthe basis for ew, since q and —g represent identical rotations.\n\nSolving for X, Yorz\n\nIf |u| < %4, we can determine which of the remaining componencs is the largest by\nexamining the first three values along the diagonal of Mf. Suppose M,, > Mf, ,. This\nexpands te:\n\n1—2x*— 22? > 1] —3y?- 22?\nSimplifying, we get:\n\n—2x* > —ly*\nOr:\n\ned < [71\n\nSimilar arithmeric applies to other comparisons berween the diagonals. So, the\nlargest component of the vector (Af, ,, Ady2, My3) corresponds to the largest value of\nthe vector (xz.\n\nOnce we have the largest component of (Mf), Ma ;, 4,4). we suberact the other\ntwo elements, and the equation reduces co a single teem. For example, assume M2 is\nthe largest term:",
      "content_length": 1285,
      "extraction_method": "OCR"
    },
    {
      "page_number": 200,
      "chapter": null,
      "content": "204 Section2 Mathematics\n\nya tls — My = My, + 1)'\"12\nIn general,\n\nAs with w, ic doesn't mamer which root we use. Once we have a suitable ¥,, We can\nsolve for y;, vand w by substitution:\n\nv= UM, + M4)\n\nv,= (My + M,i(4y)\n\naw = (My = Addy)\n\nFor the calculation of w from equation 4, 5, or 6, 4, and & must be in sequential\nonder, That is, f = 1 + (7963) and & = 1+(7903).\n\nReferences\n\n[Shomaket!4] Shoemake, K., Quazernfons, available online at fips/fftp.cis.upenn.edu/\npub) praphics/shoemake/quaturt.ps.2, May 1994.\n\n[Eberly99] Eberly, David, Quarernion Algebra anal Calculer, available online at www.\nmagic-software.com/sre/praphics/quar/quat.pdf, July 1999.",
      "content_length": 657,
      "extraction_method": "OCR"
    },
    {
      "page_number": 201,
      "chapter": null,
      "content": "2.9\n\ninterpolating Quaternions\n\nJason Shanke!\n\nQuatemions are four-dimensional extensions of complex numbers. (See “Qhuater-\nnions for Game Programming” in this book for a discussion of quatemions and\nquaternion mathematics.) This article presents four techniques (Lerp, slerp, squad,\nand spline) for interpolating between pairs or sequences of quaternions. The actual\nderivations of each of these techniques are detailed ar the end of the article.\n\nQuaternion Calculus\n\nBefore getting into quaternion interpolation, we need to define some calculus furc-\ntions of quaternions.\n\nLet g@ = cos(@) + vsin() bea unit quaternion (¥ is a three-dimensional unit\nVector).\n\nEuler's identity for complex sumbers applies to quanermions:\nq = cos(@) + vsin(@) = exp{v8)\n\nFrom this identity, we can define the power function for quaternions:\nq = [cos(@) + vsin(6)]* = exp(ve8) = costs) + vsin(:6)\n\nWe can also express the logarithm of a quarernion using this identity:\nlop(g) = log(exp(vé)) = vé\n\nWe can express the derivative of gf” as:\n(99 = g'log(a)\n\nApplying the chain cule, we cam express che derivarive of ge:\n(ge) =F '(elg\"log(g)\n\nApplying the chain rule for functions of ewe independent variables, we can\nexpress the derivative of oft}! (¢ omitted for clarity}:",
      "content_length": 1254,
      "extraction_method": "OCR"
    },
    {
      "page_number": 202,
      "chapter": null,
      "content": "206 Section 2? Mathematics\n\nig) = fal logig) + gfg\n\nQuaternion Interpolation\n\nSince quaternions can be used to represent 3D) rotations, we can use four-dimensional\nvector interpelation techniques to gencrate smooth 3D animations.\n\nLet gy and gq, be quarernions. The general formula for interpolation between q,\nand 7, is given as:\n\ngle) = folégy + fildg, (Sr 1)\nwhere fi(f) and /[(2) are scalar funetions such that:\n\nflO) = 1\nfll) = 0\nAt0) = 0\nAi) = 1\n\nLinear Interpolation\nLinear interpolation is given as:\n\nlerp(tigg.g) = (1 — egy + gy = lg, — go) + Go\n\nLinear interpolation does not preserve magnitude, so it is importance to normalize\nthe resule if you're using it as a rotation.\n\nLinear interpolation is fast, bur it does mot generate smooth animation. This\nmeans thar che animation speeds up and slows down over the course of the interpola-\ntion, even if you vary t at a constant rate. Although this variation in speed might be\nacceptable for some applications, it is not ideal. To achieve smooth animation between\nquaremions, we must we spherical linear interpolation.\n\nSpherical Linear Interpolation\n\nJust as three-dimensional unit vectors define points on a sphere, unit quarermions\n\ndefine points on a four-dimensional hypersphere. Smooth animation is achieved by\n\ninterpolating values along the great arc connecting the two points (see Figure 2.9.1).\nSpherical linear interpolation (slerp) is given ax\n\nslerp(rigy.gy) = [qysin(@(l — r))+q,sin(Br)]/sin (8)\nwhere 8 is the angle between q, and 4).\n\nWe can find © by treating q, and q, as four-dimensional vectors and calcularing\n\nthe dot product:\nFoF, = XX; + uM + Shy + Wye, = costB)",
      "content_length": 1643,
      "extraction_method": "OCR"
    },
    {
      "page_number": 203,
      "chapter": null,
      "content": "FIGURE 2.9.1. Spherical lincar interpolation.\n\nUnlike lerp, slerp preserves magninude, so there is no need to normalize the\nresult.\n\nIf gag) <0, then @ > 1/2. Since g and <9 represent the same rotation, it is best.to\ninvert g org, in this case, minimizing the angular distance the interpolation has to\nfollow. This inversion reduces unnecessary spinning over the course of the interpola-\ncicen.\n\nTF |gja\"47)| is clase to 1, we fall back to lerp, since sin(8) approaches 0 as |go*q,/\napproaches 1.\n\nSee Derivacion 2.9.1 for a derivation of slerp,\n\nSpherical linear interpolation can alen be expresed as a power function of gy\nand fj:\n\nslerp(tgpeg.) = golqy gy)\nFrom this, we can express the derivative (slerp') as:\n\nalerp (t3y.q)) = dolgy 'y) loglen \\qy)\n\nThe power form of slerp and ins denvative are used in denving spline interpola-\ntion, See Derivation 2.9.2 for a derivation of the power form of slerp.\n\nSpherical Cubic Interpolation\n\nslerp produces smooth animations, but it always follows a great arc connecting ro\nquaternions. Just like using straight lines to connect a series of points, using slerp to\ninterpolate through a series of quaternions produces a jaeged path. In practice, chis\nmeans that your animations change directions abrupdly at the control poine. To\nsmoothly interpolate through a series of quaternions, use splines (see Figure 2.9.2).",
      "content_length": 1361,
      "extraction_method": "OCR"
    },
    {
      "page_number": 204,
      "chapter": null,
      "content": "208 Section? Mathematics\n\nLinear Interpolation\n3Hore8e-0-e -=------- §pline interpolation\n\nFIGURE 2.9.2. Linear vx. spline In rerpolacinn.\n\nThe basis for spline interpolation is spherical cubic interpolation, or squad:\nsquad(r:p.¢.4.0) = slerp(2e(1 — ):slerp(s-¢.¢),slerp(ica, b))\n\nThe animation from p to g does not follow the great arc connecting p and g but\ncurves toward the are connecting « and 5.\n\nIt is common for sleep implementations wo invert ane of the input quaternions\nwhen the angle between the two exceeds 90 degrees. Although it is cruc that q and\n—q tepresent the same rotation, slerp{mp.q) does mot produce the same result as\nslerp(p.q). Since the control points a and # are chosen to work with p and g, not —p\n\nor —q, it is best not co invert the input quaternions in the version of sleep used with\nsquad.\nSpline Interpolation\n\nLet [fpete Pal ino nt) be Sequences of N quaternions.\n\nLer $42) = squad(tigq deste)\n\n‘To generate a sequence of smooth interpolations, {,.6,} is given as:\na, = 8, = quexpl—lloglg, “gaa) + loplg. qa.) 4]\n\nSee Denvation 2.9.3 fora derivation of spline interpolation.\n\nSample Code\n\nThe sample code on the CD that accompanies this book provides implementations of\nlerp, slerp, squad, and spline interpolation as well as quaternion exponential and log-\nanthim functions.",
      "content_length": 1312,
      "extraction_method": "OCR"
    },
    {
      "page_number": 205,
      "chapter": null,
      "content": "29 Interpolating Quatemions 209\n\nDerivation 2.9.1; Deriving Slerp\n\nslerp preserves magnitude, so slerping between unit quaternions always produces a\nunit quaternion, Given the basic ineerpolation function:\n\nqel=foltge + flag,\nwe want to show thac if we conscrain gle) so that AMigll) = 1, we gee:\n\nAl) = sin(8(1 = )/sin(8)\n\nile) = sin(Be)/sin (8)\n\nTo clarify che notation, the time-dependene variable has been omitted in the fol-\nlowing (q = gfe), fo= 60). ete).\n\nLet gs [xt + yf + hs we] = ge + fig = slerp(t;4,.9))\nLet g = ens (g.0q)\n\nSince g is a unit quarernion, x+y°+27+n7\"=1. Expanding 2°, y*, 2° and x gives:\nss Ofte + fix)\" = (fox)? + folie + (fix)?\ny= (foro + for)? = Cfare)* + 2fvfirar + Ge?\n\nzs (fot + fei)\" = (foto)? + Bafizus + (fiz, }? 3\nie (foto + furl = (fomry)* + afi Mots + (Aw)\n\nAdding these equations together gives:\nfu +2 fofileox t+ yoy 402) +m Qe +f? = fo +2 oh go-gi +h? = |\n\nWe can express this 24 a matrix multiplication:\n\nea\n\nwhere ¢= gy\"q, = cos(8).\nThe manrix JW can be ee bor\n\neg FAs met da\nM=)siaj3 3p\n\n= f\" Mf =1\n\narya Roe ed\n= BT\nie | 2n 2/3 | = RcR\n\na\n\nLeto = 42 RE\n\nw= | (l+)'\" au 2\n0 ale | — TaD | nA\n\nMultiplying this out gives us:\n\na= [C+ f2+22) 2.18 — G2 — 2427/2]\n\nFrom here on, we need to show the time-dependent variable. u(¢) is a ewo-dimen-\nsional unit vector, so it can be written as:",
      "content_length": 1329,
      "extraction_method": "OCR"
    },
    {
      "page_number": 206,
      "chapter": null,
      "content": "210\n\nSection2 Mathematics\n\nule) = [cos{eor), sin(tar))\n\nwhen:\n\ncoset) = (Fle + H(O)(2 + 29/2\nsin(ens) = (4(8 — f(O)(2 — Be) \"V2\n\nLet A= (2 4 2e)\"979, B- (2 —20}\"/2\n\nMultiplying cos(tae) by BIAB and sin(wr) by ALAS yields:\n\nAl®) + £8 = Boos(en/AB\nAl) — Alf = Asin()/AB\n\nSolving for 6 and f yields:\n\nAn) = [Boos(an) — Asin(oe)]/2A8\nile) = [Boos(ae) + Asin(me))/2A8\n\n248 = (1 — 2)\"\" = (1 — cos{O))\"? = sinf)\nA748 = 1, so A = cos(yf) and # = sin(yf) for some phase angle w.\n\n‘There are owo values of y thar satisfy A and 8, Wp and w,. Given this, we can\n\nrewrite jf and jf}:\n\nJolt) = [sin(yfghcos( one) — ons ( yt, )sin(oae) |/sin(®)\nJil) = [sin(y,)cos(enr) + cos(y, )sin (eae) } ‘sin (®)\n\nRecall the trigonometric identities:\nsin(ajcos(£) + sin(éjons(a) = sin(ae+6)\nsin(a)cos(2) = sin(@)cos(a) = sin(a—6)\n\nSo, we have:\n\nfle = sini, — ce)/sin(Q)\n\nfilo = sin(y, » cor)/sin(8)\n\n(siven the boundary constraings on f, and £, we can solve for y,, w, and oo:\nWO) = sin(y,)sin(®) = 13 y, - 6\n\nfi(0) = sinfy,)/sin(@) = 0 y, =0\n\nJoU1) = sinty, — 03)/sin(8) - 0 w= yw, = 8\nSo, WE Can rewrite f, and fj again:\n\nJl) = sin(BC1 — A)isin(8)\nult) = sin(Oe/sin(Q)\n\nDerivation 2.9.2: Deriving the Power Form of Slerp\n2 _———_—_————— ry\n\nStart with the definition of slerp:",
      "content_length": 1249,
      "extraction_method": "OCR"
    },
    {
      "page_number": 207,
      "chapter": null,
      "content": "29 Interpolating Quaternions 217\n\nsherp(Fsdeocgy) = [gosin(@(l —¢)) + qysin (8 #)]/sin(8)\ndp is a unit quaternion (as is g,), 50\n\nGut = 1\n\nFrom this, we can rewrite a, as:\n\nhh © Fogo th\n\nLet's expand gly):\n\ngo 1 = [oh + Vo*¥ ne MOY) + HY) — A1¥0]\n\nNotice that the scalar part of q37!qy = 41, + Votw,- This is the same as the vector\ndot product of g, and g,, which is the same as the cosine of the angle between g, and\nFis a.\n\nSince qo 'q, isa unit quaternion and we know thar its sealar part is cos{8), we can\nrewrite gy gy asc\n\n4a 4) = cos(@) + usin(8)\n\nwhere w is a wnit vector,\nChay, so now we have:\n\n) = qolcor(8)+usin(6))\nIfwe plug this into the slerp formula above, we get:\nslerp(tiqyg)) = [qpsin(O(1 — 4)) + qolcos(@) + usin(@))sin(8 4))]/sin(8)\nFrom the trigonometric identity, we know char:\nqosin (O(1 — 4) = qyflsin(@)cos(8y) = ons(8)sin (64)\nSubstinuting this inte slerp and simplifying gives us:\nslerpltigoafi) = qyloos(Gr) +usin (Os)\nFrom the power function for quatermmions, we can rewrite this as:\nslerp(ia.q)) = qyleos(B)+usin(8))*\nAh, but cos(@) + usin(@) = g9\"9,, so one more rewrite yields:\n\nslemplriqut)) = qalge qi)’\n\nDerivation 2.9.3: Deriving Spline Interpolation\n\nLet (2,0) be a sequence of quaternions,",
      "content_length": 1227,
      "extraction_method": "OCR"
    },
    {
      "page_number": 208,
      "chapter": null,
      "content": "212 Section 2 Mathematics\n\n‘To derive spline interpolation, we want to find ja.) such that the derivatives of\nS.{@) at the conerol points: (0 and t£1) are continuous. In other words, §.\"(0) =\n5.2 (1) for all 7.\n\n‘To do this, we first have to express the derivative of squad.\n\nLet Of = slerp(s3p.q). V = slerp(r:2.6), W= UV\nGiven the power form of slerp, we can rewrite squad:\nsquad(r:p,4.2,6) — ULF Yyell-d Lr eli-0\n\n‘The derivatives of U7, Vand Ware:\n\nUO\" = plp'g)'log(p\"'g) = Ulog(p-'g)\nV= ale 46)'log(a'b) = Vogtaa!)\n= 'Y'- oy\nApplying the product rule, we can express the derivative of squad:\nsquad (rp.g.¢.6) « UW)\" + Ue\nwhere [TH ]\" = (2-4 W2\"“Joe( 1) + 21-3\nWhew. Luckily for us, we only need to calculate squad’ for e-0 and r=1:\n\nLi(0) = p\nTiO) = 2\nWO) = p's\n\nC(O) = plog(p-'g)\n\n[Wet )'(0) = 2log(p-tz)\n\nsquad'(0;9,9.2.6) = p[log(#*g) + 2log(p-\"a)]\nCA) = ¢\n\nVil) «6\n\nWL) = g's\n\nOM) = glogip-'g)\n\n[We#!—87'(1) = —2log(g 4)\nsquad'(1ip,9,4,6) = g[log(p-'g) — 2log(g-'4)]\n\nPlugging in S'_,(1) = 5\\(0) gives:\nfalloglg. yg.) — 2logly,\"'é,)) = g,[log(g.\"g..1) + Zlog(g.',)]\n\nThis gives us one equation and ovo unknowns (a, and 4,). The only constraint\nwe have so far is that chis function must pass through all che control points and have\na continuous derivative. We musa select che value of the derivative at the control\npoints ourselves. A reasonable value to select for che derivative aca control parint is the\naverage of the tangent values of the nwo functions:\n\nSell) = 9,7, = §°,(0) where",
      "content_length": 1495,
      "extraction_method": "OCR"
    },
    {
      "page_number": 209,
      "chapter": null,
      "content": "29 Interpolating Quaternions 213\nel re a re i a ee\n\n7, > Llogig,-‘ga.1) + log(g,y\"'g.)]/2\n\nSo now we have two equations:\n\nqullogtg,.-'g,) — Zlog(g.'5,)] = q,lloglg. tg,.1) + logtg. 1g.) !2\nGullogtg.‘dy.1) + Zlogtq.*a,)] = g,[log(g\"g,,;) + logig, 77 q.1/2\n\nSolving for a, and &,-\n7, — b, — qoexp[(loglg, ;—'g,) at log(q. daar]\nFor a unit quaternion ¢ = [s¥]:\n\nq=q'=([5-)\n(pgi\" = q\"p\"\nlog(qé*} = —log(g)\n\nFrom these rules, we can say:\n\nloglg. 1 qa) =—log(lg,*g.)\"\") = -logig, *g,-1)\nPlugging this inta the equation for {a_,6,} yields:\na, = 6, = qexp|—(logtg. ge) + logig. ge.) V4]",
      "content_length": 578,
      "extraction_method": "OCR"
    },
    {
      "page_number": 210,
      "chapter": null,
      "content": "2.10\n\nThe Shortest Arc Quaternion\n\nStan Melax\n\nThis article shows a short routine called Astationare(). Given two vectors vy and pv,\nthis function returns a quaternion g where g*yg==»,. The implementation is fairly\noptimal and avoids a common numerical instability picfall.\n\nMotivation\nmee ee eee ee\n\nYou might be wondering where you would ever want 00 use such a function. Consider\na guided missile in your video game. This is an object chat uses orientation (3D0F),\neven though it is only the forward direction (2DOF) of this radial-symmetric object\nthat is important for its Al. As is the case for all rigid bodies, a quaternion g is needed\nto reoment this object from its current direction v, to the direction we want it to be\ngoing v,. Although we can choose from an infinite number of axes of rocation, it is\nbest to choose the obvious axis of rotation that minimizes the (arch angle af rearienta-\ntion—thac is, the obvious axis that is perpendicular ta both vectors. This routine is\nalso useful for implementing a “virtual trackball” for spinning objects with che mouse\n{as in a VRML viewer). The SpinLogo demo program included on the CD that\naccompanies this book uses RotationArc() co implement this feacure.\n\nNumerical Instability\n\nThis algorithm could easily be done by raking the normalized cross product to get an\naxis of rotation and then taking the acas{) of the dor product tx pet the angle\nbetween the vectors. This axis and angle would be fed into che constructor of a\nquaternion. However, that is not a good solution, because as the vectors 2 and », get\nclose together, the cross product (being propartional to the sin of che angle between\nthe two vectors) becomes small and potentially unstable when we wy to normalize it\n(see Figure 2.10.1). Deriving the angle can also cause grief. It is possible that taking\nthe dot product of nwo unit length vectors that are parallel can result in a small over-\nflow (greater than 1). ‘This can be problematic when deriving the angle. Try executing\nacos(7.00000001). In these cases, using the standard quarernion constructor char",
      "content_length": 2087,
      "extraction_method": "OCR"
    },
    {
      "page_number": 211,
      "chapter": null,
      "content": "2.10 The Shortest Arc Quaternion 215\n\nV% Vi\nle sv\n\nFIGURE 2.10.1. Cross product shrinks as vectors converge.\n\naccepts an axis and an angle is mot appropriace. The solution is to generate the quater-\nnon in a more direct manner.\n\nThis problem first hit us during the development of the guided missiles for the\nvideo game MDK2 [Bioware0O). This is not an obscure problem that showed up only\nin our development. It has been noticed by many others and could happen co you.\nReal-Time Rendering [Moller99] briefly mentions the subject. This article provides a\nmore thorough explanation and provides code to add to the Gane Programming Gems\nmath library (or to your own quaternion library). If you want to avoid introducing a\nnasty bug, you should use the code provided in this article for generating a quaternion\nfrom two direction vectors.\n\nDerivation of Stable Formula\n\nFor this discussion, let ¢= [¢.¢,-¢,] = cross(2.0). and the quaternion qwe are trying to\nderive has the elements ¢,.q.-q.. The angle (unknown) between che ewo vectors (rp\nand »)) is. Let a be the dot produce 2 = dot(s,.e1);\n\nThe g.qp-4, components of a quaternion g have a length that is sin of half the\nangle (#2), As mentioned, the cross product's length is che sin of che anple ¢, There-\nfore:\n\nsin(t / 2)\nsin{s)\n\n$0 mow we have to determine a stable formula for che si(2!2\\simst) term. Recall\nthe half-angle formula:\n\n[q., Ty» Fel = le Fe |\n\nainfe { 2) = {Eee a\n\nand the circle identity:\n\n= 2\nAn +oo 2]",
      "content_length": 1472,
      "extraction_method": "OCR"
    },
    {
      "page_number": 212,
      "chapter": null,
      "content": "216 ; Section? Mathematics\n\nThen:\nsin(s/ 2) - vil = cos(r))/2\nsin{t} 1 — cos*(e)\n\nWe know conf) vo be the det product (#) of the two vectors. Therefore, we replace\nit in the formula and continue the simplification:\n\nya-ai2_ | et ees\nvi-@ V20+a0—-a) Joea\n\nSubstituting back im:\n\n1 [ent yrtgl\nGor 7 po) =\n: 20+ 4)\n\nDeriving the g,, component (angle) of che quarernion is fairly straightforward\nusing the half-angle formula for cos(t2):\n\nrae colt | 2) = | et \" pte\n\nIn order te optimize our C++ function to use only one call to sqrt(}, we multi-\nply the inner square root term of our g,, formula by 2/2. Ag a result, che term within\nthe square root is now the same as for the other quaternion elements. In other words,\ngis dezived using the equivalent formula:\n\n- 3\nThese new formulas for our quaternion elements remain stable as # approaches\nv, and as the dot product @ approaches 1.\n\nRemaining Instability Condition\n\nNote thar this function still becomes numerically unstable as vy approaches —y). This\nis not surprising, because when vy equals —w, there is not a unique solution; any axis\nof rotation on the plane perpendicular no iy will do. Remember thar v, and p, are\ndirections, not orientations. A check could be added to the function in order to detect\nthis case and avoid the possibility of dividing by zero. However, we did not do this,\nbecause it is so unlikely that one would be calling this function in that case. The\nobjective of using a function such as this one is to orient an object toward a target.",
      "content_length": 1515,
      "extraction_method": "OCR"
    },
    {
      "page_number": 213,
      "chapter": null,
      "content": "2.10 The Shortest Arc QGuatermnion 2if\n\neee\n\nConsequently, ry rarely approaches <2, but instead converges to », after repeated mis-\nsile-tracking Al updates.\n\nSource Code\n\nquaternion AotationArc(vector’ wO, vectors wi) {\nquaternion q:\nvO.normalize(); f/ Skip if known to ba unit leagth.\nvi.normalize(); // Oo only if needed.\nVEttord ¢ = CrossProduct(v,vi1);\nTloat df = BotProduct(voO,vi):\nTloat a = (float)sqret((i+d)*2):\nq.% 8 c.u f 8;\n\nq.¥ = c.y / 8;\nq.2=cG.2 / 5;\nq.w=e f2.0f;\nreturn qi:\n\nVirtual TrackBall\n\nAs a bonus, this article includes code for implementing a virtual trackball function.\nAlthough such functionality might noc be necessary in the user interface of your fin-\nished game, it is very handy during development to be able to grab any of your game\nobjects and spin them around with the mouse.\n\nAn cosy way of implementing object spinning is te rotate the object abour the }-\naxis When the mouse is moved parallel oo the X direction and about the X-axis based\non vertical (F) mouse movermenct. This method doesn allow for rotation abour the\naxis (normal to window), and ic simply doesn't feel “intuitive.”\n\n‘There are a variety of other user interface methods for spinning objects. This arti-\nde explains one simple approach, The old and new mouse positions (2D [X, ¥]) are\nconverted into rays (3D) chat point from che viewpoine into the window. Next, we\ndetermine where these rays would intersect a sphere around the object the user is\nmanipulating. [fa ray does not intersect the sphere, the closest point on che silhouerne\nof the sphere is used. The sphere is rotared so thar the point of intersection from the\nold mouse ray coincides with the point of intersection from the new mouse ray. This\nisachiewed by passing these two points (using the cenrer of the sphere as the origin of\nthe coordinate system) a3 input to RotationArc(). This returns the quaternion thar is\nused to adjust che object's orientation. The source code for the virtual trackball fune-\ntion and extracting che direction vectors from mouse input are available in the SpinL-\nogo source code on the CD that accompanies this book.",
      "content_length": 2119,
      "extraction_method": "OCR"
    },
    {
      "page_number": 214,
      "chapter": null,
      "content": "218 Section 2 Mathematics\nReferences\n[BiowareO0) Bioware, Shiny, and Interplay Productions, MDK2, 2000.\n\n[Moller99] Moller, Tomas, and Haines, Eric, Regl-Time Rendering, A. K. Peters Led.,\nLo,",
      "content_length": 192,
      "extraction_method": "OCR"
    },
    {
      "page_number": 215,
      "chapter": null,
      "content": "3.0\n\nDesigning a General Robust\nAl Engine\n\nSteve Rabin\n\nCreating a multimillion-dollar game that spans several years of development is a\npretty big undertaking. The underlying structure of your Al engine will have huge\nimplications in terms of whar your game can and can't do. Therefore, rather chan let\nan engine simply evolve, it is best co build in generaliry and safety precautions from\nthe start, The generalicy allows you to make your AI characters do anything you can\ndream up. The safery precautions both prevent bugs and help you track them down.\nAfter all, the only thing standing between you and the ship party is a couple thousand\nbups.\n\n° The ideal Al engine helps solve a ton of problems for you. The following list con-\ntains just a few:\n\n1. Easily allow communication between game objects\n2. Offer a general and readable solution to implementing Al behavior\n3. Facilitate keeping debug records of every event (you want to catch all chose bugs,\n\nThis article consists of several parts. Any one part by itself might scem obvious,\nordinary, or insane, bur put together, these ideas create a very powerful system. So, as\nyou read through the article, try to keep in mind the big picture and how each con-\ncept interacts with the others. In addition, realize that the Al engine presented is\nimplemented in © as opposed to C++. (© was chosen on purpose to show that chis\nengine doesn't rely on any object-oriented code to work and is generally applicable,\n\neven to console development.\n\nEvent-Driven vs. Polling Objects\n\nAfter working on several games, you'll start to see some precty big patterns in Al\nengines. The first is that you need each of your game objects co update its logic every\ntick or so. The second is that these objects need to communicare with each other.\nThere are basically two ways for game objects to react in the world: by actively watch-\ning the world (polling) o: by sitting back and waiting for news (event driven).",
      "content_length": 1951,
      "extraction_method": "OCR"
    },
    {
      "page_number": 216,
      "chapter": null,
      "content": "222 Section 3 Artificial intelligence\n\nSince games usually have hundreds of game objects in chem, the only reasonable\nsolution is to make the objects as cvent driven as possible. Imagine for a moment that\na missile explodes, causing area damage that affects 15 of so unies. Each unit could\npoll for nearby explosions every tick as though chey were actually aware of their envi-\nronment, or the exploding missile could simply tell cach unit chac it was hit and bow\nhard. Although it’s more cool oo chink that cach game object could sense its environ-\nment and react appropriately, the fact is thar the end result is the same either way.\n\nWith that quick-and-dirty analogy out of the way, you'll probably agree thar\n\nevent-driven communication is the way to go!\n\nThe Message Concept\n\nSince the poal is co have eventedriven behavior, we need to design a robust communi-\ncation system for making that happen. For nov, let's look at the concept of messages.\nFor our PUIposes, a mentee 1s an object that has five fields: a descriptive mame, che\nname of the sender, the name of the receiver, the time at which ic should be delivered,\nand any relevant data. IF 1 was handed a message, I should have all the informacion\nnecessary to pass it to the correct game object at the right time. The receiver of the\nmessage gets the message along with all of the goodies inside it, such as who senc it\nand any extra dara\nHere's an cxample of a message:\n\nnane:danaged, Tromidragon, to:knight, delivar_at_tima:245,.34, data:19\n(anount of danege)\n\nIn effect, messages become an electronic paper trail of what's happening in our\ngame. ‘This is a powerful concept that pives us all kinds of benefits. One of the incred-\nible uses of chis concept is chat we can recond every message that is sent and dump it\ntoa file. That way, if there’s a bug, we can look at the file and examine what triggered\ncertain actions, This ability becomes invaluable when the problem involves the inter-\nactions of tens of game objects over a fraction of a second.\n\nAnother great use of this concept is chat any pame object can “listen” to any other\ngame object's mesages. Since messages have the intended receiver built in, it's easy to\ndifferentiate who the message was meant for. Call it snooping, sniffing, or just peck-\ning, but this ability gives you the power to solve some tricky logic problems. Imagine\na manager game object thar owns several ocher game objects. The manager can then\nsnoop its children’s messages to listen for key events, such as members being attacked\n\nThe messages | am describing also have a field for delivery time. By sending mes-\nsages that should be delivered at a fucure time, we wrap a really cool timer system into\nthe mesage concept. In the real world, people and creatures usually have reaction\ntimes. By delivering messages slighely into dhe future, depending on che event, reac-\ntion times can be simulated. After all, dant you hate it when you're playing a game",
      "content_length": 2958,
      "extraction_method": "OCR"
    },
    {
      "page_number": 217,
      "chapter": null,
      "content": "3.0 Designing a General Robust Al Engine 223\n\nand things tend to happen in lock-step, all ac once? Even within a single game object,\nit can send a message wo itself, to be delivered at a future time, in order to stagger\nbehavior changes. You could even fenerate a random time within some window in\nonder to add some much-needed chans.\n\nState Machines\n\nA state machine is a siraple Al concept thar delivers a lor of power with very litele com-\nplexity. The basic idea is chat a game object has a different state for cach main sepment\nof behavior it exhibies. The goal is to break down a game object's behavior into these\nlogical stares. In a baseball game, for example, the pitcher might have the states\nReadyForWindup, Windup, WairForHir, InterceptBall, CoverBase, and so on. Imag-\nine how useful it would be if ar any time during your baseball game you could simply\ndisplay on-screen the current and pase states of all nine players on the field. Alterna-\ntively, if you came across a bug, you could dump toa file all che past state information\ndlong with whac caused each state transition. For example, if your Tight fielder never\nresponded to the ball being hit, you can see why he wasn't in the night stare to listen\nfor that event. So, state machines not only break behavior into manageable bite-sized\nchunks, but they also give you instant access to che mindset or thoughes of your Al\nobjects.\n\nAn Event-Driven State Machine Using Messages\nee\n\nPutting these three major concepts together, we now have a powerful foundation for\nin Al engine. Individual behaviors are built using stare machines, whereas all com-\nmunication and event notifications are accomplished with messages. Note that each\ngame object running a state machine doesn't preclude it fom using fuzzy logic, neural\nhets, or any other exotic Al technique. The stare machines simply provide a standard-\nized peneric interface that can be exploited any way you like.\n\nAlthough state machines are a simple concept, let's review some important quali-\nties that would make a stare machine more elegant and more robust, Below is a cheek-\nlist of fearures we need:\n\n- The state machine can have an arbierary number of states,\n\n- States can be easily defined and ser.\n\nWhen a state is entered, we should be able to execute any initialization code.\nWhen a stare is exited, we should be able to execute any clean-up code.\n\nWe can easily listen for messages and execute any code in response.\n\nWe can easily listen for the update tick and execute any code in response,\n\nWe can wansparently record which messages have been received and whether\nthere was a response.\n\n- We can transparently record state changes and the message that criggered them.\n\n- We can listen fora message within only cerain states or globally over all states.\n\nON yp\n\nod",
      "content_length": 2798,
      "extraction_method": "OCR"
    },
    {
      "page_number": 218,
      "chapter": null,
      "content": "224 Section 3 Artificial Intelligence\n\nTable 3.0.1 Paeudocode for State Machines\n—————————_——_—SSaa_——————————— —————— EE\n\nBevin StateMfachine Stans dhe stare machine defininion\n\nEedStateMachine Derminates the state machine definition\n\nStaret MamoOeS tate) Designates tbe begamnarig ofa particular Stare\n\nOErnter Responds co a state being entered; allows for initialtation code\nOnExit nds to a state being exited: allows for clean-up code\nOnU pdate : nds to the a re e tick\n\nOnhisp(NameOt Message) Reiponds to any defined message\n\nSerStace(Name()Srare} Changes states: sends OnExit to old state amd QnEnter to new state\n\nSendM Seni: message to any game abject\nSend Delayed Mse() Sends a delaped message to any game object\n\n10. We can send messages to any game object, including ourselves,\n11. We can send messages with a delay built in so char the message is delivered at a\nfuture time.\n\n12. The overhead for running the state machine should be minimal.\n\nOur state machine needs to support all these fearures. Table 3.0.1 is pseudocode\nfor all the constructs we'll need.\n\nIn order to make chis concept concrete, let's look at an example of a sentry robot\nbent on killing. Ler’s also use the pseudocode from Table 3.0.1 to represent our stare\nmachine, Chur state machine has two states: Pacrol and Amack. However, the scare\nmachine stars out in none of these states, Instead. a global section ar che top of the stare\nmachine is ahways active, regardless of the current state. When the stare machine runs\nfor che first time, the OnEnter response is triggered, Inside this response, che first state is\nset with a SetState command. In chis example, it sets che starting state to Patral.\n\nBeg instateWachine\n\n//Global Responses\n\nOnEnter {\nSetState( STATE_Patral }\n\n}\n\nOnMsg( WSG Bead | {\nf/Destray this gama object\n\n}\nStatet STATE Patrol } 7\nOnEnter {\nifSat initial goal point for patrol\n}\nOnUpdete {\n\nif{ /*see the enemy*; }\nSetState( STATE_Attack }\nelse if( /*goal point raached*; }",
      "content_length": 1979,
      "extraction_method": "OCR"
    },
    {
      "page_number": 219,
      "chapter": null,
      "content": "3.0 Designing & General Robust Al Engine 225\n\ni/set next patrol point as goal\n}\n}\n\nStete( STATE_Attack } {\nOnEnter {\nffSet goal to be aneny\n\nI\nOnlipdate {\nif{ /*enemy dead*/ }\nSetState! STATE_PATAOL }\nelse if] /*enemy within weapon range*/ }\nffShoot enemy\n}\n\n}\n\nEndStateWachina\n\nSince this state machine is even driven, the only way it executes is by getting a\nmessage. It can get a message when a state is first entered (oninter), when a stare is\nexited (OnExit), when a game tick occurs (OnUpéate), or on any other defined message\n(Onmsg y).\n\nWhen looking at the state machine, envision a message being delivered to it. The\nmessage first goes to the currenc stare, [f there is a response for that message, the mes-\nsage is consumed and the response is executed. If there is no response for the message\nin that state, the message is resent to the global responses at the top of che state\nmachine. ‘This behavior creates a powerful stare machine concept: the idea thar indi-\nvidual states can have message responses or thar you can have a global response to a\nmessage, regardless of the current state, Even more powerful, you can have a global\nresponse (0 a mestage while sometimes overriding that response within certain stares.\n\nBecause there are these global message responses, a stare change might happen\nfrom outside the current state. For this reason, the OnExit message response is crucial.\nIfa global message response changes the current state, you can rely on getting che\nOnExit message in the current state to clean up anything before the stare is actually\n\nchanged,\n\nConfession Time\n\nNow I have a very big confession to make. The pseudacode you just examined der\ncompile with a normal C compiler! (That is, it docs so provided some comments are\ntutned into real code.) All you need to do is use these macro definitions and place the\nstate machine within che following function:\n\ndefine BaginStateMachine if{ STATE_Global == state } {\n\nSdefine Statela) if(O) {return( true }: } } 4\nelse if{ a == state } { af(0} {\nSdefine OnEnter return tre); } else af¢ 4\n\nMSG_AESERVED Enter == fag->name } {",
      "content_length": 2102,
      "extraction_method": "OCR"
    },
    {
      "page_number": 220,
      "chapter": null,
      "content": "226 Section 3 Artificial Intelligence\n\ndefine OnExit return({ true jj } #lse ify 4\nM5G_AESEAVED Exit == msg->name } {\nfdefine OnUpdate return{ true ji } | else ifi 4\nMSG_AESERVED Update —- msg-sname } ¢{ 1\nfdefine OnWsg(al} return, true j; } \\\nelse if{ =2 fag-snane } {\nfoeting SatStatela) SetStatelmiamedbject( go, (intja };\n\n#defing EndStateachine return] true }; } } 4 else { assert)\n!\"Invalid State\" ; \\\nreturn( false };} return( false }:\n\nbool ProacessStateWachine( GaneObject*® go, unsigned int state,\nWegobject* asqg }\n{\n\nff! Put State machine inside this funetian!\n}\n\n(-style macros are a funny thing. Normally youd want to stay away from them\nbecause they can be misused ancl lead to bugs. In this case, we can exploit macro def\nINitiOns to COMSEMUCE a new state machine language! We certainly don't have to use the\nmacros to make the state machine work; it simply makes the coding more error free,\nsimpler to read, and faster to write. Now char's a good use for macros!\n\n‘You might have noticed that a bunch of return statement are embedded in the\nmacros. Conveniently, these return starements report whether a message was handled\nor whether it fell through withour being consumed. This information is critical for\nknowing whether a message thar wasn't handled in a local stare needs to be sent to the\nglobal responses, The return value also helps log whether or nor a particular message\nwas handled by the state machine.\n\nAnother Small Confession\n\nIhave another small confession. The macros are constructed so that you don't need to\nuse all chase curly braces! The braces are there to make che stare machine more C-like,\nbut they aren't needed ar all. By not using the curly braces, you can make the scate\nmachine more elegant and perhaps more readable. The following ix an example state\nmachine without the curly braces:\n\nBeginStateWachine\n\nCnEnter\nffInitialization sede here\nOnvsg( WG SomeMessage }\n//REEDONSe code hore\n\nState( STATE_Boan }\nOnUpdate\n//Update code hare\nOnEXit",
      "content_length": 1988,
      "extraction_method": "OCR"
    },
    {
      "page_number": 221,
      "chapter": null,
      "content": "2.0 Designing a General Robust Al Engine 227\n\nf/Cleanup code here\n\nEngStatavaehine\n\nState Machine Building Blocks\n\nThese C macros were constructed very carefully in onder to make something cool hap-\npen. Think of them as building blocks thar can be stacked however you like. Because\nof this stacking ability, che minimum you need ix the following:\n\nBeginStateWachine\n\nEnd2tateWachine\n\nFrom this minimum, you can add stares and listen for any messages within those\nstates. Since it's not required to have stares ar all, you could simply have message\nresponses!\n\nThe state names and message names are simply enumerated types—in effect,\nunsigned integers, Since simple if-else starements replace che macros, the procesing\nrequired is quite minimal.\n\nState Machine Message Routing\n\nQM course, there's a bir more support code to roure messages and make this stare\nmachine work properly. Figure 3.0.1 shows an overview of the structure.\n\nThe only outside source of messages co the game objects comes from the player\ninput and the game tick update loop. Other than those, messages are spawned by the\nstate machines themselves. When a message is sent, it always goes co the message\nrouter. The router then sens it through the game object and on to the state machine\n\nMessage Rooter\n\nFIGURE 3.0.1. Oveniew of FICsSage MMIULE,",
      "content_length": 1316,
      "extraction_method": "OCR"
    },
    {
      "page_number": 222,
      "chapter": null,
      "content": "Section 3 Artificial intelligence\n\nthat the game object owns. In case a message should be delivered at some time in the\nfuture, the router hangs on vo ic until che delivery time has passed.\n\nNerte that in Figure 3.0.1, owo different game objects point to the same state\nmachine. Obviously, if you have nwo or more objects thar should behave the same,\nthey should execute the same exact code. Therefore, it's important to recognize that\nall variables and state information are stored inside the game object and nor the state\nmachine. Multiple game objects use the same state machine, so you should always be\nconscious of that fact.\n\nIn onder to explain the message router and state changes, we need to know more\nabout some variables inside each game object and message object. The following is the\nbare minimum definition of cach:\n\ntypedeT atruct\n\n{\nunsignad int unique id;\n\nffState machina info\nStateWachinelD state machine id:\n\nunsigned int state: {ifthe currant state\nunsagned int néext_state; ifthe next state\nbool force _state_ change; (fhas 6 state change been\n\ni irequested\n\nJ/Put other gaae object info in hare\n} Ganeojact;\n\ntypedef struct\n4\nMSQNBME mame: ‘fame of message\nunsigned int sender_id-\nunsigned int receiver id:\nfloat delivery time: iideliver message at this tine\n\nffRote that the sender_id and receiver_id are not pointers to\n(fgane objects. Singe messagaa can be delayed, the sender or\nffreceiver may get removed from the gane and a pointer would\n(fbecone dangerously invalid.\n\nff¥au can add right here any data you want to be passad\nffalong with every massage — sometimes it's helpful to let\n(fetsiges convey gore info by using extra data,\n\n(fFor exasple, a damaged message could carry with it tha\n{famount of dane.\n\n} MagObject:\nThe following is the code that is called when a stare change is requested. Nore\n\nthat the stare change is asked for and doesn't occur uncil the current message is done\nbeing handled. In addition, realize chat this function is called by the setstate macro.\n\nwoid SetStateInGameObject( GameObject™ go, unsigned int state j",
      "content_length": 2071,
      "extraction_method": "OCR"
    },
    {
      "page_number": 223,
      "chapter": null,
      "content": "2.0 Designing a General Robust Al Engine 229\n\nQo->next_state = state:\ngo->foree_state change = true;\n\nI\n\nThe rower takes a formulated messige that's ready ro be sene and makes sure it\ngets senc to the righe states. Ic also deals with changing states if a request has been\nmade. You can see che code for the router in Listing 3.0.1. Since the router needs to\n\ndeal with delayed messages (a concept that is explained later in this article), che func-\ntions it references are in Listing 3.0.2,\n\nSending Messages\n\nIn order to send a message from inside a stare machine, it would help if there were a\nsimple function to call. The following is an example of a send message interface:\n\nveid SendMsg( Megane name, unsigned int sender, unsigned int\n\nreceiver }\nMsg0bject msg:\nMeg.name = mane; / {The name of the neeeage\nMeg. sender = sonder: fiThe sender\nmeg.receiyver = receiver: ifthe receiver\n\nmeg.delivery time = GetCurTime(); //Send the message NOW\n\nhouteWecsage( amsg }\n}\n\nNote thar when a message is sence, the state machine immediately roures it to the\nintended receiver. This is a great feature for debugging because a breakpoint inside a\n\nstate machine lets you see the stack and, consequently, who sent che message,\nSending Delayed Messages\n\nAs mentioned before, messages can be given a future time co be delivered. The rourer\ndeals wich this command by storing delayed messages for future routing, Somewhere\nin the main game loop, che function SendOelayadMessages needs to be called so char\nthe messages are eventually sent at the correct time. The following is the interface\nfunction for sending a delayed message:\n\nwold SendDelayogWsg( MagName name, float delay, unsigned int sender,\nunsigned int receiver )\n\n4\nKestbject msg;\nhig. hime = name: {/The nema of the sessage\nhag. sender = sander: {ithe sendar\nfag-receiver = receiver; {The receiver\n\nnag.delivery time = GetCurTime() + delay; //Send a future Neseage",
      "content_length": 1915,
      "extraction_method": "OCR"
    },
    {
      "page_number": 224,
      "chapter": null,
      "content": "230 Section 3S Arthicial intelligence\nRouteMessage( &msq }:\n\nNote chat all messages contain the sender and receiver as unique [Ds, nor as\npointers. Since messages can be delayed, it’s possible thar the sender or receiver has\nbeen removed from the game. Since a poincer has no way of knowing this, it's noc safe\nto reference the game objects by a pointer only. Instead, the receiver of the message is\nlooked up using its unique ID. This method ensures that mesages are sent only co\nvalid game objects.\n\nDelayed messages arc an incredibly useful teol for the state machine. Consider\nthe following state machine for a heat-seeking rocket, The rocket is fired, and if it\ndoesn't contact anything within five seconds, it should automatically explode. This\ntask is accomplished by sending a delayed message (wSG_Se1fDestruct) when the stare\nmachine is initialized. After five seconds, the message is delivered to the state machine\nand consumed in the global responses. Ac thar time, the state is set to Explode, and\nthe rocket vall soon be history.\n\nBeginstatemMachine\n\ni fGlobal Aeeponses\nOnEnter //Triggered when state machine first starts up\nSandbelayedMsg( MSG_Selfestruct, 5.0, go-*unigque_id,\npo-SLnigque id ps\nSetState( STATE_Arned 3;\n\nOnlsg[ MSG Selfbestruct |\nZatitate( STATE_Explode };\n\nStata STATE_Armed }\nOnMsg( MSG Collision }\nSetState{ STATE _Explode };\n\nOnligdate\nfifidentify closest visible enemy and steer toward\n\nState, STATE Explode }\nOnEnter\nff/Esplode rocket - cause area damage\n‘(Delete game objact\n\nEnds tateWaching\n\nDeleting a Game Object\n\nDeleting a game object from within the state machine takes a little thought. Since the\ngame object owns the state machine, we cant delete ic while we're executing code\ninside the state machine. The solution is co set a flag identifying chat the game object\nshould be deleted. When the execution steps outside the state machine, it’s then legal\nte delete it,",
      "content_length": 1915,
      "extraction_method": "OCR"
    },
    {
      "page_number": 225,
      "chapter": null,
      "content": "3.0 Designing a General Robust Al Engine 21\n\nEnhancement: Defining the Scope of a Message\n——— a\n\nA problem that creeps up is that sometimes a message is valid only inside a particular\nstate. Unfortunately, the potential exists for a delayed mesage to be consumed by the\nwrong state. Consider the following code:\n\nBeginstatemachine\n\n' {Global Responses\nOnenter\nsetitate( STATE_Aliva 3\n\nState( STATE_Alive }\nOmnEnter\nSendDelayedisg( MEG Tinedut, 3.0, go-=unique_id,\ngo-sunique_id );\n\nOnMso( MSG_Tinedut }\n‘iPlay & Sound\n\nOnMeg( MSG Dead }\nSetatate! STATE Dead |:\n\nState{ STATE Dead )\nQnEnter\nSencdtlayadWsg( MSG_Timedut, 50.0, go->unique id,\ngo-Sundque_id };\n\nOnllsg( MSS Tinetut )\nSetState( STATE_Alive };\n\nEndatateMachine\n\nThe problem is that both states send and respond co w8G_Tinedut. If the Alive\nstale pets a MSG_Dead before it gets back che wSG_Timedut, the Dead state then incor-\nrectly gets the WSG_TimeQut spawned by the Alive state. This was clearly not intended.\n\nThe solution is to mark a message as valid only within a particular state. If the\nstate is no longer active at the time of delivery, the message should be thrown away. In\neffect, the message now has a scope and is valid only within chat scope.\n\nThis enhancement can easily be added with an extra variable called “stare” inside\ncach message object. When the message is delivered, it first checks whether che mes-\nSage ‘state’ marches the current state of the game object. Only then is the message\ndelivered. However, most of the time you want messages to he delivered regardless of\nthe current state, so messages should default to not performing this checks.\n\nSince only delayed messages sent to yourself should ever be marked with a stare,\nwe can create 2 new helper function for sending that particular kind, The following is\nan example of the code. (If this enhancement is made, the other send message func-\ntions need ro mark the message stare as invalid.)",
      "content_length": 1934,
      "extraction_method": "OCR"
    },
    {
      "page_number": 226,
      "chapter": null,
      "content": "232 Section 3 Artificial Intelligence\n\nvoid SendbelayedisgToCurrentState( WagName name, tloat delay,\nGanelbject™ go }\n{\nMeploject nap;\nNeg.ame = name: ffTh® mame of the message\nNEQ.State = Po-+5tate: fi The state in which the msg is valid\nMeg.sander = go->unigue_id; i/The sender\nmepg.raceiver = go-sunique id; J/The receiver\nmeg.delivery tine = GetCurTime() + delay; /sSend a future message\n\nRouteWessage( Bnsg )j\n\nEnhancement: Logging All Message Activity and\nState Transitions\n\nWith the current structure, it’s wrivial to snoop the current state of each game object\nand perhaps display it on screen. You could even watch all the message eraffic that\ncomes through the message router and display that on screen. Bue for real hard-core\ndebugging, the ideal situation is ro individually track each game object, logging all\nmessage activity and state transitions along with a time stamp. Surprisingly, this task\nis easy to do,\n\nThe trick is to modify the stare machine macros. When we insert some simple\nfunction calls into che macros, the task of monitoring every state machine becomes\ntransparent. The following macros log message responses and state transitions:\n\nfdefine OnEnter Feturnd trug Jr 4\nelise it{ Ma _RESEAVED Enter == msg->nanme } {4\nLogWassagel ga, @8g, GetCurTimed) 3:\n\n#define OnExit return( true ji } 4\nelse if{ MSG_RESEAVED_Exit == msg->nane } { 4\nLogWessage( go, @99, GetCurTimal) }:\n\n#oetine Onlpdate réturn( true ji } 4\nalse if WEG RESERVED Update == msg->name | { \\\nLogWessage( go, #89, GetCurTime() };\n\nfiating OnWsg(a) réturn( true jr } 4\nalse iff a == msg--name } { 4\nLogWesesage( go, mag, GetCurTime() };\n\nfidatine SetState(a) SetStateInGanefbject( go, (inthe j: 4\nLogitateChange( go, state, (intja, GetCurTime() }:\n\nThe functions Laglessage and LogStateChange can store the informarion in\nwhatever way youd like. One suggestion is to keep a circular buffer of history dara for\neach game object. You can then either browse che history on screen or dump it to a\nfile when something interesting happens. Since each event is time stamped, you could\ncompare the logs of different game objects to see how rhey interacted. As mentioned\nbefore, this feature is incredibly helpful if there are three or more game objects all",
      "content_length": 2243,
      "extraction_method": "OCR"
    },
    {
      "page_number": 227,
      "chapter": null,
      "content": "3.0 Designing a General Robust Al Engine 233\n\ninteracting over a fraction of a second. Very complex interactions are mow casy §O\ndebug.\n\nEnhancement: Swapping State Machines\n\nWithin complex characters, it's very hard to design one stare machine that serves all\npurposes. The solurion is to make bite-sized state machines that are more manageable\nand more specialized. With this functionality, a character can choose to run the state\nmachine thar best fits the situation, This function avoids overly complex state\n\nmachines char became unmanageable,\n\nEnhancement: Multiple State Machines\n\nThere is no rule chat a game object can run only one state machine at a time. In fact,\nits quite useful for an Al character to run several state machines simultancously.\nImagine that each character has one state machine that serves as the brain and one\nthat serves to keep crack of the movement goals (not the movement execution). The\nbrain could even control che movement state machine by sending it commands in the\nform. of messages.\n\nSince not all types of movement are the same, you can apply the idea of swapping\nstate machines. The brain can then run the appropriace movernenc state machine that\nfits each given situation.\n\nEnhancement: A Queue of State Machines\n\nThe dedicated mavernent state machine brings up an interesting enhancement, It\nwould be incredibly powerful to be able to queue up several movement state\nmachines. In this scenario, only the top one on che queue wauld be active; the others\nwould be temporarily disabled.\n\nThe idea is that maybe a player has directed an Al character to go to three sepa-\nrate places in succession (think RTS), For each Spot, a separate movement state\nmachine would be thrown onto the movement queue. As the first state machine\nreaches its goal, it destroys itself, and the next state machine on che queue becomes\nacuve. This approach actually solves a large number of command issues in RTS\n\nee.\n\nConsider the act of patrolling. Parrofling is going to a sequence of places and re-\npeating that pattern over and over. By employing the state machine movernent queue,\neach patrol spot can be placed on the queue. However, when a state machine reaches\nits goal, it needs to put itself on the back end of the queue in order ro maintain the\ncrcle.",
      "content_length": 2281,
      "extraction_method": "OCR"
    },
    {
      "page_number": 228,
      "chapter": null,
      "content": "234 Section 3 Artificial Intelligence\n\nScripting Behavior Outside the Code\n\nThe AI engine described in this article is clearly not scripted fom ourside the code.\nHowever, that fact doesnt exclude a programmer from cleverly influencing che behav-\njor through the use of ourside dara. IF we create variables chat impact decision making,\na state machine can be customized for a particular character. In fet, many characters\nshould be able to use the same state machine yet have wildly differing behavior due ro\nattributes such as aggrestivencss or fear,\n\nInterestingly, the original implementation of this Al engine supported state\nmachines scripted solely outside the code. Puring the logic outside the code creared a\ndebugging nightmare for everyone involved. The original intentions were admirable,\nbur the result was 2 frustrating programming environment that wasted many people's\ntime,\n\nThe lesson to learn was that logic should be inside the code and data should be\noutside. Unless the design goal is to let users write their own Al, there isn't a com-\npelling enough reason to support arbitrary scripting of Al behavior. (For a more\ndetailed discussion of data and scripting, look ar the article “The Magic of Data-Dri-\nven Design” in this book.)\n\nConclusion\n\nEven if you never use chis exace implementation of an Al engine, many of the Ereat\nideas presented here can be applied 0a any Al engine or stare machine. Some of the\nmore notable ideas are as follows:\n\n- Standardized communication with messages\n\nStandardized imers throwgh the use of messages\n\n- Using event-driven methods as opposed to polling\n\n‘Tracking communication and state changes over all Al objects\n\n- Using global responses in state machines thar are always active, regardless of rhe\nCunenk stane\n\n. Allowing a global response in a state machine w be overridden by the current\nstate\n\n7. Allowing an Al to swap stare machines\n\n8. Allowing an Al to simultaneously run multiple state machines\n\n9. Allowing an Al to quewe up several state machines\n\n10. Keep complicated logic inside the code as opposed to scripting it from ourside\n\nThe Al engine as presented here is a powerful tool for enforcing a standard sruc-\nture on Al objects, Because of the macro state machine pscudolanguage, it’s incredibly\nquick and easy to prototype new behaviors. It’s so easy in fact, thar there is a real ten-\ndency to put too much code inside the state machine. The challenge comes in deciding\nwhere to draw the line. As a general rule, probably only high level decision-making\n\nigh Wwf\n\nos",
      "content_length": 2544,
      "extraction_method": "OCR"
    },
    {
      "page_number": 229,
      "chapter": null,
      "content": "3.0 Designing 4 General Robust Al Engine 235\n\nsould be held within the state machine. Other systems of an Al character, such as\nmovement execution and animation. should certainly exist elsewhere.\n\nListing 3.0.1: Message Router\n\nWold Aoutelessage( MSG Object* msg }\n\n{\n\n}\n\nGameObject* go = GetGOFromIO( cur_mag->receiver_id }; //Funetion not\ni {supplied\nif( !qo }\n{ Jffeceiver doesn't exist anymore - diseard the message\nPeLUrn;\n}\n\nif( msg--delivery time > GetCurTime() }\n\n{ J/iThis message needs to be stored until its time te send it\nStoreDelayedWessage( msg 3\nreturn;\n\n}\n\nif( RouteWassageHelper( oo, go->state, msg } == false j\n\n{ #/Currant state didn*t handle msg, try Global state (0)\nRouteliassageHelper( go, 0, még );\n\n}\n\nJi Chack for @ state changa\n\nwhile{ go->forca_state_change }\n\n{ /fNote: circular logic (state changes causing state changes)\nffcould cause an infinite loop here - protect against this\n\nHMGreate & general msg for initializing amd cleaning up the state\nfchenepa\n\nMeg0bjact tenpnsg;\n\ntempmeg.receiver = go--umique id:\n\nTempmsg.tender = go-*unique_id:\n\ng0->Torce_state_change = false;\n\nifLet the last state clean-up\nTempmeg- name = WG RESEAVED Exit:\nROuteWessageHalper( go, go->state, Btempmsg 4;\n\n‘(Set the new state\n@0-setate = go-snaxt_state;\n\nfflet the new stata initialize\nTEeNphsg.name = 5G AESERVED Enter;\nAouteMessageHolper( go, go->state, Etenpmag };\n\nbool RouteMessagekalper| Gamedhject* go, unsigned int state, Wagobject™\nmsg }\n\n{",
      "content_length": 1465,
      "extraction_method": "OCR"
    },
    {
      "page_number": 230,
      "chapter": null,
      "content": "236 Section 3 Artificial Intelligance\n\nPfLOSk Up correct state machine for this Game Object\nfad Send mesgage to that particular one\n\nii(et inplemented here - this always calls the same one}\nreturn{ ProcessStateWachinal go, State, meg ) ;\n\nListing 3.0.2: Functions to Deal with Delayed\nMessages\n\nvoid StoreQelayedMessage( Wag0bject™ msg )\nfiStore this message (in some data structure) for later routing\n‘fA priority queve would be the ideal data structure (but not required)\nita store the delayed messages - Check out Mark Neleon's article\nfi\"Prierity Queues and the STL° in the January 1996 Or. Dobbs\" Journal\n(fhttp: //www.dogma.nat/markn/articles/pq stl/priority.hta\nffiiete: In main gama loop call Sendbelayedwessages() every gam\nff tick to chack if its time to send the stored messages\n\n}\n\nwoid SendtelayedMessages( void }\n{ f/This function is called every game tick\n\nwhile{ /\"loop through all delayed mossages*/ }\n{\nif( cur_msg->delivery_tine <= GetCurTina{) )\n{\n\nRouteWessage! curmsg };\nRenoveDelayedWessage cur_msgq |;\n\n}\n}\n\nwoid RengveDelayadMassage( Messagefbject\" msg |\n\nfifienove this massage from the delayed messages data structure\n\nReferences\n\n[LaMothe?5] LaMothe, Andre, “Building Brains into Your Games,” Gare Developer,\nalso available online at www.gamasutra.com/feamres/programming/061997/\nbuild_brains_inco_games.htm, August 1995.\n\n[Nelson$6] Nelson, Mark, “Priority Queues and the STL,” Dr. Dobbt Journal, avail-\nable online at www.dogina.net!markn/articles!pq_suliptiority,htm, January 1996.\n\n[Moodcock99] Woodeock, Steve, “Game Al: The Seare of the Industry\" Garne\nDeveloper, also available online at wwew.gamasutra.com/features!19990820/\nFame_ai_Ol hem, August 1999,",
      "content_length": 1689,
      "extraction_method": "OCR"
    },
    {
      "page_number": 231,
      "chapter": null,
      "content": "3.1\n\nA Finite-State Machine Class\n\nEric Dybsand\n\n‘This article defines a generic finite-state machine (FSM) C++ cass. Fld are eom-\nputer science and mathemarical abstractions thar have been useful for many years ina\nvariety of ways. This article is not a discussion of the theory behind the FSM; instead,\nIT téa simple presentation of a basic building-block tool, the FSMelssr which you can\nuse to help develop your own complex artificially intelligent decision-making\nprocesses in your computer game,\n\nThe first thing you should know abour FSMs is char chey are simple machines\nthat consist of a finite number of stares (obvious, don't you think?). A seate is really\nonly a condition, For instance, consider a door; its states can be apen or closed and\nlooked or unlocked.\n\nThe next aspect one should know about FSMs is char there is an fipet to the\nFSM, which affects a sate sransition from one state to another. An FSM ean have a\nsimple (or complex) stare transition function that determines what state will hecome\nthe currens sare,\n\nThe new current stare is called the enter state of the mate transition of the FSM,\nor the stare to which the FSM has transitioned based on the input. If chis concept is\nconfusing, again think of a door as an cxample FSM. When the door is in a dosed\nstate and a locked state, perhaps the inpur of see bey will cause the door to transition\nto the unlocked stare (the onepur crave of the state transition and the mew current stare\nof the door). Then the input of ase And will cause che door to wansition to the open\nstate. When the doer is in the open state, the input of see Adama will transition the\ndoor back to the closed state, When the door is in che closed state, the input of ree dep\nwill cransition the door back to the locked state. While the door is in the locked state,\nthe input of ws Ave would fail co transition che door te the open stare, and the door\nwould remain in the locked stare. Furthermore, once the door was in the open state,\nthe input of use fey would fail to cransicion the door co the locked stare.\n\nSo, in summary, an FSM is a machine that has a Spite memder of states, one of\nwhich is 2 curment sate, The FSM can accept input chat will result in a sate sransition\nfrom the current state to an owtput state, based on some state transition Jfenction, and\nthe oatpar sate then becomes the new current state.\n\nNow, how does this concept apply to Al in computer games?",
      "content_length": 2428,
      "extraction_method": "OCR"
    },
    {
      "page_number": 232,
      "chapter": null,
      "content": "Section 3 Artificial intelligence\n\n‘The answer to that question is that the possibilities are really endless! ESMs can\nform the basis for managing the pame world, simulating the emotion of a nen-player\ncharacter (NPC), maintaining the status ef the game, parsing input from che human\nplayer, or managing the condition of an object.\n\nConsider the attitude of an NPC monster in an adventure game, for cxample,\nLet's say that the monster can have the following states: berserk, rage, mad, annoyed,\nand uncaring. Furthermore, let's say thar you have AI game code that does different\nthings based on the state of the monster's attitude. We ean use an FSM to manage the\nmonster's attitude and the way it transitions from one state to another based an inpur\nfrom the game itself. Let's furcher say that inputs are pdeyer seen, player attacks, player\ngone, monster burt, and monster healed, Then the state diagram shown in Figure 3.1.1\ncan be drawn.\n\nUsing these inputs and stares, we can set up a state transition matrix that looks\nsomething like the one shown in Table 3.1.1.\n\nTable 3.1.1 A State Transition Matrix for the Monster Game\n\nCurrent State rut Output State\nInca rine layer seen iipoyed\nu Meco player armacks mad =\nmiacd monster hurr _fage\nria monster healed uinearin\nrage monsrer Burt berserk\nrage manster healed annoyed\nberserk fmenster burt beeper\nberserk indnaster healed ra\naT layex uncarin\nannoyed player antacks rabiee\nannoyed monster healed uncaring\n\nPlater dteacks\n\nPlover Gene ox Memstus Haskd\n\nPlayer Ablacks\nFIGURE 3.1.1. A sample finire-state machine.",
      "content_length": 1568,
      "extraction_method": "OCR"
    },
    {
      "page_number": 233,
      "chapter": null,
      "content": "a1 A Finite-State Machine Class 230\n\nSo, depending on the current state of the monster's attitude and the input co the\nPSM, the attitude of the monster will change. Game code that performs behavior\nbased on the attitude of che monster will then cause the monster to act differently.\n\nObviously, we could add more state transitions, based on more states and inputs.\nDoing so would affect how our monster's attitude is evaluated and determined, and\nthar is how we create the Al thar uses this monster's attitude.\n\nThe FSMeclass and FSMstate\n\nNow how do we put this idea to work? That is whar the FSMclass and its subordinate\nFS$Mstate class will show in the following implementation, as illustrated in Figure\n3.12,\n\nThe FMclass provides structure for any number of stares that are provided by\nthe FSMstate class. These ewo classes work with each other eo provide the functional-\nity for 2 generic finite-state machine. A generic FSM implies that these objects are gen-\neralized, able to support a variery of types of states, a variety of types of stare\ntransitions, and any number of stare transitions, as well as any number of states within\nthe FSM. With such variery and generalization as a design goal, these classes and their\nmembers were selected az you see in the following discussion,\n\nDefining the FSMstate\n\nHere is the class definition we use to representa state for our FSM:\nclases FiMstate\n\nunsigned m_ustumberotiransitions:; ff mexi0e number of states\n/f supported\nint *m_pilnputs; ff input array for transitions\nint \"m_pidutputstate; /f output state array\nint m_istatelD; ff the unigue ID of this state\npublic:\n\nfi ganstructor accepts an ID for this state and the number of\ni} transitione to support\n\nFoustate{ int istatelD, unsigned usTranaitions };\n\nfi destructor cleans up allocated arrays\n\n-FaMstatel);\n\nif @oetss the state Io\n\nFohstate\nFSMclage Aa number of FEMfstabes\n\nFIGURE 3.1.2. The FsMedass can use any number of PSMstares.",
      "content_length": 1945,
      "extraction_method": "OCR"
    },
    {
      "page_number": 234,
      "chapter": null,
      "content": "Section 3 Artificial Intelligence\n\nint GetiIo() { return ®_iStatelo; f\n\nff add a state transition to the array\n\nvoid AddTransition{ int iinput, int i0utputID };\nff remove a state transition from the array\nvold DeleteTransition{ int igutputID };\n\nff get the output state and offact a transition\nint Getoutput( int ilnpat };\n\nSee Listing 3.1.1 for the FSMstate class constructor and destructor implementa-\nmons,\n\nThe member variables and functions of the FSMstare class are as follows.\n\nThe Falistate::n_usNumberOftransitions controls the number of state transi-\nHons that this stare is able to support. Seating this valuc also determines the size of the\ninput and output arrays. Since we are creating a “finite” state machine, this value sets\nthe finite-state transition limit for chis scate.\n\nThe FStstate: im _pilnpwts is an ary of m_usNunbarOfTransitions size char\ncontains the input values to be used during state cransition. The input array is used by\nthe state transition evaluation function co compare to the input received and deter-\nmine the coresponding output state.\n\nThe Foustate::m_piOutputstate is an array of mwsNumberOfTransitions size\nthat contains a comesponding ourpur stare identifier that indicates the new transition\nstate during a state cransition.\n\nThe Féustate::n_i$totel0 isa unique identifier used to identify this instance of\nan PSMstate and is the value char would be ouput by any transition to chis stare fom\nanother state.\n\nThe Faustate::GetlD(} provides public access to che unique identifier of this\nanstance of the FSMstare class. See class declaration for this implementation.\n\n‘The Fawstate::AddTransition(} provides a means to add new inpur values and\nOUurpUL state arrays to this instance of the FSMstate. See Listing 3.1.2 for this imple-\nmentation.\n\n‘The Feustate::Delet oTransition() provides a means to delete an existing input\nand its corresponding owtput state identifier. See Listing 3.1.3 for this implementa-\nron.\n\nThe Feuistate::Getutput() provides the state transition function that uses che\ninput value oo determine the transition output state identifier and return it. See List-\ning 3.1.4 for chis implementation.\n\nDefining the FSMclass\n\nSew we need the actual FSMclass implementation. The FSMclass works by main-\n\ntuning a collection of FSMstate objects.\nclass FoMclags\n\nState Map nmap; {/ Gap containing all states of this FSM",
      "content_length": 2378,
      "extraction_method": "OCR"
    },
    {
      "page_number": 235,
      "chapter": null,
      "content": "2.71 A Finite-State Machine Claes P|\n\nint m_iturrent$tate; // the m_iStatelD of the current state\n\npublic:\nFSuiclass( int iStatealp }; i/ set initial state of the FSU\n—-FoMolass | )5 ff clean up memory usage\n\nff return the current state Io\n\nint GetCurrentstate() { return m_iCurrentState: }\n\nff set current stata\n\nvoid SetCurrentStata( int istateID } { m_iCurrentState = istatelo; }\n\nif return the FSWstate object pointer\n\nFoustate “GetStatel int LStateID };\n\n{f add a FaMstate object pointer to the map\nvoid Addatate( FSlistate *pState |;\n\n{i delete a FSWstata object pointer from the map\nvoid DelateState( int istateall };\n\n{/ perform state transition based on input & current state\nint StateTransition{ int ilnput }:\ni\n\nSee Listing 3.1.5 for the FSMelass class constructor and destructor implementa-\ntion,\n\nThe member variables and functions of the FS Melass class are as follows,\n\nThe Faéelass::m_map is the collection of FSMstate objects (pointers to FSMstare\nobjects, in this case) and is implemented from an 5TL <map>:\n\ntypedef map< int, Filetate*, less<int> > State_Map;\n\nA discussion of the specifics of STL and <map> collections in general is beyond\nthe scope of this article. For information abour STL, please see the Gem “Using che\nSTL. in Game Programming, The above function declares State_Map to be an STL\n<map> with an int for a key; the map contains pointers to FSMstate objects, and the\ncomparison function to use during access is the less<> operator for ints.\n\nThe F5Wclass::n_idurrentState is che stare identifier for the FSMstate object\nthar is considered co be the current stare of the FSM.\n\nThe Fsiiclass::GetCurrentState() provides public access to the unique idenci-\nfier of che stare of the current PSMostace object. See class declaration for this imple-\nmentation.\n\nThe FaMiclass::SetCurrentstate() provides public access to set the unique iden-\ntier of the state of a mew current PSMstate object for the FSM. See class declararion\nfor this implementation.\n\nThe FeMclass::Getstate() provides a method to obtain a pointer to any FSM-\nstate object contained within the FSM. See Listing 3.1.6 for this implementation.\n\nThe Fatclass: :AddState() provides a method for adding FSMobject pointers to\nthe <map> contained within the FSM. This is the method that one uses to record the",
      "content_length": 2302,
      "extraction_method": "OCR"
    },
    {
      "page_number": 236,
      "chapter": null,
      "content": "Zaz Section 3 Artificial intelligence\n\nstate relationships within the FSM that are defined by FSMstate objects. See Listing\n3.1.7 for chis implemeniarian.\n\nThe Fatclass: :DeleteState() provides a method for deleting FSMobject point-\nes from the <map> contained within the FSM. This is the method one uses to\ndynamically remove state relationships from within the FSM. Nore: When you want\nto delete the current state from che <map>, be sure to set a new current state using\nFSilclass::SetturrentState() before deleting che old current state, See Listing 3.1.8\nfor this implementation.\n\nThe FSvclase::StateTransation{) provides the method for initiating a state\ntransition, using the inpur value received and returning the output state identifier. See\nListing 3.1.9 for this implementation.\n\nCreating States for the F5M\n\nTo use our FSMclass and FSMstate classes in a game, we first build che FSMsrare\nobjects:\n\nFEMState “pFSMetate = NULL;\n\nfi create the STATE_10 UNCARING\ntry\n\nff FaMstate( int istateID, unsigned usTransitions }\npFSistate = new FoMstate( STATE_ID UWEARING, 2 MF\n\n}\ncatch{ ... }\n{\n\nthrow:\n}\n\nii now add state transitions to this state\nPFSMstate-sAddTransition( INPUT_ID_PLAYER_SEEN, STATE_ID ANNOYED }-\nprSWstate->AddTransition( INPUT_ID_PLAYER_ATTACKS, STATE_ID MAD );\n\nAnd then create an FSMelass object:\n\nf/f ereate the FSitclass object\ntry\n1\n{i FSWolass( int iStaterID 5\nM_PFSMclass = now FSMclass(STATE_I0 UWGARIWG);\n\n}\ncateh{ ... }\ni\nthrow:\nI\n\nNow add the FSMstate object to che FSMelass object:\n\ni} Tow aid thas state to the Foul\nM_AFSWelass-sAddState| pFSlistate };",
      "content_length": 1587,
      "extraction_method": "OCR"
    },
    {
      "page_number": 237,
      "chapter": null,
      "content": "3.1 A Finite-State Machine Class 243\n\nRepeat the process of creating FSMstate objects and adding chem to the FSMeclass\nobject for all che stares you want to have in your FSM.\n\nUsing the FSM\n\nTo use our F3Mclass, we need only te pass it an input value (which is game depen-\ndent) and receive am ourput stare (also game dependenc), chen act on the output state.\nSo in your game code, you would have something like this:\n\nff something happans in the game that causes an input\n\niTnputiIO = INPUT_IO PLAYER_ATTACKS;\n\nfy have the FSi do the transition to an output state\nB_LOUTpPUtState - m_pFoelass->StateTransition(iInputIby ;\n\nfy S0M8 game AL cade tests for the output state\nif({ m_i0utputState == STATE_ID MAD j\n|\n\n}\n\ni) som code for the monster to act mad\n\nIts usage is thar simple!\n\nIn conclusion, this FSMclass is not an end-all solution to your computer game Al\nneeds. Ir is a starting point, or a building block, for you to use to create your own\nFSMs that are specific t your game needs. FSMclass objects could even be placed in\nlists or maps and used to form networks of FSMs char are interrelated.\n\nThis FSMelass could be expanded to suppor different input ype data or state\nidentification dara types. A state or input-specific wansition funetion could be easily\nadded so thar, based on the type of input received or che current state, the transition\nto the ourpur state could be determined uniquely.\n\nHave fun with this concept, and you will gain a powerful tool for making com-\nplex computer game Al.\n\nListing 3.1.1\n\nFeMstate: :FaMstate{ int LStateID, unsigned ustTransitions }\n{\nif don't allow 0 transitions\nif{ JusTransitions }\nmusNunberOtTransitions = i;\nelse\nmusNunberOtTransitions = usTransitions;\n\nfi save off id and number of transitions\nH_istatelpD = istatelD;",
      "content_length": 1776,
      "extraction_method": "OCR"
    },
    {
      "page_number": 238,
      "chapter": null,
      "content": "}\n\nSection 3 Artificial Intelligence\n\nif tow allocate cach array\n\ntry\n{\nm_pilnputs = new int[m_ushunberOtTransitions| +\nfor{ int is; i<m_wsNumberOitransitions; +#1 }\nM_pilnputs{ij = ao:\n}\ncatch{ ... }\n{\nthrow;\n}\ntry\ni\nm_pidutputState = new int[mushumberOtTransitions| ;\nfor{ int i=0; i<m_usNusberOfTransitions; +42 }\nh_pidutputState[i] = 0;\n}\ncatch{ .-. }\nt\ndelete [}] m_pilnputas:\nthrow;\nI\n\nFaMetate: :-FSMstate t }\n\n{\n\ndelete [] m_pilnputs;\ndelete [| m_pidutputState;\n\nListing 3.1.2\nSe a cn a el\n\nvOld FSMatate::AgdTransition{ int iInput, int idutpetID }\n\n{\n\nif the s_pilnputs[] and m_pitutputstate[] are not sorted\nff 30 find tha first non-zero offset in m_pidutputState[]\nff and use that offeet to store the input and OutputIo\n‘i within the m_pilnputs[] and m_pidutputState| ]}\nfor{ int i=0; i<m_usNunberOfTransitions; +#4 }\n{\n\nif( Im pidutputState[i} }\n\nbreak;\n\n}\nff only @ valid offset is used\nif( i = a_usMunberd?Transitions j\n{\n\nm_pidutputState[i] = iduepytip;\n\nM_pilnputs(ij = iTaput;",
      "content_length": 993,
      "extraction_method": "OCR"
    },
    {
      "page_number": 239,
      "chapter": null,
      "content": "2.1 A Finite-State Machine Class S45\n\nListing 3.1.3\n\nwoid FoMstate: :DeleteTransition( int idutputIo }\n\n{\n\nff the g_pilnpute[] and m_pitutputState|] are mot sorted\nff so find the offset of the output state ID to remove\nfor[ int 1=0; 1<m_usNumberdfTransitiongs; +44 4}\n{\n\nif{ m_pidutpwtStateli] == idutputio }\n\nbreak:\n\n}\nff Teat to be sure the offset is valid\nif({ i == n_ustumberOfiransitions }j\n\nreturns\n\nff ramive this output 26 and ite input transition value\nn_pilnpute[i] = 0;\nn_pioutputState[i] = 0;\n\nif since the m_pilnputs[] and m_pidutputState[] are not\nif sorted, then we peed ta shift the remaining cantents\nfor({ ; is(e_ushumerOfTransitions-1)5 ++i }\n{\nAf{ In_pidutpetState[i] }\nbreak;\n\nfi_pilnputs[i] = m_pilnputs[iri];:\nf_pitutputState[i} = m_ploutputStatel ie];\n\nff and lear the last offset in both arrays\nMn _pilnputea[ij = o;\nMN pidutputState[ij = o;\n\nListing 3.1.4\nee a eae\n\nint FSWSstate: GetOutput( int ilnput }\n\n{\n\nint idutputI® = m_istatelo; i! output state to be returned\n\n/i for gach possible transition\n\nfor( int i=0; i<n_usMumberOfTranaitiens; ++i }\n\n{\nif zeroed output state IDs indicate the end of the array\nif( !m_patutputstate(ij j\n\nbreak:\nif State transition function: look for a match with the input\niv walue\nif{ ilmpet == a_pdinputs[i] }\n{\nidutputio = m_pidutputstatel il; If output state id\nbreak;\n}",
      "content_length": 1332,
      "extraction_method": "OCR"
    },
    {
      "page_number": 240,
      "chapter": null,
      "content": "246 Section 3 Artificial Intalligance\n\nff returning either this m_istatelD to indicate no output\nff state was matched by the input (i.e., no state transition\nff Can aceur) or the transitioned output state ID\n\nreturn( idutgutIo ):\n\nListing 3.1.5\n\nSr\nFEMclass!:FaMelass{ int iStatelD |]\n\ni\nm_iturrentState = iStateID;\n}\nFaMoGLase: :-FSMelass(}\ni\nFaustate \"pState = MULL:\nState Mapiiiterater it:\nff only perform this if there are pointers in the map\nif( lo_map.espty() 4\n{\nff first delete any Falstate objects in the map\nTor] it = mmap.begin(); it != mmap.end(): +4+it }\n{\npState = (FiMetate *)((\"it)-secend);\nif{ pState |= NULL }\ndalete pState;\n}\nff Let the map dter() erase the actual pointer out of the map\nI\n}\nListing 3.1.6\n\nrr\n\nFaWatate “FGliclass::GetState( int iStatelD }\n{\n\nFolistate \"pState = MULL;\n\nState _Map::iterator its\n\nff try to find this FSWstate in the map\nif( Immap.empty() }\n{\nit = m_map.find( iStateID };\nif{ it != mmap.end() }\npotate = (FSMstate \")((*it). second):\n}\n\nPetUrn( pState i:\n\nListing 3.1.7\n\na\n\nWold FiMclass::AddStatel FaMstate *pliawState }",
      "content_length": 1071,
      "extraction_method": "OCR"
    },
    {
      "page_number": 241,
      "chapter": null,
      "content": "3.1 A Finite-State Machine Class 247\neee\n\nFiMistate “patate = NIALL:\nState Map: :iterater it;\n\nff tery to tind this FaMstata in the nap\nif( !'t_map.enpty{) 3\n{\nit = mmap.find, pMewStete->GetIo(} }:\nifq it [= mimap.end{) }\npStake = (FaMstate *}((*it).secand);\n\nff if the FSilstate object pointer is already in the hap, return\nif{ pState f= NULL |}\nreturn:\n\nff otherwise put the FSMstate object pointer into the nap\nmap. ingsert{ SM_VT(pilewState->GetID(), plewStata) HA\n\nListing 3.1.8\nSS\n\nwid FiMclass::DeloteState( int aStateID }\n\n{\nFoMstate *pState = NULL:\nState _Map::iterator it;\nff try to find this FiMstate in the sap\niti If_@ap.enpty() J\n{\nff gat the iterater object of tha FSWstata object pointer\nit = mmap.tind( iStateIo };\nif{ it I= mmap.end{) }\nPpstate = (FSWstate \")((*it) second) ;\n}\nff confirm that the FSWstate is in the map\nif{ pState != HULL &&\npState->GetID,) == iStatelD )\n{\nM_tap.erage( it }; i? Pengva it Trad the map\ndeleto potate; ff delete the object itself\n}\n}\nListing 3.1.9\n\n———\n\nint FSllclass::StateTransition( int iInput }\n{\nff the current state of the FSM must be set to have a transition\nif Im_iCurrent&tate }\nreturn m_iturrent$tate;",
      "content_length": 1162,
      "extraction_method": "OCR"
    },
    {
      "page_number": 242,
      "chapter": null,
      "content": "248 Section 3 Artificial Intelligence\n\nff get the pointer to the F5Mstate object that is the current state\nFoMstate \"potate = GetState( m_icurrentState 1S\n\nif{ pState == NULL }\n\n{\n\nif signal that there is a problen\nn_iturrentStata = oO;\nreturn m_iturrentstate;\n\n]\n\n‘if OW pass along the input transition value and let the FSWstate\ni! do the really teugh job ef transitioning for the FSM, and save\nif aff the output state returned as tha new CUrrent state of tha\nff FSM and return the qutput state to the calling process\nm_iturrentState = pState->Getdutput{ input 13\n\nreturn a_iourrentState;\n\nReferences\n——————\nMore information on FSMs can be found at these World Wide Web links:\nhep:/fesr.uvicca!-mmania/machines/intohom\nweew erlang/se/documentation/dac—4.7,3/docldesign_principles!fsm.heml\nweew. ticroconsultants, com tips! fsm/fsmarce] hem\nAnother implementation of an FSM in C++ code can be found at httpafuw7doe,\nsco.com/SDK_c++/CTOC- Using Simple Finite_State_Machi html\nAn implementation in (C can be found at httpalw3execnet,com/Les/Writing/Finite'™\n20State%20Machines. html",
      "content_length": 1081,
      "extraction_method": "OCR"
    },
    {
      "page_number": 243,
      "chapter": null,
      "content": "= \"4\n\nGame Trees\n\nJan Svarovsky\n\nFor many games such as chess and checkers, we can define the sume ee as a cree on\nwhich the nodes are game states, and children of each node are the positions thar are\nreached fram it by one move. A computer player for these games works by consider-\ning this game tree as far as it can or wants co inco the furure from the current game\nposition. Ir also has an evaluation function chat atrempes to quantify how good a par-\nticular game position is for one player. This is because at some point the search must\nstop, due to time constraints. Ac thar point, some estimate will be made of the value\naf the remaining game position.\n\nThe assumptions are that whar is good for one player is bad for the other and that\none player plays to maximize the beard evaluation function and the other to minimize\nit. This “my gain is my opponent's loss\" type of game is known as a zero—men game,\nFor example, tic-tac-toe is a zero-sum game; part of a tic-tac-toe game tree is illus-\ntrated in Figure 3.2.1. In a one-ply (one-level-deep) search, a player obviously simply\ngoes for the move that produces the best board as a result, as defined by the board\nevaluation function. In a ewo-ply search, Player One assumes that whacever he does,\nPlayer Two will then do the described one-ply search, Mayer One, therefore, plays\n\nS\n\n<\n\nee\n\nane\n\nNS\n\nail\n\nx\n=\no\n\n|\n\nFIGURE 3.2.1. Part of the game tree for the opening of “tie-Lac-toe\".\n\nie SS\n\nip\n\n249",
      "content_length": 1458,
      "extraction_method": "OCR"
    },
    {
      "page_number": 244,
      "chapter": null,
      "content": "250 : Section 3 Artificial Intelligence\n\nwhichever move leaves Mayer Two (who will chen de the best move for himself) with\nthe worst possible best option. These assumptions are extended to as many ply\nseatehes as is possible in che time allowed,\n\n‘The following function (with avery similar counterpart, minimize )) retums the\nbest expected board value, looking ahead a given amount. Trivially, saximiza()\nshould be called onee for each available move at the moment, and che one that returns\nthe best value should be taken.\n\nint maximize(int ply)\nif (ply == 0 || gase_over()) return évaluate current _board():\nint best = -intinity;\n\nTor (Mowe \"m= first_available move(j; m f= NULL:\nMm = Mext_avadlable mowed)\n\nmake oova[m}:\nint fewwalue = minimizetply — 1);\nUNtake mows (mj:\nif (ftwivalue = best) best = naw value;\nf\nreturn best;\n\n}\n\nMove “which move_shall I take{int ply)\n\n4\nMave “best move:\nint best_value = -infinity;\n\nTor (Move \"m = first available move(}; m := MULL;\nN= Next_available novel) )\n{\nnakée_move(m);\nint naw_value = maximize(ply):\nunmake_ move (6);\nif {new_value > best_valua)\n{\nbest_walue = new_value:\nbast move = m;\n\nI\nreturn best_nmove;\n\nThe Negamakx Variation on the Minimax Algorithm\neS\n\nRather than writing two funetions, one char aims to minimize board stare and the\nother to maximize it, we insert a negation and turn this into just one function. Note\nthar now the evaluation function must return the qualicy of the board for the current\nplayer, rather than always returning low values, meaning a good boand for one player",
      "content_length": 1546,
      "extraction_method": "OCR"
    },
    {
      "page_number": 245,
      "chapter": null,
      "content": "3.2 Game Trees 251\n\nand high for the other. Board stare must therefore include or imply which player gocs\n\nNexe;\nint negamax(int ply)\n\nif (ply == 0 || game_over(}) return evaluate current_board(};\nint best = -infindty;\n\nfor (Move *m = first_available move(}; m f= MULL;\nm= next_avallable _mowe())\n\n{\nmake mowe(m) ;\nint mew_value = -negamax(ply — 1):\nUnneke move fm) :\nif (few_value < best) best = naw value;\n}\n\nreturn best;\n\nThe most efiictene system for this function is to have che beard/game stale Put\nforward and reversed by the make_neve and unnake_move functions, as shown, and for\nthe evaluation function to be calculated incrementally rather than calculared from\nscratch every dime ir is called.\n\nAlpha-Beta Pruning\n\nNewell, Simon, and Shaw invented alphe-dera pruning in 1958. This concept is based\non the observation that im some cases, it is clear char further investigation of part of\nthe game tree is pointless, as ilhestrated in Figure 3.2.2.\n\nHere, a5 so0n as we see that Player Bs move P will produce a board of value 1, we\nknow that Player A will never let B get co che point char it can make move P Player A\n\nA's move (maxinizer)\n\n2.\nbe ceiel pha\nB's move (maximize ee | ee\n\nFIGURE 3.2.2. Sometimes part of the game tree can be terminated,",
      "content_length": 1257,
      "extraction_method": "OCR"
    },
    {
      "page_number": 246,
      "chapter": null,
      "content": "232 Section 3 Artificial intelligance\n\nalready knows he can force B into situation , where the best B can hope for is 2\n(remember, B is seeking to minimize board value). Therefore, exploring P's siblings is\nunnecessary, because Player A will never lec situation R happen. It is already clear thar\nR is worse than © for PlayerA.\n\n‘This concept can be generalized to the statement char if we know thar the oppos-\ning player can get a better outcome elsewhere, we know thar the current board prosi-\ntion will never be made available by thar player, The search naw “prunes” the rest of\nP's siblings and goes straight on to 5.\n\nThis effectively means we add an extra parameter to the search. This is the hese\nwe know the other player can get based on the parts of the tree searched so far. As\nSon a3 OWF current search returns something that is bemer for us (and worse for the\nether player) than this “current best,” we know chat we don't have to search here any\nmore. OF course, this actually becomes owe parameters. One is the best the opposing\nplayer has gocten so far (called fens), and the other is the best we have gotten so far\n(called afpéu). Alpha is passed to the recursive call for the other player's move, where\n\nalpha and beta are swapped:\nant alphabeta(int ply, int alpha, int beta)\n{\nif (ply == 0 || ganc_ovar()) return evaluate_current_board[};\nfor (Move nH = firét_awailable mova(j: m i= HULL:\n© = next_aveilable_movel))\n{\nmake_mowe(mp;\nint new_value = -alphabeta(ply — 1, \"bata, -alpha);\nUntakKe_ move [mp >\nif (new_value > beta) return now_value; // prune\nif (new_value = alpha)\nalpha = méw_value; | update our ‘best se far’\n}\nreturn alpha:\n}\n\nYou can see that ideally, you want to find your pruning moves as soon as possible.\nThis means you want to consider the best move first at each point. That might seem\nimpossible (because finding the best mave is the whole point of searching), bur in fact\nseveral methods exist, and in practice game programs almost always succeed in sorting\ncorrectly. This method gives a theoretical square-rooting of the cose of the search,\nwhich means the search can be performed to twice the depth.\n\nMove-Ordering Methods\n\nOne move-ordering method is irerated deepening, Instead of straight-away searching ar\nfull ply, search at a gradually increasing ply, using the results of che previous level of\nsearch to sort the moves for the next level. This method might seem like lots of extra",
      "content_length": 2430,
      "extraction_method": "OCR"
    },
    {
      "page_number": 247,
      "chapter": null,
      "content": "a2 Game Trees 255\n\nwork, but, because of the exponential nasure of che search, che lasr ineration is by far\nthe most significant cost.\n\n‘The results of the previous level can be stored as a hash table [Sedgewick98], stor-\ning calculated values of board positions. This table hashes board states to board val-\nues. It helps in another way: to avoid recalculating board walues when different\nsequences of moves producc the same game state,\n\nGame-specific heuristics can be used, such as always considering capture moves\nfirst in chess. Finally, there is the “killer” heuristic: fa move turned ous to be the best\nin a sibling node in che tree, ory ic first in chis one,\n\nRefinements on Alpha-Beta\n\nAlpha and beta are effectively a lower and an upper bound on the expected board\nvalue. Alpha is the lower bound because it is the least you expect co be able co force\nplay into. You know che other player will be able to force you into not getting any-\nthing more than bera. If you are pretcy sure what the return value for the alpha-beta\nsearch will be, instead of seeding the search with negative infinity and positive infin-\nity, seed it with a range around whar you expect the rerum value to be, If the return\nvalue hits either side of your range, you know that the answer was actually outside the\nTange, 80 you have to expand the range and try again.\n\nA ftved-depth search is bad because of the Aorizen effect. If a particularly bad\nmove is going to happen soon, the computer will do all sores of other moves as long as\nthey mowe the terrible one just after the end of its search depth. This is because ir can-\nnot sec the terrible move happening if it is too far in the future, and therefore lows of\nother bad delaying moves seem like a better idea. Many methods exist for choosing\nwhen to increase the ply for some branches of the tree, bur these are out of the scope\nof this article.\n\nReferences\n\n[Eppstein] Eppstein, David, “Strategy and Board Game Programming,” available\nonline at wyw.ics.ucLedul-eppstein/ 180a/970401-heml,\n\n[Sedgewick98] Sedgewick, R, Alporithms in C++, Addison-Wesley Longman, Inc.,,\n1398.",
      "content_length": 2114,
      "extraction_method": "OCR"
    },
    {
      "page_number": 248,
      "chapter": null,
      "content": "3.3\n\nThe Basics of A* for Path\nPlanning\n\nBryan Stout\n\nThe Problem\n\nThis article examines the basic solution tw the problem of planning a path for an\nauLOROMOUs agent fo move fom one location in a game world tm another, a common\nSituatien in computer game AL. On the CD thar accompanies this book is a copy of\nmy PathDemo program, with which you can play to understand how A* (and ocher\npath-planning techniques) works.\n\nThe mast common issue involved in path planning is the avoidance of obstacles,\nincluding cul-de-sacs to be ignored (oz, sometimes, discovered and explored). The\nnext most common issue is perhaps the awareness of different verrain and secking our\nthe most efficient path among a variery of choices: exploiting roads or clear terrain,\navoiding swamps, and so on.\n\nAn Overview of the Solution\n\nThe A* (pronounced 4 star) algorithm is an old workhorse in the academic AI com-\nmunity, used since 1968 for solving different kinds of problems, of which the 15-puz-\nze is the favorite teaching example; fortunately, it is also very useful for the\npath-planning problem.\n\nA* is an algorithm that searches in a stare space for the least costly path from a start\nstate to a goal stare by examining the neighboring or adjacent stater of particular states.\nIn the 15-puczle, a state consists of a configuration of the 15 niles in che 4 x4 array, and\nan adjacent stare is reached by sliding ane tile imto the blank area. In the path-planning\nproblem, a state consis of the agent occupying a particular location in the game\nworld, and an adjacent state is reached by moving the agent co an adjacent lacation,\n\nIn essence, the A* algorithm repeatedly ceamines the most promising unexplored\nlocation it has seen. When a location is explored, the algorithm is finished if that loca-\ntion is the goal; otherwise, it makes note of all chat location's neighbors for further\nexploration.",
      "content_length": 1885,
      "extraction_method": "OCR"
    },
    {
      "page_number": 249,
      "chapter": null,
      "content": "3.3 The Basics of A* for Path Planning 255\n\nIn more detail, A* keeps track of two lists of states, called Open and Closed, for\nunexamined and examined stares, respectively. At the start, Closed is empty, and\nOpen has only the starting state (the agent in its current position), In each iteration,\nthe algorichm removes the most promising state from Open for examination. If the\nstate is nor a goal, the neighboring locations are sored: If they're new, they're placed\nin Open; if they're already in Open, information abour those locations is updated, if\nthis is a cheaper path co them; if they're already in Closed, they are ignored, since\nthey've already been examined. If the Open list becomes empry before the goal is\nfound, it means there is no path to the goal from char start location,\n\nThe “most promising” stace in Open is essentially the location with che lowest\nestimated path that would go through thar locarion. Each state X includes informa-\ntion to determine this: the cost of the cheapest parh chat has led to chis stare from the\nstart (which we'll call costFroastart(X)); a heuristic estimate CostTodoal(X) of the\ncost of the remaining distance to the goal; and che total path estimate, defined as\nCostFronStart(X) + CostTaGeal(X). The cotal path estimate is the lowest Total-\nCost(X) value that it determines is the next state to examine. In addition, each stare\nkeeps 2 pointer to its “parent” state, the state that led to this one in the cheapest path\nto it; when a goal state is found, these links can be raced back to the start in order to\nconstruct the path from start to goal. Please nore that in the lirerame, you'll find\nCestFromstart(*)} called g(X), CostToGoal(X) refernec co as h(X), and che oral path\nestimate named f0X). We'll use our names for greater clarity in this article.\n\nListing 3.3.1: The A* Algorithm\n\nIn pseudocode form, here is the A* algorithm:\n\nOpen: priorityquewue of searchnoda\nClosed; list of se#archnodp\n\nAStarSearch( location Startloc, location Gaalloc,\nagenttypa Agent } {\nclear Open and Closed\n\nif initialize a start moda\n\nStarthode Loc = Startboc\n\nStarthede CostFromstart = 0\n\nStarthode.CostTaGeal = PathCestEstinate( Startloc,\nGoalie, Agent j\n\nStarthode.Parent = null\n\nPuan Starthode on Open\n\n{/ process the list until ewesess ar failure\nwhile Open is not anpty {\npop Made from Open /f Node has Lowest TotalCost\n\nff i? at a goal, we'ra done\nif (Node is a goal node) {\nConstruct @ path backward from Node to Startle",
      "content_length": 2466,
      "extraction_method": "OCR"
    },
    {
      "page_number": 250,
      "chapter": null,
      "content": "256 : Section 3 Artificial Intelligence\n\nreturn success\n} else {\nfor each successor NewNoda of Node {\nNewlost = Node .CoatrromStart + Traversetest{ Node,\nHewhode, Agent }\ni} ignore this nade if existe and no inprovament\nif (Wewiode is in Open or Closed) and\n(NewNode.CostFronftart <= Mewtost) 1\ncontinue\n} else { ff stere the new or improved\ninforfiation\nNeeWode. Parent = Mode\nNemNode.costhronstart = NowSost\nNeenode.CastTogoal = PathGastEstimatée( Newiode.Loc,\nGoalloc, Agent |\nNewtone.Totaltoest = Nowigda.Costrromstart +\nNewttnte.CostTaGoal\nif [Newiode 44 in Closed) 4\nremove Neetodé from Closed\n\n}\n\nif (MawNode 18 in Gpen) {\nadjust Newlode's location in Open\n\n} else {\nPuen Mewiode onte Open\n\nI\n\n}\n} of! now done with Node\npush Node onto Closed\n\n}\nréturn failure J) if na path found and Oyen is empty\n\nProperties of A*\n\nA has several useful properties. (They are not proved here; readers who are interested\nin the proofs can look in the References.) First, A* finds a path from the start vo che\ngoal, if one exists, Second, it finds an optimal path, as long as the CostToGoal(X) esti-\nmate is ddmasidle, which means CostToGoal is always an underestimate—thar is,\nGostTogoal(X) is always less than or equal to the actual cheapest path cost from X co\nthe goal. Third, A*° makes the most efficient use of the heuristic: No search thar uses\nthe same heuristic function CostToGoal(X) to find optimal paths examines fewer\nstates than A*, not counting tie breaking among states with equal cost.\n\nApplying A* to Game-Path Planning\n\nLet's new look in detail at how the aspects of A* can be applied to path planning in com-\nputer games. Much of this discussion depends on the mature of the game and its internal\nrepresentation of the world: the following discussion is meant to suggest possibilities,",
      "content_length": 1795,
      "extraction_method": "OCR"
    },
    {
      "page_number": 251,
      "chapter": null,
      "content": "3.3 The Basics of A\" for Path Planning 257\n\nState\n\nAs stated above, the principle component of a state in the path search is /ocution.\nHowever, it need noc be the only component. An agent's orientation and/or its velec-\nity can also be important. For example, vehicles can often go only straight ahead or\nturn slightly, and che amount of curn possible is reduced the faster a vehicle moves.\nMost vehicles can go backward only after coming to a stop. It is quite possible vo plan\na route based only on locations, bur ir could be desirable in some situations to plan\nbased on velocity and orientation as well, to avoid planning a route through terrain or\naround obstacles that would be difficule to navigare.\n\nEven considering location alone, the issue of which locations to consider is not\ntrivial. In some games, the world is naturally tiled—real-sime strategy games often\nhave an underlying square grid, and many war games use a visible hex grid—but\nmany games do not divide the space that way, especially games that use a 3D), firse-\nperson, or oblique view of the world. In such cases, it is important to choose a set of\nlocations among which to search. Figure 3.3.1 shows a pach-planning simarion and\nseveral ways of partitioning the space.\n\n©\n\ni pee ee\n\nHiterngm =I\n\nFIGURE 3.3.1. A vaniery of means of partitioning 2 continucus space.",
      "content_length": 1340,
      "extraction_method": "OCR"
    },
    {
      "page_number": 252,
      "chapter": null,
      "content": "Section 3S Artificial Intelligence\n\nThe ways of partitioning the space are 2s follows;\n\nRectangular grid. The simplest way is to partition into a regular grid of squares,\nas shown in Figure 3.3.1b, The locations can be cither the center poines or the\ncomers of the squares; if appropriate for the game, the grid can be considered to\nconsist of che terrain most comman to the area it covers,\n\nQuadtree. Another way to partition the space is inte squares of differing sizes.\nThe quadtree recursively devides a square into four smaller squares, until each\nsquare has uniform (or at least mostly uniform) terrain, as shown in Figure\n3.3.1¢. Again, the locations for the search can be either the centers or che corners\nof the squares. This method has a couple of advantages: The larger (and fewer)\nsquares allow for a faster search, and the representation is easy two store.\n\nConvex polygons. A more complex yet possibly more robust scheme is co break\nup the space into convex polygons made up of uniform terrain (Figure 3.3.1d).\nThis scheme could already exist in che map's representation, so it can be used\ndirectly in the path search, There are several methods that can be used to parti-\ntion a space inte polygons if the existing mesh is useless or inefficient. (C-cells are\none way to partition the space; each vertex is connected co che nearest visible ver-\ntex, and the connecting lines partition the space, Another is maximum-area\ndecomposition, where areach convex vertex the edges connected oo the vertex are\nprojected out until they hit an obstacle or wall, and between chese lines and the\nline to the closest other vertex, che shortest is chosen as a boundary. Navigation\nmeshes, a third method, are discussed in another article in this volume (“Simpli-\nfied 30 Movement and Parhfinding Using Navigation Meshes\"). Similar tech-\nniques can be used to divide variable-cost terrain into convex polygons of\nuniform terrain. After the polygons are laid out, search locations can be chosen at\ntheir center and/or along various parts of their perimeters.\n\nPoints of visibility. Not all techniques divide the space into regions bur instead\ncome up with locations directly. Points of visibilicy are concemed mainly with\nobstacle avoidance: Place a search location just a little beyond each convex vertex\nof cach obstacle, just far enough away to avoid collision with che obstacles (as in\nFigure 3.3.1e). The shortest path around obstacles cypically passes near these ver-\ntices, as though a rubber band conmected the stare and goal locations. One could\npossibly extend this method to consider terrain cost by adding these points to\nthese derived from convex uniform polygons.\n\nGeneralized cylinders, Another technique concerned mainly with obstacle avoid-\nance is generalized cylinders: The space between neighboring obstacles can be\nconsidered a 21) cylinder, the shape of which changes as it goes along. Berween\neach pair of neighboring obstacles (including the walls or boundaries of che map),\ncalculate a ceneral axis (Figure 3.3,1F). The intersections of these lines provide the\n\nlocations for the search.",
      "content_length": 3108,
      "extraction_method": "OCR"
    },
    {
      "page_number": 253,
      "chapter": null,
      "content": "3.3 The Basics of A\" for Path Planning 259\n\nFor most of these schemes, when a search is done, the start and goal locations are\nusually not members of the search locations, so they need to be added to them for the\nduration of that search.\n\nWhichever scheme ts used for quantizing a continuous space, it probably must be\nexperimented with and tweaked before it suits the game's demands optimally: There\nneed to be enough locations so char ne reasonable route is unconsidered, bur not too\nmany, or the search will rake too long, Another issue is that most paths found from\nany quantization scheme seem jagged and a bit artificial, which means che route needs\nto be smoothed, either before it is assigned to the agent or in the means che agent uses\nto Follow it.\n\nNeighboring States\n\nThe neighbors of a state are determined by che map representation and the quantiza-\ntion scheme. Some schemes use only their adjacent locations as their neighbors—a\nsquare grid would consider cach interior point as having eight neighbors, four if diap-\nonals are excluded—whereas in other schemes, a location's neighbors are all other\nlocations visible to ir.\n\nA location's neighbors are also determined by the terrain. Some terrain might be\nimpassable, which means it is not a neighbor to its nearby locations after all. The type\nof agent could also enter chis determination; for example, land vehicles cannot travel\non the sea, and infanery can traverse terrain forbidden to some vehicles,\n\nWe need an efficient way to compute each location's neighbors, for the sake of\nseach speed. Grids have a natural way of calculating neighbors: The neighbors of (x,\nye are (eel, yh Geel, ptt), G5 yt J), etc. Most other schemes require that some dara\nstructure store the neighbor information for fase lookup, since the neighbor calcula-\ntions are often expensive.\n\nCost\n\nThe cost function for the path benween nwo locations (CostFreaStart above) repre-\nsents whatever it is the path is supposed to minimize—typically, distance traveled,\ntime of traversal, movement points expended, or fuel consumed. However, other Frc-\ntors can be added into this function, such as penalties for passing through undesirable\nareas, bonuses for passing through desirable areas, and aesthetic considerations (for\nexample, making diagonal moves more costly than erthogonal moves, even if they\narent, to make the resultant path look more direct; see the article on acstheric oprti-\nmizations, “A\" Aesthetic Optimizations,\" for more discussion.)\n\nJust as with connectivity considered previously, in many games, the cost is net the\nsame forall agents—for cxample, roads offer a great speedup for wheeled vehicles but\nlittle if any for infantry. What's more, in some gFamies, travel cost is asymmetric: Going\nfrom Ato B may be more costly than going from B to A, such as is the case if B is\nuphill from A. That is why the code in Listing 3.3.1 has the cost functions dependent\non the agent traveling as well as the wo endpoints of the travel.",
      "content_length": 2989,
      "extraction_method": "OCR"
    },
    {
      "page_number": 254,
      "chapter": null,
      "content": "Section Artificial Intelligence\n\nAgain, these terrain costs need to be quickly looked up during the search and in\nface are probably best stored with the connectivity information. In chat way, one\nlookup can determine whether two locations are neighbors, and if so, the cost for the\ngiven agent.\n\nEstimate\n\nThe estimate of the path cost to the goal is the complement to the known distance\nfrom the stare. If you want to guarantee thar an optimal path is found, this distance\nshould not be overestimated. A common way to do this is to multiply the actual map\ndistance from che given location to the goal times the minimum cerrain cost per unit\ndistance. Since the route cannot be shorter than the most direct, “crow’s flight” line,\nthis figure will be an underestimane (unless your game has chings like instant-trans-\nport locations). In many games, this minimum distance is che Euclidean measure\nbetween two points in 2D or 3D, bur in games with strict square or hexagonal tiles,\nthe shortest tile parh is usually a little longer than the Euclidean distance berween che\ntile'’s center points. Therefore, in a square grid, a tile (3, 5) away has a minimum dis-\ntance of 2 + 3*sqr(2), not the Euclidean sqn(34), This actual shortest distance can\nthen be multiplied by a typical terrain cost. This cost should include all the previously\ndiscussed factors concerning the cost between neighboring nodes,\n\nHowever, guarantecing an optimum path is not the only consideration; chere is\nalso the speed of the search, and che qualicy of the GostToGeal value has a tremendous\nimpact on the search efficiency. Look at Figures 3.3.2 and 3.3.3. In Figure 3.3.2a, the\nGastTobeal has been set to zero, which, after all, san underestimate, and we see char\nthe search spreads in a circle neil it hits the goal, because it has no heuristic informa-\ntion to guide it im the correct direction. In Figure 3.3.2b, we see that an accurate\nheuristic weight of | per square sends the search in a straight line to the goal. In Fig-\nure 3.3.3, the start and the goal are in costly terrain (8 per square}. Since the estimate\nof | per square is a large underestimare, the search frontier is nearly as circular as the\nuninformed search in Figure 3.3.22. In Figure 3.3.3b, we see thar even an estimate of\n2 per square focuses the search considerably. It is therefore important, perhaps crucial,\nthar the estimate be fairhy accurate. In Get, in some sivuations, one might want ro\noverestimate the cost to the goal in order to get a fast search, ar the risk of getting a\nsuboptimal path (the article “A* Speed Optimizations” ralks about this concepr). So\nrather than using a mifienins terrain cost per unit, we could use a qypical cost, which\ncan cither be fixed or dynamically determined by sampling the terrain berween the\nstated start and goal,\n\nGoal\n\n‘The goal is typically a single location, but it does mot have ro be, For example, if a\nvehicle low on fuel is trying to plan 2 route to the closest refueling station, with cach\nnew node N in the search th ietitiate 1s made of che Pe Ccalrnitee distance To eich o0-\ntion, and the minimum of them is used as the CostToGeal(N) value. This method",
      "content_length": 3163,
      "extraction_method": "OCR"
    },
    {
      "page_number": 255,
      "chapter": null,
      "content": "3.43 The Basics of A* for Path Planning 261\nei la)\n\nPOE ny\naeagpap\nma “\n\nFIGURE 3.3.2. A* search in clear terrain, 2: With a heuristic weight of 0, 6: With a heuristic\nweight of 1.\n\nFIGURE 3.3.3. A* scarch in costly terrain. a: With a heuristic weight of 1, & With a heuristic\nweight of 5.\n\nguarantees thar the search figures owt both the closest goal and che best route co it\n\nsimultaneously,\n\nWeaknesses of A*\n\nAlthough A® is about as good a search algorithm as you can find, it must be used\nwisely; otherwise, it can be wasteful of resources. On a large map, hundreds or even\nthousands of nodes might be in the Open and Closed lists, which can rake up more\nmemory than is available on systems with constrained memory, such as console sya~\ntems. On any system, A\" can take too much CPU time to be affordable,\n\nThe case in which A” is most inefficient is in determining that no path is possible\nbetween the start and goal locations; in that case, it examines every possible location",
      "content_length": 983,
      "extraction_method": "OCR"
    },
    {
      "page_number": 256,
      "chapter": null,
      "content": "262 Section 3 Artificial Intelligence\n\naccessible from the start before determining thar the goal is not among them, as\nshown in Figure 3.3.4. The best way to avoid this problem is to de a pre-analysis of\nthe map, manually or algorithmically, so chat che program can look up whether wo\nlocations are accessible from cach other—say, on che same island. If chey are not, the\nsearch is not even attempted.\n\nFurther Work\n\nThere is much more derail thar we could eover, because there are many different path-\nplanning and parh-following situations. With an understanding of the workings of\nA*, one can often figure out how to adape it to their needs, Take a look at the other\narticles in this volume for further discustion on the ways to partition a floor space for\nuse in A\", as well as efficiency and aesehetic considerations.\n\nReferences\n\nWebsites\n\n[Woodcock] Woodeock, Steven, “The Game AI Page: Building Artificial Intelligence\ninto Games,” available online at wew-gameaicom. The “Resources and Links”\nsubpage of this site has many links to Websites that discuss A*, some of which\nhave sample codc.\n\nGeneral Al Texts\n\nThe following are two recent, very good general Al textbooks, both of which happen\nto use the agent-centered paradigm for diseussing Al:\n\n[Russell] Russell. Stuart, and Norvig, Peter, <rcifictal Jncelligence: A Modern Approach,\n\nPrentice Hall, 1995. Perhaps the best current Al cext, it has a couple chapters on\nsearch techniques, including A”.\n\nSSH\n\nitis\n\nFIGURE 3.3.4. Search in a situation in which there is no path co the goal.",
      "content_length": 1549,
      "extraction_method": "OCR"
    },
    {
      "page_number": 257,
      "chapter": null,
      "content": "2.3 The Basics of A\" for Path Planning 263\n\n[Nilsson98) Nilsson, Nils J., Artificial foteliigence: A New Synthesis. Morgan Kauf-\nmann, 1998. Since Nilsson was one of the developers of A*, his discussion of ix is\nvaluable if one wane to understand the theory behind it. This text presences for-\nmal proofs of properties of A*.\n\nSearch Texts\nThese books discuss the general issues of search, which dare back to the early days of\n\nAl research:\n\n[Barr81] Barr, Avron, and Feigenbaum, Edward A. eds., The Handbook of Arsijicial\nfntetigence, volume 1, Addison-Wesley, 1981. A good multivolume survey of\nmajor Al issues and important Al programs. This volume includes che discussion\nof search, including A”.\n\n[Kanal&3] Kanal, ES and Kumar, Ve, eds, wadral Im Artificial Freelligence, Springer-\nVerlag, 1988. A collection of good articles for those who want to get into the\nadvanced considerations of scarch, including variations on A* (with imaginative\nnames like B,C, and D!).\n\n[Pearl84] Pearl, J., Hewnisties: Invelligent Search Strategies for Computer Problem Solving,\nAddison-Wesley, 1984. This is perhaps the most complete reference on search\nalgorithms and is referenced by practically everyone else,\n\n[Shapiro] Shapiro, Stuart C., and Eckroch, David, eds., Encyclopedia of Arcificial [nret-\nHgence, 2 volumes, John Wiley & Sons, 1987. A truly excellent collection of arti-\ncles abour most aspects of Al research. Good articles pertinent to this article are\n“Search,” “A Algorithm,” and “Path Planning and Obstacle Avoidance.”",
      "content_length": 1525,
      "extraction_method": "OCR"
    },
    {
      "page_number": 258,
      "chapter": null,
      "content": "A* Aesthetic Optimizations\n\nSteve Rabin\n\nComputing a path fora character is more than merely an exercise in search algo-\nrithms. It also involves creating an aeschetically pleasing path and resulting execution.\nComputed paths for characters can be improved in three main ways: making the path\nstraighter, making it smoother, and making it more direct. The execution of the path\ncan be improved by simply maximizing responsiveness, All these optimizations result\ninan experience that is more aesthetically pleasing to the player. Since providing a sat-\nistying experience is the ultimase goal, these things are fairly important and directly\nimpact the code within and surrounding A*,\n\nStraight Paths\n\nPaths calculated by A* often look like they were constructed by someone who was\ndrunk They weave and bob their way efficiently to the goal, but it sure doesn't look\nnatural, This is a serious problem that undermines the believability of any game's AL\nThere are two ways to deal with this issue, The first is to promote straight paths\nwithin the A* algorithm; the second is tw clean up the mess after the path has been\ncalculated.\n\nPromoting straighter parhs involves careful cost weighting within the A\" algo-\nrithm, Consider the owo pachs computed by A* chat are shown in Figures 3.4.1 and\n3.4.2,\n\nThe amazing observation is thar both paths crawel che exert same distance. Since\nboth paths have identical costs, A* is unable to differentiate between them and simply\nchoases the first path ic stumbles upon. The cick char will make A* choose the\nstraight path is held within dhe cost function. Simply factor in an extra cost (penalty)\nif the new step being considered is mot straight with the last step. Note that we are not\nlooking at the overall straighoness of the path, just penalizing new considerarions chat\nare not in line with the last step.\n\nA reasonable penalry is half che normal cost to step in a given clirection. The cruch\nis that. on a regular grid, any penalry at all (0.000001) for nan-straight choices causes\nA® to choose the straightest one, However, this is not the case on an arbitrary net-\nwork.",
      "content_length": 2117,
      "extraction_method": "OCR"
    },
    {
      "page_number": 259,
      "chapter": null,
      "content": "FIGURE 3.4.2. Straightenedd A“ path,\n\nA word of caution: Penalizing non-straight paths results in more work being done\nby the pathfinder, thus slowing the computation. Obviously, the algorithm has co\nconsider many more permutations in order to find the straightest one. In fact,\nsearches can take significantly more time. However, if hierarchical methods are used,\nthe extra time might not be an issuc. Make sure you understand the tradeoffs.\n\nStraight Paths In a Polygonal Search Space\n\nWith a polygonal search space, this trick is not very useful. Because criangles aren't\nuniformly spaced, as a rectangular grid is, similar paths that cost che same are quite\nrare. Therefore, there is no need co find the straighter path. Instead, there's a different\nproblem: Since triangles can vary greatly in size and proportion, paths are more\ncrooked than ever. The trick is to optimize for straightness after the pach has been eal-\nculated. Greg Snook's path-finding article, “Simplified 3D Movemenc and Pachfind-\ning Using Navigation Meshes,” discusses an excellent way to handle this problem.\n\nSmooth Paths\n\nUnfortunately, paths computed by A® are usually riddled with sharp curns. Even if\nyou employ a technique to make straighter paths, sharp curns still have che potential\nto make your characters look like robo. By applying rotational dampening to your",
      "content_length": 1351,
      "extraction_method": "OCR"
    },
    {
      "page_number": 260,
      "chapter": null,
      "content": "Section 3 Artificial Intelligence\n\nturns, you can probably mask chem a line, but you'll swing wide on every sharp cor-\nnet. There's a much beter way.\n\nStraight from the field of computer graphics, there's an algorithm that makes\nyour paths (simply series of poincs in space) smooth for you. A simple Catmull-Rom\nspline does the trick because it creates a curve that nails all che control points in the\noriginal path (unlike a Bézier curve, which is smoother but docsn't go through the\ncontrol points}. Obviously, irs beer to go directly through your points because A*\ndeemed them clear and free of obstacles,\n\nBut how do you actually input a list of points and get a smoother list back? The\nCacmull-Rom formula requires four input points and gives you back a smooch curve\nbetween the second and chird points. Figure 3.4.3 cuplains this concept a little berrer,\n\n‘To get the points between the first and second inpur points. you simply give the\nfunction the first point cwiec, then the second and third. To get the points berween\nthe third and fourth, give che function the second and third, and double upon the\nfourth.\n\nFach time you use the Carmull-Rom formula, it gives you a point roughly ws\nbetween the second and third inputs, where wis a number you pass in. The following\nis the formula (poines can be 2D or 3D):\n\nDUCPUE_ Point = point_t * (-0.5T*utu\" + ut - O.5t#u) +\n\nPoint_2\" (1.57*u\"u*u + =2.85f \"| + 1.0T) 4\npoint 3 * (-1.4f*u*utu + 2.0f'u\" + O.5T*%u) 4\npoint 4 * (0.5f*u*u*s - O.8f*u\"y);\n\nNore thar if w is zero, the formula gives you point_2. When wis 1, ir gives you\npaint_3. As you can see, the spline really does go direcely through the inpur poines.\n\nInpet Chere! Pants\n\nFIGURE 3.4.3. Geing spline points from control point.",
      "content_length": 1741,
      "extraction_method": "OCR"
    },
    {
      "page_number": 261,
      "chapter": null,
      "content": "3.4 A\" Aesthetic Optimizations 267\n\nA Pre-Computed Catmull-Rom Formula\n\nSince speed is an issue, you might want co dicrare that you want u only ar cerrain\nintervals, such as 0.0, 0.25, 0.5, and 0.75. By freezing all instances of u, you can pre-\ncompute the formula at each u. Note thar the formulas can take either 2D or 3D\npoints. The following are some formulas at various intervals:\n\nifu= 0.0\noutput_point = point_2;\n\n‘fou = 0.25\nCURT point = polnt_i * -0.0700125F + point_2 * O.B671BT5f =\nPoint_j * O.2265625F + point_4 * -0. 0234375;\n\nffw=0.5\noutput point = POint_i * -0.0é285f + point_2 = O.5625T 4\npoint_j * O.5828f + point_4 \" -0,0625T:\n\nMu = 0.75\nGUEAUT PONT = poOlnt_i * -0.0204376f + point? * O.226583T «\npolnt_3* O.887187SF + point_4 * -0.0703125f;\n\niiu = 1.0\noutput_point =| point_a;\n\nEquipped with che Carmull-Rom formula, all you need to do is walk: through che\npath thar A” found and create a new path. Remember to double up on the first input\npoint when you start, and double up on the last inpur poine when you get po the end.\nIf the A* path has only rwo points to begin with, simply dont apply the spline to che\npath,\n\nSince you have a new pach with four times the number of points, you might want\nto look inte getting rid of redundant points, Running the new path through a func-\ntion that prunes co-linear points should dramatically reduce your list.\n\nFigure 3.4.4 shows a typical path before and after the Catmull-Rom spline has\nbeen applied. Notice how it’s still just a series of points (picce-wise linear), but the\npath is now much smoother, In the large scale of things, this path is perfectly smooth.\n\nFIGURE 3.4.4. Pach poincs before and after a spline is applied.",
      "content_length": 1692,
      "extraction_method": "OCR"
    },
    {
      "page_number": 262,
      "chapter": null,
      "content": "260 Section 3 Artificial Intelligance\n\nImproving the Directness of Hierarchical Paths\na Rat lara at eeectcabaet teal lt clerics Tha La\n\nAvery important A* technique is Avenarchica! pathing. However, the problem is thar the\nresulting paths can be less than ideal. In hierarchical pathing, you parthfind in two dis-\nminct steps. You first find the large-scale path, and chen you pathfind ar the local level.\nFor example, a castle might be broken up into rooms. You might want co get from the\ndungeon to the throne room. The idea is thar you fine find the Large-scale path\nbetween the rooms (by running A* on the connectivity graph of the rooms). Once that\npath is found, you can then path-find between each connecting mom as you encounter\nit. The result ig a huge savings of rime. Unfortunately, the overall pach can look rather\nbad because the goal poine will always be the door to the next room, thus causing the\ncharacter to always travel through the center of each door. When doors are arbitrarily\nlarge, this can look rather bad. Figure 3.4.5 illustrates the problem.\n\nThere is a simple, clegant way co get the ideal path, bur ic rakes roughly ewice the\ncomputation. The trick is to always path-find to the door beyond the next door.\nThen, whenever the character crosses through the first doorway, chrow away the rest\nof the path and repeat the process. While che second half of the path is always wasted,\nit really does create the most direce and aesthetically pleasing route. Figure 3.4.6\nshows the final path.\n\nThis technique always finds the optimum passage through the deorway because it\ntakes into acoount the furure path. The following is a step-by-step sample path execu-\ntien guide to show how chis method works;\n\n1. Find the best room-to-mom path using A* on the connectivity graph of the\nPoms.\n2. The result is co crave! the following sequence of rooms 1, 2, 3, 4.\n\nFIGURE 3.4.5. The pach through several rooms.",
      "content_length": 1925,
      "extraction_method": "OCR"
    },
    {
      "page_number": 263,
      "chapter": null,
      "content": "2.4 A® Aesthetic Optimizations 269\n\nFIGURE 3.4.6. The optimized path through several rooms.\n\nParhfind from Start to subgoal l (Figure 3.4.7 a).\n\nLet the character walk until he enters Room 2.\n\nThrow away the remaining path and pachfind to subgoal 2 (Figure 3.4.7b).\nLet the character walk until he enters Room 3.\n\nThrow away the remaining path and pathfind to che final goal (Figure 3.4.7).\nLet the character walk to the final goal.\n\nyes\n\nce\n\nHierarchical Pathfinding on Open Fields\n\nThere is no real difference berween a set of connected rooms and a set of connected\nfields. The same principles apply. The resulting path is not completely straight, bur it\n\n2 Le ES be is be cee 5 co Cpa ep F\n\nFIGURE 3.4.7, The computed path durtnp various steps.",
      "content_length": 747,
      "extraction_method": "OCR"
    },
    {
      "page_number": 264,
      "chapter": null,
      "content": "270\n\nSection 3 Artificial Intelligance\n\nFIGURE 3.4.8. The computed path during various steps.\n\ncomes pretty close. You also meed ro realize that these fields are fairly large relative to\nthe player, Figure 3.4.8 shows the hierarchical steps applied to open fields.\n\nEliminating Pauses During Hierarchical Searches\n——————&—&{—————————\n\nNote that every time the character enters a new room, a new local path must be com-\nputed. Since this obviously takes time, the character appears to pause as he enters each\ndoorway, The search inself can't be sped up, bur the new path request can be ancici-\npated and computed slightly before it's needed. This simple trick keeps the character\nmotion fluid throughour the pach.\n\nMaximizing Responsiveness\n\nController responsiveness is critical to game play. When a player issues a move com-\nmand in an RTS, they expeer the unit to respond immediately. However, in the world\nof pathfinding and search algorithms, sometimes it can take awhile co find that path.\nThat's where we need to pull a few tricks in order to give the feeling of instantaneous\nresponse.\n\nThe first trick is to stall by playing a sound byte that identifies the unit as having\nreceived the command. This erick gives immediate feedback that the unir is aware of\nthe command and will execute it shortly. Meanwhile, the pathfinder is working ar full\nspeed trying to find the pach.\n\nAnother ick is co stall by playing a “get ready to move\" animation. The meve-\nment of the character signifies that he’s going to move—even though he might not\nactually take any steps. You can even rotate the character to the “hest-guess” direction\neo that he'll be ready to move when the final path is available, thus stalling even\n\nlonger.",
      "content_length": 1723,
      "extraction_method": "OCR"
    },
    {
      "page_number": 265,
      "chapter": null,
      "content": "3.4 A* Aesthetic Optimizations art\n\nYou can take the idea further by moving the character in the “best-guess” direc-\ntion before the final path is ready. Unfortunately, you could be dead wrong in your\nguess, and the character will have to backrrack. Unless the pathfinder is extremely\nslow, irs probably best to avoid using this method,\n\nMoving large groups of people ar once can take even longer. If the player grabs 20\nunits and asks chem to move across the map, you could be waiting a long time wo get\nthe 20 paths processed, There are nwo cricks no dealing with this situation. The first is\nto queue the path requests and let each unit move as its request is serviecd. This way,\nit looks as though there's immediate feedback, because at least some of the units start\nto move immediately. Tr looks a bit like popeom popping as cach unit starts 6 move,\nbut overall, it's fairly satisfying to the player, The second wick is to choose a leader in\nthe group of 20 and find a path for only him. Then cell che other 19 units ta follow\nthe leader, However, this method can get complicated because there could be massive\nbunching, the leader could dic halfway through the path, and each unic should even-\ntually stop ata unique destination.\n\nConclusion\n\nAll these techniques are designed ro make pathfinding more transparent to the player.\nThe goal has always been to find good, direct paths instantancously. Since that’s a\ntough problem, hopefully you can apply these gems to your current pathfinder in order\nto get berter-looking paths that ultimately feel better to the player.\n\nReferences\n\n[Patel99] Parel, Amic J., “Amit's Thoughts on Pathfinding,” available online at\nhetps!/theory.stanford.cdu/-amitp/GameProgramming/, November 27, 1999.\n[Stout] Stour, Bryan Wi, “Smart Moves: Intelligent Path-Finding,” Game Devel-\naper, October/November 1996, pp. 28-35, also available online at www.gamasu-\n\ntracomfearures/ 1999021 2/sm_O1.btm.",
      "content_length": 1932,
      "extraction_method": "OCR"
    },
    {
      "page_number": 266,
      "chapter": null,
      "content": "A* Speed Optimizations\n\nSteve Rabin\n\nTraditionally, A* is a slow algorithm thar never runs as fast as you'd like, Since there's\na long list of optimizations that you could make, its very important to understand\nwhy its slow so you cin wisely use your optimization time.\n\nThe first ching to notice about A* is thar it is at the mercy of the search space. Usu-\nally, the sheer number of connections to search is a good indication of how fast At\nworks. In a rectangular grid of 1,000 by 1,000 squares, there are 1 million possible\nsquares to search. To find an arbitrary path in that kind of world simply takes a lor of\nwork, no matrer how optimized your code. The solution is to optimize the search space.\n\nOnce the search space has been optimized, it's time to look deeper into the actual\nA implementation, Since A* churns through alot of memory, it’s critical to optimize\nmemory allocation as well as cach of the data accesses. A also demands a lor of sart-\ning, bur this can be dealt with quickly and efficiently using some specialized dara\nstructures.\n\nLastly, the best way to speed up A* is by not using itar all for simple cases. Con-\nstruct some Kind af test to determine whether you absolurely need to fire up the\npathfinder. Many times, simple routes can be determined without using the full-\nblown A* implementation. For example, try running a blind straight-line path to the\ngoal, resting to see if it collides with walls or other objects. Undoubtedly, there will be\n\ntimes when this simple solution works amazingly well.\n\nSearch Space Optimization\n\nSimplifying the Search Space\n\nThe biggest win always comes from searching through less data. If you can represent\nyour world as a simplified connectivity graph, A* will work all the faster. Practically,\nthere are several options to choose from, Since speed isn't the only consideration,\nsome other pros and cons are also discussed here. A simple diagram of each technique\nis provided in Figure 3.5.1.",
      "content_length": 1959,
      "extraction_method": "OCR"
    },
    {
      "page_number": 267,
      "chapter": null,
      "content": "3.5 A* Speed Optimizations 273\n\nRectangular or Hexagonal Grid\n\nDeseripian\n\nA uniform rectangular or hexagonal grid is overlaid onte the world, The size of each\ngrid space is proportional to the size of the smallest character. Therefore, a character\nin a grid space blocks thar space during the A* search. See Figure 3.5. 1a.\n\nPros\n* Obstacles and characters can be easily marked in the grid allowing for avoidance.\nThis creates a one-step solution to finding a path through static and dynamic\nobjects.\n© Works well for 21D tile-based worlds.\n\nCons\n* Typically recules in the largese search space.\n* Rectangular grids don't map very well onto 3D worlds.\n* Paths cend co look like moves on a chessboard,\n\nActual Polygonal Floor\n\nDesorption\n\nIn a 3D game world, the floor polygons are specifically marked and used direcaly as\nthe search space. This polygonal floor is identical to the rendered geometry, thus\nbeing arbitrarily simple or complex. See Figure 3.5. 1b.\n\nPros\n* Data strocture already exists in the 3D world,\n* Can be walked through quickly with a BSP tree.\n\nCans\n* Three-dimensional worlds can have arbitrarily high numbers of polygons on che\nfloor.\n* Cant represent obstacles such as tables or chairs (because the floor exists beneath\nthese objects).\n* Requires algorithmic solution for choosing path points within a polygon.\n\nA B t o\nFIGURE 3.5.1. Four options for representing the search space.",
      "content_length": 1407,
      "extraction_method": "OCR"
    },
    {
      "page_number": 268,
      "chapter": null,
      "content": "Section 2 Artificial Intelligence\n\nPolygenal Floor Representation\n\nDescription\n\nAn artist or level designer creates a polygonal floor representation thar is used exelu-\nsively for pathfinding. The polygons can be eliminated in places where characters are\nnot allowed to walk, such as under tables or chairs, See Figure 3.5. 1c.\n\nPros\n* Simall search space representation,\n* (Can be walked through quickly with a BSP erce.\n* Obstacles can be incorporated in the representation.\n\nGores\n* Requires artist or level designer to construct.\n* Cant represent characters within che space.\n* Requires algorithmic solution for choosing path points within a polygon.\n\nPoints of Visibility\nOescriptian\n\nPoints are placed at convex comers in the world (sticking out a little from each cor-\nner). Each poine is then connected to all other points that it can “see”. This creates a\nconnectivicy graph that describes the minimal paths required to get around walls. See\nFigure 3.5. 1d\n\nPros\n* Creates minimal search space representation,\n* Obstacles can be incorporated in the representation,\n* Resulting paths are perfecely direct.\n\nCons\n\n* Requires alporithmic or designer assistance co create the graph,\n\n* Obstacles canit be removed from the graph if chey should be destroyed.\n\n* Cant represent characters within che space.\n\n* Doesn't work well with entities that have large widths, such as a wide formation\nof characters.\n\n* Worlds with curved walls could cause the graph to become unnecessarily com-\nplex.\n\nAs you can see, there is no obvious choice, Each representation has its trade-offs,\nIf your world is 31 with few dynamic obstacles, then using points of visibiliry is a rea-\nsonable choice. IF your world is 2D tile-based or there are hordes of moving characters\n(as im a large RTS game), a rectangular grid might be che best choice. Just remember\nthat your decision in choosing a search space representation has huge repercussions in\nterms of speed and flexibility,",
      "content_length": 1959,
      "extraction_method": "OCR"
    },
    {
      "page_number": 269,
      "chapter": null,
      "content": "3.5 A* Speed Optimizations = 275\n\nPoints of Visibility Explained\n\nSince using points of visibility is an extremely viable oprion, it's worth explaining a lie-\ntle better, The technique requires that you build up a praph thar can be used to get\naround the world. Points are placed at convex comers and connected to all other\npoines they can see. It's as though a freeway system has been constructed for che sole\npurpose of petting around walls, The problem now is how you get on and off the free-\nway:\nTo get on the freeway, you test the visibiliry berween che starting point and every\npoint on the freeway. Since you can potendally compare thousands of points, it's\nimportant that you use other space-partitioning techniques (such as hierarchical\npathfinding). Once you have a list of potential on-ramp points, you pur them on the\nA® Open list and begin running the algorichm. With each point you explore, you\nmust test its visibilicy with the goal poinc. If you find a point char can see the goal\npoint, you have a potendal off-ramp. Figure 3.5.2 shows a simple example.\n\nHierarchical Pathfinding\n\nHierarchical pathfinding is an extremely powerful technique char speeds up che\npathfinding process. Regardless of which search space represencation is used, this\ntechnique im effect simplifies that space. Therefore, if your world representation is\nlarge, there's still hope. The hey is to break up the world hierarchically.\n\nConsider a castle. Itcan be thought of as a single, large building or as a collection\nof rooms connected by doors (a large-scale connectivity graph). The pathfinder works\nin two distiner steps. Ic firsc finds the room-to-room path, knowing the starting and\nending room. Once thar room-ro-room path is known, the pathfinder then works on\nthe micro problem of getting from the current room to the next room on the list.\nThus, the pathfinder doesnt need ro compute the entire pach before it takes the first\nstep. The micro path is figured our on a need-to-know basis as each new room is\nentered. This method significantly cuts down on the search space and the resulting\ntime to compure the path.\n\nThis technique really shines if your world is already constructed hierarchically.\nEven a 3D world could be constructed using a simple building-block paradigm. Con-\nsider a circular staircase. Normally, a circular staircase causes most pathfinders a lot of\n\nFIGURE 3.5.2. Points-of-visibiliy example.",
      "content_length": 2417,
      "extraction_method": "OCR"
    },
    {
      "page_number": 270,
      "chapter": null,
      "content": "Section 3 Artificlal Intelligence\n\nFIGURE 3.5.3. Hierarchical pathfinding on a circular staircase.\n\ngricl, The structure is very 3D, mostly circular, and could spiral for a very long dlis-\ntance. A spiral staircase could be built using a quarter-turn piece of the staircase. This\npiece could then be duplicated indefinitely co create a very tall spiral staircase,\n\nA hierarchical pathfinder could blazingly compuse a path up the scaircase if it\nwere constructed in this fashion. The pathfinder would first compute che large-scale\nroute through each connecting quarter-turn piece and then would quickly find the\nlocal path from the start co the end of each quarter-turn piece, All of a sudden, a cam-\nplicated path over some rather complicated geometry becomes trivial to compute.\nFigure 3.5.3 shows an example.\n\nHierarchical pathfinding isn't restricted to rooms with doors. You can easily\nextrapolate the idea co huge fields of landscape thar are stitched together. Although it's\ntrue that there isn't one easily identifiable “door” spot anymore, the entire seam from\none field to another becomes the door.\n\nlinagine an immense world created with these stitched pieces of land. Now imag-\nine telling a character to walk from ome end to the other. No problem! The pathfinder\nfirst finds a route through the network of land pieces and then finds the local path\nfrom the current land piece co the next. With a litle work, you can even imagine\nplanning a route from the throne room of one castle to the ninth-level dungeon below\na completely different castle—even thaugh the castles might be 10 miles apart!\n\nAvolding Pauses While Computing Local Pathe\n\nSince a path is computed every time the character enters a new room, it’s important\nthar the character not pause at each door while his new path is constructed. In order\nto aveid a pause, the pach request must be anticipated and completed before the char-\nacter actually needs it. This simple trick keeps the character motion fluid throughout\nthe execution of the path.\n\nAlgorithmic Optimization\n\nPlaying with the Heuristle Cast\n\nDesigning an algorithm for the heuristic cost can at times seem more like voodoo\nthan science. The idea behind the heuristic cost is to estimate the crue cost from a par-",
      "content_length": 2251,
      "extraction_method": "OCR"
    },
    {
      "page_number": 271,
      "chapter": null,
      "content": "2.5 A\" Speed Optimizations 277\n\nticular node to che goal, Here's an inceresting fact: If you always knew the true cost to\nthe goal, A* would beeline a path to che goal without wasting any search time going\ndown the wrong path. Bur if the heuristic estimate happens co overestimate the crue\ncost, the heuristic becomes “inadmissible,” and the algorithm might noc find the opti-\nmal path (and might find a terrible parh).\n\nThe way to guarantee that the cost is never overestimated is by calculating che\nfeomenic distance beeween the node and the goal. When coding A” for the first time,\nthis is the best ching co do undil irs time co optimize. Since the cost will never be more\nthan this distance, the optimal pach will always be four.\n\nOverestimating the Heuristic Coast\n\nInteresting fact #2: Using a heuristic chat routinely overestimates by a little usually\nresults in faster searches with reasonable paths. However, how much should the cost\nbe overestimated? To answer this question, you need to understand what happens\nwhen this remaining pach cost is artificially bloaced_\n\nTf the heuristic part of the total cost (tote! core = cost so mode + Desristic cost) is big-\nger than it should be, ir distorts the reasoning by which nodes on the Open list arc\npicked off. Since A* always picks the node with the least total cost, this distortion pro-\nmotes nodes closer to the goal to be picked.\n\nWhen yout look at an wA* search that’s trying to fined its way around a wall, you can\nsec a shape that develops from the modes explored (nodes on the Closed list). This\nshape is the easiest way to see the effects of playing with the heuristic estimate.\n\nWhen the heuristic equals zero, the search evolves as a circle around the starting\npoine, When the heuristic uses the Euclidean distance to the goal, the search looks\nlike an oval, with che stare and goal points the foc. When the heuristic is overesti-\nmated, che shape changes to be more of a diamond or hexagon, with the start and goal\npoines ac che extreme corners of the shape, Figures 3.5.4, 3.5.5, and 3.5.6 show the\ngrowth of the search using various heuristic costs while trying to overcome a large\nobstacle.\n\nLd = =\nGon OAL &3 : Gs)\n\nFIGUBE 3.5.4. The heurtetic cost of zero.",
      "content_length": 2231,
      "extraction_method": "OCR"
    },
    {
      "page_number": 272,
      "chapter": null,
      "content": "278\n\nSection 3 Artificial Intelligence\n\ntt] = a\nWRAL. ool. OOaL\n\nFIGURE 3.5.5. The heuristic com using Euclidean distance to goal.\n\nFIGURE 3.5.6. The heuristic cost overestimaned.,\n\nWhat does all chis mean? It means that by overestimating the heuristic, the search\npushes hard on che closest nedes to the goal. This causes pressure for the search co\novercome large obstacles chat are between the start and goal points of the search. If the\nactual solution requires backtracking before going to the goal, an overestimating\nheuristic slows the search. However, if most of the time there's a way to get around\nlarge blocking obstacles, che overestimating heuristic is faster. Figure 3.5.7 illustrates\nthis point as the non-overestimating heuristic explores three times more nodes than\nthe overestimating heuristic.\n\nUlumarely, getting the right amount of overestimating requires experimentation.\nUnfortunately, if the search space is not on a grid, ir's probably not possible to accu-\nrately observe the shape of the search. Instead, you need to measure indicators such as\nthe size of the Closed list and the maximum size of the Open list.\n\nThe final size of the Closed List cells how many nodes were explored: the maxi-\nmum size of the Open list is a good indicator of how long it takes to explore each\nnode (since Open list operations take a relatively long time as the list prows big).\nWhen tuning your heuristic, you can ery cypical searches and watch che Open and\nClosed list sizes in order to identify good heuristic values, By testing searches on your\nactual game, you'll be able to tune the heuristic co something reasonable.\n\nDecoupling Pathfinding Data from the Search Space\n\nA® requires a large amount of memory in order to store the progress of each search.\nTraditionally, this memory is held inside each searchable node. If the search space is a",
      "content_length": 1855,
      "extraction_method": "OCR"
    },
    {
      "page_number": 273,
      "chapter": null,
      "content": "35\n\nA* Speed Optimizations 279\n\nSL.\n\nB Walk\n\n4? Fae Feih\n\nSooners Latiog Mewriate Chrepestind otha Vewrtarle\n18 Ex plonnd Mocks $0) Explored Sanna\n\nFIGURE 3.5.7. A DOn-cwencstimating heuristic va. an overestimating heuristic.\n\nrectangular grid, cach grid square contains pathfinding mode data. If the search space\nisa polygonal mesh, each triangle contains pathfinding node data. Since an individual\nsearch almost never covers every single node in the search space, there is mo reason to\nhave this incredible amount of memory dedicated to pathfinding. For example, a\n1,000 * 1,000 tiled world has | million pachiinding nodes just sitting there unused\nmost of the time.\n\nThe solution is to decouple the pathfinding node dara from the search space.\nThis solution reduces the huge memory overhead and could also speed up searches.\nInterestingly, by decoupling the node dara from che search space, you allow for simul-\ntaneous searches, which can now occur because multiple-node data can poine to che\nsame real node in the search space. However, it’s generally not a good idea to allow\nsimultaneous scarches—siill, in certain circumstances, it mighr be useful.\n\nPre-allocating a Minimum Amount of Memory\n\nDecoupling the node data from the search space requires char each search use some\nother chunk of memory. We could simply allocate node data on che fly, bur A* can\nchurn through hundreds of modes each search, so this isn't a reasonable solution. A\nway around this is co pre-allocate a sufficiently lange block of memory that can be\nrecycled for cach A®* search.\n\nWhat is A° storing so much off It's all the data that tracks the progress of the\nsearch. Por every node explored, the algorithm needs to save the following informa-\n\ntion:\n\n. A pointer to the parent node\n\nThe cost to get to this node\n\nThe total cost (eort + Aenoristic estate)\nWhether this node is on the Open list\nWhether this node is on the Closed list\n\nhi",
      "content_length": 1921,
      "extraction_method": "OCR"
    },
    {
      "page_number": 274,
      "chapter": null,
      "content": "Section 3 Artificial intelligence\n\n‘The idea is ta pre-allocate a ton of these nodes (call it the mode Aané). The actual\nnumber varies depending on the size of your largest search, Now, you done want to\npre-allocate too much memory, so this array should be able to enow if needed—or\nalternatively, force the search to give up.\n\nWhen A* explores 2 new node for the first time, it needs to ask for a frec node\nfrom the node bank When it gers a free node back, it needs te fill out the info in\norder to personalize it for this new node.\n\nStoring Explared Nodes In a Master Node List\n\nOnce a node has been personalized from the node bank, it needs to be put somewhere\nfor fast retrieval, The optimal data structure for this activity is a Aawh table, Hash\ntables allow constant-time storing and looking up of data. Therefore, we store all\nexplored nodes in this: master node lise, This hash table allows us to instantaneously\nfind our if a particular node is on the Closed list or the Open list, Remember, since\nthe node dara memory is already allocated, the hash table contains only pointers ta\nthese nodes.\n\nAr this point you might ask yourself, “Where is che Closed list?” The answer is\nthat it lives inside the master mode list. All explored nodes are stored inside the master\nnods list, and the Closed list just happens to be in the same place. This isn't a prob-\nlem, because each node is clearly marked as whether it's on the Closed or Open liss. So\nwhere does che Open list live? The Open list is maintained separately, dict the master\nnode list also contains pointers te all the same nodes that are on the Cpen list. Why\nthe duplication? Because sometimes it's faster wp find the nade you want using the\nmaster node list, and sometimes it's faster using che Open list. Ir's all about speed.\n\nWhen any given node is explored during the A* algorithm, irs possible thar che\nnode was already explored during this same search. ‘To make things simple, you'll\nwant a function that gives you back a pointer co thar particular node's dasa, whether\nits been searched before or nor.\n\nThis function first checks che master node list to see if the node has been explored\nbefore. If ic has, the function simply returns a pointer co thar existing node. If the\nnode is not in the master node list, a free node is taken from the node bank, it is ini-\ntialized to represent the desired node, and irs pointer is rerurned_ In effect, the func-\ntion completely hides the details of allocating mew modes from the node bank and\ngeting nodes char already exist.\n\nHode* GetNodel WasterWodelist nodelist, ModeLoration node location }\n{\n//GethodeFromlasterNodelist accesses the hash table of nodes\nNode\" node = GetNodeFromWasterNodelisty nodeliet, node location );\nif({ node ) {\nretura( mode )5\n\nelon\n{ /#Mot in the Master Node List — get mew one fron the Node Bank\nNode* nawiede = GetFreeNodeFrondodedank();",
      "content_length": 2885,
      "extraction_method": "OCR"
    },
    {
      "page_number": 275,
      "chapter": null,
      "content": "35\n\nA* Speed Optimizations 204\n\nnewNode->locatian = mode location;\nnewNode-ronOpen = false;\nnewhods ->orGlosed = false:\n\nffStoreahodelnMasterhadelist places the node inte the hash table\nStoreladelnMastarNodelist( modelist, newNode );\nreturn( newiede };\n\nOptimizing the Open Liat\n\nThe beaury of A* comes from its ability to direct the search toward the most promis-\ning directions. The way it achieves this goal is by putting all nodes it could search next\nimmo the Open lise. It then orders the list from the most Promising to de lease promis-\ning nodes to search. The problem ix that the Open list tends co get big, and each time\nit goes through the A* loop, the most promising node must be extracted from che list.\nThe node to extract is che one with the lowest total cost (cost fo get to the node + Bewris-\nBc entimate of the remaining cost to the goal), As it turns out, the best way to store che\nOpen list is co keep it sorted as a priority queue.\n\nA prtoriry queue can be implemented as a binary heap. A Ainary Aeap is a sorted\ntree thar has che property thar che parent always has a lower value than its children.\nHowever, there is no ordering among siblings, so a heap is nora completely ordered\ntee. Because of this interesting property, insertions and extractions (removing the\nlowest clement) take only Oflog n). Fortunarely, thar’s preery much all At needs to do\nwith the Open list.\n\nImplementing a Priority Queue\n\nIt's out of the scope of this article to implement a priority queue from scracch, but\nthere's an casy way to implement one using STL. Whether you're using STL or nor, be\nsure to check out 2 grear article about priarity queues [Nelson96). Ir describes prior-\nity queues Clearly enough that you could probably construct one withour the help of\nSTL. Otherwise, consult any standard algorithm and dara strucrure hook far more\ninformation.\n\nIn order ro properly use the priority queue, use the following four operations that A*\nneeds ro perform on the Open list:\n\nExtract the node with che minimum total cost (and resort the list): Ofleg 7).\nInsert anew mode on the Open list (and resort the list}: Oflog ni).\n\nUpeate the total cost of a node already on the Open list (and resort the listh:\nOfnedog m),\n\n4. Determine whether the Open list is empry= O(1).\n\nSTL actually implements a priority queue with something called a connainer\nadapter. However, the operations that can be performed on ir are very limiting. In\n\nFoes iP",
      "content_length": 2444,
      "extraction_method": "OCR"
    },
    {
      "page_number": 276,
      "chapter": null,
      "content": "282 Section 3 Artificial Intelligence\n\nfaet, it has no interface co perform operation #3 (updating a nodes total cost and\nresorting the list). Therefore, we can't use the STL implementation of a priority\nqueue. However, we can use the STL heap operations on an STL vector container co\nmake our own prioriry queue!\n\nLissings 3.5.1, 3.5.2, 3.5.3, and 3.5.4 coneain the four Open list operations along\nwith the node object, the heap object, and the STL comparison object—all imple-\nmented in C++ using STL, In addition, on the CD that accompanies this book, you'll\nfind that Greg Snook’s pathfinding article, “Simplified 3D Movement and Pathfind-\ning Using Navigation Meshes,” contains almost identical code for implementing an\nSTL prioricy queue.\n\nA* Using the Optimized Master Mode List and Open\nList\n\nThere's nothing too tricky about using che ideas presented, bur just in case, the eurs of\nthe A* algorithm are implemented in Listing 3.5.5 using the master node lise and the\nOpen list. Some other small wicks are also included, such as not searching the node\nfrom which the search just came.\n\nConclusion\n\nSince pathfinding is fundamentally a tough computational problem, the besc strate-\ngies have always been to simplify the problem. Before any effort is made to optimize\nthe algorithm, ensure that the world is represented in the simplest reasonable way.\nOnce that’s decided, ir's very importance that some kind of hierarchical scheme is also\nincorporated. Usually this scheme involves some pre-processing that requires level\ndesigners and artists to be very involved in the search space representation. Alchough\ninadds some overhead to the development of assets, there's no better way to speed up\nparthfinding.\n\nOnce the search space is finalized, it’s important to get the pathfinder working\ncorrectly in thar space before any optimizations are atcempred_ A™ is not a trivial alga-\nrithm, and it’s extremely difficult wo debug if many of the optimizations have been\nincorporated. When you are ready to optimize, start by decoupling the node memory\nfrom the search space, The next step is to implement a priority queue for the Open\nlist and a hash table for the master node/Closed list. Finally, when everything works\nlike a charm and the pame is stable, you can play with the heuristic cost. In order go\nget the bese results, you'll wane co rune the heuristic several times during development\nas the game world becomes better defined.\n\nAfter all these techniques have been implemented, che next step is co chear. Some\ntechniques for giving the impression of instantaneous pathfinding can be found in the\n“A® Aesthetic Optimization” article in this book. The trick involves making the player\nthink that a path has been found when in reality you are just stalling. If che player\nfeels chat the game is very responsive, the pathfinder appears to be unobtrusive and",
      "content_length": 2866,
      "extraction_method": "OCR"
    },
    {
      "page_number": 277,
      "chapter": null,
      "content": "3.6 A\" Speed Optimizations\n\nnransparent, which is the core reason for speeding it up.\n\nListing 3.5.1: Node Object\n\nclasé Hede\n\nq\npublic:\n\nNodelocation location; // lecation of node (some location\nff representation)\n\nNode* parent; ff parent node [zero pointer represants\nff starting node)\n\nfloat cost: ff cost to get to thie node\n\nflnat total; ff tetal cost (cost * hewristica estinate}\n\nbool anOpen; ff on Open list\n\nbool anGliosed: ff on Glosed list\n\nListing 3.5.2: Priority Queue Object\n\nclass PriorityQueue\n\n{\n\npublic:\n‘fHeap inplamentation using an STL vector\nfffiete: tha weetor is an STL container, but the\n‘foperations done on the container cause it ta\n(/D8 a priority queue organized as a heep\nStd: :vector<Node*> heap;\n\nListing 3.5.3: STL Comparison Function\n\n— ——\n\nclass NodeTotalGreater\n\n{\n\npublic:\n/Thia 18 required for STL to sort the prierity quave\nf/(ita entered as an argument in the STL heap functions)\nbool aperater()( Nede * first, Node ~ second ) const {\n\nratural first->total > second->total |;\n\nt\n\nIi\n\nListing 3.5.4; Four Open List Operations\n\nKode\" PopPriorityucuel PriorityQueues poweue }\nq {{Tatal time = Ofleg aj\n\n(fGet the nade at tha front — it has the lowest total cost\nBode * fodé@ = pqougua. heap. tranti ys",
      "content_length": 1238,
      "extraction_method": "OCR"
    },
    {
      "page_number": 278,
      "chapter": null,
      "content": "Section 3 Artificial Intelligence\n\n=\n\n‘/pap_heap will move the node at the front to the position WN\n‘fand then sort the heap to make positiens 1 through M-1 correct\n(f(5TL makes 0 assumptions about your data and dogsn’t want\n‘ite change the seize of the container.\n\nStd: :pop_heap( poueue.beap.begin(), pqueue.heap.end(},\nNodeTotalGreater() ;\n\nffpop_back() will actually remove the last element from the heap\nifimow the heap is sorted for positions 1 through Ww}\nqueue. heap. pop_back( );\n\nreturn{ mode };\n\n}\n\nvoid PushPriorityQueue( PriorityQuewea pqueve, Node\" node }\n{ J/Total time = O(log nj\n\n//Pushes the node ente the back of the vector (the heap is\n// now unsorted)\nPOvEUE heap. puch back( mode }3\n\n{{Sorte the new elegant into the heap\nSOI: push hesol powgue.heap.bagin(), pqucue.heap.end(),\nNodeTotalGreater() 4:\n}\n\nvold UpdateNadetnPriorityQueue( PriorityQueuek pqueuwe, Nada™ node i\n{ /ffTotal tine = O(mtlog nj)\n\nifleng through the heap and find the node to be updated\nstd: vector<hode*>::iterator i:\nfor{ i=pqueve.heap-begin(); il=pousue.heap.end(j; itt }\nif\nit( (*i)-slacation == node->Location |\n{ /fFound made = resort from this position in the heap\nfi(since its total value was changed before this funetion\nifwags called)\nata: push _heap( pqueve.neap.begin(), i+t,\nHodeTotalGreatar() J:\nreturn;\n\n}\n\nbool IsFriorityQueucEnpty( PriorityGueuek pquewa }\n{\nffempty() 48 an STL function that determines if\nifthe STL vector has no alemente\nreturn( pqveue.heap.enpty() J:",
      "content_length": 1480,
      "extraction_method": "OCR"
    },
    {
      "page_number": 279,
      "chapter": null,
      "content": "3.5 A* Speed Optimizations —\n\nListing 3.5.5: A* Implemented with a Master Node\nList and a Priority Queue Open List\n\nMasterliadeList g nodelist;\n\nbool FindPath( Gasedaject* ganechject, Worldlocation goal 4\nt\nif/Get & path in progress aif it exists for this gene abject with\n// this goal\n(fA Path may have Been started and not finished from Jast game tick\nfiTf 00 path in progress, it raturna an empty path structure\nPath* path = GetPathiInFrogress{ gamecbject, goal }:\n\nif( lpath=>initialized j\n\n{ (ithe InitializePath function fills out the path structure for\nffthis path reguest\nFfTt initializes a clean WasterNodeList and a clean Open list\nInitializePath( path, gamgahject, goal 4;\n\nifCreate the very first mode and put it on the Open list\nWode* startnode = GetNode( g nodelist, GetNodeLocation|\ngameabject-spos ) };\n\nStartnode-+onQpen = true; SiThas node goes on Open List\nStartmode-sonGlesad = falsa; (This node. not on Glosed list\nStartnode->parent = 0; {i This node has no parent\nStarthoade-scost = 03 {/This node has no cast to get to\n\nStartnade->total = GetNomeHeuristie( startnode-=location,\npath. goal js\nFushPriorityOueue( path.open, startmode );\n\n}\n\nwhilet (IsPriorityduaueEnpty( path-sopen } )\n\n|\n/#Gét the best candidate node to search next\nNode\" bestnode = PopPrierityQuewe( path.apen );\n\nif( AtGgal[ bestnode, goal | )\n\n{ ffFound the goal mode — construct a path and exat\nifthe complete path will be stared inside the gane object\nGonstructPathToGesl( ganeobjest, path 4;\nretura{ true Mi hipetirn with success\n\n}\n\nwhile! f*leop through al] connecting nodes of bastnode*/ }\nf\n\nNode newnde;\n\nneamode.location = /*ehatever the new location is*/:\n\n[This avoids searching the node we just came tron\nif( bestnoda-=parant == 0 |!\n\nbastnade->sparant-*Location {= newnode.location |\n{\n\nnewnade.parent = bestnoda;\nhewnnde.cogt = bestnode-scost + GostFromNadeTonode |",
      "content_length": 1871,
      "extraction_method": "OCR"
    },
    {
      "page_number": 280,
      "chapter": null,
      "content": "Sectlon 3 Artificial Intelligence\n\ndnewnods, bastnode 7\nhewniedd.total = ngemode.cast:\n\nffGet the preallocated nada for this location\n\n(Both mewnode and actualnode represent the same node\niflotation, but the search at this point may not want\nifte ¢loabber over the data fram a more promising route —\niithus the duplicate nodes for now\n\nHoge* actualmoda = GetNode( g_nodelist,\nnownode, location );\n\n/iKote: the Tollowing test takes O(1) time (na sé#arching\n/ithrough lists)\nif{ !( actualnode-sandgen £8 noenode.total >\nactualnode-=total ) 4&4\n'( actualnode-sanClosed A newnode.totel >\nactualnade->total | }\n{ JitThis node is very pramising\n(Take it off the Open and Closed lists (in theory)\nFfand push on Open\nactualnode--ontloged = false; /fetteactively removing it\nfitrom Glosed\nactualnode->parent = agwoods. parent;\nactualnode->ceet = nownode.cost:\nactwalnode->tatal = nowneda, total:\n\nif{ actualnade-sonQpen }\n\ni #fSinee this node is already on the Open list,\nffupdate it's position\nUpdatenodadaPriorityQueua, path.apen, actwalnode j:\n\n}\n\nelse\n\n{ ff Put the node on the Opan List\nPUSHPriorityluewe! path.open, actualnede };\nactualnede->ontpen = true:\n\n}\n\n}\n}\n\nifMow that we'ws explored bestnade, put it on the Glosed list\nbestmada-sonClosed = true;\n\nFfUSG 50m methed to determine if we've taken too much time\nFfthis Tick afd should abort the search until next tick\nif({ ShouldAbortSearch() ) {\nreturn( false };\n}\n\n}\n\nHitt wa got here, all nodes have been searched without finding\nfithe goal\nreturn{ talse );",
      "content_length": 1510,
      "extraction_method": "OCR"
    },
    {
      "page_number": 281,
      "chapter": null,
      "content": "3.5 A* Speed Optimizations 27\n\nReferences\n\nA® Algorithm\n\n[Heyes-Jones98] Heyes-Jones, Justin, “A* Algorithm Tutorial,” available online at\nwww.gamedev.net/ reference! programming/ai/article690,asp, 1998.\n\n[Parel99] Patel, Amic J_, “Amit's Thoughts on Pathfinding,”” available online at\nhtrp.! cheory.stanford.edu/-amitp/GameProgramming/, November 27, 1999.\n\n[Stouts] Srour, Bryan W., “Smart Moves: Intelligent Path-Finding,” Creme Devel:\naper, —October!Nevember 1996, pp. 28-35, also available online ar www, gama-\nsutta.comfeareres! 1021 2/em Obes.\n\nData Structures\n\n[Lewis91] Lewis, Harry Ru, Dine Srrwcrures artel Ther Alport, HarperCollins Pub-\nlishers Inc, 1991.\n\n[Nelson96)] Nelson, Mark, “Priority Queues and the STL.” Or Dabbi fournal, also\navailable online at www.dogma.net/marke/articles/pq_sel/priority htm, January\n1996.",
      "content_length": 832,
      "extraction_method": "OCR"
    },
    {
      "page_number": 282,
      "chapter": null,
      "content": "3.6\n\nSimplified 3D Movement and\nPathfinding Using Navigation\nMeshes\n\nGreg Snook\n\nGerting an object to move from Point A to Point B intelligently has always been a\nchallenge for the game programmer. Doing the same for an object in 3D Space is a\ngrearer challenge still. In today’s world of complex 31 environments, the task can\nbecome overwhelming. This article proposes a rather simple method to help over-\ncome these obstacles and get all your objeccs safely to Point B wich the least amount\nof work: Ghear.\n\nYes, chiear. Rarely do real-time games have the time to compute true 3D) objecc-\nto-scene interaction and pathfinding, and the code complexity wo do so is often\nunnecessary for most applications, We are here to find the easier way out. We seek a\nsimple, extendable method to roll our dice and move our mice in a way that looks\nbelievable to the player. Ler’s face it: The easiest ways almost always invalve cheating.\n\nIn a Nutshell\n\nWhat we need is a way to simplify 31D space into more familiar 21D terms. Objects in\n2D space move in a highly predicable fashion and can be controlled very intuitively\nby the player. In addition, there isa myriad of 2D search algorithms at our disposal to\ncreate intelligens parhs for our objects to move on. Whar we will create is a method\nallowing our objects to function in a pseudo-3D environment while providing a full-\n3D presentation for the player. To do this, we employ a mesh of triangular polygons\nto represent our 3D space as a warped 2D playing field,\n\nThe idea stems from the fact thar, for most game environments, you can pretry\neasily predict where objects can and cant move. From thar information, a simple ser\nof geometry can be created to define this area as a “walkable” surface area, One way to\nvisualize this area is to imagine a room within a typical 3D environment. Since your\ncharacters are humanoid and the planet hosting the came has gravity, you can assume\nthe game objects will spend most of their time on the floor of this room. You can also",
      "content_length": 2015,
      "extraction_method": "OCR"
    },
    {
      "page_number": 283,
      "chapter": null,
      "content": "3.6 Simplified 30 Movement and Pathfinding Using Navigation Meshes 289\n\nFIGURE 3.6.1. A 31 environment with the associated navigation mesh drawn in wireframe.\n\nassume that they wont be walking through the pillars, desks, soda machines, and\nother objects sharing the floor space. We can define che remaining portions of the\nfloor with some simple, coarse geometry that covers the open, walkable surface area.\nThink of this geometry as a sort of polygonal carpet, which we refer to as a navigation\nmea. Tt represents the area around which your objects can meve within the environ-\nment, Figure 3.0.1 shows the 31D environment used in the mertmerh program avail-\nable on the CD thar accompanies this book. The wireframe polygons show the\nfavigation mesh, which defines the area where objects can move.\n\nIn a sense, this navigation mesh object can be treated like the grid systems\nemployed by 2D tile-based games. Each polygon of the mesh can be thought of as a\ngrid cell, except that they artach to adjacent cells on chree sides instead of four, With\na bie of effort, we can even use this mesh for traditional grid-based algorithms such as\nline-of-sight detection and pathfinding, The added bonus is that our replacement for\nthe 21D grid can have cells of irregular shape and size, wind up and down srairs and\nhills, and even overlap irself on things like bridges and carwalks—all while providing\naccess to the same time-tested 2D algorithms we all know and love.\n\nUnlizing a navigation mesh can also reduce the amount of collision testing\nrequired berween an object and its static environment, Since the navigation mesh\nalready represencs an approximation of the open surface area in the environment, our\nobjects need collide with only the mesh edges rather than the true scene geometry. By\nProjecting a control point from the object onto the mesh, we can casily track ebject\nmovement and collisions with 21D line intersection tests rather than full 3D polygon\nintersection, In cases in which higher detail is needed for collision, che mesh cells can\nstill link to sets of rue scene geometry for refined testing. Objects char collide with a\ncell edge would chen be passed onto routines that resolve the collision with the associ-\nated room geometry. Linking process dara with che cells in chis manner serves as a",
      "content_length": 2310,
      "extraction_method": "OCR"
    },
    {
      "page_number": 284,
      "chapter": null,
      "content": "250 Section 2 Artificial intelligence\n\nquick-and-dirty proximity test for objects in motion, an idea that can be extended to\ntigger traps, doors, or switches whenever an object enters a given cell or collides with\na particular edge.\n\nConstruction\n\nNavigation mesh geomerry needs to adhere to a few simple rules in onder to work cor-\nrectly. First, it needs co be compased completely of wiangles co ensure chat each cell is\ncontained in a single plane. Second, the entire mesh must be contiguous, with all\nadjacent triangles sharing two vertices and a single edge. Finally, no cwo triangles\nshould overlap on the same plane. That is, any piven point within a triangular cell\nshould be exclusive to thar cell. This will aid our algorichms immensely and provide\nbelievable movement for che player.\n\nThe navigation mesh is mor intended to be vistble to che player. We use it only\nbehind the scenes co limic character movement and determine paths. Therefore, it\nneed consist of only the minimal amount of polygons necessary to represent che area\nin which objects can move. Highly detailed navigation meshes might produce che\nmost accurate resules, bur their overhead would be a limiting factor for mast real-time\ngames. The mesh should be one that contains only che cells necessary to facilitate\nbelicvable movement to the player, not one that represents every pebble and twig on\nthe prownd.\n\nRoll the Dice and Move Your Mice\n\nTo begin, we first examine using the navigation mesh to conrol object movement in\na 3D environment. Once we have our objects happily interacting with the mesh, we\ncan extend its use for pathfinding and line of sight. Bur firse chings first: We need to\nget some objects moving around the confines of the mesh geometry.\n\nWeattach objects to the mesh using a. control point that will he locked to the nav-\nigation mesh surlace. This control point may never leave the mesh, but it can move\nabout the surface of the mesh ac will. Using our polygonal carpet example, imagine a\nperson standing in a room. The concrol point can be visualized as a marble sitting\ndirectly below the person, resting between his ar her feet. Wherever the person is\nmoved in the room, the marble rolls along, always maintaining a position on the car-\npet directly under the person.\n\nAll desired object movement is transferred ea this control point, which, in wen,\ngers resolved on the surface of the navigation mesh, The object is then moved relative\nto the new control point location. In our example, kick the marble and let it ricochet\noff the walls, then move the person to the new marble location.\n\nThe basic procedure is as follows, giver that each object maintains a control point\non the mesh and we know which cell of the mesh currently contains the concral\n\nPoint:",
      "content_length": 2765,
      "extraction_method": "OCR"
    },
    {
      "page_number": 285,
      "chapter": null,
      "content": "a6 Simplified 3D Movement and Pathfinding Using Navigation Meshes 254\n\nI. Project the object's desired motion vector onto the plane of its current cell. This\ntranslares the motion into a 2D vector along che plane of the cell. We'll call this\nnew vector a motion path and represent it asa 2D line segment. The endpoints af\nthe segment are the starting location of the control point and the desired ending\nlocation, bork translated to 2D space relative to the plane of the cell,\n\n2. Test the motion path against the cell’s 2D triangle edges. Duc to the nature of rri-\nangles, we know that for our path to exit the cell, ic must intersect with exactly\none side of the triangle. So, we cest the 2D) line segment of the motion path\nagainst the three line segments representing the cell wiangle for any possible inter-\nsections. There can be only one of three possible results to this test:\n\na) Our path intersects with an unshared edge (Le., an edge not connected to an\nadjacenc cell). This means we have hit something solid. Resolve the collision af\nthe motion path vector and the cell wall, adjusting che motion path ro aceount\nfor any change in direction, and repear Step 2.\n\nb) Our path intersects with a shared edge. Mave to the adjacent cell and nepeilt\nthe entire process from Step 1, projecting our current veetor to the plane of che\nnew cell and resting against its walls\n\n¢) The only remaining possibiliry is that our motion path does mot exir the cur-\nrent cell. We have reached the end of our process and found che cell char hosts\nthe object's new resting position. We translate our resulting 2D motion path\nendpoint back into 3D space ta find the ruc 31D location of the control point\nand move the object relacive to it.\n\nObviously, for complex navigation meshes, this can be a very cumbersome process,\nFor each cell encountered, we need to project an arbitrary 3D vector onto a 3D plane.\nFrom there we translate the resulting vector along with the cell edges to 2D space,\nwhere we can perform our line intersection rests, Once finished moving abour the\nmesh, we need to unde the translations and projections to produce our new contol-\npoint position in 3D space.\n\nThat's quite an effort to undertake in real time, especially if you have many\nobjects to test or your objects plan co cravel over many cells in a given frame. For sim-\nple environments, however, this could he plausible and allows for che greatest flexibil-\nity in navigation mesh geometry. For complex environments, we can still speed up the\nprocess considerably with a bir more careful planning (read: cheating) and an addi-\ntional navigation mesh geometry rule: Ja facilinare fas projections. all cell normale mrest\nface in the same direction along a predetermined cardinal axis.\n\nImagine our room again with the navigation mesh carpet on the floor. All cell\nnormals of the floor point up, so they meer this new requirement of our mesh, That\nis to say; all cell normals have a positive y value in our environment, Note that we do\nhot require our new savigation mesh ro be flat, we simply no longer allow cells whose\nnormals are 90 degrees or more away from our chosen axis.",
      "content_length": 3148,
      "extraction_method": "OCR"
    },
    {
      "page_number": 286,
      "chapter": null,
      "content": "Section 3 Artificial intelligence\n\nWith this new cule, the projections become incredibly simple, We simply throw\nout the dimension along the axis we have chosen. In our carpeted room example, pro-\njecting points onto the floor is now as simple as throwing their y values our the win-\ndow. In addition, when we have finished the Motion Path processing along che\nnavigation mesh cells, we have a new 2D (x, z) location and the cell that contains it.\nUsing the cell's plane equation, we can solve for y using our (x, z} location and trans-\nform ourselves back into 3D) space easily. Qur new motion-tracking process is reduced\nwo the following:\n\n1. Create 2 motion path consisting of the concrol point and the desired location,\nreduced to 2D points by tossing out their common axis values.\n\n2. Test the 2D motion path against the sides of the cell criangle as before until a cell\nis found chac contains the destination endpoint of the motion path.\n\n3. Using our new (x, 2) control point location and che plane equation of the cell it\nresides in, solve for y and reconvert our control point back into 3D space,\n\nThe #tarimiert sample program includes some simple classes thae illustrate chis\nprocess. In the source code, an object called Navigation Cell is used to represent a sin-\ngle triangular cell, and NiwigationsWest represents a collection of chose cells. Ler's first\ncamine MaigetionCell, since ix does most of the work.\n\nNevigetionCel defines a single cell of the mesh with the following members:\n\nPlane m_CellPlane; // A plane containing the cell triangle\nvectors m_Vertex[3]; ff the threes vertices of this cell\nLing2D m Side(a]; // a 20 line rapresenting each call wall\nNavigationGell* m_Link[4]; ij pointers ta celle that attach to\nff this cell on gach of its three\nff sides. A WOLL link danotes a solid\nif edge.\n\nVectors, Plane and Line2D are premy straightforward workhorse classes whose\nsource code is also provided. One point of distinction is that Line2D is really treated\nasa ray passing through wo poincs. Ir hasan implied direction, fram Endpoint A to\nEndpoint B. It also tracks a perpendicular “normal” for che 2D line segment. This\nnormal is used co classify points as being cither on the Lime’s left or right side, These\nnotions of “left” and “right” are defined as though you were standing on Endpoine A\nof the line looking toward Endpoint B, As you see in che source code, the ability to\nclassify points in relation to the line is used quite heavily in our motion processing.\n\nThe main use of NavigatonCell is to perform the seep in our process where we\ndetermine how a path interacts with the walls of a cell. NavigusionCell contains a\nmember function to classify a 21D line segment to its chee cell walls and return a\nresult. This function, ClassifyPathToGell(), is the basic building block of navigation\nmesh use. The return value of this function can be one of the following enumerated\ntypes:\n\nenum PATH_AESULT",
      "content_length": 2935,
      "extraction_method": "OCR"
    },
    {
      "page_number": 287,
      "chapter": null,
      "content": "2.6 Simplified 3D Movement and Pathfinding Using Navigation Meshes 293\n\n{\nNOLRELATIONSHIP = 6, fy the path does not cress this call\nENDING _CELL, if the path ends in this cell\nEXITING_CELL ff the path exits this cell\n\nbi\n\nTn the case where EXITING_CELL is the result, che cell wall traversed as well as che\n2D point of intersection with the wall are provided to the caller, This allows us to\ncompare any 21D pach w the cell and determine what type of intersection occurs,\nWhen an intersection with a solid edge occurs, we can use the point of intersection to\ncalculate our new direction and retest. Listing 3.6.1 shows the ClassifyPathToCell(}\nfunction in detail.\n\nNavigarion/ew uses this Function as needed to process our movement as defined\nin the preceding steps. The Nevigarion/ feo’ member function ResolvewotaondnWesh{)\nmanages the entire process, testing cach cell encountered using ClassityPathTacell().\nIt takes ina 31 concrol point, a pointer co che cell is is currently occupying, and the\ndesired location for the control point after movement has occurred, Ir returns to the\ncaller the true final location of the control point and the cell the new control poine will\nreside im. Listing 3.6.2 details the use of the Resolveliotiondnvesh() function.\n\nGetting There Is Half the Fun\n\nNow thar we have seen how to use the navigation mesh to control object movement,\nwe can look into other applications for che mesh. The first obvious use is pathfinding,\nKeep in mind that our mesh consists of linked cells, which share common edges, just\nlike a gid or hex map. Any path-finding algorithms traditionally applied to a grid or\nhex map should then reasonably translate co our euesh,\n\nAsa mater of fact, using polygonal meshes for search algorithms is no new feat.\nSince path-finding algorithms were designed to work over databases of linked node\ndata, they work quite nicely across sets of linked vertices. As game programmers, we\nhave become too accustomed to seeing these methods applied co grids and hexes,\nwhich is only a stall subset of the environments within which they can be used_\n\nUsing our navigation meshes, we do add one small wrinkle to the path-finding-\nover-polygons methed: We don't use the mesh vertices. Instead, we use the midpoincs\nof each cell wall. Why? Two reasons come to mind, both of which are arguable\ndepending on your game environment, The first is that we are also using our naviga-\ntion mesh oo limit object movement in the environment. If we generate a path along\nthe cell vertices, we are always traveling on the edges of the cells. This is the most\ncostly movement on a navigation mesh, since moving down che edge of a cell cxactly\nMeans you are constantly colliding with the cell edge, causing a lot of extra, unneces-\nsary IMGEDSOction bests,\n\nThe second reason is purely aestherie. If we assume our mesh was designed to use\nthe minimal number of polygons, ir stands to reason thar there are not many vertices",
      "content_length": 2948,
      "extraction_method": "OCR"
    },
    {
      "page_number": 288,
      "chapter": null,
      "content": "Section 3 Artificial Intelligence\n\nFIGURE 3.6.2. [wo overhead views ofa sample hallway and navigation mesh showing a\npath a: generated along cell edges and 6: through cell wall midpoint:\n\nor polygon edges in the body of our open space. Have a look at Figures 3.6.24 and\n3.6.2b, which show an overhead view of a hallway, and a reasonable number of paly-\ngons to define the open space within ic. If we generated a pach on the cell edges (Fig-\nure 3.6.2), we would spend mast of our time dragging ourselves against the wall of\nthe hallway. Using the cell wall midpoints (Figure 3.6.2b), we can generate a more\nvisually appealing path down the body of the hallway,\n\nfis [ said, both reasons are arguable. You could simply increase the complexity of\nyour navigation mesh and add code to avoid paths that drag along the solid edges of\nthe mesh, bur | have found it easier (and concepeually more inmicive) co move\nthrough the wall midpeints. In application, it has alse proved to be easier for che level\ndesigners creating the mesh to work withour having to concern themselves with che\nplacement of extra vertices and cell edges for pathfinding, In essence, all we have\nreally done is offset our mesh vertices to create a more believable path.\n\n30 how do we build the path? As in any path-finding situation, you need to\nchoose the best method for your game environment. Best-first searching, Dijkstras\nalgorithm, and the venerable A* can all be applied to the cells of our navigation mesh.\nEbewhere in this boak are some excellent explanations of the various search methods,\n50] will not ga inte detail on them all here. Check our the articles by Steve Rabin and\nBryan Stout in this book for detailed information on A*. You can also check the ref-\nerences at the end of this article for some recommended reading on pachfinding.\n\nFor demonstration, the save) ample code shows how to use A™ on the navi-\ngation mesh. Although it can be the most complex method co employ, A* can achieve\nhighly accurate results and is often more efficient than other methods in terms of\nmemory use and search time. However, its efficiency hinges on the use of a good\nheuristic. ‘The heuristic helps steer the search algorithm toward the goal, preventing it\nfrom fanning out all over che mesh unless necessary.\n\nThe best heuristic to use is purely a game-specific matter. Only you know how\nwell your objects move over your game's rerrain, and you need to tune your heuristic\naccordingly. You might even need to tailor separate heuristics for each object type,\ntaking into account its ability to climb steep grades, corner at high speeds, and so on.",
      "content_length": 2620,
      "extraction_method": "OCR"
    },
    {
      "page_number": 289,
      "chapter": null,
      "content": "3.6 Simplified 30 Movement and Pathfinding Using Navigation Meshes 285\n\nIn most cases, however, this heuristic is simply the approximate distance from a given\ncell to the goal. For the purpose of our demonstration, this is the heuristic we employ.\n\nTo run the A* algorithm, we maintain a list of cells char need to be processed. In\nthe manimesh sample code, these “Open” cells are held in an ordered list called a Naw\nigationteap. Cells are listed in the order of best ta worst cost in terms of the distance\nrequired to reach the goal. Therefore, each time we pull a cell off the heap, we know\nwe are dealing with the current “best guess\" of the cell thar will provide the best path\nto our goal,\n\nTo begin pathfinding, we need to stoke the heap with the first cell, our destina-\ntion. We then pop and process each cell on the heap until we reach our starting posi-\ntion of man out of heap. [the heap runs dry before we reach the goal, we know there\nis mo path available berween our two locations.\n\nTo process a cell, examine each of its neighbors. We determine the distance rrav-\neled to reach each one by adding the cost associared with our current cell to the dis-\ntance required co cross the cell co cach neighbor. This Arrive! Case for each neighbor\nis then added to the neighbors’ own heuristic values co arrive at a priority score fos\neach of the neighboring cells.\n\nWe now examine the score, or cost, of cach neighboring cell to do one of revo\nthings, If the neighboring cell is not currently in the Open heap, we must sore it by its\nscore value. This essencially purs it off for later processing. If the cell is already in the\nheap, we need to see if our new score is berter than the score by which the cell is cur-\nrently sorted. IF che new score is an improvement, we need co move the cell up within\nthe heap to its new priority position for earlier processing. If the new score is not an\nimprovement, we toss it out, since a more optimal path already passes chrouph this\ncell. In either case, each time a cell is added to che heap or repositioned within che\nheap, we record che identiry of the cell thar has sec the current Aniual Case.\n\nThis is done so thar the cells can keep track of the next closest cell to the destina-\ntion along the generated path. You'll notice that the mepinresh sample runs the A*\nalgorithm in the reverse search direction, starting at the destination cell and searching\nfora path backward te our current location. When the search is complere, each cell\ncontains a link co the next cell closest to the goal along the generated path. We can\nhop through these links in the proper order, from current location to destination, and\nbuild a final waypoint list for our game object.\n\nIn the sample code, the entire process is run by the Bui ldNavigationPath() mem-\nber function of the Mergarionesh class. It uses the NavigationHMeap object to main-\ntain a list of NaeigarionCels to be processed. As each cell is pulled from the heap, its\nProcessCell() function is called, which does the work of testing each neighboring\ncell, as outlined previously, Cells are added or moved within the heap as necessary,\nuntil a pach as found. Ar that point, SuilgNavigationPath() iteraces through the cells\non the path, adding their wall midpoint co the final NawigurionPanh waypoint list.\nSource code for the entire process is shown in Listing 3.6.3.",
      "content_length": 3367,
      "extraction_method": "OCR"
    },
    {
      "page_number": 290,
      "chapter": null,
      "content": "Section 3 Artificial Intelligence\n\nIt Works, But It Ain't Pretty\n\nAs you can see by the blue lines drawn in the marines’ sample program, building a\npath through polygonal objects yields a very jagged result. Very rarely will you find\nthat your navigation geomienry is set up to produce a straight-line path. The nature of\nthe mesh forces our path to meander from cell to cell, making many abrupt twists and\nturns (see Figure 3.6.34). Any object that uses this path verbatim will look very odd\nindeed to the player. Luckily, we have one final application oo discuss thar can smooth\nthe path our considerably: line-of-sight determination.\n\nBack when we were working out how to move objects around the mesh, we\ndefined a function, ClassifyPathToGeli(), co compare a 2D line of mation to a cell.\nThe result of dhe function told us whether che path ended within the cell, encoun-\ntered a solid edgc, of passed through to an adjacenc cell. We can now use that function\nagain wo perform a line-of-sight test. smoothing our our path by skipping ahead to the\nfurthest visible waypoint.\n\nFach time we arrive ara waypoint in our path, we look ahead to the next few way-\npoines in che list. By creating a line of motion from our current position to each of\nthese waypoines, we can quickly test if the waypoint are “visible.” To do this, we test\nthe path against each cell between our currenc position and the waypoint using the\nClassifyPathTocell() function. If the function rerurns a solid-wall intersection, we\nknow the waypoint is not visible from our current position. Conversely, if we reach\nthe waypoint without such an intersection, we know the point is visible to us. By\nsearching for the furthest visible waypoint up the chain, we can skip over some of the\nmeandering waypoints and smooth out our path. Figure 3.6.3b shows the new\nsmoother path generated by skipping over the redundant visible waypoints.\n\nThis method can be used for all sors of visibilicy testing. Using our Glassity-\nPath Toceli() function, we can test whether any cwo points on the mesh can see each\nother. This has some very useful applications in enemy Al, since you can quickly test\nwhether enemy objects can see the player's position ar any given moment. The Line-\nOfSightTest() member function of che NavigurionMenh class details the process for\ndetermining point visibility.\n\n[ah qb)\n\nFIGURE 3.6.3. a: A sample path generated using A®. & The same path smoothed using line-\nof-sight testing.",
      "content_length": 2463,
      "extraction_method": "OCR"
    },
    {
      "page_number": 291,
      "chapter": null,
      "content": "2.6 Simplified 3D Movement and Pathfinding Using Navigation Meshes 207\n\nConclusion\n\nee\nT hope this article has demonstrated char 31D space need nat be so computationally\ncomplex. My goal was to show thar using familiar 2D methods (and a bit of cheat-\ning), we can greatly simplify the game environment withour impacting the player's\n3D experience. The end result is a very flexible and useful tool for moving objects\naround in 3D space without a boatload of 3D math.\n\nThis method allows you to reduce object/scene collision operations, create com-\n\nplex paths, and test for the visibility between any two paints in the environment space.\nHowever, there is still more that can be done with navigation meshes, They can be con-\nstructed of high-order primitives rather than rigid triangles, ressellated like multireso-\nlution meshes for greater path finding detail near che camera, or even animared to\nrepresent fluid surfaces, For now, I leave the exploration of these ideas to you. Give the\nmeshes a try and sec what new uses you can layer on top of chis foundation.\n\nListing 3.6.1: Intersecting a 2D Line with a Cell of\nthe Navigation Mesh\n\nHawigationGell: |PATH_RESULT MavigationCell: :ClassifyPathToCell [const\nLine2D& MotionPath, NavigatianGell** pNextCell, CELL SIDES Bide,\nvVector2\" pPountOtintersectian) const\n\n{\n\nint Interiorount = Oo;\n\nif Gheck our MotienPath against each of the thraa cell\n\nff walle\nfor (int 1-0: <3: s4i)\n{\n\nff Glassify the WotionPath endpoints as being either\nff QOM_LINE, or to its LEFT_SIDE or RIGHT SIDE,\n\nfi Since our triangle verticas are in elockwise order,\n‘f we Know that points to the right of each ling are\nff inside the sell. Points to the left are outside,\nff We do this test using the ClassifyPoint function of\nff Line2n\n\nff If the destination endpoint of the BotionPath\nff is Not on the right side of this wall...\nif (m_Sidé[i)-ClassifyPoint (MotionPath.EngPointB()} !=\nLine2D; :AIGHT_SIBE)\ni\nPf ..8td the starting endpoint of the iotiLonPath\nff is WOt on the lett side of this wall...\nif\n(f_Side]i] .ClassityPoint(WotionPath-EndPointar)) !=\nLine2t: :LEFT_SIpe)\n\nff Check to see if we intersect the wall\nif using the Intersection function of\nfi Line2o",
      "content_length": 2193,
      "extraction_method": "OCR"
    },
    {
      "page_number": 292,
      "chapter": null,
      "content": "238 Section 3 Artificial Intelligence\n\nLine2i: :LINE CLASSIFICATION IntersectRhesult =\nWotionPath.Intersactiom(m_Sideliy,\npPointhf Intersection) ;\n\nif (intersecthesult ==\nLine20: ;SEGMENTS_INTERSEGT ||\nIntersecthesult ==\nLine20; :A_BISECTS_B)\n{\nff record the link to the naxt\nfi adjacent cell for NULL 4f ae\nfi attachment exists) and the\nfi enumerated ID of the side we hit.\n\n\"pNextGall = m_Link[iJ;\nSide = (GELL_SIDE)i:\nreturn {EXITING CELL);\n\n}\n}\n}\nelse\n{\nff The destination andpeint of the MotionPath\nff is on tha right sid#. Inerement our\nff InteriorGount #9 we'll know how many walls we\nf/f were to the right of.\nInteriorfount+;\n}\n\n}\n\nff An interiarGount of 9 means the destination andpoint of\nff the MotionPath was on the right side of all walls im the\nff ooll. That meane it is located within this triangle,\n\nff and this is cur ending cell.\n\nif (IinteriorCount == 3)\n\n{\n}\n\nreturn (ENDING CELL};\n\nif We reach here only af the MotionPath dees not\nif intersect the cell at all,\nreturn (NO_AELATIONSHEP) -\n\nListing 3.6.2: Resolving Motion on a Navigation\nMesh\n\nwold NavigatLonilesh::ResolveMotiondeMesh(const vectora& StartPos,\nNavigationCell* StartCell, vectord& EnoFos,\n\nHavigationCell** Endtell)\n\nt\n\nff create a 20 motion path from our Start and End",
      "content_length": 1255,
      "extraction_method": "OCR"
    },
    {
      "page_number": 293,
      "chapter": null,
      "content": "2.6 Simplified 30 Movement and Pathfinding Using Navigation Meshes 258)\n\nff positions, tossing aut thair ¥ values to project them\nff dow to the Zz plane.\n\nLinezD MationPath(vectore (Starthos.*,StartPos.z),\nveetor2(EndPos.«,EndPos.z});\n\nff these three will hold the results of our tests against\nff the cé#1l walls\n\nNawigationGell::PATH RESULT Result =\n\nNavigationCell : :Mo RELATIONSHIP:\n\nNavigationGell::GELL SIDE Wal lhuaber;\n\nvector2 Polntotintersection:\n\nNavigationGell\" MextCell;\n\nff TestOell ds the cell we are currently examining.\nNavigationGell* TestCell = Starttell;\n\nif\nif Keep testing until we find our ending cell or stop\nI @oving due to triction\nil\nwhile ((Result I= MavigationGell:: ENDING CELL}\n£4 (MotLonPath.EndPaiatat) =\nUotionFath.EndPointe( )})}\n\nifouse NavigeationCell to determine how our path and\n\nff call interact\n\nResult = Test0ell->ClassityPathTotell(MotionPath,\nSNextCell, WallMunber, &PointOf Intersection) ;\n\nff aif exiting the ¢ell...\nif (Result == NavigationGell::EXITING CELL)\n{\nff Set if we are moving to an adjacent ¢e11 or\nff we have hit @ solid (unlinked) edge\nit (MextCell)\n{\nff moving on. Set our motion origin to the\nff point of intersection with this cell\nff and continue, wsing the new cell as our\nff test cell,\nMetigarath, SatEndPointal PointOfintersaction}:\nTestCell = MaxtCell;\n}\nelse\n{\ni} we haye hit a solid wall.\nfi) Resolve the collision and cerrect our\nit path,\nMationPath. SetEndPointa(Pointlfintersection):\nTestCell-s?rojectPathinCell Wall (WallNunber,\nMationPath) ;\n\nff add same friction ta the new MotionPath\nfi sintea we are scraping against a wall,\nif we dg this by reducing the magnitude of",
      "content_length": 1645,
      "extraction_method": "OCR"
    },
    {
      "page_number": 294,
      "chapter": null,
      "content": "Sectlon 3 Artificial Intelligence\n\nfd our motion 10%\nweotor2 Direction =\n\nMotionPath. EndPointe() =\n\nBotionPath. EnOPointAl } ;\nDirection \"= 0.9T;\nMotionPath.SetEndPointh(letionPath.EndPodntaAl) +\nDirection);\n\n}\n\ni\nelse if (Result == NavigationCell: :MO RELATIONSHIP}\ni\n\nff Although theoretically we should never\n\nff encounter this case, we do sometimes find\n\nff qureelvas directly on a vertex of the cell.\n\nff This can be viewed by some routines as being\nif outside the call. To accommodate this rare\nif case, we force our starting point into the\n// current cell by nudging it back so we may\n\nif continue.\n\nWeoters Newlrigin = MotionPath,EndPointAl):\nTesteel1->ForcePointTocellCollumn(Newrigin) ;\nMotionPath  SetEndPointa(Newtrigin) :\n\n}\n\ni/o we now have our new host cell\n\"EndGell = Testte11:\n\ni! Update the new contral point position,\n\nfi solving Tor ¥ using the Plane member of the\nif Mavigationtell\n\nEndPos.«x = MotionPath.EndPoint®().x;\n\nEndPos.z = MotionPath.EndPoint8().¥;\n\nTestCell -sWapVectorHeight Tetell (Endres);\n\nListing 3.6.3: Building a Navigation Path on the\nMesh Using A*\n\nbool NavigationMesh: :-BuildNavigationFath(NavigationPath&’ NavPath,\nHavigationGell* StartCell, const vector3& StartPos,\nNavigationCell* EndCell, const wactors& EndPos)\n\nbool FoundPath = false;\n\nff Incramant our path finding session ID\n\nff This identifies each path finding session\nif $0 we do mot need to clear out old data\nff in the cells from previous sessions.\nt++m_Pathdession;\n\nif load our data inte the NavigationHeap object",
      "content_length": 1522,
      "extraction_method": "OCR"
    },
    {
      "page_number": 295,
      "chapter": null,
      "content": "2.6 Simplified 3D Movement and Pathfinding Using Navigation Meshes 307\n\nii to prepare it for use.\nA_Naviitap.Setup(m PathSession, StartPa) ;\n\n7 Wa are doing & reverse search, Trom Endtell to\nff StartCell. Push our Endtall onte the Heap as the first\nj/ cell to be processed.\n\nEndtell->QueryForPath(in NavHaap, 0, 0):\n\nfi} process the heap until empty, or a path is found\nwhile (n_Navigap.NotEmoty() && 1FoundPath)\n{\n\nNivigationNode ThisMode;\n\n/? Pop the top cell (the open cell with the lowest\n‘f east) off the Heap\nfh_MavHeap. GetTop(ThiaNode}:\n\nff if this cell is our Starttell, we are dona\nif(Thisheda.cell == StartCell}\n{\n\n}\nelse\n\n{\n\nFoundPath = true;\n\nif Process the Cell, Adding its neighbors te the\nii Open Heap as needed\nTHishode.cell->ProcessCell( dm Mavieap) +\n\n}\n\nfi If we found a path, build a waypoint list\n// gut of the cells on the path\nif (FoundPath)\n{\nNavigationGell* TestCell = StarttCell;\nVECtOrS NewiayPoine:\n\n// Setup the Path object, clearing out any old data\nNavPath.Setup(this, StartPos, StartCell, EndiPas,\nEnigtel1):\n\nff Step thraugh each cell linked by aur A* algorithm\nff trom Starttell ta Engtell\nwhile (TestCell £8 TostGell f= Endtell)\n{\nff add the link point of the cell as 4 way point\nff [the exit wall's canter)\nint LinkWall = Test€ell-=ArrivalWall|);\n\nMawayPoint =~ TestGell->Wal Midpoint (LinkWall) ;\nNawayPoint - GnapPointTotell(Testtel1,\nMawWayPoint ) :\n\nff just te be sure",
      "content_length": 1409,
      "extraction_method": "OCR"
    },
    {
      "page_number": 296,
      "chapter": null,
      "content": "Section 3 Artificial Intelligence\n\nNavPath AddWayPoint (NowvayPoint, TestCell) ;\n\niif and of to the next cell\nTeetGell = TestCell->Link(LainkWall):\n\n}\n\n‘i! cap the end of the path.\nNavPath.EndPath( ):\nreturn( true};\n\nI\n\nff no path exists between the two points provided.\nff d.@. \"you can*t get there from here\"\n\nff This will never happen on a contiguous mesh.\nreturn(false);\n\nbool Mavigationtell: :ProcesstelliMavigationHeap* pHeap)\n\n{\nif (m_S69si0n1D-\"pHeap->SessionID{))\n{\nff ance wet have boan processed, we are closed\nm Open = false:\nff query all our maighbore to see if they need to be\n‘f added to Open haap\nfor (amt 1=0;1<35++1)\nif (m_Link[i])\n{\niy The Distances between the wall midpoints\nfy oof this opll are held if th® order\ni) ABtOBG, BOTOOA end CAtoAB.\nfy abs(i-n_Arrivalwall) 44 a farnula to\nff determine which distance measurement\nff to use. We add this distance to known\nff marrivalCest to campute the total cost\nif to reach the next adjacent call.\n@_Link[i]->OueryForPath(pdeap, this,\nB_Arrivaltast+m Walllistance| abs (\ni-m_ArrivalwWall)j}:\nI\n}\nreturn(true);\n}\nrequrn(false) ;\n}\n\nbool NayvigationGall: :QueryForPath(NavigationHeap* pHaap,\nNavigationGell* Caller, flaat arrivalcost)\n{\n\nif (m_SeseionID!=pheap->Sessionio ))",
      "content_length": 1238,
      "extraction_method": "OCR"
    },
    {
      "page_number": 297,
      "chapter": null,
      "content": "a6 Simplified 30 Movement and Pathfinding Using Navigation Meshes\n\nI\n\nfi this is a naw session, reset our internal data\nH_SessioniO = pHeap->SeasionID( |:\n\naf {Galler}\ni\n\nn_Open = true;\nConputeHeuristic(pHeap->Goal());\nn_ArrivalGost = arrivaleast:\n\nii Remember the triangle wall this caller is\ni} oenta ring Tron\nif (Caller == s_Link[O))\n\n{\nn_ArrivalWall = 0;\nI\nelse if (Caller <= m Link[1]}\nt\nn_ArrivalWall = 1:\nI\nelee if (Caller == m Link[2)}\n{\nn_ArrivalWall = 2:\nIr\nI\nelse\n{\n\ni} We are the cell that contains the starting\nii Iaeation of the A*®* search.\n\nm Open = false:\nM_ArrivalGest = oO;\nmn Heuristic = O;\nm_ArrivalWall = 0;\n\nI\n\nff add this cell ta the Open heap\nPHeap ->AddCell (this) 5\n\nreturn( true);\n\nelee if (m_ Open)\n\nf\n\nfi] A true m_Open means we are already in the Open\n\nfi Heap. If this naw caller provides a better path,\nff adjust our data. Then tell the Heap te reasert our\n{i} position in the list.\n\nif ((arrivalcost + m_Heuristic) =< (m_aArrivalCast + m Heuristic) }\n{\n\nf_Arrival€est = arrivalcost;\n\n!! Renember the triangle wall this caller is\n!! entering fron\nif (Caller = n_Link[d])\n{\nm_ArrivwalWall = 0;",
      "content_length": 1126,
      "extraction_method": "OCR"
    },
    {
      "page_number": 298,
      "chapter": null,
      "content": "k:\n\nSectlon 3 Artificial Intelligence\n\n}\nolse if (Caller == m_Link[1})\n\n{\nn_ArrivalWall = 1j\n\n}\nelse if (Caller == m_Link[2])\n{\n\nmn ArrivalWall = 2:\nij\nIi @8k the heap to resort our position in the\nii priority heap\npHeag->Adfuetlell (this);\nreturn (true);\n}\n\n}\n\nfi this cell is closed\n\nreturn(falsep ;\n\nwoid NavigationGell::ComputeHeuristic(canst vectar3& Goal)\n\nff qur hauristic is the estimated distance (using the\nff Longast axie delta) between our cell canter point\nff and the goal lecation\n\nTioat KDelta = fabs(Goal.x - o_GanterPoint.™);\nTloat YWelta = fabs(Goal.y - m_CanterPoint.y):\nTloat 2De1ta = fabs(Goal.z - m_CanterPoint.?):\n\nM_Heuristic = _ max(_ mix(XOelta, Delta), 7Delta):\n\nReferences\n\n[Patel99] Patel, Amit J., “Amits Thoughts on Pathfinding,” available online at hup:/f\n\ntheory.stantord edu/—amitp/GamePmgramming!, November 27, 1059,\n\n[Heyes-Jones99] Heyes-Jones, Justin, “A* Algoricam Turorial,” available online at\n\nwww. gamedev.net/reterence/programming/aifarticleG90.asp, November 27, 1999.\n\n[Stouc?6] Sout, Bryan W., “Smart Moves: Incelligent Path-Finding,” Game Devel-\n\noper, alto available online at www-gamasurra.com/fearures!19990212/sm_01\nhom, Oetober 1996.",
      "content_length": 1185,
      "extraction_method": "OCR"
    },
    {
      "page_number": 299,
      "chapter": null,
      "content": "Flocking: A Simple Technique\nfor Simulating Group Behavior\n\nSteven Woodcock\n\nFlocking (sometimes called soaring or bending) is a wechnique first put forth by Craig\nReynolds in a 1987 paper he did for SIGGRAPH, “Flocks, Herds, and Schools A\nDistributed Behavieral Model.” In that paper, Reynolds proposed a series of three\nsimple mules, which, when taken together, gave groups of autonomous agents (also\ncalled Soids) 2 realistic form of group behavior similar to flocks of birds, schools of\nfish, or swarms of bees, (See Figure 3.7.1 for an example of this behavior in action.)\n‘These rules, which Reynolds refers to as steering behaciors, are:\n\n* Separation. Steer to avoid crowding local flockomates.\n* Alignment. Steer toward the average heading of local flockmares.\n* Cohesion. Steer to move toward the average position of local flockmates.\n\nFIGURE 3.7.1. An cxample image of the flocking demo in action.",
      "content_length": 908,
      "extraction_method": "OCR"
    },
    {
      "page_number": 300,
      "chapter": null,
      "content": "Section 3 Artificial intelligence\n\nSeparation gives an agent the ability co ory to maintain a cercain separation dis-\ntance from other agents in the immediate viciniry. This helps prevenc agen from\ncrowding together while ensuring a “natural-looking” closeness that emulates groups\nin the real world, The code presented in this article accomplishes this goal by having\ncach member of a flock rest how close it is to its nearby flockmates and then adjust its\nheading (steering) to obtain a desired distance.\n\nAlignment provides an agent that has the abiliny co align itself with (Le., head in\nthe same direction and/or speed as) other agents in its immediate viciniry. As with\nseparation, this article accounts for alignment through each member of a flack look-\ning at nearby Hockmaces and then adjusting its heading and speed to match the aver-\nage heading and speed af its neighbors.\n\nCofeston gives an agent the ability co “group” with other nearby agenn, thus emu-\nlating similar behavior seen in nature. Again, chis article accomplishes this goal by\nhaving each agent examine nearby agents, averaging their positions and then adjust ing\nbeading to match.\n\nThe Fourth Rule\n\nIn later implementations and papers, Reynolds added what has sometimes been\nreferred to as the “fourth rule” of flocking:\n\n* Avoidance. Steer to avoid running into local obstacles or enemies.\n\nApeidance provides an agent with the ability to steer away from obstacles and\navoid collisions. This behavior is accomplished by giving each agent the ability to\n“look forward” some distance and determine whether a collision with some object is\nlikely, then to adjust its heading to prevent ir. Similarly, it might be desirable co avoid\ncertain other types of agents (such as rabbits avoiding foxes or doves avoiding hawks),\nand again this principle would come into play.\n\nHo Memory\n\nNote that che steering behaviors say norhing about state information er about a given\nagent maintaining knowledge of the flock, its environment, where it's headed, or the\nlike. Flocking is a sratefer algorithm in chat no information is maintained from update\nto updare; each boid reevaluates ite environment at every update cyele, Not only does\nthis reduce memory requirements that might otherwise be needed to provide a simi-\nlar behavior using approaches besides flocking, burt it also allows che flock to react in\nreal time to changing environmental conditions. As a result, flacks exhibit dements of\ncmengent behavior Noa one member of the flock knows anything abour where the flock\nis going, bur the flock moves as one mass, avoids obstackes and enemies, and keeps\npace with one another in a fluid, dynamic fashion,\n\nHow Is This Concept Useful for Computer Games?\n\nFlocking provides a powerful cool for unit motion and making more realistic environ-\nmens the player can explore; it has been wed with erear success in a variery of com-",
      "content_length": 2893,
      "extraction_method": "OCR"
    },
    {
      "page_number": 301,
      "chapter": null,
      "content": "4.7 Flocking: A Simple Technique for Simulating Group Behavior 207\n\nmercial tithes. For example, both Lmreal (Epic) and Half-Life (Sierra) used flocking\nalgorithms for many of cheir monsters as well as less life-threatening creatures such as\nbinds and fish. Enemy Nations (Windward Studios) used a modified flocking algo-\nnthm to control unit formations and movement across a 3D) environment. Groups of\nanimals can be made to wander the terrain in real-time strategy games or RPGs more\nrealistically than can be done with simple scripting. Groups of archers or swordsmen\nean be made to move realistically across bridges or around boulders and other obsta-\ncles. Monsters in a first-person shoorer can wander the dungeon halls in a more\nbelievable fashion, avoiding players where possible but perhaps launching an arrack\nwhen the flock prows large enough. The possibilities are practically endless.\n\nimplementation\n\nVectors and Motion\n\nA quick overview of the mechanics of morian for the members of a flock helps in\nunderstanding how the code does whar it does.\n\nFigure 3.7.2 demonstrares the concepre of doeal spare (space relative vo the boid\nitself). “Forward” is coward che positive #-axis, “left” is toward the positive X-axis,\nand “up” ts vertical toward the top of the boid. Our boid in this article is che classic\ndelta-wing shape often used by Reynolds, but of course it can be any shape desired.\n\nFigure 3.7.3 demonscrates another important principle, ortewtation. Referred to\nas mali pitch, and yaw, orientation is simply an indication of how a given object is ari-\nented in the local space, shown in Figure 3.7.2. Roll is rotation around the local 7-\naxis (the one facing forward and backward), Pitch is rotation around the local X-axis\n(the one running left and right). Yaw is roration around the Yaucis (the one running\ndirectly up and down through the boid). Understanding orientation is important\nbecause we use it when making decisions about our boid's orientation during move-\nment. The idea presented in this article works by building a velocity vector during each\n\nLavcal ¥\nLocal 2%\n\nLocal X\n\nFIGURE 3.7.2. Local space is defined for each boid.",
      "content_length": 2163,
      "extraction_method": "OCR"
    },
    {
      "page_number": 302,
      "chapter": null,
      "content": "rer Sent ih\nsie aT te\n\nFIGURE 3.7.3. The three axis rotations are defined as roll, pitch, and yaw.\n\nupdate cycle that will adjust the boid's local X, ¥, and Z orientations to match the\nneeds of che four steering behaviors.\n\nAnother important aspect of how this idea operates is the manner in which it\narbitrates conflicting desires on the part of a boid. Looking at the four stecring behay=\niors for a moment, one can sce that there is no guidance on how to prioritize these\nbehaviors—all are considered of equal importance. This loosely matches most normal\nbehavior in the real world: A dove might want co both keep up with its fellows and\navoid cutting through a flock of hawks while doing so; however, this concept doesn't\ntake into account life-and-death situations.\n\nOne can solve this problems in several ways—automatically giving higher priority\nto avoidance, for example—but this article uses a vector accumulation approach. The\norentation changes that a given boid wanes to make to satisfy each of the four steer-\ning behaviors are summed in a changer verter before being applied to the boid’s\nmotion. This change vector, by convention, is held to a unit vector so that the accu-\nmulated changes are kept in proper proportion. This method allows each steering\nbehavior to have a proportional influence on the boid’s final motion changes while\nenabling the boid to satisfy (at least partially) the needs af hwo or more conflicting\n\ndirectives. Qver time I've found thar this approach is generally more satisfactory than\nothers.\n\nConstraints\n\nSeveral constraints on our boids restrict how they can move and react, Possibly che\nmost influential in this implementation is each boid’s perception nange, which restricts\nhow far a flockmate can “look” around its environment to detect other flockmates,\npotential obstacles, or enemies. The larger this range, the more organized and coher-\nent the flocks and the better they are at avoiding enemies and obstacles. Making this\nrange smaller results in more erratic flocks, groups of boids splitting off more often\nwhen confronted by obstacles or enemies, and so on.\n\nAnother constraint on how car agents can move is their relocity and maximamn\nvelocity change. In the real world, animals in flocks are restricted in their ability to keep\nup with their flockmares by how fast chey can move, how fast chey can tum, and the",
      "content_length": 2370,
      "extraction_method": "OCR"
    },
    {
      "page_number": 303,
      "chapter": null,
      "content": "2.7 Flecking: A Simple Technique for Simulating Group Behavior 209\n\nlike. ‘This article simplifies the problem of morion in a 3D environment somewhat by\nignoring acceleration and focusing entirely on velociry; changes mo velocity are\nrestricted ta same proportion of overall maximum velocity. This helps prevent the\nagents in our deme from turning on a dime or putting on ridiculous bursts of speed\nwhen trying to catch up with their flockmates. It also provides a governing restraint on\nhow quickly they can slow down or alter course to avoid an obstacle. If allowed “infi-\nnite response,” they might fly directly up co the surface of an obstacle before tuming\nwith infinite agility and speed to move around it—not a very realistic behavior.\n\nA final constraint for the purposes of our demo is the world in which our boids\nflock. For the purposes of this article, I've arbinarily created a Box class that defines\nthe warld in which our boids can move. Any boid thar strays beyand the boundaries\nof the Box is magically transported to the opposite side, keeping the same motion\ncharacteristics it had before. The effect is char flocks that stray too clase to the edge of\nthe Box can lose members to the “other side of the world.” where they can lose mack\nofthe main flock and form a mew flock of their own.\n\nVirtually all these parameters are adjustable so char ome can see the potential\nimpact of fiddling with them.\n\nThe Code\n\nThree classes make up the heare of this article: Car, CFlock, and CBoid. Organiza-\ntionally, these classes can be viewed as described in Figure 3.7.4.\n\nFach flock is represented by an instantiation of a CAlock object. There can be\nmultiple Fleck objects residence within Cfox, and they can be created or destroyed ar\nany point (although this article creates chem only ar inisialization). Clack objects\nserve to organize and simplify access co the members of the flock.\n\nSimilarly, a CBefa object represents cach member of a flock. There can, of course,\nbe multiple CBerd objects associated with each CAloct (if there werent, it would be a\n\n(Flock Flock f through 7...\n\nEee re)\n\nFIGURE 3.7.4. The Box dass defines the basic world in which our flocks will fly.",
      "content_length": 2187,
      "extraction_method": "OCR"
    },
    {
      "page_number": 304,
      "chapter": null,
      "content": "310\n\nSection 3 Artificial Intelligence\n\nprety small flock), and, like CAteck objects, they can be created or destroyed at any\npoinc, Although this article creates flack members only at inicializarion, ic wouldnt he\nhard co all co build in some “lifetimes” for individual members (sec che “Limitations\nand Potential Improvements” section) so thar individuals might age and die.\n\nThe CBox Class\n(Bex is a rather simple class, as one might expect:\n\n¢lass Gaox\n{\n\npublic:\n\neee ee ee ee\nij constructors and destructors\neee eee ee ee\n\ni} Constructor #1.\n\nff Greates a Box with default values of 50 waters\nff on any side not specified.\n\nBox (float lv=50.0, float w=50.0, Tloat nv-40.0);\n\nff Destructar\nvirtual -Chax();\n\neee eee ee\nff miscellanéous functions\nCOLAC RN ARSE?\n\nff Gethoslength.\nif Returns the length of the Box, in meters.\nfloat GetBoxLength (void);\n\nit Gethoetidth. .\nii Returns the width of the Box, in meters.\nTlost GetBoxWidth (void);\n\ni} Gathoxkheight.\nIi Returas the height of the Box, in meters.\nFloat GetBoxbsight (void);\n\nThis class provides us with a simple way ro parameterize and retrieve che bound-\nanes of our world.\n\nThe CFlock Clase.\nThe CAlock class represents a basic flock of boids and serves mostly as an organiza-\n\ntional tool rather than a strict representation of each flock per se. Its various functions\nare fairly simple and deal primarily with the “bookkeeping” that one might desire\nwhen handling flocks, The class definition for CFisek can be found in Listing 3.7.1.",
      "content_length": 1500,
      "extraction_method": "OCR"
    },
    {
      "page_number": 305,
      "chapter": null,
      "content": "3.7 Flocking: A Simple Technique for Simulating Group Behavior a4\n\n<=\n\nProcedurally, flocks are first created and then have one or more boids added to\nthem. The class is built to allow for real-time creation and deletion of flocks, although\nthe demo itself does not do this. A list of all CAlck objects is maintained in the simple\nstatic array CFlock::List0fFlocks|] (again, simplified for che purposes of this article).\nAr each update cycle, the flocks’ cFlock: :Update() method is called to updace all the\nmembers of that flock, New boids can be added at any time using GFlock::AddTo(},\nand members can be removed, if desired, via GFlock::femoveFrom(). CFlock: :Get-\nCount () and CFlock:i:GetFirstMember(} provide methods co obrain spechc Statls:\ninformation about a given flock, whereas the debugging method CFlock::PrintData()\nprovides more exhaustive information.\n\nFlocks can be created at any rime, although the demo provided creates them only\nat initialization. Each flock can have any number of Cid objects as members. Note\nthar members of a flock have no idea what flock they're a member of. but the Jock\nitself does know who its members are. For the purposes of this article, a CBoia object\nremains a member of whatever CFfock it is initially assigned wo, bur it wouldn't be\nhard ar all to add code that would allow boids te change their loyalties if so desired\n(see the “Limitations and Potential Improvements” section).\n\nThe CBoid Class\n\nThe CBorf class implements the true “meat” of the flocking algorithms and, as such,\nis fairly beefy. Ic is contained in Listing 3.7.2. This class handles all aspects of a spe-\ncific agent's motion and existence: how it moves, how it senses its environment, how\nit POritines Is actions.\n\nFach C#oid object represents a single individual agent. Much as with CAlack\nobjects, CBotd objects can be created or deleted at will. Once created, they are indi-\nrectly managed through the GFlock::AddTo(), CFlock::Removerrom(}), and\nCFlock::Update() methods, as described previously.\n\nFach CBoid object is updated via its Flock: :FlockIt() method, which begins by\nbuilding a list of these flockmates that a given boid can see (based on its\nperceptten_naonge valuc)_ A list of enemies (members of ocher flocks) is also built if char\nOption is active.\n\nThe method then begins to implement the steering behaviors as described previ-\nously, summing an accumulating series of velocity vector changes to accommodate\nthe wishes of che agent. The methods CBoid: :Keepbistance!) (separation behavior),\nCBoid::MatchHeading() (alignment behavior), and CSoid: :SteerToCenter (cohesion\nbehavior) are called to determine what the boid would like to do. If the option is\nactive, avoidance behavior of members of other flocks is modeled through a call co\nCBold: :FleeEnemiesi }.\n\nOne additional method implemented here is Choid::¢ruising(). This method\nattempts to model a boid's “desired cruising speed,\" if everything were up wo it and it\nwasnt under any other influences. The primary reason for chis method was to give",
      "content_length": 3043,
      "extraction_method": "OCR"
    },
    {
      "page_number": 306,
      "chapter": null,
      "content": "412 Section 3 Artificial Intelligence\n\nany boids wandering on their own (our of sight of their flockeaartes) some “purpose”\nto their motion.\n\nAt each stage of the update process, we accumulate all desired velocity vector\nchanges proportionally into an accumularion vector, A check at the end of the\nCBoid::Flockit() method ensures thar an individual mever exceeds ite maximum\nallowed speed or velocity change.\n\nTwe final methods serve as “cleanup” ro ensure that everything looks correct.\nCHoid::Computenry(} males calculations necessary to orient our boid properly as a\nresult of its final velocity vector changes. CBoid: ;WorldBound() does some sanity test-\ning to determine whether any agent has strayed outside the bounds of the CRox world\nobject in which ir resides and, if it has, places it back in irs bow.\n\nVarious private methods handle visibility and linked-lisr Management; there's\nnothing particularly special abour chem, sor are they flocking related per se. A debug\nmethod, CBoid: :FrintData(), provides cchaustive information on a even boid on an\n\nupdate-by-update basis.\nLimitations and Potential Improvements\n\nHard reality dictates char any demonstration of flocking behavior has some limirations.\nThis article docs not implement obstacle avoidance ar all, although it does allow for\navoidance in the form of “enemy flocks.” Boids remain assigned to the flocks they start\nwith, but one could easily envision code that reassigns a boid dynamically to a new\nflock should ir lose sight of ixs old onc. Similarly, beids in this implementation are\nblessed with an amazing, 360-degree, full-spherical field of views there are no restric:\nWiens such that they can see only objects or flockumares directly in front of them. A\nmore realistic field of view would probably be desired for any game implementation,\n\nA list of other possible improvements is fairly easy to come up with. Many people\nwhe have used flocking behavior and its variations have implemented “life clocks” on\nindividual agents, making boids thar die if they stray too far from cheir mares but that\ncan “breed” new flock members if they remain with their brothers long enough, One\ncould also examine predator and prey behavior, modifying the base code to allow one\ntype of flock ro “feed” on another.\n\nListing 3.7.1: The CFlock Class Definition\n\nclass Grlock\n{\n\npublic:\n\nPOPP PPPOE ELS\nfi stetic variablas\nreese ee",
      "content_length": 2391,
      "extraction_method": "OCR"
    },
    {
      "page_number": 307,
      "chapter": null,
      "content": "3.7 Flocking: A Simple Technique for Simulating Group Behavior 313\n\nff number of flocks\nStatic int FlockCoaunt;\n\nff list of flocks\nStatic CFlock * ListO?Flocks [WAX FLOCKS);\n\nA0RCAAA ARLE\nfi constructors and destructors\nA000 UU ALAO SEE\n\nff Cometractor.\nit Greates & new fleck.\nOFlock (void):\n\nIf Destructor.\n-OFlock (wodd);\n\nARCOLA RODGERS\nIf Plocking functions\nTerre eerie |\n\ni Update.\nIf Updates all members of a flock.\nvoid Update (void):\n\neee ee\nff migeellaneaus functions\n\nJACAOLALE LEER BEOGGE\n\ni] Addo.\nff Adds the inditated boid to the flock.\nWold AddTo (GHoid * boid);\n\nff GetCount.\nif Returns the # of boids in @ given flock.\nant GetCount [vwoid);\n\n{) GetPirestiember .\n\n// Returns & pointer to the first boid in a\n// given fleck (if any).\n\nCBoid * GetFirstienber (void);\n\ni) PrintData,\ni/ Dunps all data deseribing a given flock.\nwoid PrintData (void);\n\nfy Remver ren.\n(J Removes the indicated boid fram the flock.\nvoid RemoveFrom (CBodd * boid);\n\nprivate:\nint m_iel; if id of this flock\nint fh_fhian_menbers; // cumber of bodds in this flock\n\nCBoid = *m_first_oonmber; ii pointer to first member",
      "content_length": 1108,
      "extraction_method": "OCR"
    },
    {
      "page_number": 308,
      "chapter": null,
      "content": "a14 Séction 3 Artificial Intelligence\n\nListing 3.7.2: The CBoid Class Definition\nclass Choid {\npublic:\n\nJC0UACOROOSR EGG\nff static wariables\nACCUUASDEEE EEL\n\nHf visible friends list (work space reused by each bodd)\nStatic Choid * VisibleFriendsList|MAx FRIENDS VISIBLE];\n\neee ee eee ee\nf/ constructors and destructors\nA220 KOR DELOREELOODOEEES\n\nif Constructor #1.\n\nff Greates an individual bold with randomized pasition,\nif velocity, and orientation,\n\nC8oid (short id _v};\n\nfi Gonstructor #2,\nI! Creates an individual baid with specific position,\nfi velocity, and ardentatian.\nCSoid (short idg_v,\nweetor “ pos_¥, vector = vel_v, weetar * ang_vj;\n\nff Dastructer\n-CHoid (void) ;\n\nTerre eee eee |\nff public flocking methods\neee eee eee ee\n\nfi Floekit.\n\nffi Used for frama-by-frane updates: no time\n\nif deltas on positions.\n\nwold Flockit (int flock_id, CBoid *first _boid};\n\nCUE\nif miscellancows. tunctians\nieee eee eee ee\n\nff AddToVisibletist.,\n\nff This visibility list is regenerated for cach menber each\nfF update cycle, and acts auch like a push-down queue: the\n\nff) latest menber added to the list becomes the first one\n\nff when the List is sequentially accessed. Mastly I did\n\nff this for speed reasons, as this allows for toast inserts\n\ni? (and we don't delete fron this list, wm just rebuild it",
      "content_length": 1298,
      "extraction_method": "OCR"
    },
    {
      "page_number": 309,
      "chapter": null,
      "content": "4.7 Flocking: A Simple Technique for Simulating Group Behavier 3415\n\nfy each update cycle}.\nWOiG AddToVisibleList (CSoid *ptr);\n\ni) GlearVisiblelist—\ni] Cleare the visibility list.\nwoLd ClaarVisibleList (void):\n\nfy Gethaxt.\n\nij Returns the \"next\" pointer of the invoking member.\nCBoid * GetNext();\n\nff LinkOut.\nif Remves a menber from a last.\nwoid LinkOut [()};\n\nij PrintQata.\nfi Dumps all data describing a given merbor.\nvoid PrintData (void);\n\nfy Setvexwt.\nfi) Set the “next” pointer of an individual menber.\nvoid SetNext (CBoeid ptr};\n\nfj SetPrev.\nfy Set the “prev* pointer of an individual member.\nwoid SetPrev (Cfodid \"ptr};\nprivate:\nPOPPER EES\ni} data members\neee eee ee ey\n\nfy supplied with constructor (s)\n\nshort m_id; if menbar individual ©D\nfloat m_perception range; i) how far genber ean sec\nvector m_pos; if position of meaber\niflin meters)\nvector m_vel; if veletity of menber\nif (meters/sech\nvector m_ang; fi orientation of member\nfi computed\nfloat m_speed; if averall speed of member\nu_short m_nun_ftlockmates_seen; il # of flocknates this\nfi tember sees\nu_short m_nun_enamies seen; i) # of enemies this\nff tesber sees\nG8oid “nm nearest _Tlocknate; if pointer to nearest\nif flockmate (if any)\nCaoid “n nearest _eneny; if pointer to nearest\n\nff enemy (i? any)\nfloat B_dist_to_nearest_flockmate; // distance to\n\nif nearest ftlocknata",
      "content_length": 1345,
      "extraction_method": "OCR"
    },
    {
      "page_number": 310,
      "chapter": null,
      "content": "316 Section 3 Artificial Intalligence\n\nor\nfi (iF anyp, in\nff meters\n\nfloat m_Giet_to_nearest_anemy; if distance ta\n\nff nearest eneny\nff (if any), in\n\ni) meters\nvector m_oldpos; if last position\nvector m_oldvel; if last velocity\nCaoid *m_hext; ff pointer to next\nff flockmate\nCeoid ‘Em prev: iJ pointer to\n\nff previows\nif flockmate\n\nFRAO EEE\nff Tlocking methods\nPEPPERS EEE\n\nff Gruising.\n\ni) Generates a vactor indicating how a fleck boid would\n\nfi like to move, if it were all up to hia and he was under\nii no other influences of any kind.\n\nvector CBoid::Cruising (void);\n\ni} FleeEnemies.\nI} Generates a veeter for a flock bodd te avodd the\nif] nearest enesy (boid of a different flock) it sees,\n\nWector CBoid: !FlaaEnemies (void);\n\nii KeepDistance.\n\nfi Generates a vector for a fleck bedid to maintain his\n\nif dge6ired separation distance from the mearest flockmate\nffs te sees.\n\nwector CBoid: :KeepDistance (void);\n\nff MatchHeading.\nI} Generates a vactor for a flock bodd to try\nfi to match the heading of its nearest flockmate.\n\nwettor CHoid: :MatchHeading {void};\n\ni} Segknemies.\n\nff Determines which enemy flock boids a given flock boid\nif can 866.\n\nint Cioid: :SeeEnenies (int flock_id);\n\niy! SeeFriends.\n\nff Determines which flocknates a given flock boid can see.\nint Gioid: :SeeFriends (CBoid \"first boid):",
      "content_length": 1314,
      "extraction_method": "OCR"
    },
    {
      "page_number": 311,
      "chapter": null,
      "content": "3.7 Flocking: A Simple Technique for Simulating Group Behavior aif\n\nfi StearTotenter.\ni} Generates & vweeter to guide a fleck boid towards\nif the \"center of mass\" of the Tlockmates he can sen,\n\nweetor GHoid: :SteerTatenter (woaid):\n\nfy WorldBownd.,\n\nff! Implenents a world boundary so that flecks don\"t fly\n\nff infinitely far away from the camera, instead remaining\nff ina nite viewable area. It does this by wrapping flock\nff boids around to the other side of the world, so {for\n\nMY example) they move out tha right and return on the left.\n\nwold Cioid::WorldBound (woid);\n\nCOBO ORE LEER\nff giscellanesus functions\nAGERE ERR\n\nJ} AccumulatecChanges.\n\ni) Adds vector values in changes inte the accumumlator\nff vector. Returns magnitude of accumulator vector atter\nif ating changes.\n\nTloat Choad: :AccunulataGhanges (veeter Zaccunylator,\nvector changes);\n\nff CantSee.\nff Deterning whether a given invoking boid can see the boid\nff if question. Returns the distance to the boid.\n\nTloat Ciioid:-:CanISee (Choid “ptr};\n\niY Computenpy\nFi Computes the rall/piteh/yaw of the flock boid basad on\nff ite latest velocity vector changes. Aoll/pitch/yaw are\nfi etored in the ‘ang\" data member as follows:\n\nff piteh is about the x axis\n\nii yaw is about the y axis\n\n/} roll is about the z awdgs\n\nFf} All calculations assum a right-handed coordinste\n\nfi 4ysten:\n\ni +m = through the left sido of the object\nif; +y = up\n\nfj 42 = throwgh the nese of the model\n\nwiid CBoid::GomputeRPyY (void):\n\nResources and Acknowledgments\n\nI's virnually impossible to study this particular field without quickly discovering that\nnearly every flocking/swarming/herding application on the Web is somehow related",
      "content_length": 1674,
      "extraction_method": "OCR"
    },
    {
      "page_number": 312,
      "chapter": null,
      "content": "318\n\nSection 3 Artificial Intelligence\n\n10, derived from, or inspired by some other flocking/swarming/herding application.\nThe implementation described in this article is no exception, Many thanks to\nChristopher Kline (Mitre Corporation) for his original method for computing\nroll/pitch/yaw (liberally adapted here), originally published in his C++ Bosds imple-\nmentation (available on his Website). Also thanks to Mile Louic (Bocing) for helping\nwith the transformation math (7 hate matrices).\n\nBesides Christopher's Web page, which includes many excellent demos and am-\nple code (at weew.media.mitedu!-ckline/boids/), there are a number of other excel-\nlent references on this subject on the Web and in bookstores. Probably the best single\nplace to start seeking more information is with the “father of flocking” himself, Craig\nReynolds, Craig's Websire can be found ar ww red. comicwr, Also see Reynolds, ©\nWe, “Flocks, Herds, and Schools: A Distributed Behavioral Model,” in Computer\nGraphic, 21(4), SIGGRAPH “87 Conference Proceedings, pages 25-34, 1987.\n\nThe JMicroroft DirectX SDK also comes with two fairly simple-ro-follow imple-\nmentatons included on the source CD. On the OrecXN 7a CD, they are locaned ar\nLOAF sornples \\iultineceta ld 3adim\\orc\\boids and VON FP amples\\multimedialdmusicurc\\\ndmboids. Both versions fearure obstacle avoidance using a “force-field” approach that\nis fairly natural looking.\n\nFinally, an excellent book char addresses the topic of artificial life in general, in\naddition to discussing both flocking and boids, is Steven Levy's Artificial Life, Vintage\nBooks.",
      "content_length": 1599,
      "extraction_method": "OCR"
    },
    {
      "page_number": 313,
      "chapter": null,
      "content": "3.8\n\nFuzzy Logic for Video Games\n\nMason McCuskey\n\nThis article is an introduction eo an artificial intelligence technique called fizey logic.\n\nThe best way to define furzy logic is co explain how it differs from craditional\nlogic, Traditional logic works on the idea of “true” and “false”—something’s either on\nor off, Zero OF One, yes OF NO, positive or negative.\n\nFuzzy logic allows us to work with concepts chat aren't “crisp\"—in other words,\nthings that require an adjective specifying “to what degree” or “how much.” For\nexample, fuzzy logic allows us to mathematically model size concepts such as “pretty\nbig,” “awfully small,” “medium,” “gigantic,” and so on.\n\nFuzzy logic has mysiad uses in game Al. For example, we can use fuzy logic vo\nsimulate emotions of computer-concrolled characters: “irritated” vs. “incredibly\nangry, “a bit nervous” vs. “terrified,” “happy” vs, “ecstatic,” and so on. This in wun\nallows us to create an Al that's more human or deep than one built using traditional\n(“black or white”) logic could ever be.\n\nHow Fuzzy Logic Works\n\n‘To define how fuzzy logic works, let's first take a step back and review how traditional\nlogic works. Traditional logic manipulates “crisp sets.” A crisp set is a set for which a\ngiven element either belongs to the set or doesn't. For example, ler’s define a crisp set\ncalled M, which consists of all real numbers between $ and 10:\n\nff = (5, 10]\n\nThe characteristic function for sec M looks like che one shawn in Figure 3.8.1\n(for the sake of chis example, let's assume our universe of discourse is the set of all real\nnumbers berween 0 and 20, as shown in Figure 3.8.1).\n\nThis is a crisp set because any given number in our universe is cither in sec M or\nnot in set Ad—thar is, either the number is berween $ and 10, in which case our func-\ntian retums ome, of it isn't, in which case it returns zero.\n\nA crisp Ser works reat For black-and-white SCCMAarLOS, bute it Falls apart under cer-\ntain situations. Say we want co make a set of all call people. We decide thar 7 fer is\n\n318",
      "content_length": 2045,
      "extraction_method": "OCR"
    },
    {
      "page_number": 314,
      "chapter": null,
      "content": "Sséction 3 Artificial Intalligence\n\nTu\nt a\na 5 iD =a\n\nFIGURE 3.8.1. Representation of seq AY,\n\ntall, so we declare our set of tall people as “all people who are at least 7 feet tall.” We\nmake a function thar returns one if the given height is greater than 7 feet, zero if it\nisnt. The problem with this is that people who are 6 feet, 11.5 inches aren't in our tall\nsct, even though very few people would dispune the fact thar chey're tall. So, to cry and\nfix the problem, we drop our minimum height requirement down to G fer, bur irs\njust as silly to put two people, one $ feet 11 inches and one G feet, next to each other\nand say that one of them is “tall” and ome isn't. The rigidiry of the crisp set works\nAgainst us.\n\nIn other words, whar crisp sets don't give us is the abiliry ro specify bow much (or\nto whet degree) something is in a set. Fuzzy sets, however, give us that abilicy, Using\nfurzy sets, we can “flex” the separation berween “in the set” and “nor in the set” co\ninclude things like “just a litde bie in the set” or “almost entirely in the set.”\n\nWe do this by having our characteristic function return not only zero and one,\nbur also values bereere zero and one thar indicare to wvrat degree the given number is\nin the set. Going back to our previous example, if zero means “not call” and one\nmeans “tall,” then 0.5 cam mean “sorr of rall” (or, “halfway in the set of tall people\"),\nand 0.01 can mean “a little tall” (or, “just barely in the tall set”).\n\nFigure 3.8.2 shows our fuzzy set of all call peaple.\n\nCompare the graph in Figure 3.8.2 to the graph of the crisp set in Figure 3.8.1,\nThe fuzzy set in Figure 3.8,2 has slopes—5—someone who's five feet is nor tall, bur\nstarting at 5 feet 3 inches, the heights gradually start belonging to the tall set, until\nfinally, at 7 feet, they belong entirely co the call set.\n\nThar's a firzy oct,",
      "content_length": 1861,
      "extraction_method": "OCR"
    },
    {
      "page_number": 315,
      "chapter": null,
      "content": "3.8 Furry Logic for Video Gamez 321\n\n& Aiba 6 feat 7 Freed:\n\nFIGURE 3.8.2. Representation of set “tall people,”\n\nFuzzy Logic Operations\n\nNow that we understand what a fuzzy set is, let's do some operarions an it,\n\nFigure 3.8.3 defines another fuzzy set: a set of people “sbour 6 feet tall.”\n\nHere's an example of the fuzzy see AND operation, Figure 3.8.4 shows the graph\nof the fuzzy set \"people who are tall AND are about 6 feet.”\n\nContinuing with that same idea, Figure 3.8.5 shows the graph of the fuszy sec\n“people who are tall OR 6 fees.”\n\nSteet Bi foot F bead\nhit\n\nFIGURE 3.8.3, Representation of set “abour six feet tall,”",
      "content_length": 629,
      "extraction_method": "OCR"
    },
    {
      "page_number": 316,
      "chapter": null,
      "content": "322 Section 3 Artificial intelligence\n\n5 feed: 6 fest ? feet\nHeigne\n\nFIGURE 3.8.4. Representation of sec “people who are all tall AND alsouc six feet”\n\nFinally, Figure 3.8.6 shows an example of the NEGATION operator: the set\n“people who are NOT ull.”\n\nI Brake for Fuzzy Control\n\nNew we know how ro create and operate on fuzzy secs. The next step is using furzy\nsets to accomplish something. This is called fixzy contrel\n\nLet's say, for the sake of example, that we want to model trafic, Maybe we're\nmaking a ciry simulation game, and we want the linle cars in our city to behave real-\ntically. We have a line of cars, and we want cach car in that line to speed up or slow\ndown as though it were driven by a real person. This means that no cars can bump\n\nSfoat 6 foot 7 fone\nHesyght\n\nFIGURE 3.6.5. Representation of set “people whe are tall OB sre fee”",
      "content_length": 851,
      "extraction_method": "OCR"
    },
    {
      "page_number": 317,
      "chapter": null,
      "content": "3.8 Fuszy Logic for Video Games 323\n\nFIGURE 3.8.6. Representation of set “people who are NOT rll.”\n\ninto the backs of other cars and that inside each car is a safe driver who tries to main-\ntain a reasonable distance (two car lengths) berween his or her car and the car in front.\n\nThis situation is easy to model with fuzzy logic, because for cach car, there are\nonly owo variables we need to worry about (in fuzzy logic, these are called Enreraistic\n\nlL. The distance between this car and the one in frone of it. (We'll call this linguistic\nvariable dimncuee)\n\n2. The distance dele between this car and the one in front of i IF the apace berween\nthe owo cars is growing, we have a positive distance delca; if the space is shrinking,\nwe have a negative distance delta. If the space is neither growing nor shrinking,\nthe distance delea is zero.\n\nAfter spending hours carefully studying real cars on real highways, we come up\nsome rules, For each car:\n\n* Waistance deles is zero and distance is about two car lengths, maintain your cur-\nrent speed.\n\n* Lf distance defta is negative and ditence is less than two car lengths, slow down.\n\n= Uf divance dele is peosicive and distance is greater than two car lengths, speed up,\n\nThere are many mare rules, which all follow the same pattern and are summed up\nin Table 3.8.1.\n\nNow that we've got our cules, we need co mail down all che cecrns we've used to\ndeserihe dittance and alissence delta with furzy sere, This means thar we need to define\n15 furzy sets: five cach for distance, distance dele, and the action of the car (which\nwe'll call action). These sets are summarized by Tables 3.8.2, 3.8.3, and 3.8.4 and the\ngraphs in Figures 3.8.7, 3.8.8, and 3.8.9,",
      "content_length": 1704,
      "extraction_method": "OCR"
    },
    {
      "page_number": 318,
      "chapter": null,
      "content": "324 _ Sections Artificial Intelligence\n\nTablé 3.4.1. Rules for Our Car Al\n\nMaintain\nSlow down spood Seeerd up\n\nd\n\n| seca\n— Brake | heard! | Brake hard! Slow dawn Slow dean\n\nDistance Label Gormesponding Furry Set\n\nWery small Les than one car h\n\nSmall About one car lenpth\n\nPerfect About two cer lengths\n\nBie About three cr lengths spe oe\n\nWery bic More than three car lengths —=\n\nTable 3.8.3. Distance Delta Fuzzy Set Definition\n\nDistance Delta Label Comesponding Furry Sal\n\nShrinkine Fast Ra y equal co negative (half the car's presence ]\nShrinking Lest than vere =\n\nSable About zero (the nwo cars are moving at roughly the same speed)\nGrow (Greaner than zero\n\n(Growing fast Roughly equal co half the car's present speed\n\nTable 3.6.4, Action Furry Set Definition\n\nBrake Harel Half your speed (speed fa 2)\nSlow down Decrease your speed by half your present speed (speed —= speed / 2)\nMaintam speed Dn nothin\n\ndw Increase your speed by half your present speed {5 += speed / 2)\n\nFlaar it Double your speed (spocd *= 2)",
      "content_length": 1015,
      "extraction_method": "OCR"
    },
    {
      "page_number": 319,
      "chapter": null,
      "content": "3.8 Fuzzy Logic for Video Games 325\n\nPorto\nLees than 1 car length 1 car eregth (@Car Lorghs} Searkngta ere than d cor lengths\n\nFIGURE 3.8.7. Representation of Dusrrmce defininion.\n\n‘ary srrmall oral Bag ery Bag\n\nPartect\nLees than 1 car henge Vicar length @CarLergral doriengts Mom than dow lenge\n\nFIGURE 3.8.8. Represcotation of Diraece Delos definition.\n\nNew lets take a concrete example and lear how the numbers flow through the\nfuzzy control system we've just created. Figure 3.8.10 shows an actual value we've\npicked for afsance; Figure 3.8.11 shows an actual value for distance delta,\n\nAs you can see, we've picked 1.3 as the distance variable and 0.25 as the aismance\ndelta. Que fuzzy sets tell us thata alimance delta of 0.25 is “slightly growing” (it belongs\nto the “growing” set to a degree of about 0,3), and that a distance of 1.3 is “mostly\nsmall” (it belangs to the “small” ser roa degree of about 0.75). Note that we could alo\nsay distance ts “barely perfect” (ic belongs to the “perfect” set co a degree of about 0.1),\nand thar dinenee delta is “mostly stable\" (it belongs vo che “stable* set to a degree of\nabou (5).",
      "content_length": 1132,
      "extraction_method": "OCR"
    },
    {
      "page_number": 320,
      "chapter": null,
      "content": "Section 3 Artiticial Intelligence\n\nHail spect Seed (Ceastain epee\n\nFIGURE 3.6.8. Representation of Acciow definition.\n\n‘Vary smal Vory Ekg\n\nPoet\n(ues Pea 7 ear kenga T car length (Cor Lengths) Zen logis Moco than 2 cor lengths\n\nFIGURE 3.6.10. The Dérnnce value we've chosen for this example.\n\nThis means that we're dealing with four of our sets: che cwo sets to which alisance\nbelongs (“sraall” and “perfect\") and the two sets to which distance deltas belongs\n(\"growing and “stable\"). Given the combination of these sets, we know whatever we\ndecide will be based on one of these four rules:\n\n* Tf distance is small and distance dlefra is growing, Maintain current speed.\n© Tf @tnance is small and dimace defes is stable, slow down.\n\n* [fF distance is perfect and distance alcita is growing, speed up.\n\n* If distance is perfect and distance delta is stable, maintain speed.\n\nThe next step is to evaluate the degree to which each of these rules is “true.”",
      "content_length": 953,
      "extraction_method": "OCR"
    },
    {
      "page_number": 321,
      "chapter": null,
      "content": "| Fuzzy Logic for Video Games 327\n\n0\nhegre [halt of car's poset space) jtabiiod Hatof cars present see!\n\nFIBURE 3.8.11. The Ditence Delta value we've chosen for this example.\n\nLets look at the first rule. The degree to which we should maintain our current\nspeed depends on “how true” che statement “distance is small and distance delta is\ngrowing” is. ‘We know that dimznce belongs to the “small” sec wo a degree of 0.75, and\nwe know thar désene dele belongs to the “growing” set to a degree of 0.3. Sa, we\nknow the result of the fuzzy statement “wires is small and aisnaee deles is growing”\nis 0.3. This is because 01.3 is che largest degree vo which don statements will still hold\ntruc.\n\nWe can evaluate the degree of “trueness” of the other three rules the same way,\ngiving us the following:\n\n* distance is small and distance delte is growing: 0.3 degree of “trueness”\n\n* distance is small and alistence celts is stable: 0.6 degree of “trueness”\n\n* distance is perbect and aictance defts is growing: 0.1 degree of “trueness”\n* distance is perfect and distance delta is stable: 0.1 depree of “trueness”\n\n‘This means that of our possible actions, “maintain speed” gets a score of 0.3 and\n0.1, “slow down\" gets a score of 0.6, and “speed up” gets a seore of 0.1.\n\nThe exact way we get from where we are now to a final value is called a deficcziif-\ncation method. There are many available defuzzification methods; you need to pick\none that suits your application. Most of the time, however, it’s good enough to per-\nform a simple center-of-mass calculation on the “true” area of the action graph (sec\nFigure 3.8.12).\n\nThis caleulation gives us our final course of action, namely, “sow down” to a\ndegree of about 0.25, Now it's simply a matter of applying 25% of the slow-down mule\nto the car's present speed. Since “slow down\" to a degree of 1.0 is 0.75 of the car's\nspeed, 2596 of the slow-down rule means we should multiply the car's speed by about\nO81.",
      "content_length": 1954,
      "extraction_method": "OCR"
    },
    {
      "page_number": 322,
      "chapter": null,
      "content": "328 Section 3 Artificial Intelligence\n\nIY \\,\n\nFIGURE 3.6.12. Using che defurzification method.\n\nSo the car slows down slightly which makes sense given the inpur crireria (aii\nnance is small, bur diseence dele is growing),\n\nOF course, the entire process we just wene through is performed by the computer\nhundreds of times a second, simulating the expert control of a safe driver.\n\nOther Applications of Fuzzy Logic\n\nFuzzy logic and fuzzy control can be used in a variety of game situations. The general\nidea is that furzy logic can be used anywhere you're wrying co emulate a human expert.\nOther good places for fuzzy logic include Al for enemies (the ogres in battle against\nthe playet’s paladins are scared te what degree’), non-player characters (few much does\nthe shopkeeper trust the player?), flocking algorithms (Sew far away am I from the\nrest of the pack?), and myriad other places.\n\nFuzzy logic can also be used to represent inorganic evenes, such as how clouds\nmove, given wind speed and direction.\n\nConclusion\n\nFuzzy logic is a powerful tool with many uses. With any luck, this article has\nexplained fuzzy logic and how the processes of fuery logic and fuzzy control work, as\nwell as giving you a few ideas on where to use fuzzy logic in your games,\n\nIf you have questions or comments, please contact me or visit my Website. See\nthe author's section for my conract informacion.",
      "content_length": 1388,
      "extraction_method": "OCR"
    },
    {
      "page_number": 323,
      "chapter": null,
      "content": "3.8 Furry Logic for Video Games a28\n\nResources\n\n[Bauter00) Bauer, Peter, Nouak, Stephan, and Winkler, Roman, available online ar\nwww. fl 1 1 suni-linz.ac.av/pdw-furzy/index.html, March 21, 2000.1 based chis arti-\nele on their excellent online lecture,\n\n[Nguyen99] Neuyen, Hung T., and Walker, Elbert A., A Fist Course In Fuuczy Logic,\nCRC Pres, 1999. This is an excellent book that explains mathematically the\nbasic ideas of fuzzy logic.\nfog, 1GD Books Worldwide, 1995. Another great book, this one with an\nemphasis on creating C++ classes and code for both fuzzy logic and neural-net Al\ntechniques.\n\n[Woodoock00) Woodenck, Steven M., “Game Al,” available online ar We frames\ncom, March. 21, 2000. This is a great place for information on all sors of Game\nProgramming Al topics, including fuzzy logic.\n\nAnd, in general, www.gamedev.net/ is a great site for game development.",
      "content_length": 874,
      "extraction_method": "OCR"
    },
    {
      "page_number": 324,
      "chapter": null,
      "content": "3.9\n\nA Neural-Net Primer\n\nAndré LaMothe\n\nIn many ways, the computational limies of digital computers have been realized. Sure,\nwe will keep making them faster, smaller, and cheaper, but digital compurers will\nalways process digital information because they are based on deterministic binary\nmodels of computation. Mewnal nets, on the other hand, are based on different models\nof computation, They are based on highly parallel, distributed, probabilistic models\nthat dont necessarily model a solution to a problem the way a compurer program\ndoes. Instead, they model a network of cells that can find, ascerrain, or correlate pos-\nsible solutions co a problem in a more biological way by solving che problem in little\npisces and pucting the result copecher, ‘This article is a whirlwind tour of neural nets\nand how they work.\n\nBiological Analogs\n\nNeural nets were inspired by our own brains. Literally, some brain in someone's head\nsaid, “T wonder how T work?” and then proceeded to create a simple model of itself.\nWeird, huh? The model of the stanland sewroe'r is based on a simplified model,\ninvented over 50 years ago, of a human neuron. As shown in Figure 3.9.1, there are\nthree main parts to a biological neuron:\n\n* Dendrites. Responsible for collecting incoming signals.\n* Soma. Responsible for the main processing and summation of signals.\n* Axon. Responsible for cransmiteing signals to other dendrites.\n\nThe average human brain has abour 100,000,000,000, or 10\", neurons, and\neach neuron has up co 10,000 connections via the dendrite. The signals are passed via\nelectrochemical processes based on sodium, potassium, and chloride ions, Signals are\ntransferred by accumulation and potential differences caused by these ions. The\nchemistry is unimportane, but the signals can be thought of as simple electrical\nimpulses thar cravel from aor to dendrite. The connections from one dendrite to an\naxon are called sapies, ancl these are the basic signal transfer points,",
      "content_length": 1971,
      "extraction_method": "OCR"
    },
    {
      "page_number": 325,
      "chapter": null,
      "content": "2.9 A Neural-Net Primer L 331\n\nh F Synaptic\n. gaps i Dendrites from\ni ai\n\n| i J\ngam [Soma\n\n1 al\n\nFIGURE 3.9.1. A basic biological neuron.\n\nSo how does a neuron work? Well, chat question docsn't have a simple answer, but\nfor our purposes, the following explanation suffices. The dendrites collect the signals\nreceived From. other neurons; then the soma performs a summation of sorts and, based\non the result, causes the axon to fire and transmit the signal. The firing is contingent\nupon a number af Getors, but we can model it asa cransfer function that processes the\nsummed inputs and then creates an ourput if the properties of the transfer function\nare met. Im addition, the ourput is non-linear in real neurons—thart is, signals aren't\ndigital, they are analog. In fact, neurons are constantly receiving and sending signals,\nand the real model of them is frequency dependent and aust be analyzed in the S-\ndorait: (the frequency domain). The real transfer function of a simple biological neu-\nron has. in fact, been derived, and it fills 2 number of chalkhoards.\n\nNow that we have some idea of what neurons are and what we are Irving to\nmodel, lees talk fora moment about what we can use neural nets for in video games.\n\nApplications to Games\n\nNeural nets seem to be the answer for which we all are looking. If we could just give\nthe characters in our game a litele brains, imagine how cool a game it would be! Well,\nthis is possible, in a sense. Neural nets model the structure of neurons in a crude way,\nbut not the high level functionality of reason and deduction—ar least, nor in the clas-\nsical sense of the words. It takes a bit of thought to come up with ways to apply\nneural-net technology to game Al, but once you get the hang of it, you can use it in\nconjunction with deterministic algorithms, fuzzy logic, and genetic algorithmy to cre-\nate very robust thinking models for your games. Without a doubr, it will be better\nthan anything you can do with hundreds of iFthen statemencs or scripted logic.\nNeural nets can be used for such things as:\n\n* Environmental scanning and classification. A neural net can be fed with infor-\nmation that could be interpreted as vision or audicory information. This infor-\nmation can then be used co select an ourput response or teach the nee. These\nresponses can be learned in real time and updated to optimize the response.",
      "content_length": 2372,
      "extraction_method": "OCR"
    },
    {
      "page_number": 326,
      "chapter": null,
      "content": "S32 Section 3 Artificial Intelligence\n\n* Memory. A neural net can be used by game creatures as a form of memory. The\nneural net can learn through experience a set of responses; then when a new expe-\nrence occurs, the met can respond with something char is the best guess at what\nshould be done.\n\n* Behavioral control. The output of a neural netcan be used to control the actions\nof a game creature. The inputs can be various variables in the game engine. The\nnet can then control che behavior of the creature.\n\n* Response mapping. Neural nets are really pood ar “association,” which is the\nmapping of one space to another. Association comes in two flavors: aufoauecia-\nfen, which is the mapping of an input with itself, and Aeteroasociation, which is\nthe mapping of an input with something else. Response mapping uses a neural\nnet at the back end of output to create another layer of indirection in the control\nor behavior of an object. Basically, we might have a number of control variables,\nbur we have crisp responses for only a number of certain combinations wich\nwhich we can teach the net. However, using a neural net on the output, we can\nobtain other responses thar are in the same ballpark as our well-defined ones.\n\n‘The preceding examples might seem a lirtle fuzzy, and they are. The point is that\nneural nets are tools that we can use in whatever way we like. The key is to use them\nin cool ways that make our Al programming simpler and make game creatures\nrespond more intelligently.\n\nNeural Nets 104\n\nIn this section, we cover the basic ccrminology and concepts used in neural-ner dis-\ncussions. This isn't easy, since neural nets are really the work of a number of different\ndisciplines, and therefore, each discipline creates its own vocabulary. The vocabulary\nthat we deseribe here is a good intersection of the well-known vocabularies, In addi-\ntion, neural-network theory is replece with research char is redundant, meaning thar\nmany peaple reinvent the wheel. This has had che effect of creating a number of\nneural-net architectures thar have different names. I try to keep things as generic as\npossible in this article so thar we don't get caught up in naming conventions. Laver in\nthe antiele we cover some ners that are distinct enough that we refer to them by their\nproper names. As you read, don't be too alarmed if you don't make the “connections”\nwith all che concepts. Just read them for now; most of the concepts are covered again\nin full context in the remainder of the article. Let’s begin.\n\nNow that we have seen the wetware version of a neuron, let's take a look ar che\nbasic artificial neuron on which to base our discussions, Figure 3.9.2 is a graphic of a\nsandard neurede, or arificial neuron, As you can sec, it has a number of inpurs\nlabeled X; —X, and B. These inputs each have an associated weight w, —w,, and b\namached to them. In addition, there is a summing junction Y and a single ourpur y.\nThe output y of the neurode is based on a transfer or “activation” function, which is a\nfunction of the net input to the neurode. The inputs come from the Ms and from B,\nwhich is a bias node. ‘Think of B as a past history, memory, or inclination.",
      "content_length": 3181,
      "extraction_method": "OCR"
    },
    {
      "page_number": 327,
      "chapter": null,
      "content": "4.9 A Meural-Net Primer 333\n\nsingle neurodes\n\nTotal input ¥j,=8-b+ Ex: wy)\n\nFIGURE 3.9.2. Asingle neurodes with = inpurs.\n\nThe basic operation of the neurode is as follows: The inputs X, are each multi-\nplied by their associated weights and summed. The output of the summing is referred\nto as the inpar actination Y,. The activation is then fed to the activation function f(x),\nand the final output is y. The equation for this operation is:\n\nY,=Btb+ EX\" w, (3.9.1)\n\nand y = £(Y,). The various forms of F(x) are covered in a moment.\n\nBefore we move on, we need to talk about the inputs X., che weights w;, and their\nrespective domains. In most cases, inputs consist of the positive and negative integers\nin the set (—, +6), However, many neural nets use simpler éfnadent values (meaning\nthat they have only two values). The reason for using such a simple inpur scheme is\nthar ultimately all inputs are dinary or bipolar, and complex inputs are converted to\npure binary or bipolar represencacions anyway. In addition, Tay times we ane trying\nro solve computer problems such as image or voice recognition, which fend them-\nselves to bivalent represencations, Nevertheless, chis rule is not etched in stone. The\nvalues used in bivalent systems are primarily 0 and 1 in a binary system or—1 and 1 in\na bipolar system. The twe systems are similar excepe thar bipolar representations rurn\neut to be mathematically better than binary ones. The weights w, on each input are\ntypically in the range (—e, +e) and are referred to as excisarory and inmbibitery for pos-\nitive and negative values, respectively. The extra inpuc & (the bias) is always 1.0 and is\nscaled or multiplied by b—thar is, bis its weight, in a sense. This concept is illustrated\nin Equation 3.9.1 by the leading term.\n\nContinuing with our analysis, once the activation Y, is found for a neurode, ir is\napplied to the activation function and the output y can be computed. There are a\nnumber of activation functions, which have different uses. The basic activation func-\ntions £,(x) are shown in Table 3.9.1.",
      "content_length": 2065,
      "extraction_method": "OCR"
    },
    {
      "page_number": 328,
      "chapter": null,
      "content": "Bes | Section 3 Artificial intelligence\n\nTable 3.9.1. Tho Activation Functions f, [x]\n\nEquation 3.9.2 Equation 3.9.3 Equation 3.9.4\nFix) =1,ifx2@ Fix} = x, forallx F(x} = 1/(l+e*)\n0, ifx<@\n\nThe equations for cach function are fairly simple, bur each is derived to model or\nfit various propertics.\n\nThe sep function is used in a number of neural nets and models as a meuron fir-\ning when a cricical input signal is reached. This is the purpose of the factor @, which\nmodels the critical input level or threshold ac which the scurode should fire. The Jin-\near activation function is used when we wane che output of the neurode vo more\ndosely follow the input activation. This kind of activation function is used in model-\ning Jinear systems such as basic motion with constant velocity, Finally, che expomential\nactuation function is used to create a won-dinear response, which is the only possible\nway to create neural nets that have non-linear responses and model non-linear\nprocesses. The eqpenentia! ecteation function is key in advanced meural mets because\nthe composition af linear and step activation functions is always linear or step; we will\nnever be able to create a net that has non-linear response, ‘Therefore, we need the\nexponential activation function to address che non-linear problems that we wane to\nsolve with neural nets, However, we are noc locked into using the exponential fune-\ntion. Ayperbolic, dogarithmic, and manscendental fenetions can be used as well, depend-\ning on the desired properties of the ner. Finally, we can scale and chift all these\nfunctions if we need to.\n\nAs you can imagine, a single neurode isn't going to do a lot for us, so we need to\ntake a group of them and creare a layer of neurodes, as shown in Figure 3.9.3. This\nfigure illustrates a single-layer ncural nerwork The neural net in Figure 3.9.3 has a\nnumber of inputs and a number of output nodes, By convention, this is a single-layer\nnet because the input layer is not counted ules it is che only layer in che nerwark. In\nthis case, the input layer is also the ourput layer; hence, there is onc layer. Figure 3.9.4\nshows a two-layer neural net. The input layer is still not counted, and che internal\nlayer is referred to.as “hidden.” The output layer is referred to as che ourpur or regparne\nLeper, Theoretically, chere is no limit to the number of layers a neural net can have:",
      "content_length": 2380,
      "extraction_method": "OCR"
    },
    {
      "page_number": 329,
      "chapter": null,
      "content": "3.9 A Neural-Net Primer a5.\n\nMietes welt (Aa aren ace are equal in 0.0\n\nFIGURE 3.9.3. A four-input, chree-newrode, single-Layer neural net.\n\nhowever, it might be difficult to derive the relationship of the various layers and came\nup with tractable training methods. The best way to create multilayer neural nets is to\nmake each network one or two layers and then connect them as components or func\ntional blocks.\n\nAll right. now let’s talk abour remponz or time-relared topics, We all knerw that\nour brains are fairly slow compared to a digital computer. In fact, our brains have\neyele times in the millisecond range, whereas digital computers have oycle times in the\n\nHIDDEN LAYER OUTPUT LAYER\nBigs Blas\n\nMoin: waelghis ig 1nd Wie are dittererct\n\nFIGURE 3.9.4. A two-layer neural network.",
      "content_length": 789,
      "extraction_method": "OCR"
    },
    {
      "page_number": 330,
      "chapter": null,
      "content": "Section 3 Artificial Intelligence\n\nnanosscond and, soon, sub-nanosecond range. This means that signals take time ro\ntravel from neuron to neuron. This fact is also modeled by artificial neurons in the\nsense that we perform the computations layer by layer and transmit the results\nsequentially, This model helps co better model the time lag involved in the signal\ntransmission in biological systems such as humans.\n\nWe are almost done with the preliminaries. Lers talk about some high-level con-\ncepts and then finish up with 2 couple more terms. The question thar you should be\nasking is, “What the heck do neural nets do?” This is a good question, and it’s a hard\none to answer definitively. The question should be, “What do you want to ley to\nmake neural nets do?\" Neural nets are basically mapping devices that help map one\nspace to another space, In essence, they are a type of memory. Like any memory, we\ncan use some familiar terms co describe them. Neural nets have both short-term\nmemory (STM) and long-term memory (LTM). STM is the abiliry for a meural net to\nremember something it just learned, whereas LTM is the ability of a neural net to\nremember something it learned some time ago amid its new learning.\n\nThis leads us no dhe concept of plaricty or, in other words, how a neural pet deals\nwith new information or training. Can a neural net learn more information and still\nreeall previously stored information correctly? If so, does the neural net become\nunstable because it is holding so much information that the dara starts to overlap of\nhas common intersections? This area is referred ta as stability. The bottom line is, we\nwant a neural net to have a good LTM, a good STM, be plastic (in most cases), and\nexhibit stability. OF course, some neural ners have no analog 1 memory. They are\nmore for functional mapping, so these concepts don't apply aa is.\n\nNow thar we know about these memory concepts, let's talk about some mathe-\nmatical fectors char help measure and understand these properties.\n\nOne of the main uses for neural nets is as memories, which can produce a\nresponse by processing inpuc that is incomplete or “noisy.” The response might be che\ninput itself (auteaseciation) or another output thar is totally different from the input\n(Aeteroanociarion). Furthermore, the mapping may be from an n-dimensional space wo\nan m-dimensional space and non-linear to boot. The bottom line is that we want to\nsomehow store information in the neural net so that inputs (perfect inputs as well as\nnoisy ones) can be processed in parallel. This means char a neural net is a kind of\nhyperdimensional memory unit because it can associate an input n-tuple with an out\nput m-tuple, where m cam equal n, but it docsn't have co.\n\nWhat neural nets do in essence is partition an n-dimensional space Into regions\nthat uniquely map the input co the outpur or classify the input inte distincr classes,\nlike a funnel of sorts. Now, as the number of input values (vectors) in the inpuc data\nset (which we eall 5) increase, it logically follows that the neural ner will have a harder\ntime separating the information, As a neural net is filled wich information, the input\nvalues that are to be recalled overlap, since the input space can no longer keep every-\nthing partitioned in a finite number of dimensions. This overlap results in crovseadh,\nmeaning that some inputs are not as distinet as they could be. Crosstalk might or",
      "content_length": 3430,
      "extraction_method": "OCR"
    },
    {
      "page_number": 331,
      "chapter": null,
      "content": "3.9 A eural-Net Primer 347\n\n= --\n\nmight not be desired. Although this problem isn't a concem in all cases, itis a concern\nin associative memory mcural nets, so to illustrare the concept, let's assume thar we are\nOrFing to associate n-tuple input vectors with some output set. The output set isn't as\nmuch of a concern to proper functioning as che input set is.\n\nIf a set of inputs 5 is binary, we are looking at sequences in the form\n11O1010,..10110. Let's say chat our inpur bit vectors are only 3 bits each; therefore,\nthe entire input space consist of these eighe vectors:\n\n¥, = (0,0,0), v. » (0,0,1), v. = (0.1.0), v, = (0.1.1), vs = (1,0,0), v= (10,1), ¥. =\n(1,1,0), v,= (11,1)\n\nTo be more precise, the basis for this set of vectors is:\nv= (1,0,0) “bb. + (0,1,0) * b, + (0,0,1) * b,.\n\nwhere b, can take on che values 0 or 1.\nPor example, if we lec bj=1, b,=0, and by=1, then we get the vector:\n\nv= (1,0,0) * 1 + (0,1,0) * 0 + (0,0,1) * 1 = (1,0,0) + (0,0,0) + (0,0,1) = (1,0,1)\n\nwhich is ¥, in our possible inpur set.\n\nA. basis is 2 special vector summation that describes a set of vectors in a space. So\nv describes all the vectors in our space. To make a long story short, the more orthege-\nmal the veccors in the input set. the better they distribure in a neural net and the bet-\nter they can be recalled. Oreboganality refers to the independence of the vectors or, in\nother words, if nwo vectors are orthogonal, their dot product is 0, their projection\nonto ome another is 0, and chey cant be written in terms of one another. In the set v\nare a lot of orthogonal vectors, but they come in small groups—for example, ¥, is\northogonal to all the vectors, so we can always include it. But if we include v, in our\nset 5, the only other vectors char will fit and maintain orthogonaliry are v, and ¥, or\nthe sec:\n\n¥, = (0,10.0), = (0,0, 1 he ¥ = (0,1 iO}, y= (1,0,0)\n\nWhy? Because vy; - vy; for all ij from 0..3 is equal co 0. In other words, che dot\nproduct of all che pairs of vectors is 0, so they must all be orthogonal. Therefore, this\n\nset will do very well in a neural net as input vectors. However, the set:\n\nwill potentially do poorly as inputs because v, - ¥; is non-zero of, in a binary system,\nitis L. The next question is, “Can we measure this orchogonaliry?” The answer is yes,\nIn the binary vector system, there is a measure called Aanmring distance. It is used to\nmeasure the n-dimensional distance between binary bit vectors. The hamming dis-\ntance is simply the number of bits that are different beoween nwo vectors. For exam-\nple, the vectors:\n\n¥o = (0,0,0), ¥, = (0,0,1)",
      "content_length": 2592,
      "extraction_method": "OCR"
    },
    {
      "page_number": 332,
      "chapter": null,
      "content": "338 Section 3 Artificial Intelligence\n\nhave a hamming distance of 1, whereas the vectors:\n¥2 = (0,1,0), vy = (1,0,0)\n\nhave a hamming distance of 2.\n\nWe can use hamming distance as the measure of orthogonality in binary bir ver-\ntor systems, which can help us determine whether our input vectors will have a lot of\noverlap. Determining orthogonality with general vector inputs is harder, bur the con-\ncept is the same.\n\nThat's all the time we have for concepts and terminolagy, so let's jump right in\nand sec some actual neural nets chat you will be able to use in your game's Al. We\ncover neural nets used to perform logic functions, classify inputs, and associace inputs\nwith outputs.\n\nPure Logic, Mr. Spock\n\nThe first artificial neural networks were created by McCulloch and Pitts in 1943.\nThese neural networks were composed of a number of neurodes and were Typically\nused to compute simple logic functions such 2s AND, OR, XOR, and combinations\nof them. Figure 3.9.5 is a represencation of a basic McCulloch-Pitts neurode with own\ninputs. IF you are an electrical engineer, you will immediately see a dose resemblance\nbetween MoCulloch-Pitts neurodes and transistors or MOSFETs. In any case,\nMcCulloch-Pitts neurodes do mor have biases and have the simple activation function\nf(x), which is equal to Equation 3.9.5.\n\nf(x) = 1, ifx=0 (3.9.5)\n0. ifx<6\n\nThe MP (McCulloch-Pitts) neurode functions by summing the product of che\ninputs X, and weights w, and applying the result Y, co the activation function fo(x).\nThe early research of MeCulloch-Pitrs focused on creating complex logical circuitry\nwith the neurode models. In addition, ane of the rules of the meurode model is that it\ntakes one time step for a signal to travel fom neurode to neurode, This helps model\nthe biological nature of neurons more closely,\n\nLet's take a look at some examples of MP neural nets that implement basic logic\nfunctions. ‘The logical ANT? function has the following truth rable:\n\nMI X22 © ©6(Qurpur\n( 0 0\no I 0\nI 0 0\nL 1 1\n\nWe can model this table with a two-input MP neural net with weights w,=1,\nw =I, and 8=2, This neural net is shown in Figure 3.9.6a. As you can see, all input",
      "content_length": 2168,
      "extraction_method": "OCR"
    },
    {
      "page_number": 333,
      "chapter": null,
      "content": "3.8 A Neural-Net Primer 39\n\nOx.\n\nInputs ¥ Output\nWl, y\nMy Wig = By, #0,\ny=1,if¥,,>8\n0,7 ¥),,= 4\n\nFIGURE 3.9.5. The MeCulloch-Pitts neurodes.\n\ncombinations work correctly. For ceample, if we ory inputs X,=0, ¥,=1. the activation\n\nwill be:\nyw, + Xp\" wy = (1\"(1) + (OND) =\n\nIf we input 1 to the activation function Fag) the resule is 0, which is correct. As\nanother example, if we ory inputs X,=1, X)=1, the activation will be:\n\nX,tw, + X%w, = (1)\"(1) + (LY) = 2\n\nIf we input 2 to the activation function Fox), the result is 1, which is comect.\nThe other cases work aloo. The function of the OR ts similar, but the threshold of 6 is\nchanged to 1 instead of 2, as it is in the ANID. You can try running through the euch\ntable yourself to see the resules.\n\nThe XOR network is a little different because it really has two layers, in a sense,\nbecause the results of the pre-processing are further processed in the output neuron.\nThis isa good example of che reason a neural net needs more than one layer to solve\ncertain problems. The XOR isa common problem in neural nets, used to test a neural\nnet's performance. In any case, KOR is not linearly separable in a single layer; it must\nbe broken down into smaller problems and then the results added together. Let's rake\na look at MOR as che final example of MP neural networks, The truth table for KOR\n\nis a5 follows:\nXI M2 Output\n0 0 0\n0 l I\n1 it 1\n1 I 0\n\nXOR is cue only when che inputs are different. This is a problem because both\ninpucs map co the same output. KOR is not linearly separable, as shown in Figure\n3.9.7. As you can see, there is na way to separate the proper responses with a straight\nline. The pains is that we can separate the proper responses with two lines, which is\njose what two layers do. The first layer pre-processes or solves part of che problem, and",
      "content_length": 1822,
      "extraction_method": "OCR"
    },
    {
      "page_number": 334,
      "chapter": null,
      "content": "Section Artificial Intelligence\n\nInputs\n\nB\nHIDDEN LAYER\nH=1\nInputs\nCc\n\nFIGURE 3.9.6. Basic logic functions implemented with MeCulloch-Pirts new.\n\nthe remaining layer finishes up. Referring to Figure 3.9.6c, we see that che weights are\nwy=l, w=—l, wy=1, wy=—-l, wy-1, w=]. The network works as follows: Layer One\ncomputes whether X, and X, are opposites in parallel, he results of either case (0,1)\nor (1,0) are fed to Layer Two, which sums these up and fires if either is true. In\nessence, We have created che logic function:\n\nz = ((X, AND NOT X,) OR (NOT X, AND X,))\n\nIfyou would like to experiment with the basic McCulloch-Pitts neurode. Listing\n3.9.1 on the CD is a complete two-inpur, single-neurode simulator with which you\nCal experiment,",
      "content_length": 744,
      "extraction_method": "OCR"
    },
    {
      "page_number": 335,
      "chapter": null,
      "content": "29 A Meural-Net Primer BPG |\n\na. The best & single layer\n\nnetwork cen do %\nA. single lina cant\nportion the +'s\nfrom the —'s\na |\nb, With two layers Layer 2\nthe sor can be Ky |\n+ =\nsolved ee *1,1)\n=——= Layer\n7 = A ih + -\n0,0) (7,0) my\n\nFIGURE 3.9.7. Using the XOR function vo ilbuscrace linear separabiliry.\n\nThat finishes up our discussion of che basic building block invented by McCaul-\nloch and Pits. Now ler’s move on to more contemporary neural nets such as those\nused to classify inpur vectors.\n\nClassification and “Image” Recognition\n\nAr this point, we are ready to start looking at real neural mets thar have some girth to\nthem! To segue into the following discussions on Hrbbien and Hopfield neural nets,\nwe analyze a generic neural net structure thar illustrates a number of concepts such as\nlinear separabiliry, bipolar representations, and the analog that neural mets have with\nmemories.\n\nLet's begin by making a look at Figure 3.9.9, which shows the basic neural net\nmodel we use. As you can sec, it is a single-node net with three inputs, including the\nbias, and a single ourpur. ‘We will see whether we can use this network to solve the\nlogical AND function that we solved se easily with McCulloch-Pits neurodes.",
      "content_length": 1225,
      "extraction_method": "OCR"
    },
    {
      "page_number": 336,
      "chapter": null,
      "content": "Section 3 Artificial Intelligence\n\nFIGURE 3.9.8. The basic neural-net model used for discussion.\n\nLer's start by first using bipolar representations, All Os are replaced with —1s, and\nIs are left alone. The truth table for logical AND using bipolar inputs and ourpuss is\n\nas follows:\n\nbt et Output\n-l =|] -l\n-] i -]\n\n] =| —]\n\n] | ]\n\nEquation 3.9.6 shows the activation function £.(x) char we will use.\n\nf(x) =1,ifx>68 (3.9.6)\n—l,ifx<6\n\nNotice thar the function is step with bipolar outputs. Before we continue, let me\nplace a seed im your mind: The bias and chreshold end up doing the same thing, giv-\ning us another degree of freedom in our neurons that make che neurons respond in\nways that cant be achieved without them. You will see this concept illustrated shortly,\n\nThe single-neurode net in Figure 3.9.8 will perform a classification for us, In-will\ntell us wheeher our input is in one class or another. For example, is this image a (ree or\nnora tree? Or in our case, is this inpur (which just happens to be the logic for an\nAND) in the +1 class or the <1 class? This is the basis of most neural nets and the rea-\nson I was belaboring linear separabilicy, We need to come up with a linear partiion-\ning of space that maps our inputs and outputs soa solid delineation of space separates\nthem. Thus, we need to come up with che comect weights and a bias thar will do this\nfor us. Bur how do we achieve this goal? Do we merely use trial and error, of is there a\nmethodology? The answer is that there are a number of ining methods to teach a\nneural met, These maining methods work on various mathematical premises and can\nbe proven, but for now, we simply pull some values thar work out ofa har. These cxer-\ncises lead us into the learning algorithms and more complex nets thar follow.\n\nAll right, we are trying to find weights w; and bias b thar give use the correct\nresult when the various inputs are fed to our nerwork with the given activation func-",
      "content_length": 1956,
      "extraction_method": "OCR"
    },
    {
      "page_number": 337,
      "chapter": null,
      "content": "3.8 AWNeural-Net Primer 343\n\ntion F(x), Let's wrote down the activacion summation of our neurode and see whether\nwe can infer any relationship berween the weights and the inputs thar might help us.\nGiven the inputs X, and X, with weight: w, and w, along with Bel and bias b, we\nhave the following formula:\n\nK,\"w, + x, + B\"b=8 (3.9.7)\nSince B is always equal to 1.0, che equation simplifies to:\nKy\"w, + X,\"*w, + bef\n\nWhar is this entiry? Ir's a line! Ane ifthe left side is greater than or equal ro 8, that\nis, (M,°w, + X,*w, + b), che meurode will fire and ourput 1; otherwise, che newrode\nwill output -1. Therefore, the line is a decision boundary. Figure 3.9.92 illustrates this\neencept. In the figure, You can see chat the slope of the line is -w,/w,, and the X,\nintercept is (0-b)/w;. Now can you see why we can gee nid of 6? It is part of a con-\nstant, and we can always scale b to take up any loss, so we assume that @ = 0. The\nresulting equation is:\n\nX= —X,°w, fr, — bier\n\nAy = XW, fw, + (G—-b)/w, (solving in terms of X,)\n\nWhar we want co find are weights w, and w, and bias b so thar ir separates our\nourpucs or classifies chem inte singular partitions withour overlap. ‘This is the key to\nlinear separabiliry. Figure 3.9.9b shows a number of decision boundaries that suffice,\nso we can pick any of them. Let's pick the simplest values, which are:\n\nWw, =w, = |\n\nb=—l\nWith these values, our decision boundary becomes:\nmg = =A)\" w/w — biw, — My = —-1\"X, +]\n\nThe slope is =1 and the X, intercept is 1. Ifwe plug che inpue vectors for the log-\nical AND into this equation and use the £{x) activation function, we will ger the cor-\nfect ouipucts. For example, if X, + Xy—1> 0, chen fire the neurode; else output —1.\nLet's try it with our AND inputs and see what we come up with:\n\nInput X]1 x2 Output (X2+X1-1)\n| -l (-I}+(-1})-l=3<0 = dont fire, output —1\n—1 I (-I)+(1)-l=-1<0 = don't fire, output -1\n\nl 1 (1)+Cl)-l=-2<0 dont fire, outpur —1\n\nI 1 (+-l=1.0 fire, outpure 1",
      "content_length": 1974,
      "extraction_method": "OCR"
    },
    {
      "page_number": 338,
      "chapter": null,
      "content": "a44 Section3 Artificial Intelligence\n\nFIGURE 3.9.8. Mathematical decsston boundaries generated by weights, bias, and 8.",
      "content_length": 119,
      "extraction_method": "OCR"
    },
    {
      "page_number": 339,
      "chapter": null,
      "content": "2.9 A Newral-Net Primer 245\n\nAs you can ses, the neural neowork with the proper weights and bias salves the\nproblem perfectly. Moreover, there is a whole family of weights thar will do just as\nwell (sliding the decision boundary in a direction perpendicular to itself}. However,\nthere is an important poinc here. Withour the bias or threshold, only lines chrough\nthe origin are possible, since the X, intercept has to be zero. This is very important\nand the basis for using a bias or threshold, so this example has proven an important\none, since it has flushed out this fact.\n\nSo, are we closer co seeing how to algorithmically find weighes? Yes, we now have\na geometrical analogy, which is the beginning of finding an algorithm.\n\nThe Ebb of Hebbian\n\nNow we are ready co see the first learning algorithm and its application to a neural\nnet. One of the simples: leaming algorithms was invented by Donald Hebb and is\nbased on using the input vectors co modify the weights in a way so thar the weights\nereate the best possible linear separation of the inputs and ourpurs. Alas, the alga-\nrithm works merely okay. Actually, for inputs that are orthogonal, it is perfece, bur far\nnen-orthoponal inpurs, the algorithm falls apart. Even though the algorithm doesn't\nresult in correct weights for all inputs, however, it is the basis of most learning algo-\nrithms, so we start here.\n\nBefore we see the algorithm, remember thar it is for a single-neurode, single-layer\nneural net. You can, of course, place a number of neurodes in the layer, but they all\nwork in parallel and can be taught im parallel. Are you starting to see the massive par-\nallelization char newral mers exhibie? Instead of using a single weight vector, a multi-\nnheurode net uses. a weight manrix. The algorithm is simple; it goes like his:\n\nGipen:\n\n* Input vectors are in bipolar form I = (=1,1,..-1,1) and contain k elements.\n\n* There are nm inpur vectors, and we refer to the secas I and the jch element as I.\n* Ourputs are referred to as y,, and there are k of them, one for each input I,\n\n* The weighs w,—w, are contained in a single vector w = (w,, We, -.- W,)-\n\n1. Initialize al your weights to 0, and let them be contained in a vector w that has n\nenuies. Also initialize che bias b to 0.\n\n2. For j= 1 ton, do:\nbebey, (where ¥ is the desired output)\nwewel)*y (remember, ds is a vector operation)\nend do\n\n‘The algorithm is nothing more than an “accumulator of sorts, shifting the deci-\nsion boundary based on the changes in the input and output. The only problem is",
      "content_length": 2534,
      "extraction_method": "OCR"
    },
    {
      "page_number": 340,
      "chapter": null,
      "content": "346 section 3 Artificial intelligence\n\nthat it sometimes can't move the boundary fast enough (or at all), and so “learning”\ndoesnt take place.\n\nSo how do we use Hebbian learning? The answer is, the same way as the previous\nnetwork except that now we have an algorithmic method with which to teach the net,\nso we refer to the net asa ebb or Hebbian net,\n\nAs an example, let's take our rusty logical AND function and see whether the\nalgorithm can find the proper weights and bias to solve the problem. The following\nsummation is equivalent to running the algorithm:\n\nwe [Lyi] + (h\"y2) + [Ey\"y5] + [\"ya) = -1, -1)\"(-1)] + [(-1, 1)*t-1)] +\n(C1,—-1)\"-1)] + (C1, 1)%{1)] = @,2)\n\nb=y) ty. t+yst yy = (1) + (-1) + (-1) +0) =2\n\nTherefore, w)=2, w;=2, and b=—2. These are simply scaled versions of the values\nwy=l, wy-1, b=—1 thar we derived geometrically in the previous section. Killer, huh!\nWith this simple learning algorithm, we can tain a neural net (consisting of a single\nneurode) to respond ro a set of inputs and cither classify che inpurtas true or false, 1 or\n—1. Now if we were to array these neurodes together to create a nenwark of neurodes,\ninstead of simply classifying the inputs as on or off, we can associate patterns with the\ninputs. This is one of the foundations for the next neural-net structure, the Hopfield\nnet. One more thing: The activation function used for a Hebb net is a sep with a\nthreshold of O and bipolar outputs 1 and -1,\n\nTo get a feel for Hebbian learning and how to implement an actual Hebb ner,\nListing 3.9.2 on the CD contains a complete Hebbian Neural Net Simulator. You can\ncreate networks with up to 16 inputs and 16 neurodes (ourpues). The program is self-\nexplanatory, buc there are a couple of interesting properties: You can select one of\nthree activation functions, and you can input any kind of dara. Normally, we would\nstick to the step activation function, and inputs/outputs would be binary or bipolar.\nHowever, in the light of discovery, maybe you will find something interesting with\nthese added degrees of freedom. I suggest that you begin with the step function and\nall bipolar inputs and outputs, though.\n\nPlaying the Hopfield\n\nJohn Hopfield is a physicist who likes to play with neural nets (which is good for us),\nHe came up with a simple (in structure at least) bur effective neural merwork called\nthe Hopfield net, which is used for autoassociation. You input a vector x and you pet x\nback (hopefully!) A Hopfield net is shown in Figure 3.9.10, It is a single-layer net-\nwork with a number of neurodes equal to the number of inputs KM. The merwork is\nfully connected, meaning that every neurode is connected to every other neurode and\nthe inputs are also the outputs. This structure should strike you as weird, since there\nis feedback. Feedback is one of the key features of the Hopfield net and che basis for\n\nthe convergence to the correct result.",
      "content_length": 2903,
      "extraction_method": "OCR"
    },
    {
      "page_number": 341,
      "chapter": null,
      "content": "3.9 A Neural-Net Primer 47\n\nw=[4m 4]\n\nInputs ( Wag Outputs\n\nx, ¥ -—s J\natl Ye\n\n* Single Layer\n\n* Inputs x, act as outputs y,\n\nBidirectional arrows\n\nmean thal 4 Wo A =\n\n———_\n\nOutput becomes input\nalter Tet cycle\n\nFIGURE 3.9.10. A four-node Hopfield auroasociative neural nes.\n\nThe Hopfield network is am frerative autoaueciative memory. This means chat it\ncan take ane or more cycles to retum the correct result (if at all). Let me clarify: The\nHopfield network takes an input and then feeds it back, and the resuling ourput\nmight or might not be the desired inpur. This feedback cycle can occur a number of\ntimes before the inpuc vector is returned. Hence, a Hopfield network functional\nsequence is as follows: First, we determine the weights based on our input vectors that\nWe WANT to autoassociare, then we input a vector and see what comes out of the acti-\nvations, [F the resulr is the same as our original input, we ane done; if ner, we take the\nresult vector and feed it back chrough the network,\n\nNow let's take a look at the weight matrix and learning algorithm used for Hop-\nfield nets.\n\nThe learning algorithm for Hopfield nets is based on the Hebbian rule and is\nsimply a summation of products. However, since the Hopfield network has a number\nof input neurons, the weights are no longer a single array or vector bur a collection of\nvectors that are most compactly contained in a single matrix. Thus the weight matrix\nW fora Hopiield net is created based on this equation:",
      "content_length": 1483,
      "extraction_method": "OCR"
    },
    {
      "page_number": 342,
      "chapter": null,
      "content": "Section 3 Artificial Intelligence\n\nrrrwrs:\n* Input vectors are in bipolar form I = (-1,1,,..-1,1) and conrain k elements.\n* There are m input vectors, and we refer to the set as T and the je element as I...\n* Outputs are referred to as y, and there are k of them, one for each input 1.\n* The weighe macrix W is square and has dimension kx k, since dhere are k inputs.\n\nk\nWray = 51x], (3.9.8)\n\nb= 1\n\nNote: Each outer product has dimension k x k, since we are multiplying a column\nvector and a row vector\n\nWi = 0, for alll i,\n\nNotice that there are no bias terms and the main diagonal of W must be all\nzerocs. The weight macrix is simply the sum of matrices generated by multiplying the\ntranspose I) * I, for all i from 1 ton, This is almose identical to the Hebbian algo-\nrithm for a single neurode except that instead of multiplying the input by the output,\nthe input is multiplied by isself, which is equivalent to the ourpur in the case of\nautoassociation. Finally, che activation function f(x) is as follows.\n\n0, ifx<0\n\nf,(=) is a step function with a binary ourpur. This means thar the inputs must be\nbinary, but didn't we already say that che inputs are bipolar? Well, they are, and they\naren't. When the weight matrix is generated, we convert all input vectors to bipolar,\nbut for normal operation we use the binary version of the inputs, and the output of\nthe Hopfield net will also be binary. This convention is not necessary, but it makes the\nnetwork discussion a litle simpler.\n\nAnyway, let's move en to an example. Say we want to create a four-node Hopfield\nnet and we want it co recall these vectors:\n\nT,=(0,0,1,0), T,=(1,0,0,0), 1,=(0,1,0,1) Note: these are orthogonal.\nConverting to bipolar (*), we have:\n\nI) = C1,-1,1,-1) , I, = (1,-1,-1,-1), I; = (-1,1,-1,1)\n\nNow we need to compute W), W, Ws, where W is the product of the transpose\nof each inpur with itself\n\nWy=(1,'x 0, J = (-1,-1,1,-1} x (=1,=1,1,-1) =\n1 1 =] 1\n1 L = 1\n4 hi oot ee cal\n1 1 -l 1",
      "content_length": 1964,
      "extraction_method": "OCR"
    },
    {
      "page_number": 343,
      "chapter": null,
      "content": "3.9 A Meural-Net Primer 249\nel!\n\nWy, = [1,*x Ly ] = (1,-1.-1,-1} x (1,-1,-1,-1) =\n\n] -l -l1 -l\n-l 1 1 ]\n—l 1 1 I\n—l 1 1 |\n\nWy; = (1,*x I, ] =(€1,1=-1,1) x (-1,1,-1,]) =\nLe teed od ay\n=| i -l I\n eloeclel a]\nelite alee nol\n\nThen we add W, + W, + W,, resulting in:\n\nWo e2aa) =\n\n3 -1 -l =\n—) 3 =I 3\n—l -l 3 —l\n-l || 5\n\nZeroing out the main diagonal gives us che final weipht maqix:\n\nWs\n\n0 -l =-1 -1\n—| 0 =! 3\n= ee)\n-l 3 =! )\n\nThat's it, now we are ready to rock. Let's inpur our original vectors and see the\nresults, To do this, we simply multiply the input by the matrix and chen process each\noutput value with our activation function f(x). Here are the results:\n\nI, x W = (-1,-1,0,-1) and f{(-1,-1,0,-1)) = (0,0,1,0)\n1, * W = (-2,3,-2,3) and &((-2,3,-2,5)) = (0,1,0,1)\n\nThe inpurs were perfectly recalled, and they should be, since they were all orthog-\nonal, As a final example, let's assume thar our input (visual, auditory, ete.) is a litle\nnoisy and the inpur has a single error in it. Let's take I, = (0,1,0,1) and add some noise\nto T,, resulting in 1° ~ (0,1,1,1). Now let's see what happens if we input this noisy\nvector to che Hopfield net:\n\ni x OW = (3, 2-3, 2) and f ((—3.2,-2, 2)) has (0,1,0,1)",
      "content_length": 1203,
      "extraction_method": "OCR"
    },
    {
      "page_number": 344,
      "chapter": null,
      "content": "350 Section 3 Artificial intelligence\n\nAmazingly cnough, the original vector is recalled. ‘This is very cool. So we might\nhave a memory that is filled with bit patterns char look like trees (oaks, weeping wil-\nlow, spruce, redwood, etc.}. MPwe input another tree thar is similar to, say, a weeping\nwillow bur hasn't been entered inco the net, our net will (hopefully) output a weeping\nwillow, indicating that this is whar ir “thinks” it looks like.\n\nThis is one of the strengths of associative memories: We don't have to teach the\nnetwork every possible input. We just have to teach ir enough to give it a good idea.\nThett inputs thar are “close” will usually converge to at actual trained input. ‘This is\nthe basis for image and voice recognition systems.\n\n‘To complete our study of neural nets, I have included a Hopfield auvoassociative\nsimulator that allows you to create nets with up to 1G neurodes. It is similar no che\nHebb net, but you must use a step activation function and your input exemplars must\nbe in bipolar while training and binary while associating {running}. Listing 3-9-3 on\nthe CD contains the code for the simulator.\n\nConclusion\n\nI hope that this article has given you an idea of whar neural nets are and how to create\nsome working computer programs to model them. We covered basic terminology and\nconcepts, some mathematical foundations, and finished up with some of che more\nprevalent newral-net structures.\n\nHowever, there ts still so much more to learn about neural nets: Perceptrons,\nfuzzy ASOCTVEe MeMeries (FAs), bidirectional associative memories (BANMs),\nKohonen maps, Adalines, Madalines, back-propagation networks, adaptive resonance\ntheory networks, “brain state in a box,” and a loc more, Well, that's it, my neural net\nwants to play PlayScarion 2!",
      "content_length": 1784,
      "extraction_method": "OCR"
    },
    {
      "page_number": 345,
      "chapter": null,
      "content": "4.0\n\nOptimizing Vertex Submission\nfor OpenGL\n\nHerbert Marselas\n\nThere are a number of functions available for submining and rendering vertices in\nOpenGL, which range from the simple immediate mode functions to more compli-\ncated multiple vertex functions and vendor-specific extensions. However, the pertor-\nmance can vary greatly depending on the fanctionaliry used.\n\nImmediate Mode\n\nOften, immediare mode functions (e.g., giVertex*, glColor*, giNormal*) are used to\nget up and rendering quickly, These are easy to use since cach function is geared\ntoward submitting a different component of the vertex: position, color, normal, tex-\nture coomdinates, etc. However, what makes che immediate mode functions so easy to\nuse (submitting a vertex component by component) also makes them the lowest per-\nforming.\n\nThis is due to two factors. First, several function calls are required to render a sin-\ngle vertex. Second, each function must be entered, where it then performs a small\namount of work, and then exited, The time required to enter and leave a function is\ncalled the irmenan everfesd. This overhead occurs regardless of the amount of work\nthe function does, and represents a fixed amount of time required to use the function.\nIf the function does a lot of work, chen the overhead will be low compared co the\nwork being accomplished, If the function doesn’t do a lot of work, or if the function\nis called a large number of times, the overhead can quickly add up.\n\nFigure 4.0.1 shows the amount of time in CPU cycles required co submit 300 col-\nored, textured, and transformed vertices using the immediate mode functions\nglTextured?, glCelerdf, and givertexat. The 300 vertices comprise 100, three-pixel,\ndiscrete, uniform, right triangles. These timings were taken under Microsoft Win-\ndows 98 on a 450MHz Pentium II using a popular consumer OpenGL graphics card.\nThe source code used to generate this dara can be found as a Microsoft Visual C++ 6\nproject on the accompanying CD.",
      "content_length": 1985,
      "extraction_method": "OCR"
    },
    {
      "page_number": 346,
      "chapter": null,
      "content": "354 Section4 Polygonal Techniques\n\ninmediate Mode Viertex Submission\nTune to Submit Each Verte\n\nFIGURE 4.0.1 CPU cyeles to submit 300 vertices (100 discrete triangles} using immediate mode,\n\nUsing small transformed triangles removes the time spent in transform (they are\nalready transformed), lighting (hey are pre-lit), and rasterizarion (they are very\nsmall). This guarantees that we are effectively measuring che rime required to enter\neach function, store the data, and return. In total, it required -163,154 CPU cycles to\nsubmit and render all 300 vertices.\n\nOn average, it took -544 CPU eycles to submit the position, color, and texture\ncoordinate of a single vertex. However, there were spikes in performance. This can be\nseen in the glVertex function char rook -38238 CPU cycles the first time it was called\nduring a frame, probably co allocare data, although more detailed analysis of the dri-\nver would be required 00 verify this. It then averaged -308 CPU eyeles per call with\nspikes up to ~1500+ CPU cycles per call. The full analysis is contained in a Microsoft\nExcel 97 spreadsheet on the accompanying (CD),\n\nThe simplest way of improving performance would be to remove the function\noverhead by reducing the number of functions called 09 submit and render che 300\nvertices. Calling one or two functions to submit and render all 300 vertices could be\nmuch higher performing than calling 900 functions as we have just done.\n\nInterleaved Data\n\nIf your vertex data is already contained ina single straccure, glinterleavedarrays can\nbe used to submit all the components of the vertex in a single finction call. gliInter-\nJeavedArrays is capable of submitting a number of standard interleaved vertex suruc-\ntures ranging from a lightweight position-only vertex, to a heavyweight vertex with\nposition, normal, diffuse color, and texture coordinates.",
      "content_length": 1856,
      "extraction_method": "OCR"
    },
    {
      "page_number": 347,
      "chapter": null,
      "content": ": 4.0 Optimizing Vertex Submission for OpenGL 355:\n\nQlinterleavedarrays only submits a pointer to the vertices to be rendered.\nAnother function such as giDrawArrays, glDrzwElenents, or glArrayélenent must be\ncalled to actually render the dara.\n\nApplying the use of glinterleavedarrays to the previous immediate mode exam-\nple. a single function call could be used to submit all of the dara for a single vertex.\nHowever, as its name implics, glinterleavedArrays can accept an array of vertices ro\nsubmit for rendering, This allows us to make a single function call to submit all 300\nvertices, rather than three calls per vertex (00 coral) in immediate mode.\n\nIn the case of the test dara, an array of 300 vertices is generated using the glIn-\nterleavedrrays (GL_T2F (3R_V36F vertex structure formac. This effectively dupli-\ncates the data that was submitted and rendered by the immediate mode functions.\n\nFigure 4.0.2 The amount of time required ro submit and render the vertex work-\nload using glinterlaavedArrays and gitrawarrays. The average time to submis che\n300 triangle workload is -72,821 CPU cycles. This is less than half the time (44%)\nthar was required by the immediate mode functions co submit and render che same\nworkload.\n\nglinterleavedArrays Vertex Submission\n\n200000\n100)\nno\n140000 fe\n20000 oe\nqooo00 £\nagooo\n60000\n‘0000\n20000 fe\n\nin\n\n=\nfT\n7\na\n=]\nX\n1 ]\n\ngintarhgawedss rays gDraw Arniys Total Submission\nTena\n\nFIGURE 4.0.2 Submitting vertices with gilnrerlcaved/Arrays.\n\nStrided and Streamed Data\n———————————COOCO ees\n\nAnother altemarive vertex submission interface is the gl*Pointer functions. Similar to\nglinterleavedArrays, pointers to the vertex data are submited using che gl*Pointer",
      "content_length": 1704,
      "extraction_method": "OCR"
    },
    {
      "page_number": 348,
      "chapter": null,
      "content": "o56 Section 4 Polygonal Techniques\n\nIndependent Date Streams\nVaCa |...) TxGn\n\nInterleaved Data\n\nVeron | Gator Fetes] v2 [6 | Teo2| va] es] Taca |. [va [Gn [Thom\n\nFIGURE 4.0.3 Streamed vs. interleaved dara.\n\nfunctions (e.g. g1VertexPointer, giColorPointer). The submitted vertex dara is then\nrendered using the glOrawArrays, glArrayElesent, or glOrawElenents functions.\n\nThe 91*Pointer functions also have a uniform stride parameter, similar to glIn-\nterleavedtrrays. The stride specifies the number of bytes from the beginning of one\nvettex component to the next. When che stride is greater than zero, the operation of\nthe gl*Pointer functions is essenially the same as making a single call to glInter-\nJeavedarrays, When the stride is zero (the data is tightly packed together), rhe data is\nreferred ta as stream data (Figure 4.0.5).\n\nStream data is very important when using SIMD (Single Instruction Multiple\nData} instruction segs like Intel's SSE (Streaming SIMD Instructions) or AMD\":\nSD Now! instructions to transform, light, and/or clip vertices. If the data was in an\ninterleaved vertex format, the dara must be moved piecemeal into and our of the\nCPU's SIMD registers, With the dara in stream formar, the CPU can quickly and eas-\nily move large chunks of the dara into the SIMD registers for processing.\n\nEven without taking advantage of the CPU's SIMD instructions for geometry\nand lighting, a performance boost can be had just by using che g1*Pointer functions.\n\nTt takes on average -51,212 CPU cycles to submit and render the 300 vertex\nworkload using the g1*Pointer functions with glDrawarrays (Figure 4.0.4) as com-\npared to -72,821 CPU opcles using gl Interleavedarrays and g1Dramirrays (Figure\n4.0.3). This is -30% reduction in time. Again, the performance increase would be\neven larger if we were relying on SIMD CPU instructions to perform geometry and\nlighting operations.\n\nComplled Vertex Arrays\n\nThe compiled vertex arrays extension (EXT_compiled_vertex_array) builds upon the\nfunctionaliry of glinterleavedArrays and the gl*Pointer functions. The compiled",
      "content_length": 2077,
      "extraction_method": "OCR"
    },
    {
      "page_number": 349,
      "chapter": null,
      "content": "4.0 Optimizing Vertex Submission for OpenGL 357\na a a ene ee Ee ee ee eet ae\n\n220000\nTen\n1E0000\nlh ae\n120000\n\n1Tno000 - - ~ - BpiOrawarrays\nBOo00 = i BCVA sOrawsrrigs\n\nooo\n\nFIGURE 4.0.4 Vertex submission time for glDrawArrays with and without Compiled Vertex\nAIrays,\n\nvertex array (CVA) function allows the application to specify a range of data in the\narrays supplied by glInterleavedArrays of gl*Pointer chat wont be changed by the\napplication. These allow the driver to optimize the data range once, and re-use the\noptimized version wneil the application unlocks che data.\n\nThis can result in significant speed increases by allowing the CPU's transform and\nlighting implementation to re-arrange the data for aptimal access. It can also allow the\nrendering hardware to modify the data for faster performance, or even make a local\ncopy of it on the graphics adapter for faster access,\n\nThe performance difference berween using CVA and not using CVA is not very\nlarge in our test workload (Figure 4.0.4), bur this is only because we are attempting to\nquantify the overhead of the function, The performance differential would be sub-\nstantially greater if the vertices were being transformed, lit, and clipped, or if there\nwere more of chem.\n\n(CWA is very useful for data char is static, or that can be used multiple times before\nbeing modified. If the data is only used once, then the overhead of using CVA may\nourweigh the benefit. To improve the performance of dynamic data, the only current\nalternative is to use a vendor-specific extension.\n\nEliminating Data Copy—Vendor Extensions\n\n‘With both the immediate mode functions and the array functions when not using\nCVA, the dara submitted for rendezing must be copied from application-allocared",
      "content_length": 1745,
      "extraction_method": "OCR"
    },
    {
      "page_number": 350,
      "chapter": null,
      "content": "358 Sectlon 4 Polygonal Techniques\n\nmemory te driver-allocated memory. As any data copy cakes time, eliminating the\ncopy is an easy performance win,\n\nCVA reduces this copy to a single time when the vertex array is locked. However,\nCVA assumes thar che dora is static or will be used repeatedly before being modified.\nThe problem of copying daca from application memory to driver memory srill exists\nfor dynamic arrays of dara thar are frequently updated or changed.\n\nThe only way to remove this copy would be for che application to store vertices\ndirectly in driver-allocated memory, and some vendors support chis as an extension,\nThe nVidia extension wglAllocateMenoryNv is one such vendor-specific extension. It\nallocates memory direcely accessible to the graphics card where the application can\nstore vertex data. This eliminates the need for any driver copying of data, and im-\nproves the performance when a vertex array is submiteed and then immediately ren-\ndered since the data is ready to go.\n\nCheck with your vendor for their specific OpenGL extensions.\n\nData Format\n\nA second area of consideration is the formar thar vertices are submitted in for render-\ning triangles. Vertex lists, Like those used in the test workload, are the most common\nformat. In a vertex list, chree vertices define each riangle (Figure 4.0.5a). However,\nwhen triangles share vertices, there's offen no reason to repeatedly include the same\nvertex. One alternative is to use triangle scrips of fans (Figure 4.0. 5b).\n\nDiscrete, stip, or fan triangles are identified by the mode parameters of\nglOram4rrays and g“l0rawElements. These are GL_TRLANGLES, GL_TRIANGLE_\nSTRIP and GL_TRIANGLE_PAN, respectively.\n\nUtilizing a separate array of vertex indices to build fees from the vertex array is\nanother way to reduce the number of vertices required to draw a number of triangles\n(Figure 4.0.$¢). glOrawElements is similar co g1Orawirrays, but it adds a new pare-\nmeter that accepts the face vertex index liss.\n\nUsing both triangle strips and face vertex indexing, it's posible to lower the ver-\ntex per triangle ratio to almost 1:1 for some complex triangle meshes. On many oypes\n\nindeed Veotions\nWerlex List rene : 2 Vortices: Por First\n\n3 \\Veetoos Per Trangia 1 Vera Por Ackettignnl Tei od 6 f Wertex Per Additional\nB Vertices to Grew 2 Tranghas 9 5 Vordicaa bo Dea 3 Tearngiee 8 Wortions to Draw &\nA B C\n\nFIGURE 4.0.5 A,B, G. Vertices for a: three discrete triangles, é chree strip riangles, and\nsix indexed triangles.",
      "content_length": 2499,
      "extraction_method": "OCR"
    },
    {
      "page_number": 351,
      "chapter": null,
      "content": "4.0 Optimizing Vertex Submission for OpenGL 359\n\nof dara, however, triangle fics combined with face wertex indexing are nearly as fase,\nand require less: pre-processing to create.\n\nGeneral Recommendations\n\nThere are also a number of general recommendations for increasing vertex submission\nand rendering performance.\n\n1. When using indexed data, care should be taken to co-locate all the vertices for a\nsingle triangle as near to each other as possible, [fF the vertices required for a trian-\ngle are too far apart in the array, it may cause the graphics adapter ta continually\nre-process sub-parts of the array as it jumps around.\n\n2. Pre-sorting vertex data by material, shader, and texture settings can help increase\nthe number of vertices that can be submitted and/or rendered in a single function\ncall.\n\n3. Keep the amount of information submitted per vertex as lean as possible, Don't\ninclude extra information that's only used occasionally. This must be balanced\nwith continually changing vertex formats. For example, don't submit a vertex\nwith additional color information if that information is rarely used.\n\n4. There is a balance between submitting too little data and woo much data, Most\narray functions require at least 10-50 vertices no be submitted to overcome the\nfunction overhead. On the upper end of the scale, no more than 32k—64k of dara\nof vertex data should be submitted, These amounts vary by graphics adapter.\n\n3. Spending too much time getting a lot of vertex data together into a single buffer\n(if it's not a driver-allocared buffer) can present more problems than ir solves on\nthe CPU. These include cache issucs, letting che graphics card stall, and over-\nwhelming the function with too much clata.\n\nConclusions\n\n1. Immediate mode functions may be easy to use when getting started, bur they are\nthe lowest performing functions for submitting vertices for rendering (Figure\n4.0.6).\n\n2. Submit and/or render as many vertices as ts feasible in a single function call.\n\n3. Use Compiled Vertex Arrays (CVA) for static dara, or for data that doesn't change\nvery often.\n\n4. For the best CPU transform and lighting performance, use streamed dara formats\nwith CVA.\n\n3. Some vendors will provide specific vertex submission extensions for even higher\nperformance.\n\n6. Use indexed vertex data with discrete or strip triangles to increase the number of\ntriangles that can be drawn with the smallest number of vertices.",
      "content_length": 2433,
      "extraction_method": "OCR"
    },
    {
      "page_number": 352,
      "chapter": null,
      "content": "360 Section4 Polygonal Techniques\n\nSummary Vertex Submission Time\n\nBm mediate Mode\nBginieteaveda nays\nGHgt@Psémiat Sbaam\n\nGEVA gFFointer Stream\n\nFIGURE 4.0.6 Summary comparison of verrex submission and rendezing time by function.\n\nReferences\n\n[ARB] OpenGL Extensions. OpenGL ARB. Available wow.opengl_org.\n\n[Kempf?7] Kempf, BL, ancl Frazier, C., Open Reference Manual 2™ Edition, Addi-\nson-Wesley Developers Press, 1997.\n\n[Spitzer] Spitzer, John E, Maximizing Open(sL Performance for GPUs. Online. 08\nMarch 2000. Available www.nwidia.com.",
      "content_length": 538,
      "extraction_method": "OCR"
    },
    {
      "page_number": 353,
      "chapter": null,
      "content": "4.1\n\nTweaking a Vertex’s Projected\nDepth Value\n\nEric Lengye!l\n\nMany games need to render special effects such as scorch marks on a wall or foorprints\non the ground that are not an original part of a scene, bur are created during gamie-\nplay. These types of decorarive additions are usually decaled ante an existing surface,\nand thus consist of polygons that are coplanar with other polygons in a scene. The\nproblem is that pixels rendered as part of one polygon rarely have exacdly the same\ndepth value as pixels rendered as part of a coplanar polygon, The result is an unde-\nsired pattern in which parts of the original surface show through the decaled poly-\nPons.\n\nThe goal is co find a way to offset a polygon’s depth in a scene without changing\nis projected screen coordinates or altering its texcure mapping perspective. Most 3D\ngraphics libraries contain some kind of polygon offser function to help achieve this\ngoal. However, these solutions generally lack fine control and usually incur a per-ver-\ntex performance cost. This article presents an alternative method that modifies the\nProjection matrix wo achieve the depth offser effect,\n\nExamining the Projection Matrix\n\nLet us first examine the effect of the standard OpenGL perspective projection matrix\non an eye space point P= (PL 2, F, 1). To simplify our matrix, we assume thar the\nview fruscum ts centered about the z-axis in eye space (i.c., che rectangle on the near\nclipping plane carved out by che four side planes has the property thar lef? = —nighrand\nbottom = —rap)). Calling the distance to the near clipping plane m and the distance to\nthe far clipping plane £ we have:",
      "content_length": 1643,
      "extraction_method": "OCR"
    },
    {
      "page_number": 354,
      "chapter": null,
      "content": "BC) i Sectlan4 Palygonal Techniques\n\nmn 0 i o Fa ne.\nO it] i] = nb,\nva | Fi=\noO ayifoct yeaa P apa aja. . (4.1.1)\nfo—m j-a . f—nS 1x\n\noo =] i) —P\n\n=\n\n‘To finish the projection, we need to divide this result by its w-coordinate, which\nhas the value =?,. This division gives us the following projected 3D point, which we\n\nwill call P\"\n_ ak\nPe\nTi\nP= = + (41.2)\n\nFae aa\n\nfon Plf-n\n\nRecall that the near clipping plane lies at z =—m, and the far clipping plane lies at\n== —f since the camera points in the negative z direction. Thus, plugging — and —f\ninto Equation 4.1.2 for P, gives us the expected = valucs of =I and I bounding the\nnormalized clipping volume. Also recall that this mapping from [—s.—/] to -1..1] is\na function of inverse « This is necessary So thar linear interpolation by the 3D herd-\nware of values in the depth buffer remain perspective correct.\n\nTweaking the Depth Value\n\nTt is clear from Equation 4.1.2 that preserving the value of —P, for the ncoordinate\nwill guarantee the preservation of the projected x- and y-coordinates as well. From this\npoint forward, we shall only concern ourselves with the lower-right 22 portion of\nthe projection matrix, since this is the only part that affects the z and wcoordimates.\nThe projected s-coordinate may be altered without disturbing the x coordinate by\ninwoducing a factor of 1 + €, for some small ¢, as follows.\n\noT fpr aa || fia eels\na eee for [?|- AF f-n| (413)\n-I i) sali\n\nAfter division by w, we arrive at the following value for che projected z-coordi-\nnate.",
      "content_length": 1527,
      "extraction_method": "OCR"
    },
    {
      "page_number": 355,
      "chapter": null,
      "content": "4.1 Tweaking a Vertex's Projected Depth Value 363\n\n— ftn if\nBARA sey ay\n\n: |\nSet) 9 Sern\n\nf-n Plf-n) f=\nComparing this to the z-coordinate in Equation 4.1.2, we see thar we have found\n\nFew\n\nfa”\n\n(4.1.4)\n\naway to offset projected deprh values by a constant €\n\nChoosing an Appropriate Epsilon\n\nDue to the nonlinear narure of the z-buffer, the constant offset given in Equation\n4.1.4 corresponds to a larger eye space difference far from the camera than it does near\nthe camera. While this constanc offset may work well for some applications, there is\nno single solution that works for every application at all depths. The best we can do is\nchoose an appropriate € given an eye space offset 6and a depth value P, which collec-\ntively represents the object thar we are offsetting. To determine a formula for &, ler us\nexamine the result of applying the standard projection matrix from Equation 4.1.1 ra\na point whose z-coordinare has been offset by some small 6,\n\nfat fon (4.1.5)\n\n-(P. +6)\n\nDividing by m, we have the following value for the projected 2-coordinate.\n\nfon f-# ,\n\nell 0\n\nga a et, ee\nHe foe (F+8\\f—m)\n\nfr-r Pf x) fon Pid Be\n\nEquaring this result to Equation 4.1.4 and simplifying a bit, we end up with:\n\n(4.1.6)\n\n_2h | 2 ; (4.7)\nf+n\\ P(r +d)\n\nA good value of é for a particular application can be found with a little experi-\nmentation. In showld be kept in mind char dis an eye space offset, and thus becomes",
      "content_length": 1417,
      "extraction_method": "OCR"
    },
    {
      "page_number": 356,
      "chapter": null,
      "content": "364. Section 4 Pohrgenal Techniques\n\nless effective as J, gets larger. For an m-bir integer depth buffer, we want co make sure\nthat:\n\n2s mbes (4.1.8)\n\nsince smaller values of € will noc yield an offset significant enough to alter the integer\ndepth value. Substituting the right side of Equation 4.1.7 for £.and solving for d gives\n\nLs=\n\nkp\n\nj= —— ole\n1 &P (4.1.9)\n\nkp?\n=\n\n= 4.1.10\n1+ EP :\n\nwhere the constant & is given by:\n\nepee At Ds\n2 fil 2\" ~ |\nEquation 4.1.9 gives us the minimum effective valuc for éwhen offsetting a paly-\n\ngon toward the camera (the usual case), and Equation 4.1.10 gives us the maximum\neffective value for 6 when offsetting a polygon away from the camera.\n\n(4.1.11)\n\nImplementation\n\nThe following sample code demonstrates how the projection matrix shown in Equa-\ntion 4.1.3 may be implemented under OpenGL. The function Load0ffsetmatrix\ntakes the same six values that are passed ro the OpenGL function glFrustun. It also\ntakes values for Gand P, that are used co calculare £\n\nSource Code\n\ninclude <g1.h»\n\nVOLO Load fsetWatrix(Gldouble 1, Gldouble r,\nGidouble ob, GLdowble ¢t,\n\nGidoubla n, GLoouble #,\n\nGLfloat dalta, Glfloat pr)\n\nGLfloaat matrix] 16];",
      "content_length": 1177,
      "extraction_method": "OCR"
    },
    {
      "page_number": 357,
      "chapter": null,
      "content": "ra | Tweaking a Vertex's Projected Depth Value 365\n\nff Set up standard perspective projection\nglllatriniode (GL_PAOJECTION) :\ngiFrustun(1], r, b, t, m, fT):\n\nif Retrieve the projection matrix\nglGetFloaty(GL_PAQJECTION_WATRIX, matrix);\n\nif Galculate apsilon with equation (4.1.7)\nGLiloat epsilon = -2.0F * # * mn * delta ;\n((t +n) * pe * (pz * delta};\n\nff Modify entry (3,3) of the projection matrix\nHatrixfio] *= 1.0F + epsilon:\n\n/? Sand the projection matrix back to OpenGL\ngiloadMatrixf (matrix |;",
      "content_length": 499,
      "extraction_method": "OCR"
    },
    {
      "page_number": 358,
      "chapter": null,
      "content": "4.2\n\nThe Vector Camera\n\nDavid Paull\n\nThe vector camera is a generalized form of the matrix-based camera found in many\nmaditonal graphics engines. Macrices are often difGeult to read due to che face chat\nthey typically hold several operations concatenated together, The vector camera uses\nonly simple vectors to describe its orientation, position, field of view, and aspect ratio.\nThis formar allows for some interesting optimizations to the overall graphics pipeline.\nThe vector camera uses the same information found in matrix-based cameras. The\nworld-te-camera matrix (view matrix) is broken down into four vectors. As you can\nsee in Figure 4.2.1, a view matrix is really four vectors,\n\nThree vectors represent the three axes that define the camera's orientation, and\none vector represents the camera's position in the world coordinare space. In total, his\nprovides six degrees of freedom. In some graphics engines, you may need to invert the\nview matrix to be compatible wich the vector camera. Figure 4.2.2 shows a scene with\nthe vector camera and a cube model. Ir also shows the viewing pyramid that defines\nthe limies of the camera's view.\n\nThe main advantage to the vector camera is that it can operate in both local and\nworld coordinate space. The camera's orientation and position vectors are stored in\nworld space; however, they can be inverse transformed into local space using the\ninverse of the model’s local-to-world matrix. The camera and dhe object wan't move\nin relation to each other; rather, the camera's new orientation and position are relative\nto the local space object. These are the only cransformations required to render che\n\n2, 0.707 0.000 0.707 §0.000 :\n=, 0.000 1.000 0.000 80.000\n0.000 ae\n\n0.000 0.000 0.000\n\nFIGURE 4.2.1. The view matrix is composed of four vectors.",
      "content_length": 1797,
      "extraction_method": "OCR"
    },
    {
      "page_number": 359,
      "chapter": null,
      "content": "42 The Vector Camera i687\n\nFIGURE 4.2.2. Ulusiration of che vector camera.\n\nobject. Now that the vector camera is in local space, it can project the local space\ncoordinates, and no further transformations are required. After doing almost no\nwork, the vector camera can now cycle through each of the local space vertices in the\nmodel, and project them into 2D sereen coordinates, If the model is static, like a\nmountain, the model data can be stored in world space. This allows for an even faster\neode path, With both the object and the camera in world Space, no inverse matrix\nheeds to be calculated, and no wansformations are required at all.\n\nThese diagrams use a left-handed coordinate system with the ¥-axis pointing up.\nThe vector cameras position is (0), 2,—2), and has a small rorarion about the L/-axis to\ntilt the camera down. The bor's position is (0, 0, 2), and has a rotation of 45 degrees\nabout the Y-axis. The smaller arrows show world (x, y, 2]-axis vectors to help illustrate\nrotations.\n\nIntroduction to the Vector Camera\n\n‘The vector camera uses three vectors to represent its orientation. The tf, Vo and\nvectors are parallel to the A, ¥, and 2 origin vectors, respectively, if the camera has no\nrotation and is positioned ar (0,0,0). The C! vector pains co the right, the vector\npoints up, and the N vector points in the direction thac the camera is facing, Figure\n4.2.3 shows the vecuor camera with its 3D screen. This 3D screen is created using the",
      "content_length": 1468,
      "extraction_method": "OCR"
    },
    {
      "page_number": 360,
      "chapter": null,
      "content": "368 Section 4 Polygenal Techniques\n\ncameras Of, Vand NV vectors, and cwo field of view parameters. The field of view\nparameters ate calculated using a user-defined field of view that is then scaled by the\naspect ratio. There are many ways to calculate the field of view parameters. For these\nexamples, I used the following code:\n\nTloat Aspecthatio = Screenteight/ScreenWidth;\nTloat FOV = pase;\n\nfloat hFrac = tan(Fove'o,5):\n\nfloat wFrac = tan{FOV\"O. S*Aspecthatio) 5\n\n[f the camera had no rotations or translations, the vectors would be defined as fol-\n\nlovers:\n\nO vector = -U vertar * hFras 4 V vector = vFrac\nS wactor = WU vector * hFrac * 2\nT vector = -¥ vector “* vFrac * 2\n\nThe 3D screen is created by adding these vectors, For this example, the distance\nto the near plane is 1.0; thus, starting at che camera's position, add 1.0 * N vector.\nThen add the © vector, This defines the point in 310 that will be called the screen ori-\ngin, The Sand 7 vectors originare from this poinc. The Sand Tvecrors define lines of\nconstant screen A and screen F, respectively. It is analogous to adding a screen-sized\ntexture to the quad defined by the Sand J vectors, Using the world space position of\nthe camera and the world space Sand vectors, any point in wodld space can be pro-\njected into screen coordinates using the following method. A veceor is created starting\nat the world space position of the camera, which ends at che world space position of\nthe vertex to be projected. If the vertex is in view of the camera, we can calculate the\n3D point where the ray intersects the 3D sereen of the vector camera. This intersec-\ntion point is shown in Figure 4.2.3 and Figure 4.2.4 as the ? vector. Then using the\nvector det product, the distance along beth the Sand T vectors can be fownd, which\nessentially converts che values into 21D. ‘These 2D valwes are rescaled based on che cure\nrent display resolution, and the resule is 2D screen coordinares ready for display.\n\nLocal Space Optimization\n\nThe camera vector are stored in world space; however models are typically stored in\nlocal space, sometimes called model space. The model is centered around (0,0,0) and\nis accompanied by a local-to-world matrix, This local-to-world matrix defines how\nthe object will rotane and cranslate in order to end up in its final world space orienta-\ntion and position. Since the model data is stored in local space, it would be adwanta-\ngeous to be able to work in local space, In order to accomplish this, the camera must\nbe moved from world space into local space. The camera must be rotated and trans-\nlatecl about the object, such that the camera's new orientation and position retains che\nsame spatial relationship as if the object was transformed bocal-vo-world, and viewed\nby the camera in world space. The solucion is che inverse of the model's local-to-world",
      "content_length": 2848,
      "extraction_method": "OCR"
    },
    {
      "page_number": 361,
      "chapter": null,
      "content": "42 The Vector Camera 269\n\n, al\n\nFIGURE 4.2.3. Using the P vector.\n\nmatrix. The inverse of a rotation matrix is calculated in two parts, ‘The first part per-\nforms @ transpose of the upper 3x3 rotation matrix. The second part uses three dot\nproducts to calculate the new position, This inverse matrix can perform the opposite\noperation of world-to-leeal.\n\nPlease mote thar there are really two local-to-world wansformations that need to\nbe preserved. The camera has an assumed local-to-world already applied to che cam-\ncras orientation and position; thus, we only need to worry abour che ebject’s local-to-\nworld macrix. The newly created world-to-local matrix defines how the camera's\norientation and position will rotate and translate in order to preserve the spatial rela-\ndonship between the object and the camera. As you can see in Figure 4.2.3, the cube\nhas undergene the lorcal-to-world transformation, which is a slow per-vertex process.\nAlso in Figure 4.2.3, nove the camera's world position and orientation for comparison\nwith Figure 4.2.4. You can sec in Figure 4.2.4 thar the cube is in its local coordinare\nspace without any rotation or translation. The camera, however, has been rotated and\ntranslaned such thar the camera generates the same image found in Figure 4.2.3. Mov-\ning the camera into local space is computationally faster than moving the local data\ninto world space. Only four transforms are required to move the camera into local\nspace, while it takes NV transforms to move a shape with NV vertices from local-to-\nworld. Once the model data and the camera data are in the same coordinate space,\nprojection of the model data requires little computation.\n\nNow thar the camera is in local space, some additional optimizations are possible.\nIf you store the plane normal for cach triangle with your model, back facing can be",
      "content_length": 1847,
      "extraction_method": "OCR"
    },
    {
      "page_number": 362,
      "chapter": null,
      "content": "aro\n\nSectlon4 Polygonal Techniques\n\nFIGURE 4.2.4. The cube resides in a local coordinate space,\n\nperformed using a single dot product. If the triangle faces the camera, all of its vertices\nare flagged as visible. When the entire object has been back-face culled, only the visi-\nble vertices will need to be projected.\n\nConclusion\n\nThe vector camera is a handy way of representing the camera math for use in software\nor hardware 31D rendering engines. Its simplicity allows the freedom ta intuitively\nplace and manipulate the camera, The camera's abiliey to work in che local coordinate\nspace allows for several well-known optimizations to have a larger impact on render-\ning speed than they do on traditional matrix-based cameras. The vector camera pro-\nvides a consistent 25% increase in frame race. It accomplishes this by reducing the\nnumber of required transforms, computing small final packets for display, and using a\nlow amount of memory overall, The projection math is flexible enough that ir can\nalso be applied ro any focus-based frustum like shadow volumes. Sometimes, the best\noptimization is to redesign the method, rather than squeeze performance out of che\nexisting method!.\n\nThe OpenGL source code to the vector camera is included with this book. For\nthe latest version of the source code, please visit the Tanzanite Software Website ar\nwww. tanzanite.to. All diagrams used in this article were rendered using the TechNa-\nture engine.",
      "content_length": 1450,
      "extraction_method": "OCR"
    },
    {
      "page_number": 363,
      "chapter": null,
      "content": "4.3\n\nCamera Control Techniques\n\nDante Treglia II\n\nThe interactive nature of games is the key element in what attracts and enthralls che\nPlayer. The fact chat one can become so many differenc characters, from a Sexy, Scant=\nily clad warrior to an Italian plumber with the charm to arerace a princess, is what\nentices so many people ro purchase games. But in order to allow the player to see che\nworld through a differenc set of eyes, the game needs to have a solid camera model.\nThis is where camera control encers the picture. This article will outline a few basic\n\ntechniques thar can be used co develop the proper camera model for your game.\n\nA Basic First-Person Camera\n\nLook-At\n\nBaste first-person carnera moxdels rely on “look-at\" uriliries such as OpenGLs glu-\nLookAt(Q). Given a camera position, view direction, and up veetor, this function\nTetuIns an ofentation view martrix. The view macrix is then placed on the OpenGL.\nMODELVIEW matrix stack and concatenated with orientation macnices far each object in\nthe scene as they are rendered. This camera model is very easy ro implement, and\nquite useful. An implementation of this function can be found in the Ces matrix\n\nlibrary.\n\nEuler Angles\n\nOrientation in three-dimensional space can be represented with three Euler angles:\nyaw, pitch, and roll (also known as azimuth, elevation, and roll). Yaw, pitch, and roll\naccount for the rotation in the F-axis, A-axis, Z-axis, respectively as illustrated in Fig-\nure 4.3.1.\n\nOne method for calculating the orientation matrix is to concatenate the three\naxcs rotation matrices, However, for control purposes, it is necessary to maintain the\ncurrent position as well as information abour che cameras X (side), F (up), and -#\n(forwand) directions. The forward, side, and UP VEChors are weed ta calculate the cam-\neras forward movement, strafe, and jump, respectively. The following code gives a\nfunction that calculates these vectors, which can be used as parameters to che glu-\nLookAt() function to produce the cameras view matrix.",
      "content_length": 2030,
      "extraction_method": "OCR"
    },
    {
      "page_number": 364,
      "chapter": null,
      "content": "a72 Section 4 Polygonal Techniques\n\nFIGURE 4.3.1. An image of a plane with the yaw, pitch, and roll angles described.\n\nvoid FlyCam::CosauteInfo() {\nfloat cosY, cos, cosh;\nfloat sini, sinP, sink;\n\nii Only Want ta Cale these once\ncosy = cost (v)}\ncos? = cost(F);\ncos = cost (Al;\n\nsin¥Y = sint(¥);\nsinP = sinf(P);\nsink = sint(A):\n\nii Fad Vector\ntwd.s = ain¥ * cosh;\ntwd.y = sink;\ntwd.z = cosh * -cosy:\n\nff Look At Point\nat = fwd + eye;\n\nif Up Vector\n\nUp-« = -cosY ~ Sink - sinY * sinP * cosh;\nUp-¥ = cosP * cash:\n\nUp.z = -sinY * si8h = sinP * cosh * -cos¥;\n\ni! Side Vector (right)\nside = CrossProduct(fwd, up);",
      "content_length": 607,
      "extraction_method": "OCR"
    },
    {
      "page_number": 365,
      "chapter": null,
      "content": "4.3 Camera Control Techniques afa\nia aE aa ee eee ee\n\nControls\n\nMethods for moving the camera's orientation and position through the scene are very\ngame-dependenc. For example, the camera position of a first-person shooter will most\nlikely follow the contours of the environment. A very accurate Hight simulator will\nrely on other environmental factors such as engine thrust, altitude, air conditions, cur-\nbulence, etc. I'm only going to cover the necessary components to get you off the\nground. Let's assume that the user's input device is a keyboard and a mouse. bur keep\nin mind that these techniques can be casily applied wo almost any inpur device,\nincluding joysticks, console controllers, and even VR devices.\n\nThe most intuitive control using Euler angles is to map the yeu to the mouse's\n(screen-relative) X position, and the pitch co the ¥ position. This mapping will mimic\nthe camera control found in Quake, which allows the user to change their view\nrapidly with two degrees of freedom. This cechnique can be used in conjunction with\nother camera models, For example, Super Aferiodd¢ was mostly a third-person game,\nbur also included the abilicy to examine the world through Mario's eyes. Since rofl is\nnota common human experience, it is usually disregarded.\n\n‘The cameras interaction with the environment is a very Fame-specific topic. As I\nmentioned earlier, the forward, side, and up vectors are used for contralling the posi-\nion of the camera, and should tie directly into your game engine. However you\nchoose to incorporate these vecrors, I strongly recommend thar you use time-based\nphysics. This will ensure thar your controls are frame-rate independent and give the\ngame a more realistic feel. Aca bare minimum, you should interpret che user's input as\na velocity in the desired direction. Since you have the camera's orthogonal orientation\nbasis vectors (forward, side, up), the implementation is a simple one-dimensional\nphysics problem:\n\nPosition += deltaTime * inputSpeed \" forward\n\nAAccelerations can also be applied co achieve damping effects. In the sample code,\n[have consolidated these control rechniques into a flying cameza that allows you to\nmove the view in any direction.\n\nScripted Camera\n\nSeripted cameras are a crucial part of many games, from cinematic scenes in role-play-\ning games to helicopter fly-throughs of a golf course. Most games that use this camera\ntechnique use an animation package to script the camera, then import the animation\ninto their game engines. This is an excellent solution for a static path, but what abour\ndynamic paths? Say, for example, you want the player ro have an out-of-body experi-\nence and fly through the scene while targeting on enemies, allics, the gates of heaven,\nor the gares of hell.",
      "content_length": 2766,
      "extraction_method": "OCR"
    },
    {
      "page_number": 366,
      "chapter": null,
      "content": "a74 Section4 Polygonal Techniques\n\nB-Spline Curves\n\nSpline curves are a flexible, easy, and efficient solution to generating a smooth curve\ngiven a set of control points, There are several ocher curve-peneraring algorithms and\nmodifications that offer more flexibiliry and power that I encourage you to explore,\nbut B-Splines are a great place to start. The cubic implementation I will discuss is\nbased on a basis function in the form of the matrix shown in Equation 4.3.1, Givena\nset of four contrel points and a parameter, wu, that uniformly progresses from 0 co 1\nthrough a set number of subdivisions, this matrix will produce a smooth curve sec-\nvon. For each element (x, y, 2) of the control points, the Build() function is applied.\n\n-| 3 31\n3-6 0 4/1\n\nB- Spline = =\nSlibetenaes: in le\n\n\\1 0 0-0\n\nEQUATION 4.3.1. The cubic §-Spline basis function.\n\nvoid Spline::Guild[) {\nfloat u, w_2, u_3;\nint 4, 4, &:\nint index;\n\nindex = 0;\nfi For each control Point (Minus the last three)\nFor {i = 0; a < controltnt = a: ite) 4\n\n/i Far each subdivision\nTor] = 0; j = curvesubD; j++) {\nuo = (float)] / curvedubb:\nweer\" uo:\na= wz\" u:\nfor(k = 0; kK <3; kee} {\nJi Position\ncurvebata[ index].pos[k} =\n{\n(-1*u_3 * G*u 2 = 3*y + 1)\ncontralDatali ].pos[k]\n{ 3°03 - Gu 2 + O*y + 4)\ncontrallatalito] .pos[k]\n(-3*u_3 # 37u 2 + 3*u + 1]\ncontrolpatali+1].pos[k]\n{ 13 * Ofu 2 4+ 0% + 0)\ncontrolData[i+2] .pos[k]\n} / BOF;\n\nchk t+ te fe\n\nindex ++;",
      "content_length": 1423,
      "extraction_method": "OCR"
    },
    {
      "page_number": 367,
      "chapter": null,
      "content": "43 Camera Control Techniques 375\n\nWote thar che paramerer # is squared and cubed; hence, we have a codic splinc.\nAlso note thar the last three control pointes are nor weed, since this algorithm utilizes\nfour continuous control poincs ara cime. | leave dhese extra components in my algo-\nnthm so chat] can preserve the continuity of che curves. For ceample, the following\ncontrol points will create a very close approximation of a cirele.\n\nCG: 46.000000 2.00RRO 46.000000 // Not drawn\n\n2\nC: 48.000000 2.0000 -46.000000\nC: -48.000000 2.000000 -48.000000\nC: -48.000000 2.000000 46.000000\nC: 48.000000 2.000000 46.0eh000\nC: 48.000000 2.000000 -48.0KM00 // Mot drawn\nCz -d8. 000000 2.000000 -48.000000 // Mot drawn\n\nUnilizing B-Splincs for our purpose requires a little work. The curve provides che\nposition of the camera, but we also need a target and an up vector. For multiple\ncurves, cach control point should be associated with a target position. Hence, the\ncamera will continue to focus on the target as it moves along the curve. Once it\neRCOLNEers a new Larger position, the camera control logic can simply interpolate\nberveen che points to get the desired effect. A more complex but flexible solution\nwould be ta use ewo B-Spline curves, one for camera position and the other for target\nposition.\n\nTricks\n\nGiven a set of control points, the game engine can either compuce the entire curve\nduring one frame, or calculate only the needed portions of the curve. This reduces the\namount of computations per frame, and also reduces the amount of memory needed\nto store curve data. B-Splines only require four control points for any subsection of a\ncurve, So, by continuously cycling in a new control point, whether it is a random\npoint ora carefully calculated one, a smooth curve of infinite length can be created.\nThe demo software for this article demonstrates such a solurion.\n\nAlthough the curve is guaranteed to be continuous, the distance berween subdivi-\nsions is mot. Hence, moving the camera across the curve incrementally is noc a suffi-\ncent solution. The camera would visibly change velocicy between conerol points, and\nit would be subject to changing frame races. The best method for moving the curve\nacross the screen is co use distance and speed calculations. For accurate distance calew-\nlation, you need co calculate the distance between cach subdivision at dhe curve level.\nThis method requires a lot of calculation, bur it is worth ic. Use chis function to cal-\nculate an appropriate index for a piven distance:\n\nint Spline::GetindeaxAtDistance(tloat distance) {\nint imdex = 0;\n\n1f (agLstenca «< 0.0) raturn -71;\nff Forward Push\nwhile (indax < curvetnt 4&",
      "content_length": 2673,
      "extraction_method": "OCR"
    },
    {
      "page_number": 368,
      "chapter": null,
      "content": "a76\n\nSection4 Polygonal Techniques\n\ndistance > curveDatalindex].distance}\n\n{\nindex++>\n\nif (index >= curvetnt) return -1;\nreturn index:\n}\n\nAnother useful trick for using B-Splincs is to utilize the tangents of the curve to\nforce the orientation of the camera to the curve. This would be particularly useful if\nyou wanted to implement a roller coaster. A close approximation can be calculated by\nswberacting each curve point from the one preceding it. However, a more accuraic\nsolution is to calculate the derivative of the B-Spline basis function. This derivative is\ngiven in Equation 2. These calculations are performed in the sample code.\n\n(ie © Spake sy\n,_|0 3 -4 of1\ney lo 3 2 41 4|2\nO10 0\n\nEQUATION 4.3.2. First derivative of the B-Spline basis.\n\nOne pitfall | should mention is normal calculations, Finding a normal co a curve\nisa simple problem. One solution is to take che tangent of the current concrol peint\nand cross it with the tangent of the next concrol point. Finding the appropriate nor-\nmal, on the other hand, is a difficule problem. There are an infinite number of pare\nmals at any given point of a curve, and the problem is to find the one thar produces\nthe result you wane. I found thar using the narural normal, by crossing tangents, usu-\nally gave me the resule I wanted. However, since | was using the cross product, che\ntight-hand rule would occasionally flip my normal when the curve switched diree-\ntions. | compensated for this by checking the doc product of the current normal and\nthe previous one to sce if the difference was -180°, Ifso, I would set a flag to flip the\nnormals back. In some instances, I simply provided the normal that I wanted with the\ncontrol point, and interpolated to the next natural (or specified) normal as | subdi-\nvided the curve.\n\nCatmnull-Rem\n\nSince I'm on the topic of B-Splines, I should mention a variation of curve gcnicration\nfunctions called Carmull-Rom curves. The biggest difference between these ewo\ncurves is thar Catmull-Rom curves go through the control points, whereas B-Splines\ndo not. However, I must warn you that the “curviness” of this variation is not as pleas-\ning to the eye as B-Splines. Nonetheless, you may find it useful or necessary to have\nthe curve pass through the control points. The basis functions are listed in Equation\n4.4.3.",
      "content_length": 2317,
      "extraction_method": "OCR"
    },
    {
      "page_number": 369,
      "chapter": null,
      "content": "4.3 Camera Control Techniques STT\n\n-—| fF =] O\nCarmull — Rem = Sell, =|\n—3 4 Ll OF2\n1 —l .0..0\n—i -] 4 -1]\n\nCarrill — Form’ = EAR SE Bra eel st\n— 3 & 1 }2\n\nSoe he\nEQUATION 4.4.3. The Carmuull-Riom basis functions.\n\nCamera Tricks\n\nZoom\n\nSay you want co have a high-powered sniper rifle with a long range scope in your\ngame, and you want the player to be able to look around through the seope. One\nquick and dirty method for accomplishing this in OpenGL is wo use the FOV para-\nmeter of che gluPerspective() function. This snippet of code will cause the camera\nto zoom in and out with the cosine function:\n\nQlvatrinvode (GL_PARIECTION):\nglLoadidentity();\n\n@luPerspective(cos(teapAng += 0.03F)\"10 4 34,\nB40.0F /480.0F, 1.0, 2000.0);\nglMatrinMode (GL_MOOELVIEN) ;\n\nDamping\n\nDamping is the key to making camera controls look and feel right. The following\nfunction will return a vector that approaches the target vector such that as it reaches\nthe target, it begins to slow down. However, there is 2 major problem with this solu-\ntion: It is frame rate dependent. As che frame-rare increases, the damping effect\ndecreases.\n\nVectors dampTypel(vectors currx, vectors targeex) {\nreturn currex + ( (targets - currk) | i6.0F);\n}\n\nUsing physics is one possible solution for damping. Applying accelerations and\nfriction to the camera's position will produce the desired result, and physics equations\nare frame-rate independent. But, physics is more appropriate for an interactive solu-",
      "content_length": 1472,
      "extraction_method": "OCR"
    },
    {
      "page_number": 370,
      "chapter": null,
      "content": "a78 Section 4 Polygonal Techniques\n\ntion. They don't easily offer a current and target position interface, which would be\nmore useful in situations where the camera is scripted or affected by fixed animations.\nSprings are the perfect solurion.\n\nFa ma= hx — bop\nEQUATION 4.3.4, The spring equation.\n\nLet's break the spring cquation up into usable pieces and ger a function, First, ler's\nassume that our mass is 1. a represents the displacement from the nesting (target) scare\nof the spring to the current position, The nwo constants & and é, represent Hooke’:\nspring constant and the damping constant, respectively. p is the velocity of the target\nposition. The function char implements this damping is shown here. Whar a perfecs\n\nopportunity for C++!\nweetera Springdenp(\nVectors currPos, Ji Current Position\nWECtOrS trgPes, fi Target Position\n\nWectord previrgPos, // Previous Target Position\nfleat deltaTine, i? Change in Tine\nfloat springtenst, // Hooke's Constant\n\nfloat dampCenst, ff Dap Canstant\nfloat epringlen} i\n\nvectors disp; ff Displacement\nvectors velocity; if Velocity\nfisat forceWag; if Foreé Magnitude\n\nff Galeulate Spring Force\ngisp = currPas - trgPas:\nvelocity = (prevTrgPos - trgPos) * eltaTime:\nforcellag = springtenst * (apringlen - disp. lengthi)) +\ndampConst * (DotProduct(disp, velocity) |\ndisp. Llenmgenh());\n\nff Apply Spring Force\n\ndisp normalize | |;\n\ndisp *= forceMag * deltaTime;\nreturn currPas += disp:\n\n}\n\nThird-Person Camera\n\nOn the topic of cameras, | also need to mention the valuable third-person camera, As\nan example, I have added a spring-based third-person camera model co my sample\ncode. The actor im the scene is regulated by a spline. This is only to mimic random\norentations that an actor could possibly undertake. In an interactive game, the orien-\ntation of the actual actor can be controlled by game logic, canned animations, or even\nthe first-person camera model described earlier. Regardless, the camera tracks a pasi-\nHon that is a given distance behind the actor I use the spring damping function to\ngive the camera a realistic feel,",
      "content_length": 2080,
      "extraction_method": "OCR"
    },
    {
      "page_number": 371,
      "chapter": null,
      "content": "43 Camera Contral Techniques a70\n\nQuatemlons\n\nAsa final note, quaternions have become an integral part of game programming, and\nplay an important role in camera orientation techniques. There are many benefits ro\nusing quaternions to internally represent orientations. The three-parameter represen-\ntation of Euler angles requires crigonometry and nine-parameter orthogonal matrices.\nQuaternions, on the other hand, only require four parameters and are less computa-\ntionally expensive.\n\nWhen it comes to view interpolation, the Fuler angle implementation is inher-\nently buggy. Say you wish to rotate the object 90° in the F-axis (yaw = m2). Because\neach rozation is computed separately, this operation rotates the X-axis onto the nega-\ntive “axis. Hence, the result of a rotation in the X-axis by an angle @ is the same as\nrotating -8 in the #-axis. In other words, the camera will roll when you apply a change\nin the yaw. This parametric singularity is called gimbal ck. Because of this lock,\ninterpolating through these singularities produces strange and most likely unwanced\nresults. Quaremions, on the other hand, do nor have this problem, and can be inter-\npolated quite easily. By representing camera orientation with quaternions, we can per-\nform smooth interpolations between two viewpoints.\n\nMore sophisticated implementations of orientation controls such as those found\nin commercial flighe simulators apply angular velocities via quaternions. However, for\nour purposes, it is sufficient and more ineuitive to increment rotation around an angle\nusing the Euler angles, than to directly recalculare a quaternion. Hence, it is useful co\nhave a function that produces a quaternion given the three Euler angles.\n\nquatertiion Aquaternion: :Seteuler(float yaw, float pitch,\nfloat relly {\nTloat cos = cost(yaw / 2.0F}:\nfloat sin’ = sinf(yaw / 2.0F):\nT1loat cosP = Gesf (pitch | 2.0F}:\nTioat sinF = sinf(pitch | 2.0F):\nfloat cosh = cosf(roll / 2.0F);\nFloat sink = sinf({roll | 2.0F):\nsetValues[\ncosh * sinF * qosY + eink * eosP * sin,\ncosh * cosP * sinY - gin * sinP * cosy,\nSank * cosF * cogY - cosh * sinP * sin,\ncosh * cosP * cosY # sinh * sinP * sin¥\n\nF\nF\n\nNe\nreturn \"this;",
      "content_length": 2180,
      "extraction_method": "OCR"
    },
    {
      "page_number": 372,
      "chapter": null,
      "content": "A Fast Cylinder-Frustum\nIntersection Test\n\nEric Lengyel!l\n\nBefore attempting to render a complex object, many games first determine whether a\ngeometrically simple volume bounding that object is visible. Due co cheir computa=\ntonal efficiency, spheres and boxes are commonly used as bounding volumes, bur it i\nsometimes the case thar objects are naturally suited to be bounded by a cylinder,\nAlthough we will mot be able to achieve the speed at which a sphere or box could be\ntested, this article presents a quick algorithm for determining whether an arbitrary\ncylinder potentially intersects the view frustum (and thus whether the objece is visible),\n\n‘The efficiency of the algorithm relies on the fact that we can reduce the problem\nto that of determining whether a line segment innersects a properly neodified view\nfrustum. Given a cylinder described by a radius and two point in space representing\nthe centers of the end faces, we individually move each of che six planes af the view\nfrustum outward by the cylinder's effective radius with respect to that plane. The effec-\ntive radius depends on the cylinder'’s orientation, and ranges from zero (when the\ncylinder is perpendicular to the plane) to the actual radius (when the cylinder is par-\nallel to che plane).\n\nThe cylinder test has advantages over the sphere and box tests when an object's\nbounding cylinder has a large height-to-radius ratio. Such a case arises, for instance,\nwhen rendering shadow volumes for infinire light sources, since a shadow volume\ntypically needs to be long relative to the size of the object casting it. A shadow volume\nas completely contained inside the extrusion of the object's bounding sphere along the\nlight direction, making it a natural candidate for a cylindrical bounding volume.\nUsing a bounding sphere for such a volume would contain a grear deal of empty\nspace, Ciusing a sphere visibiliry test eo return positive in many cases when the volume\nis not really visible. Although a bounding box would generally contain an acceptably\nsmall amount of empry space, box visibility tests are not well suited for boxes having\none dimension that is much larger than the other two. This is due to the face that box\ntests only detect that a box is invisible by determining that the bax lies completely on\nthe negative side of any one of the six planes bounding the view frustum. A lang rec-\ntangular bounding box could easily straddle one of the view frustum planes far out-\nside the view frustum, but the box tests would rerurn positive.",
      "content_length": 2526,
      "extraction_method": "OCR"
    },
    {
      "page_number": 373,
      "chapter": null,
      "content": "44 A Fast Cylinder-Frustum Intersection Test 381\n\nThe View Frustum\n\nQur view frastum shall be completely described by four quantities. The first is the\nfocal length 4 which determines the field of view. Fora desired horizoncal field of view\nangle @, the focal length is given by the formula:\n\nwe ala .\nran(@ / 2)\n\nThe second quantity is the aspect ratio 2, which is simply the viewport's height\ndivided by its width. At a distance / from the camera, a plane perpendicular to the\ncameras viewing direction carves a rectangle out of the view fruscum whose left and\nright edges reside at x = 21, and whose top and bottom edges reside at y = +2.\n\nThe remaining ovo quantities thar describe our view frustum are the minimum\nand maximum depths that define the near plane distance » and the far plane distance\nJ Aca distance # from the camera, the viewport rectangle is bounded by x = 2n//and\ny= tral These values are passed to the OpenGL function g1Frustum.\n\nUsing the values of f and a, the inward-pointing unitlength normals of the six\nfrustum planes are given, in eye space coordinates, by the following formulas:\n\n(44.1)\n\nTable 44,1. View Fruatum Plane Normals\n\nPlane Normal\nNear (0, 0,-1)\nFar (0,0, 1)\n\ni 1\nBagh — 0-74]\n| Je +1 wi 41\nTap [o.- z= nant = |\nPage {f° +a\"\n\nRie Pada Vi + a?",
      "content_length": 1284,
      "extraction_method": "OCR"
    },
    {
      "page_number": 374,
      "chapter": null,
      "content": "382 Section 4 Polygonal Techniques\n\nThe cylinder intersection test will take place in eye space so that we can ake\nadvantage of the symmetry of these normals, as well as the murmerous zeros that appear\nin the table.\n\nCalculating Effective Radi\n\nLet us call the two endpoints of the cylinder's axis P, and P., and the cylinder's radius\nr (see Figure 4.4.1). Now we select one of the six view frustum planes, label irs normal\nN, and call the angle between the normal and the cylinders axis of. The effective\nradius r’of the cylinder with respect to this plane is given by the simple formula\n\nr= 7rsin (4.4.2)\n\nThe most immediate method for determining the value of sin of would be to cal-\nculate the magnitude of a cross product, bur we can calculate the same value using sip-\nnificantly fewer operations through a bit of rigonometric manipulation. Recall che\n\nidentity:\n\nsin? + cos? = 1. (4.4.4)\n‘This gives us the alternative form for Equation 4.4.2:\n\nr= ryl — cos’ a, (4.4.4)\nThe value of cos ais given by\n\nRB -PI-N\ncos of = (\":-®) (4.4.5)\n2B\n\nThe normalized vector representing the axis of the cylinder only needs to be caleu-\nlated once. For cach view frustum plane, Equation 4.4.5 can then be evaluated through\nasimple dot product with a normal having at most owo non-zero components.\n\nIt is not absolutely necessary ro calculate the effective radii, simee the actual radius\ncould be used in its place, saving up to five possible square root calculations. Using\nthe actual radius may be desirable in the case when many cylinder visibility tests are co\nbe performed, and the square root operation is slow on the target machine. The dis-\nadvantage of using the actual radius is that it increases the number of visible cylinders,\nperhaps significantly if the actual radius is large. If speed is am issue, the decision co\nuse effective radii or the actual radius should be determined chrough experimentation.\n\nThe Algorithm\nes\n\nThe intersection test executes by visiting each of the six view fruscum planes individ-\nwally, We consider the near and far planes first since they are parallel and chus produce",
      "content_length": 2105,
      "extraction_method": "OCR"
    },
    {
      "page_number": 375,
      "chapter": null,
      "content": "44 A Fast Cylinder-Frustum Intersection Test amd\naad\n\nFIGURE 4.4.1. Calculating an effective taclins.\n\nthe same effective radii. Quee we have discovered char at least part of the cylinder lies\nbetween these planes, we proceed to the four side planes. For each plane, we first cal-\nculare the effective radius r'of the cylinder and move the plane outward by char dis-\ntance, at illustrated in Figure 4.4.2. This has the effect of reducing the cylinder to a\nline segenent, but it carries the slight cost of including a few more cylinders in aur vis-\nible set that do not actually intersect the view frustum.\n\nAfter adjusting a plane, we next test the ewo endpoints P, and P, to determine on\nwhich side of the plane they lie. This is done by plugging each endpoint’s coordinates\ninto the plane equarion\n\nF-N-d=( (4.4.6)\n\nwhere d=” —r'for the near plane, d = —f— 7\" for the far plane, and d= <r'for any of\nthe four side planes. The sign of the left side of Equation 4.4.6 indicates on which\nside of the plane the point F lies. Since the plane's normal points toward the interior\nof the view frustum, any point lying on the negative side of the plane lies outside the\nview frustum. Thus, if both P, and P, lie on the negative side of the plane, then we\nimmediately kaow that the cylinder is not visible, and the algorithm exits, Any point\ninterior to the view frustum must lie on the positive side of all six planes, so whenever\nboth P; and P, lic on the positive side of a single plane, we cannot draw any conclu-\nsions and just continue to the next plane.",
      "content_length": 1552,
      "extraction_method": "OCR"
    },
    {
      "page_number": 376,
      "chapter": null,
      "content": "Section4 Polygonal Techniques\n\nFIGURE 4.4.2. The shaded region represents the volume added to the view frustum after\neach plane has been expanded by che associared effective radius.\n\nIn the remaining case thar one endpoint lies on the positive side and the other lies\non the negative side, we calculate the point where the line segmene intersects the\nplane and replace the exterior endpoint with it. This effectively chops off the part of\nthe cylinder thar we know to lie outside the view frustum. To find the point of inter-\nsection, we use the parametric equation for a line\n\nP-P,+x#P,—- P)) (4.4.7)\n\nwhere 05 ¢S 1. Substiuucing the right side of this equation for P in Equation 4.4.6\ndlows ws to solve for che value of rae the point of intersection:\n\nd-B-N\n\njp -P)-N (4.4.8)\n\nPlugging this back into Equation 4.4.7 gives us our new endpoint. After replac-\ning the exterior endpoint with it, we continue to the next plane.\n\nIf we visit all six planes of the view frustum and never encounter the case that\nboth endpoinrs lie on the negative side of a plane, then the cylinder is ar least partially\nvisible. Of course, this means that we do not have to replace any endpoints for the last\nplane that we visit. As soon as we know thar at least one of the endpoints lies on the\n\npositive side of the final plane, we know thar part of the cylinder intersects the view\nfrustum.",
      "content_length": 1372,
      "extraction_method": "OCR"
    },
    {
      "page_number": 377,
      "chapter": null,
      "content": "44 A Fast Cylinder-Frustum Intersection Test 365\n\nimplementation\n\nThe sample code in Listing 4.4.1 implements the cylinder visibility test. The Frustun\nclass encapsulates the view frustum and is constructed by specifying the focal length,\naspect ratio, near plane distance, and far plane distance, The components of the nor-\nmals listed in Table 4.4.1 are precalculated inside che constructor, The member fune-\ntion CylinderVisible determines whether a cylinder specified by two points and a\nradius intersects the view frustum and returns true or false.\n\nListing 4.4.4\n\n#include “mtxlib.h\"\n\n6lass Frustum\n\n{\n\nPrivate:\n\nff Near and far plane distances\nfloat nearbistance;\nfloat farbistance:\n\nff Preceléulated normal components\nfloat leftRights;\nfloat Jefthightz:\nfloat topBattony;\nfloat tophottenz:\n\npublic:\n\nf/f Constructor defines the frustun\nFrustun(float 1, float a, float nm, float fj;\n\nff Intersection test returns trué or false\nbool CylinderVisible{vector3 pi, woctors pz,\nTlost radius) comet:\n\ni\n\nFrustum::Frustua(tloat 1, float a, float n, float f)\n{\nif Save off naar plane and far plane distances\nnearbistanee = nm:\nTarDistance = f;\n\ni! Précaleulate side plane normal components\nTloat d= 1.0F # sqrtqi * 1 4 4_0F);\nLeftAightx = 1 * d:\n\nLeftAight2 = d:\n\nd= 1.0F / sqrtt(l * 1+ a8 * a};\ntopfottomY = Ll * @\ntopBottemz = a * d",
      "content_length": 1332,
      "extraction_method": "OCR"
    },
    {
      "page_number": 378,
      "chapter": null,
      "content": "Section 4 Polygonal Techniques\n\nbool Frustum; iCylindervisible(vectora pl, vectord p2, float radius) const\n\nf\n\nff Calculate unit vector representing cylinder's axis\nvector’ dp = pe - pi;\nop.normalize();\n\nif Visit near plane Tirat, NH = (0,0,-1}\nfloat dat) = -pl.z}\nfloat dot2 = -p2.z;\n\nif Galculate affective radius for near and far planes\nfloat effectiveRadius = radius * sqrt(1.0F - dp.2z * dp.z);\n\nif Test endpoints against adjusted near plane\nTloat d = nearbistance - effectivenadius:\nbool interior! = (doti >= dj;\n\nbool interiora = (dots > dj;\n\naf {linteriord)\n\n{\nff If neither andpoint is interior,\ni! cylinder is mot visible\nif (linterior2) return (false):\n\nii 1 Was outside, 50 move it to the mear plane\nfloat t = (d + pi.z}) / dp.z;\n\npi.x -= t * dp.x;\n\npi.y -= t * dp.y;\n\nPI-2 = =]\n\nelse if (linterior2)\n\n{\nff $2 was gutside, so move it to the near plang\nTloat t = {di + pi.z) f dp.zz\npe.x = pi.x = t+ = dpix:\np2.y ~ pl.y - t * dp.y;\np2.2 = od;\n}\n\ni! Test endpoints against adjusted far plane\nd= farfistance + effectiveRadius;\n\ninterior? = (doti < oj};\n\ninterior2 = (dot? < a):\n\nif (linterior1)\n\n{\nff Of neither andpoint 18 interior,\nff cylinder is not visible\naif (linterdor2) return (falze);\n\nii pl was outside, so move it to the far plane\nfloat t = (d + pi.z) J (pa.z = pi.z);\n\npl-x == tf * (p2.e - pi.x);\n\npl.y -= t * (p2.y - ply);\n\npl.z = -d;",
      "content_length": 1356,
      "extraction_method": "OCR"
    },
    {
      "page_number": 379,
      "chapter": null,
      "content": "44° A Fast Cylinder-Frustum Intersection Test\n\n}\nelse if (linteriera)\n{\nff p2 was outside, so move it to the far plane\nfloat t = (d + pi-z) / (p2.z - pi.z);\np2- = pi.m - t * (pl.a - pi.xys\nPe.Ww = play - t* (p2.y = pl.yh;\npz.z = -d;\n}\n\ni] Misit Left side plane next\n\nff The pornal components hava been preaalculated\nfloat n= = lefthightx;\n\nfloat nz = leftRightZ;\n\nfy Compute pl * No and pe * w\ndott = ne * pl. = nz * piizs\ndot2 = 9k * Pe.k = nz * pez:\n\nff Galculate effective radius for this plane\nfloat 6 = nx * dp.m - nz * dpvz:\neifectivenadius = «radius * sqrt(1.0F - § * sj;\n\ni! Test endpoints against adjusted plane\ninteriari = (dati = effectiveRadius);\ninterisre = (date = effectivenadius);\n\nif (Jinteriort)\n\n{\nfi Tf neither andpolnt is interior,\nif cylinder is not visible\nif (!interior2) return (false);\nff fl was owtside, sa move it to the plane\nFloat t = (attectivenadius - dott) ¢ [(dot® - dott);\nPl.w += t ™ (pe.u - pi-x);\nPl.y += t \" (pe.y - ply);\npl.2 += t \" (pe.z - plz);\n}\n\nelse if (lintariore)\ni\nif Pe was outside, so move it to the plane\nfloat t = (effectiveRadius - doti) | (det? - dott);\npe-x = pi.w * t * (pe.a - pix):\nPe-y = pi.y tf * (peey - pt.y)}\npe-= > pi.z + € * (plz = pi.z:\n}\n\nff Wisit right sida plane next\ndati = -nx * pi.x - mz * pliz:\ndat] = -nx * pe.x - nz * pez:\n\n5 = «na * dp.x - nz * dp.z;\notfectivenadius = -radius * sqrt(1.0F - ¢ ™ s};",
      "content_length": 1374,
      "extraction_method": "OCR"
    },
    {
      "page_number": 380,
      "chapter": null,
      "content": "Section4 Polygonal Techniques\n\ninterior] = (detl > effectiveRadius):\ninterior? = (dota > effectiveRadius):\n\nif (linterior)\n\n{\nif (linterior2)}) return (false);\nTicat t= (effectiveRadius - doti) f# (dot? - deti);\npi.w t= t * (pox + pi.x):\nPi.y + £ * (pe.y + pl-y}i\nfl.2 += £ * (pe.z = pl.z)i\n}\nelse if (linteriore)\n{\nfleat + = (effectiveRadiue - doti) # (det? - doti);\np2.% = pix + t * (pZ.m - pl.x};\np2.y = pl-y + t * (pz.y - pi.yt;\np2.z = pl.t + t * (pe.z - pl.zy}:\n}\n\nif Visit top side plane next\n\nff The nomial components have been pracalculated\nfloat ny = topBottom;\n\nnz = tepbotton?;\n\nmoti = -ny * pi.y - az * pi.z:\ngot2 = -iy * pe@.y = oz * pe.z:\n\nSo -fy * dp.y - nz * op.z\neffectivenadius = -radiue * aqrt(i.dF - 5 * 5);\n\ninteriort = (dot? > effectivernadiue):\ninteriar2 = [(dot2 > eftectiveRadius);\n\naf [linteriori}\n\n{\nif (linterior2) return (false);\n\nfloat t = (ettectivenadius - deti) / (dete - dott};\nPi-x += { \" (pe.m - pi.x};\nPi-y += £ * (p2.y - pi.y};\npl.z += t * (po.z - pi.z):\n\nelse if (linterior?)\n\n{\nfinat t= (ettectiveRadius - dotij f (dotz - dott);\nPe-x = pl.x + t * (p2.x - pix};\nPe-Y = ply +t * (p2.y - pl.yh;\npe-2 = plz +t * (pR.z - pl ep\n}\n\nif Finally, visit bottom side plane\ndot) = ny * pi.y - mz * pl.z;\ncote = my * pay - ne * Azz;",
      "content_length": 1258,
      "extraction_method": "OCR"
    },
    {
      "page_number": 381,
      "chapter": null,
      "content": "44 A Fast Gylinder-Frustum Intersection Test 386\n\n$= ony * dp.y - me * dp.z;\neffectiveRadius = -radiys * agrt(i.OF - 5 = 3);\n\ninterior! = (doti > effectivenadius);\ninterdor2 = (dot® > effectivenadius);\n\nff At least one endpoint must be interior\nff oor cylinder is net visible\nreturn (interiert | intarior2}:",
      "content_length": 307,
      "extraction_method": "OCR"
    },
    {
      "page_number": 382,
      "chapter": null,
      "content": "4.5\n\n3D Collision Detection\n\nKevin Kaiser\n\nA real-time physics engine is central to creating a 31D gaming environmenc where the\nplayer can easily suspend their dishelief; instead of just realistic pictures, the physics\nengine provides realistic interactions between objects in the pictures. These ineerac-\ntions provide the player with a basis for reality; in other words, the player can beter\nunderstand and navigare in a world where things act as they do in real life. The firse,\nand arguably most important step in setting up a real-time physics simulation is har-\ning accurare collision detection; ance collisions are detected, the simulation can react\naccordingly. This article will help lay the groundwork for building an accurate physics\nsimularion by starting with one of the most crucial parts of a real-time physics engine:\n3D collision detection.\n\nOverview of the Algorithms\n\nThe two basic collision algorithms this artick covers are:\n\n* Bounding Sphere Collision Detection—For the sake of clean code and an easy-\nto-understand explanation, we'll be using bounding spheres. The bulk of chis\ncode checks the radius of a bounding sphere against the radius of another bound-\ning sphere co determine possible collisions.\n\n* Triangle-to-Triangle Collision Detection—It might be wise ro brush up on\nyour calculus before amemping to understand this algorithm; it uses parametric\nequations to determine collision points between one criangle and che plane of the\nother mangle, then determines whether those collision points lic inside che oppo-\nsite triangle.\n\nBounding Sphere Collision Detection\nCollision detection is best performed in hierarchical steps: Object Bounding Sphere\n\nto Object Bounding Sphere, Polygon Bounding Sphere to Polygon Bounding Sphere,\nthen Triangle to Triangle. We will begin by generating bounding spheres. Calculating",
      "content_length": 1847,
      "extraction_method": "OCR"
    },
    {
      "page_number": 383,
      "chapter": null,
      "content": "4.5 3D Collision Detection 361\n\nbouncing spheres is very simple; all you need is to find che center of the object, chen\ncompute the maximum distance between the center and a vertex in the object. By\nstoring the radius of each bounding sphere, you can perform bounding sphere colli-\nsion detection by adding the radii of the nwo objects, then taking the distance\nbetween the two center vertices. If the distance is greater than the sum of the radii, che\nspheres are certainly not colliding.\n\nLer's go through this step by step. First, you'll need to determine the center point\nof the mesh. One way to do this is to create a bounding box and find the midpoine\nbetween diagonally opposite vertices (see Figure 4.5.1), To compute the bounding\nbox. you need to find the minimum and maximum x, y, and z values for the entire\nobject, This can be accomplished by iterating through the vertices and maintaining a\n“current” minimum and maximum. After checking all vertices, you'll have the maxi-\nmum extents of the bounding box, The minimum and maximum values will be wsed\nto create the bor,\n\nGiven a bounding box with eight maximal paints (ABCDEPGH, see Figure\n4.5.2}, let's call the vertex assignments:\n\n(minx, miny, minz)\n(minx, Maxy, mainz)\n(Maxx, RAY, mainz}\n(Maxx, miny, minz)\n(minx, miny, maxz)}\n(Minx, RAxy, maxz)\n(ize, Haxy, maxz)\n(iixx, miny, maxz)\n\nTaAaAmMooagds\n\nhobo wt\n\nNow find the center point, given by averaging the minimum and maximum\npoints on the bounding box (these are indicated by paints A and G}.\n\nFIGURE 4.5.1 Finclinge the midpoine.",
      "content_length": 1549,
      "extraction_method": "OCR"
    },
    {
      "page_number": 384,
      "chapter": null,
      "content": "Section 4 Polygonal Techniques\n\nFIGURE 4.5.2 (Creating a bounding box.\n\nI? Widpeint formula; Given A{xi,yi,21) and B(x2,y2,22),\n\nif the midpoint of the line the passes through A and & is\nif [(xiteay/2, (yityeps2, [ztez2}/2]\n\nif\n\ncéenter.x = (A.x + G.xjs2\n\ncenter.y = (A.y + G.yp/e:\n\ncenter.z = (A.2 + G.zj/2y\n\nThe radius of the bounding sphere is easily computed by looping through the\nobject's vertices and finding the distance berween the center point and the cument\nwertex. If the distance is greater than the current maximum distance, replace the max-\nimum distance with the mew distance. After the loop, the maximum distance is the\nradius of the bounding sphere. (Of course, an casy optimization here is co only do the\nsquare root at the very end.)\n\nff Distance formula:\nff gist = soqrtl ((e2-xip°2)4((y2-y1)c2p+( (z2-z1)\"2) ]\nHi didatag = ( (2x1) 024 (Cy 2 yi Be ize-21 0-2)\nif\nforeach vertex v in object {\nEurrent_distante_sq = distsq(ebject.center, vj:\nif (current_distance aq > max_distance_ sq)\nmax_distance sq = current_distance sq;\n\nobject.os_radius = asqrt(max_ distance 44);\n\nThis will next be repeated on the polygonal level; bounding sphere checks are\nquick and simple, which is why when you have co check many polygons against cach\nother, it’s advantageous co begin with this test. After you have generated the necessary\nbounding boxes, bounding spheres, and center points for each object and polygon,",
      "content_length": 1418,
      "extraction_method": "OCR"
    },
    {
      "page_number": 385,
      "chapter": null,
      "content": "45 3D Collizion Detection 303\n\nyou will be ready to get into the real meat of this article: riangle-to-triangle intersec-\ntion tests! Get out the calculus book—you might need ir.\n\nTriangle-to-Triangle Collision Detection\n\nThis method of triangle-ro-triangle collision detection relies directly on some easy-\nto-understand but slightly ticky mathematics. Imagine chat we are given two triangles\nin 31D space (see Figure 4.5.3). We'll need to collect a lor of information from the nwo\ntriangles. We need to begin by finding the plane equation of one of the triangles. IFyou\nremember correctly, the plane equation is.Av+By+Cz+D=0. We determine A, 8, Cand\nby taking cross products of vertices:\n\n‘if given a triangle trit with vertices a, b and ¢,\nff wectord a, b, ©;\nWeotors v1, v2, cross_vixve;\n\nff create vectors vi, v2 (tril.b = trii.a,\nif tril.c - trit,a)\nwio= trii.b — trit.a:\nva = tril.c — tril.a;\n\ni] HOTE: You may be able te skip this step and substitute your\nff OWN SUPTfete normals if you already have then stored somewhere,\nfi Take cross product of vi and w2 (this is the normal\n\nfi vector of the cross product of vi and w2)\n\nCross Wixv2 = GrossProduct(vi, v2}¢\n\nFIGURE 4.5.3. Two intersecting trianeles.",
      "content_length": 1211,
      "extraction_method": "OCR"
    },
    {
      "page_number": 386,
      "chapter": null,
      "content": "Section 4 Polygonal Techniques\n\nif Then we plug these values back into Ax#By4Cz+b-0\ntril.pA = cross vixve.x«;\nTPLil.pa = eross vixve.y:\nTrill. pl = cross vixve.z:\n\nii Following this rule; Ax+By+Gz+0-0\n\nff if point P(xd,y0,20) is a point on the polygen\nif A = cross vinv2.x\n\nif B= 6ros4 yvinvily\n\nff, c= Gross vinvw2.z\n\nff O = (-A\"ed-B yo-Gez0)\n\nteil.pO = -DetProduct(cross vixw2, P);\n\nLine-Plane Intersection\n\nWe now have the plane equation of rriangle? and can move on to step two: sccing if\nsrianigle? collides with szangéel’s planc. This is done in multiple steps. The main idea\nis thar given owo vertices of miange2, we take the line defined by these vertices and\ndetermine at what point that line collides with sriangfeJ's plane. If the collision point\nis berween the two vertices, sriangle2 is colliding with rriangiel’s plane; if ix isn't\nbetween che two vertices, we iterate through the other two lines of sriaaghe2 te see if\nthere are collision points berween chose points.\n\nWe solve this line-plane intersection using parametric equations from caleulus\nGiven wo vertices, alxyG20) and bixlyplcd), we set alayO20i\"r -\nbic! yizly(1-2). cis an interpolation fetor that ranges from 0 ro 1. When =i) you\nare at point b, and when f=] you are at poine a. If we plug in paramenric equations for\neach component of the plane equation, we can then solve for r\n\nA(x + sD fI—) + Bt op ll) + C0 + cl Yl) 4 Da 0\nThis reduces down to:\n\np=—(A*el + BYyl + Cel + D)/(A(xO-x1) + BYyO-pl) + C'(e0-21))\nThe following code solves for 5\n\nff dO = (A*sD}) * (B*yO) + (o™z0)\nif = (tri1->pA*a->x) + (tril-+pe\"a->y) + (trii->plra->z);\n\nff 11 = (Atxi} * (Bt yt) + (6*z1)\n17 = (tril->pA‘b->x) + (trit-spa“b->y) + (trii->pt*b->z);\n\niY Be wary of possible divide-by-zeres here (i.e. if 20 == if}\nfinal_t = -(11 * trii->pO) / (id-11);\n\nff Then plug final_t back inte the functiona x(), yt} and zi)\nff to get the point of intersection from line to plane\nfinal_x = ({{a-*xj*(final_t)j+((b->x)*(1-Tinal_t1)});\n\nfinal_y = (((a->y)*(final_t))+((b->y)*(1-Tinal_t)));\n\nTinal_z = {{{h-*2)*(final_t}}+((b->z)*(1-final_t1}};",
      "content_length": 2090,
      "extraction_method": "OCR"
    },
    {
      "page_number": 387,
      "chapter": null,
      "content": "4.5 3D Collision Detection 305\na eS He at\n\n‘This will give you the final point where the line intersects the plane (see Figure\n4.5.4). OF course, the t value we've computed must be berween zero and one or che\nIntersection ts not between our two vertices! A special case char you also need to look\nfor at this step ix the presence of vertical line segments. The quickest way to determine\nthe intersection point is to plug x and z of either point a or b inco the plane equation\nfor the triangle and solve for ». The intersection point would then be (a.x, solved.y,\n\na2).\n\nTriangle “Flattening™\n\nWe're going to assume a right-handed coordinate system now. Imagine flattening a\ntriangle against one of the coordinate planes, depending upon triangle orientation. It\nmight lose the y coordinate and keep the x and 2 coordinates. The concepr here\ndoesn't specifically call for losing the y coordinate; it just requires losing the appropri-\nate coordinate $0 that it will flatten. A good way co decide which coordinate to drop\nis by looking at the normal of the plane; if you determine which component's absoluce\nvalue is the greatest, you can then find a plane to flarcen against where the triangle will\nnot be a “straight line” (such as a vertical triangle losing the y coordinate). For exam-\nple, if the x component is greatest, you would project to the yz plane. Regardless of\norientation, the tangle produced by chis will be flat (as if it were lying flat on a table,\nsee Figure 4.5.5). This ts very advantageous because now we can use basic algebra to\ncheck and see if the final intersection point, when flattened in a similar manner, lies\ninside the flartened triangle. The code in Listing 4.5.1 effectively flamens the polygon\napainst one of the coordinate planes.\n\nFIGURE 4.5.4 Determining collision points.",
      "content_length": 1808,
      "extraction_method": "OCR"
    },
    {
      "page_number": 388,
      "chapter": null,
      "content": "Section 4 Polygonal Techniques\n\npate =\n\n: Flattened Triangle :\n\nFIGURE 4.5.5 Verex projection.\n\nPoint-in-Triangle Test\n\nNow that we have flattened the coordinates, we need to do some algebra co determine\nwhether the flattened intersection point lies inside the flawened rriangle or not. There\nare several popular ways of doing this; we're going to make use che equation for each\nline of the flattened criangle. Take noge that regardless of which plane you project to,\nin this discussion we will seill refer wo the x and y coordinates of the flattened points.\nThis is because by projecting the vertices, we have effectively reduced the problem to\n2D; hence, the + and y. First, we need to find a point that is definitely inside the trian-\ngle. The easiest point to find char fits this description is the center of the triangle,\ncomputed as the average of irs vertices: ((xexl+x2)/2, (y0+-yI+72)/2)), Now thar we\nknow what direction the inside of the triangle is, we need to see if our point is on the\n“inside” side of the lines thar are made by each pair of vertices (see Figure 4.5.6).\n(siven two vertices, WO and v1, first find the equation of the line that goes through\nthem in the form y=nx+4. Remember thar the formula for slape (1) is (yf (lt),\nand you can find # by using the computed slope and 3 known point on the line. Now\nthat we have the equatian of the line in slope-intercep: form, we can determine\nwhether che factened intersection point lies on the side of the line that is the inside of\nthe triangle. We do this by comparing y values. If you plug the x coordinate of che flar-\ntened intersection poin into the line yen, you will ger che y value of the line ar x.\nNext, you determine whether the center point we computed earlier is “above” or\n“below\" the line by checking y values. We know thar ir is inside the triangle, 50 our\nintersection point has to have a» value that is in che same “direction” from the line as\nthe center point. If it docs, the intersection point is “inside” the triangle with respect to\nthe line ab. Repeat this for lines be and ca. If the point is on the inside after each vest,\nthe point is certainly inside the triangle. There is a special case to take into considera-",
      "content_length": 2211,
      "extraction_method": "OCR"
    },
    {
      "page_number": 389,
      "chapter": null,
      "content": "4.5 3D Collision Detection 397\n\nOutside\n\nFIGURE 4.5.6 Determining the boundaries of a wiangle.\n\ntion: a projected vertical line segment. You cannot graph vertical lines using y=nexed. If\nthis is encountered, you instead check x coordinates instead of y coordinates; char is,\nfirst determine on which side of the vertical line the inside poine is, Then, check the x\nvalue of the projected intersection pointe. If it is on the “inside” side of the vertical line,\nitis inside with respect to thar line. See Listing 4.5.2 for this procedure.\n\nCheck All the Lines, in Both Triangles!\n\nOF course, if one line of our triangle does not intersect, we still need to check the\nother lines, One line/triangle collision is all thar is needed to show thar both criangles\nare colliding. See Lasting 4.5.3 for the rest of this sample ende,\n\nAfter all of this has finished, if no collision has occurred, you need to reverse the\n\nprocedure, starting with triangle? as the source. This ensures a perfect collision detec-\nton.\n\nListing 4.5.1\n\nif [xX=\"FALSE) { // dropping x coordinate\nal = tri->a.y7\nbl = tri-2a.z7\n\na2 > tri-2o.y;\nba = tri->b.z7\na4 = tri-sc.y:\nba = tri-2¢.z;\n\nad = wert->y;\nBa = wart->z:\ninside = Oo;\n}\nalse if (y==FALSE) 4 // drapping y coordinate\nAl = tfi->a.e:\nbl = tri->a.z7\nao = tfl->b.x:\nba tri-sb.7:\na3 = tri->c.%j",
      "content_length": 1318,
      "extraction_method": "OCR"
    },
    {
      "page_number": 390,
      "chapter": null,
      "content": "298 Section 4 Polygonal Techniques\n\nba = tri->o.2;\na4 = vert->x;\nb4 = vert->2;\ninside = oO;\n\n}\n\nelse if (Z==FALSE) { // dropping z coordinate\nai = tri-Fa.e;\nbl = tri-za.y;\naf = tri->b.x:\nb? = tri->b.y:\nBe © tri-*c.x;\n\nbd = tri->s.y;\nad = Wart->K;\n\nbl = vart->y;\n\ninside © 0;\n\nListing 4.5.2\n——————$——————————\n\nHf TWGSe are used to check Tor vertical line segments in the\n\nff flattened triangle; you cannot graph vertical lines in 20\n\ni? using yenr+h, so we have to instead check if the flattened\nff intersection polnt lies batween the x coordinates af any\n\nHf vertical Line and the canter point of the triangle to see if\nff the flattened intersection point lias on the inside of the\nff triangle with respect ta the vertical Line segment,\n\nAR_vert = BG yoert = GA vert = FALSE:\n\nif yeme+h for outer 3 Lines\nif [{a2-aiji=oy q\nAi = (b2-bi)/(az-gi); ss a>\nboi = (bij«(mi*at}; if yi(ax) using vertex a\n} elae if ((a2-at}==9) ¢\nAB vert = TAUE;\n}\n\nAf [(@3-a2)i=0) {\n\nm2 = (bo-b2p/(ad-a2jp: ff b-ec\n\nbbe = (h2)-(mz*a2) ; if yim} using vertex b\n} @lse if ((ad-B2)=-o) (\n\nBC vert = TRUE:\n}\n\nif ({{at-aapl=0) {\n\n83 = (b1-bS) /(ai-agj; fy o-pa\n\nBS = (b3)-(ma*as); fi vitae) using vertex ¢\n} @1se if ((ail-asj==-0) [\n\nCA_vert = TRUE;\n\n}\nff find average point of triangle (point is guarantesd\ncenter_x = (altaztad)/4a; if ta lie ingide the triangle)\n\neenter_y = (bi+b2eba)/a:",
      "content_length": 1360,
      "extraction_method": "OCR"
    },
    {
      "page_number": 391,
      "chapter": null,
      "content": "4.5 30D Collision Detection Hi ei lt]\n\nff See whether (center_x,center_y} is above or below the line,\nff then set direction to UP if the point is above or DOWH if the\nff point is below the Line\n\nff @->b\nit (((mi*center_x)jibbt) == center _y)\nDIRECTION(direction,UP);\nplse\nDIRECTION( direction, DOWN) :\nif (AB_vert==TRUE) {\nif ((a1<a4)éh(al<gonter_x)) // vert projected Line\ninside+:\nelse if ((ai>a4)4h(alscenter_x}} // vert projected line\ninside++;\n} else {\nif (direction=syF) i\naif (ba <- ((ml\"a4j+bhb1)) // b4 lesa than y to be inside\ningicde++: fi (Ling i6 above point)\n} else if (direction==poAWM) {\naf (ba >= ((m@i\"a4a)+bb1)) fy) b4 greater than y to be ineide\ningide++: ff (ling is below point)\n}\n\n}\n\nff bec\nif ((ime\"center_x)+bo2) += canter_y)\nDEREGTION (direction UP}:\nelse\nDIRECTION (direction , DOWN) ;\nif (BG_vart==TRUE) {\nif ¢ (az < a4phh{a2 =< centers) ) // vert projected line\ningida++;\nelse if [ (a2 > a4djBR(a? > cemter_x) ) ff! vert projected ling\ninside++;\n} else {\nif (direction==UF) {\nif (b4 <= ((a2*a4)eboe)) f/ Ba less than y to be inside\ninside++; ff (line a8 above point)\n} else if (direction--DOWN) {\naf (D4 == ((m2*a4)+bb2)) ff Ba greater than y to be insida\ninsiders; fi (ling is below point)\nHi\n}\n\nfi c->a\nif (((ma*center_x)4683) >= center_y)\nDIRECTION (direction ,UP};\nalse\nDIRECTION( direction , DOW) ;\nif (CA_vart==TRUE) {\naT { (a3 = adjeh(ad =< center_x) } fs vert projected line\ninsidet+:\nelse if ( (aa > a4jee(aa > center_x) } // vert projected Lina\ninsides:\n} else {",
      "content_length": 1501,
      "extraction_method": "OCR"
    },
    {
      "page_number": 392,
      "chapter": null,
      "content": "400 Section 4 Polygonal Techniques\n\nif (direction==UP) {\nif (b4 <= ((m3*a4)4bb3)} // ba less than y to be inside\ningide++: ff (1in@ is above point}\n} #lse if (direction=-Dow) {\nif (ba == ((m3*a4)+bb3)) // b4 greater than y to be inside\ninsicde++: ff (Line 48 below point)\n\n}\nif (inside==3) {\nPéiturn TRUE;\n} @lse {\nraturn FALSE;\n}\n\nListing 4.5.3\n———\n\nff Sorell thru 3 line segments of the other triangle\n\nff First iteration (a,b)\n\np=Line_plane_collision((vertex_ptr)&tri2.a, (vertex_ptrjatriz.b,\n(triangle ptrjstrii};\n\nif Determine which axis to project to\ni] X is greatest\nif ((abs(trii.pAj>=abs(trit.p8) )S4(abs(trit.pAj>~abs(trit.pc)})\ntop = Point_inside_triangle((triangle_ptr)&tri1, (vertex _ptr)ép,\nTRUE, TRUE FALSE} ;\nfi ¥ ds greatest\nelse if ({abs(trit -PR)> abe (trait. pA) )ealabs (tris -RE)>=abs(trit.poj)}\ntemp = point_inside_triangle((triangle_ptr)&tril, (vartex_ptrjdp,\nif 2 as greatest asad ioe\nelse if ((abs(trit.pC)>=abs(trit. pA) )Sh(abs( tril. pC)>=abs(trit.po}))\nteap = point_inside triangle((triangle_ptrjatril, (vertex_ptrjap,\nFALSE, TRUE, TRUE) ;\n\nif (temp==TRUE} {\n\nff Point seeds to be checked to see if it lies between the two\nff wartices.\nff First check for tha special case of vertical lina SeQnents\nif ((tri2.a.x = tri2.b.x)Ab(triz.a.z <= tri2.b.z)) {\n\nif (((tri2.a.y <= p.y)SA(p.y <= tri2.b.y))]|\n\n((tra2.b.y <= p.y)SA(p.y <= tri2.a_y)))\nreturn TAUE;\n\n}\niy End vertical ling segment check\n\nff Now check for point on line segment\nif [point_inbetwgen_vertices ( (vertex_ptr)&triz.a,\n(vertéx_ptr)Stri2.b, (triangle ptr)atril)==TRUE}\nreturn TALE;\nelaa\nraturn FALSE;",
      "content_length": 1591,
      "extraction_method": "OCR"
    },
    {
      "page_number": 393,
      "chapter": null,
      "content": "4.5 30 Collision Detection 407\n\nif Sé@cond iteration (b,c)\npeline_plane_collision( (vertex ptr) btri2.b,(vertex_ptrjatriz.c,\n{triangle _ptrjStrit);\n\nif Determine which axis to project to\ni] X 4 greatest\nif ((abs(tril.pAjs=abs(tril. pe) jeh( abel tril. pAj>-abs(trit.pop))\ntemp = point_inside triangla((triangla ptr)strii, (vertex _ptridp,\nTAWE , TRUE, FALSE);\ni] ¥ ais greatest\nelse af ((abs(trid,pa)>sabs{trit. pA) jaa abs(tril .pb)==abs(tril.pc)})\ntenp = point_inside triangle( (triangle_ptr)&trii,(vartex_ptr)ap,\nTAWE , FALSE, TRUE):\nif £ 45 greatest\nelse df ((aba(tril.po)>-abs(trii.pA))&A(abs(trit.pG)>=abs(trit.pB)}}\ntenp = point_inside triangla((triangle_ptr) Streit, (vertex_ptr)ap,\nFALSE, TRUE, TAUE} ;\n\nif (temp==TRUE) {\nii Point needs to be checked to see if it lies betwoen the two warticeas\ni} First check for the spacial case of vertical ling segnents\nif ((triz.b.% == tri2z.c.ujah(tri2.b.% == triz.c.zj) {\nif (({triz.b.y == p.y)aalp.y c= triz.c.y))]\n(ltriz.c.y == p.y}Sa(p.y c= trie boy) ))\nraturn TRUE:\n}\n\nji Now check for paint on line segnent\nif (point_inbetween vertices ((vertex_ptr)&triz.b,\n(vertex _Pirjatriz.c, (trianglée_ptr)&triij==TAVE)\nreturn TRUE:\nelse\nreturn FALSE;\n}\n\nff Third iteration (c,a}\np=Line_plane_collision((vertex_ptr)Strit.c,(vertex_ptr)&triz.a,\n{triangle _ptr)strii);\n\nff Ootermineg which axis to project to\nfi X is greatest\nAf ((abs( tril, pAj=\"abs (tril. ph) SS (abs(trit.pAjr=abs( tris, pop)\ntemp = point_inside_triangle( (triangle ptr)strii, (vertex _ptrjap,\nTRUE, TAVE, FALSE} ;\nfj ¥ ais greatest\nelse if ((abs(trii.pB)j>=abs(tril.pA))&4(abs {tril .ps)>-abs(trit.pc}))\nTEP = pPoOlnt_inside triangle((triangle ptrjatrii ,(vertex_pirjap,\nTRUE FALSE, TRUE) ;\nfi 2 is greatest\nelse if ((abs(tril.pC)>-abs(tril.pA))S&(abs(trit .pG)>sabs(trit.pB}))\ntemp = point_inside_triangle( (triangle _ptr)a&tril, (vertex_ptrjép,\nFALSE, TRUE, TRUE);\n\nif (tenp==TRUE} {\nfy Point needs to be checked to see if it lies between the two wertices",
      "content_length": 1969,
      "extraction_method": "OCR"
    },
    {
      "page_number": 394,
      "chapter": null,
      "content": "E\n\nSection4 Polygonal Techniquer\n\nff First check for the special case of vertical line segments\nLf ((triz.c.x == triz.a.x}eh(tri2.c.7 = triz.a.zj} {\nif (((trig.e.y <= p.y)Ss(p.y <= triz.a.¥))]|\n((tri2.a.y <= p.y)S8(p.y <= triz.c.y¥}))\nreturn TRUE;\n}\n\nji Now check for point on line segnent\nif (point_inbetween_verticas((vertex_ptrj]&tri2.c,\n(Vertex ptr }Striz.a, (triangle_ptr)&tril)==TRUE}\nreturn TRUE; /! Intersection point is inside the triangle and an\nalee if the line segeant\nreturn FALSE:\n}\n\nreturn FALSE; // Ostawlt value/na collision",
      "content_length": 541,
      "extraction_method": "OCR"
    },
    {
      "page_number": 395,
      "chapter": null,
      "content": "4.6\n\nMulti-Resolution Maps for\nInteraction Detection\n\nJan Svarovsky\n\nThis article describes a method for reclucing the number of proximity tests that must\nbe performed for games with large numbers of game objects of varying sizes. The cost\nof simply testing cvery abject against every other object goes up with the square of the\nnumber of objects. which can ger very large! This is particularly bad if the proximicy\ntest is expensive.\n\nUsing a Grid\n\nThe simple solution ts to cut up the world with a grid-based map. Esch grid square\nhas a linked list af the objects whose centers are locared above i. Because the objects\narc of non-zero size, they may overlap into adjacent map squares. When che time\ncomes to search for all possible collisions benween objects, cach object only has to test\nfor others after it in the linked list associated with its own map square, and also map\nsquares 0 the east, southeast, and south. Any collisions co che north and west and\nwith objects earlier in the list are detected when other objects do meir check. This\nenables you to avoid checking for the same collision rwice.\n\nProblems with Varying Object Size\n\nThis approach has problems when the game objeces vary widely in size. You are only\nguaranteed to find all the collisions in chis way if your game objects are smaller than\nyour map squares. IF you have large game objects, you could make the map squares\nlarger. However, this would mean chat smaller ebjeces would test against each other\nwhen they are in fact far apart, when a finer grid system would have avoided them\neven considering each other, Sec Figure 4.6.1.\n\nIf you make the map squares smaller than some game objects, then there is a dan-\nger that objects’ interactions are not detected because they are far enough apart in\nmap squares to never check each other, though physically they do touch.\n\n403",
      "content_length": 1851,
      "extraction_method": "OCR"
    },
    {
      "page_number": 396,
      "chapter": null,
      "content": "| 3\n\nSection4 Polygonal Techniques\n\nFIGURE 4.6.1 Object 2 checks against Object 3 and map squares A, B, and C.\n\nYou can solve this by giving cach object “feet.” Here, objects do nor sie in the map\ndirectly (unless they are small enough); instead, rarher small helper objects sit in the\nmap squares that the object touches. Management of these fect is simple, thoweh a lic-\nthe clumsy (Figure 4.6.2).\n\nFIGURE 4.6.2. Lareer Object 2 now has feet!",
      "content_length": 444,
      "extraction_method": "OCR"
    },
    {
      "page_number": 397,
      "chapter": null,
      "content": "4.6 Multi-Resolution Mape for Interaction Detection 405\n\nMulti-Resolution Maps\n\nThe alternative suggested here is to have several resolutions of map. The map square\nsites go up in powers of owo to make conversion herween the different coordinate sys-\ntems simple. Each object resides in the map where the squares are the smmallest possi-\nble while actually being larger than the object. When doing the collision detection,\nyou not only check against your own map square but also che map squares in the\nlower-resolution maps (larger map squares) chat you touch. Much like only checking\nin the linked list after yourself, you don't bother checking in higher-resalution maps,\nThe smaller objects will find you when they do their own checking, so you don't have\nto search for chem (Figure 4.6.3).\n\nIt is simplest to have all resolutions of map squares, down to one map square cov-\nering the whole world. Each lower-resolution map is four times less data, so the mem-\nory fequirements ate vanishingly small. In my experience, if you cut off the map\nresolutions at some level, you may every now and then dunng game development dis-\neower a game object (such as an explosion’ effect sphere) will be just a little too large\nand crash your game. The only cxura cost for not cutting off che map resolutions is\nthar the searching goes all the way to the lowest-resolution map.\n\nYou can add a lower bound for the resolution simply, with a decision—do you\ndisallow larger objects, or do you just put them in the lowest-resolution map squares,\naccepting thar sometimes they won't be collided with correctly? recommend allew-\ning them to reside in the lowest-resolution map, assuming that the objects are only\ntoo large during development of the game, and by the time of release you will need ro\ntune the map square size co suit the largest object available in the game.\n\nri\n\nFIGURE 4.6.3 Multiple simple maps; cach object resides im che finest resolution map\npossible.",
      "content_length": 1954,
      "extraction_method": "OCR"
    },
    {
      "page_number": 398,
      "chapter": null,
      "content": "406 Section 4 Polygonal Techniques\n\nSource Code\n\nhh ee a\n#include <stdio.h>\nFincludé <a6¢ert.h>\n#include ‘mtxlib.h*\n\nff This ie your gane object base class\nClass Gamedhject:\n\neee eee ee eee eee eee ee eee CEE REALE E SOAP EATS\ni\nff External definitions\n\nfy) Tf the sap decides two objects are close enough together, it will\nff call this function, which you have to prowide\nextern void process collisian(Gamp0bjact “a, Gametbject \"bj;\n\nA00U0ASRUOAAG CUO R UGC OGG LEBEAU OO EEE EEE\nii\n\nif A gana object. Derive your ow objects off this\nclass Gasedbject\n\npublic:\nGaneObjact | }\n{\n\nNextInWap = MULL;\nMapSquare = NULL;\n\nNaphies = Os\nI\n\nif The object if in a singly linkad list hanging off one of\nJf the map squares\nGaneQoject *MaxtInMap;\n\nff And this is the map square that this abject is hanping off,\nff ile the start of that list\nGaneObjact *\"Mapequare;:\n\nff The reselution of the map the object is sitting in\nint Mapes:\n\nff Take the object aut of the map's linked list\nWold RénoveFromlapt):\n\nif calls \"process collision® om all the relevant other objects in\nif the ap, a4 per the article\nwold Process¢ollisions(class Map *my_nap);\n\nprivate:\n\nff 00 on€ resolution of map, used by ProcessCollisions( }\nVOid ProtessOnelevel(Map ‘my_map, Gamedbjact **map_=ho,\nGanedhject \"walker, int eurrent_rasj;",
      "content_length": 1292,
      "extraction_method": "OCR"
    },
    {
      "page_number": 399,
      "chapter": null,
      "content": "4.8 Multi-Resolution Maps for Interaction Detection 40T\n\nJCUUBDBE A OODLEUEEECUOUBDBEEL OCHO LOE EU SEEDER BBE UE E EEE\nif\njj The map.\n\nff for efficiency’s sake, the map dimensions etc are constants, you\nif could sinply turn them into variables if you so wished\n\nff (1 << this) is number of aap squares at highest ras\nfidefine MAP_HE RES SHIFT iB}\n\nfo and the mumber of map squares at tha lowest ras\nfdefing M4P_LO_RES_SHIFT Ct)\n\nif snallest size of a map square\n\nfdefine MAP SMALLEST SQUARE SIZE_SHIFT (a)\n\nPietine MAP SMALLEST SQUARE SIZE {1 oc |\nMAP_SMALLEST_BOUARE SIZE SHIFT)\n\nfi? largest\nfdefine MAP_BEGGEST SQUARE SIZE_SHIFT (WAP SMALLEST SQUARE SIZE SHIFT +\nMAP HI RES SHEFT \\\n- MAP_LO AES SHIFT)\ndefine MAP_BIGQGEST SMARE SIZE qi <<}\nWAP BIGGEST SQUARE SIZE SHIFT)\n\nif The Length of one Bdge of the nap if, aétual game coordinates\nfdetine MAP_SIZE (1 << \\\n(MAP_SWALLEST SQUARE SIZE SHIFT + MAP_HI_RES SHIFT) )\n\nif The map,\nclass Wap\n\n{\n\npublic:\n\niia array of pointers th the differeat resalutions of Tap.\nGamaGbject **Who[MAP_HI_RES SHIFT - MAP_LO AES SHIFT + 1];\n\nMap);\nWap (hi\n\nff Fills in the who array and clears it\nbool Init();\n\nff deallocate\nVoid Reseti);\n\nff fills in the object's map-related information given its\nff position and radius\n\nvoid Placateject(Ganeteject Bob], const vectora &pos,\nfloat radius);\n\n{/ Q@iven 4&4 map square at a certain resolution, returns the\n\nff one at the next lower resolution, or NULL if that was the\nff Lowest res\n\nGaneObject \"\"GetLowarWapSquare (Gamedbject **current, int res};",
      "content_length": 1527,
      "extraction_method": "OCR"
    },
    {
      "page_number": 400,
      "chapter": null,
      "content": "};\n\nsection 4 Folygonal Techniques\n\nAA CRUAAUROROLAL ALOU SDA GAEEOUOEG LUPE LEEEELE LED EELE EEL\n\ni\n\nfi implementation\n\nvoid\nif\n\nwoid\n\nGama0bject::ProcessCollisions(Map *my_map)\n\nff We loop through several resolutions of map, starting with\niy the current.\n\nff First start with the objects in my aap square\n\nGameObject “walker = Nextinwap;\n\nint current_ras = Maphes:\n\nGameQhject **map who = MapSquere;\n\noo\n\n{\n// 00 ong resolution's worth of eellisign\nPracessOngLevel(my_map, naplwho, walker, CUrrenk_res);\n\nff Move to the next lower resolution\nmap who = my_Map->GetLowsrWapSquare (map who, curréent_ras);\ncurrent_ras—;\n\n}\n\nwhile (map_who); // until we're at the lowest resolution.\n\nGaneObject::ProcessOneLovel(Map \"my map, GameDoject **map sq,\nGareGbject “walker, int CuUrrent_res_ shift)\n\nint turrent_res_ Size = | =< curhant_res_shitt;\n\nff 06 all tha objects in the first list presented\nTor {; walker; walker = walker->MextInMap)\n\n{\n}\n\nff Work gut if you can go to the adjacent map #quaras\nint current_offset = map eg - hy_map-Anolcurrént_ras_ shift —\nWAP_LO_RES_SHIFT];\n\nprocess_collision(this, walker);\n\nff Than do fap squares to the east, southeast and south\nif ((current_offset & (current_oros size - 1) t=\nturrant_reg size = 1)\n{\n\nfi} Square te the east\n\nfor (walker = map_sqli); walker;\n\nWalker = walker->WextInWap)\n\n{\n\n}\n\nprocess collision(this, walker);",
      "content_length": 1363,
      "extraction_method": "OCR"
    },
    {
      "page_number": 401,
      "chapter": null,
      "content": "4.6 WMulti-Resolution Maps for Interaction Detection\n\nif (curment_offset + current_res_size <\n{i << (curremt_res_shitt * 2)))\n\n{\ni} Square te the south\nfor (walker = nap_sq[curront_ros_ size]; walker:\nwalker = walker->NextInilap}\n{\nprocess eollisian(this, walker);\n}\nffi and lastly, southoast.\nif ((ourrent_offset & (current_res size - aj) !=\ncurrent_res_size - 1)\n{\nfor (walker = map_sq[current_ras_size + 1]; walker;\nwalker = walker-=HaxtIoMap)\n{\nprocess _collision(this, walker);\n}\n}\n}\n}\nvoid GaneQbject: :AemoveFromapt}\n{\nff Search for nyself.\nfor (GameObject **pointer_to_me = Mapaquare;\n“painter_to_mea |= this;\npointer to me = &(*pointer_to_mé)->NextInidap)\n{\nassert (\"polinter_to_ma 43\n\"Gane object couldn't find itself in map\");\n}\nff Aénovwe myself.\n\"pointer_to_me = fextinMap:\nif and tor satoty's sake, lat's clear my pointers.\nNextinWap = MULL;\nMapSquare = MULL;\n}\npat\nfor (int res = WAP LO RES SHIFT; res <= WAP_HI RES SHIFT: res++)\n{\nWhojres - MAP_LORES SHIFT] = MULL;\n}\n}\nMap: : lap i }\n\nReset;",
      "content_length": 1008,
      "extraction_method": "OCR"
    },
    {
      "page_number": 402,
      "chapter": null,
      "content": "410 section4 Polygonal Techniques\n\nvoid Map: iReset()\n{\nHf You'd better have cleared all the objects out by now.\nff IT won't check.\nfor (int ras = MAP_LOORES SHIFT; res <= MAP_HT_RES SHIFT; res++}\n|\ndelete.] Wholres - WAP LO RES_SHIFT);\nWoe[res - MAP LO RES SHIFT] = NULL;\n\n}\n\nbool Map:sImit (}\n\n{\nHeset(); #/ just in case\nff allecate and claar everything.\nTor (ant res = MAP LO AES SHIFT; res <= MAP _HI RES SHIFT; res++}\n1\nWhol Pes - MAP LO RES SHIFT) = new GameQbject*\n[1 << (res * 2);\nif (IWhe[res - MAP_LO_RES SHIFT))\nreturn falge; sf alloc failed\nfor (int sq = 0; sq < (1 << (res = 2)); sq++)\nWholres - MAP_LO RES SHIFTJ[eq] - NULL:\n}\n}\nreturn true;\n}\n\nff fills in the object's map-related information piven its\n\nii position and radius\n\nVoid Map: :PlaceObject(Game0bject obj, const vectors Epos,\nTlaat radius)\n\n{\n\nff input value cheeking.\nassert(radius == 0.f &4 radius < MAP STZE);\n\nff Tf you want ta allow positions «aff the Nap, change\ndf these asserts inte assignments\n\naSsert(pos. 2 = O.f BE pos.e = MAP SIZE):\nASsertipos.y >3 0.7 £8 pos.y < MAP SIZE};\n\n‘i Conversion inte integer coordinate systam needed far\n\nff shitting/array maths later on. Note that these conversions\nff are often slow and may have to be replaced with faster\n\nff versions in some compilers. If you do replace then,\n\nff preserve their rounding-down nature\n\nint iradius = int(radius);\n\nint ix int(pos.x 4;\n\nint iy int(pos.y 1;",
      "content_length": 1407,
      "extraction_method": "OCR"
    },
    {
      "page_number": 403,
      "chapter": null,
      "content": "4.6 Multi-Resolution Maps for Interaction Detection 411\n\nft Find which resolution level of the map the object showld\nif go in.\n\nobj .Maphes = MAP_HI RES SHIFT;\n\nfor (int map size = MAP SMALLEST SQUARE SIZE; map size <=\nWAP_BIGGEST SQUARE SIZE;\n\nHap siza <<= i}\n\n{\n{f Does the object fit?\nif (iradius <= map size} goto it_tits;\nfy step on...\nobj -Mapies=;\n}\n\nassert(! \"object too large for map - soné collisions nay not be\ndetected\");\n\nit fits:\n\nI\n\niy Put it an the nap.\nint which_level = obj.Mapaes - MAP_LO_ RES SHIFT;\nGamedbject **which who = Who[which level];\n\niy Then add on the position\n\nwhich why += ix >> (MAP_BIGGEST_SQUARE SIZE SHIFT - which level):\nwhich_wha += {iy >> (MAP_BIGGEST_SQUARE_SIZE_SHIFT — 5\nehi¢h_level)) == obj.Maphes;\n\nif Insert tha object inte the map square\nobj .MextinWap = “which wha;\n\"which who = hobj;\n\nob). MapSquare = which who;\n\nGaneObject **Map:;GetLowerWapSquare(Gamedbject **current, int who res)\n\n{\n\nff Top of map?\nif (who res == MAP_LO_AES SHIFT) return MULL;\n\nif Gunning bit-shifting -\nint current_otfset = ¢urrent = Wholwho_res - MAP_LO RES SHIFT];\n\nff Extract tha y part af the current offset.\nint ¥_Maek = Oxttttttt? << who res;\n\nif The new offset is this:\nint newloffset = ((current_offset & -y_mask } == ij #\n({current_offset & [y_mask <= 1)) => 2);\n\nreturn Wholwho_res - MAP_LO RES SHIFT - 1] + new offset;",
      "content_length": 1352,
      "extraction_method": "OCR"
    },
    {
      "page_number": 404,
      "chapter": null,
      "content": "4.7\n\nComputing the Distance into a\nsector\n\nSteven Ranck\n\nThis article describes 2 simple and fast algorithm for decermining where a point is\nberween the edges of a 2D quad (or sector). The result is a unir floating point num-\nber, where O indicares that the point lies on the leading edge, and where 1 indicates\nthat the point lies on the opposite edge. The sector may be any four-sided, 2D convex\nshape,\n\n‘This article is useful for any game that may require knowledge of how far “into” a\n20) sector an object or point is. For example, a 3D racing game might use a cop-down\n2D sectorization of its track no describe to the AI driving system how to navigate the\ntrack, Using the sector data and a vehicle's AZ position within a sector, the Al system\ncould use chis algorithm to determine hew far into the current sector the vehicle is, or\nwhere laterally it is. The algorithm is very fast, and in most cases can easily be com-\nputed for every vehicle each fame, if heocssary.\n\nThe Problem\nee ee eee eT\n\n412\n\nFigure 4.7.1 shows a four-sided, 2D sector in XZ world space. The object's posi-\ntien on the AZ planc is shown as point P. We would like to find a continuous fune-\ntion that acceprs Pas a parameter and produces a value of O if P lies on the leading\nedge, 1 if Plies anywhere on the trailing edge, and a value between O and 1 if the\npoint lies berween the leading and trailing edges. Figure 4.7.2 shows the desired sealar\nvalues for several points within a sector.\n\nAs Figure 4.7_2 shows, all points lying on the leading edge produce a value of 0,\nand all points lying on the trailing edge produce a value of 1. Points beeween the evo\nedges produce values that increase from 0 to 1 as the poine is swept across the secrar\nfrom the leading edge to the trailing edge. Because we're interested in an algorithm\nthat's computationally inexpensive, we will not require thar the interpolation be lin-\ncar. However, it must be a smooth interpolation, and the function must work far all\nconvex sector shapes. A few examples are shown in Figure 4.7.3.",
      "content_length": 2048,
      "extraction_method": "OCR"
    },
    {
      "page_number": 405,
      "chapter": null,
      "content": "4.7 Computing the Distance inte a Sector 4413\n\nHe\n\nie\n\nLeaclirny\nEdge\n\nFIGWAE 4.7.2 Dresired scalar valuss for various Poln Within a sector.\n\nFigure 4.7.3 shows that, regardless of the sector's shape, the value\nreturned from our desired function is always 0 on che leading edge and 1\non the railing edge, and it is interpolated when our paint lies between the\n\nTaro eckpes.\n\n0.0 1.0\n0.0\n0.0 0.0\n1.0\n0.0\" 1.0\n\n0.0 1.0\nFIGURE 4.7.3 Example convex sector shapes showing comesponding scalar values.",
      "content_length": 494,
      "extraction_method": "OCR"
    },
    {
      "page_number": 406,
      "chapter": null,
      "content": "414 Séction4 Polygonal Techniques\n\nDescription of the Algorithm\n\nA fast and simple solution to the problem in the previous section is given by the equa-\nLi:\n\nT= (Vip #¥,)\nVip @ Ny + Vp oN,\nEQUATION 4.7.1 Equation for computing a distance value across a sector,\n\nWhere\need adie\nV>y- PP,\nAnd:\n\nPis the point of interest within the sector.\n\n* is any point on the Leading Edge.\nPyis any point on the Trailing Edge.\n\nis the inward-pointing unit normal of the Leading Edge.\nNris the inward-pointing unit normal of the Trailing Edge.\nDis our result: a floating point number from 0 to 1,\n\nFigure 4.7.4 shows the variables involved in Equation 4.7.1 and their relationship\nto the problem. Note thar ?, may lie anywhere along the leading edge, and F; may lie\nanywhere along the trailing edge. However, using opposite corners of the sector offers\nseveral advantages. First, sino the sector is most likely defined by its four vertices, it\nmakes sense to use the corners far aur purposes. Second, by choosing opposite cor-\nners, Equation 4.7.1 can be used to compute both the distance from leading edge to\ntrailing edge, as well as the distance laterally, This is because #, lies on both the lead-\ning edge and one of the lareral edges, and > lies on both the trailing edge and the\nother lateral edge.\n\nEquation 4.7.1 has several fearures:\n\n- It produces a scalar from 0 to 1.\n\n- It produces 0 if P lies on che leading edge.\n\n~ It produces 1 if Plies on che crailing edpe.\n\n- Although not lincarly, it docs produce a smooth, interpolared value from 0 to 1,\ndepending on how far into the sector P lies.\n\n. It's fast, requiring only two 2D vector subtractions, nwo 21D det products, one\nsealar addition, and one scalar divide to compute.\n\n6. The raw, world-space point P can be directly plugged inte the equation. No\n\ntransformation into warped sector space is required.\n\nee a fc) me\n\nNoah",
      "content_length": 1874,
      "extraction_method": "OCR"
    },
    {
      "page_number": 407,
      "chapter": null,
      "content": "4.7 Computing the Distance inte a Sector 415\nee\n\nFIGURE 4.7.4 Parameters used in the algorithm.\n\ni\n\n- [f the sector is a staric shape, then P;, Py, N;, and M>may all be pre-determined\n\nand stored in the sector definition data stracture.\n\n8. Ifthe sector dynamically changes shape, P; and Pare still available from the sec-\ntors vertices, and N, and My can easily be computed from che sector's vertices\n(although this is slower because it involves a square root per normal).\n\n9. Tt may be used to compute the distance larerally, moo, provided thar the nwo\n\ninward-pointing unit normals for the lateral edges are available,\n\nThe equation has several requirements;\n\n- The sector must be convex and have four sides, each of non-zero length.\n\n. The sector must have non-zero area.\n\n- must lie within the sector, or along any of its perimeter line segments. If che\npoint lies outside of the sector, the result might not be a value between 0 and 1,\nas expected,\n\nee\n\nApplications\n\nDistance Down a Track\n\nEquation 4.7.1 has many applications in game development, One example is in the\ndetermination of how far down the track a vehicle is. Figure 4.7.5 shows a top-down\nview of a road track overlaid with a chain of sectors.\n\nWhat wei like co know is how far down the track each vehicle is. When the vehi-\ncle is at the starting line, it should be a value of 0. When che vehicle is at the finish\nline, wee like a value of 1. And, weld like reasonable interpolation in between.\n\nThe sectors are constructed to completely contain the crack so that the vehicle\nposition, P, will always be within a sector, This also means thar adjacent sectors use\nthe same vertex points. Ar game initialization time, each sector's inward-pointing unit\nnormal for both irs leading edge and trailing edge is computed. Note char a sector's",
      "content_length": 1808,
      "extraction_method": "OCR"
    },
    {
      "page_number": 408,
      "chapter": null,
      "content": "416 Section 4 Polygonal Techniques\n\nFIGURE 4.7.5 Secrorization of a track.\n\ntrailing edge normal is equal to its neighboring sector's negated leading edge normal.\nBut if the memory is available, it’s fastest co store the evo normals with cach sector.\n\nAnother piece of information we'll need is the approximate world-space distance\nberween cach sector's leading and railing edges. A sloppy bur decent metric for this is\nto use the magnitude of the vector extending between the midpoints of the leading\nand trailing edges as shown in Figure 4.7.6,\n\nAs with the other sector data, we pre-compute sfor each sector and store it in the\nsectors data structure. Ac chis point, we might have a sector dara structure that boolss\nlike this:\n\ntypede? struct {\nFloat f%, fz; // 20 X2 worldspace coordinate\n} Weck? +;\n\ntwpede? struct {\n‘i Glockwise, where [0] = left side of Leading Edge\nVookZ_t aVertices[4];\n{i Clockwise, where [0] = Leading Edge\nWack? _t aUnitNormals[4]:\nif Distance from Leading Edge's midpoint to\nif Trailing Edge's midpoint\nTloat feactorDist;\n\nif = previews sector's fTotalPriorbist + fSectarDist\ntloat fTetalPriorbist;\n} Sector_t;\n\nNote the tTotalPriorDist field, which is simply che sum of the previous sector's\nfTotalFriorfist and tSecterDist fields (fTotalFriorDist is 0 for che first sector).\nWe'll discover why we need this below, The final piece of information we will need is\nthe sum of all iy adding together #SectorQdst for all sectors. We'll pre-compute and\nstore the inverse of this and call it fOneQverTotalSactorDist. We store the inverse\nbecause, as we'll see, we actually need to divide by the sum of all s, and multiplying by",
      "content_length": 1652,
      "extraction_method": "OCR"
    },
    {
      "page_number": 409,
      "chapter": null,
      "content": "47 Computing the Distance Inte a Sector 417\n\n5 = |S!\n\nFIGURE 4.7.6 Approximating the world-space distance berween sector edpcs.\n\nthe inverse is faster on mest CPUs than dividing. Since we have the luxury of pre-\ncomputing this information, we won't pass up the opporeunity to do the division (rec-\niprocal) ar that time and score an inexpensive multiplication at run-time,\n\nArmed with the preceding information, we're now able to determine how far\ndown a track a vehicle is. For each vehicle, we need the following information:\n\nfinclude \"ntxlib.h®\n\ntypedet struct {\nvectors WorldPossD;  // Vehicle's origin in 3D worldspace\nSector_t \"pSector; fi Points to the sector the\nff vehicle origin is currently in\n} Vehicle t;:\n\nAt the start of the race, the vehicle structure is initialized for cach vehicle, and\npSecter is pointed to the sector containing its origin. This initial sector may be four\nby either scanning the entire list of sectors for the one sector containing the vehicle\norigin point, or by storing the initial sectors as part of the starting line data.\n\nOnce the race begins, we need to track which sectors the vehicles are in, since\nEquation 4.7.1 requires that che point lic within a sector. To do this, each time we\nmove the vehicle, we use a simple point-in-sector test to see if the vehicle is still within\nsector. If nor, then the vehicle is either im the next sector or the Previous sector, and\nWe agilin use the point-in-secvor test, Most of che time, only one test is required; occa-\nsionally, two tests are required. If the vehicle is moving backward, three tests will be\nneeded. [fit is possible that the vehicle's speed is fast enough that the vehicle skips an\nentire sector from one frame to the next, a more sophiscicared sector-tracking algo-\nrithm will be needed. One such solution would be to check, in order, the nar N for-\nward sectors first. Ifthe vehicle is not found in any of those, the algorithm would next\ncheck the previous W sectors. If the sector is still not found, this could be considered\nAn uncommon condition, and the algorithms would resort ro scanning the entire sec-\nbor list,",
      "content_length": 2124,
      "extraction_method": "OCR"
    },
    {
      "page_number": 410,
      "chapter": null,
      "content": "418\n\nSection4 Polygonal Techniques\n\nNow thar we have a valid secoor for cach vehicle, we can write a function for\nEquation 4.7.1 te determine how far ine its sector each vehicle is:\n\nTloat CaléUmitDistIntosector( float fPointx, float fPaintzZ, const\nSector_t *pSector j {\n\n}\n\nVeex2_t VLF, VIP:\nfloat flotL, fOotT:\n\nff Compute vector from point on Leading Edge to P:\nVLP.fX = fPointX - pSecter-saverticas[0O] .tX:\nVLP.fd = fPointZ - pSector-saverticas[0] tz;\n\nif Compute vector from point on Trailing Edge to FP:\nVIF.TX = TPointk - pSector--avertices[2].7x;\nVIF.?Z = TPointZ - pSector-savertices[2].#2Z;\n\nji Gampute (WLP dot Leading Edge Normal):\nfDoth = VLP.fX*pSector->alinitNornals[0] x +\nWLP. f2*pSector-sallnithernals(o].Tz:\n\nJi Gonpute (VIP dot Trailing Edge Normal):\nFDotT = VIF. tx*pSecter->alinitNormals[2] fx +\nVIP. TE\" pSactor-*alinithornals[2].tz;\n\n/f Conpute unit distance into sector and return it:\nreturn { fDotl / (fOo0th + tOotT) }:\n\nFinally, we can compute the distance down the track like this:\n\nif Pre-computed to be tha inverse sum of Seoter_ti:tSectarbist\n\nIf\n\nTor all s#eters.\n\nfloat TOnefverToatalSectorbist;\n\nfloat CalclnitbistbownTrack({ const Vehicle t “pYehicle } {\n\nfloat TUnitDistintesector, tOistDoenTrack;\n\nff Campute how far vehicle is inte its sector:\nTUNLEDstlateSecter = CalclUnithistintegector [\npP¥venicle-“WorldPoasso. x,\npYehicle->WorldPosso.z,\npWehicle->pSector\nNM\n\nfi The distance down the track is the full distance\n\nff across all previous sectars, plus the partial\n\nff distance into our current sector:\n\nfOistlewmiTrack = p¥ehicle->pSecter->fTotelPriorbist\n+ p¥ehicle->pSector:>*SoctorDist *\nFUnLtDistIintesector ;\n\nff Finally, our unit distasice dom the track is our\nif distance sa tar divided by the track's total distance:\nreturn fOistBownTrack * fOnelverTotalsectarDist;",
      "content_length": 1817,
      "extraction_method": "OCR"
    },
    {
      "page_number": 411,
      "chapter": null,
      "content": "4.7 Computing the Distance Inte a Sector 4419\n\nThe function CaleUnitbistbownTrack() returns a value of O if the vehicle is on\nthe leading edge of the firsc sector of the crack, returns a value of | if the vehicle is on\nthe trailing edge of the lasr sector of the crack, and returns an interpolared value\nbeeween 0 and | based on how far down the mack the vehicle is,\n\nSmooth Light Changes\n\nAnother practical application of Equation 4.7.1 is the smooth interpolation af light-\ning on objects moving through sectors. If we associate ambient and directional lights\nwith leading/trailing sector edges, we can interpolate the lighting parameters as the\nabjects to be lit move from sector to sector.\n\nConsider a sector enclosing a section of a track that begins in che sum at the sec-\ntors leading edge, and ends in a dark cave at the sector's trailing edge as in Figure\n477.\n\nWe can store the ambient RGB light color at each adjoining sector edge lile so:\n\ntypedef struct {\nfloat fA, 76, TB; // ROB ambient light\n} Anbient_t;\n\ntypedef struct {\nff Clockwise, where [0] = left side of Leading Edge\nVeex? t aVertices|4];\n{f Clockwise, where [0] = Leading Edge\nVeex? t allnmitNormals[ 4);\nff Oistance trom Leading Edge's midpoint to Trailing\nfi Edge\"\nFleat fSectordist:\nif = previous sector's fTotalPriorfist + TSecterDist\nFloat fTotalPriorDist;\ni} Ambient light at Leading Edge\nAbient_t LradingAmbient ;\nff Ambient light at Trailing Edge\nAnbient_t Tradlingémbient:\n} Sector_t;\n\nThe ambient value of adjacent sectors must be the same to avoid a visual pop of\nthe light level when the vehicle crosses into a different sector. In the preceding imple-\n\nBrigh sunlight\nambient light sii Feito\nipaaecedl ® ambiant light\nwe FP on Trailing Edge\n\nFIGURE 4.7.7 Ambient lighr pradient ZTOSs @ POCO.",
      "content_length": 1779,
      "extraction_method": "OCR"
    },
    {
      "page_number": 412,
      "chapter": null,
      "content": "Section4 Polygonal Techniques\n\nmentation, we simply store both leading and wailing ambient values with each sector,\nbut a more memory-conscious implementation might share ambient dara through\npointers. In any case, the preceding is all we need to smoothly animate the ambient\nlight level from sunlight to cave light as the object progresses through the sector. The\nfollowing funcoon dees the trick:\n\nSdeTine LEAP( fUnit, fVO, f¥1 ) ( (1.0f-(fUnitpp\"fvo + 4\n(flnitprsv1 )\n\nAabient_t CalcAmbientlightLevel( const Vehicle t *pvahicle }) {\nfloat funitDistintasector;\nAmbignt_t “pleadAnbiant, *plrailambient, RatAmbient;\n\n‘i Conpute how Tar vehicle is inte its sector:\nFUnitDistintesector = Calclitbistintesector|\npiehicle->WorldPos30.x,\npVenicle->WorldPos30.z,\np¥enicle->pSecter\nla\n\npleadanbient = &pvehicla->pSecter->Leadingénbient:\npTrailAnbient = &pvehicla->pSector=>TrailingAmbient:\n\nRetAmbient th = LERP( flnithistintosecter,\nPleadémbient->fA, plrailambient->fA 4};\nRetAmbient. 7G = LERP( fUnitDistintoSector,\npleadAmbient->9G, pTrailAmbient->f0 };\nRetAnoient. Th = LERP( fUnitDistintosector,\nPLEAOUAMOLENT-=Th, PrrailaAmbient-+fh jp;\n\nreturn AetAmbient;\n}\n\nThe preceding function computes the ambient light level at the world pasition of\nthe vehicle, A graphics engine could use the resulting ambient RGB ta provide the\noverall ambient light with which ro light the vehicle, combining it with other, more\nsophisticated lighting if desired. As the vehicle drives through the sector, the ambient\nlight is smoothly interpolated, regardless of the shape of the secter.\n\nFunctions similar to CaleAmbientLightLevel(} can be written to smoothly incer-\npolate any parameter that's assoctated with a sector edge. Examples are directional\nlight (interpolating the direction and color), sector heighs, water flow rate and direc-\ntion, foe characteristics, sky appearance, Al dificuley. etc.",
      "content_length": 1881,
      "extraction_method": "OCR"
    },
    {
      "page_number": 413,
      "chapter": null,
      "content": "4.8\n\nObject Occlusion Culling\n\nTim Round\n\nOcclusion culling is a technique for culling unwanted geometry from the field of\nview, This is an extension of field of view culling, in that it helps reduce unnecessary\nprocessing time associated with rendering a mesh (Le., transformation, lighting, and\nrasterization). The occlusion provides a culling method that will work on arbitrary\nand dynamic geometry data. This means the mesh data doesn't have to contain any\ninformation about the potentially visible data set. Occlusion culling also isn’t limited\nto indoor scenes, and can be used to mark ampwhere in the mesh data that could be\nblocked from your field of view (see Figure 4.8.1 for an example).\n\nUsing a 2-buffer makes it easier to display a scene correctly, but you still need to\ntransform, light, and draw che polygons, while resting cach pixel’s depth. This imple-\nmentation of occlusion culling simplifies the process of building the occlusion dara by\nusing simple pre-defined occlusion shapes, namely rectangles. ‘These occlusion rectan-\ngles could easily be added into the original geometry as wo co-planar triangles, and\neither named or colored in such a way that che exporter or the loader could separate\nthem our from the original mesh dara.\n\nFIGURE 4.8.1 A typical occlusion.",
      "content_length": 1289,
      "extraction_method": "OCR"
    },
    {
      "page_number": 414,
      "chapter": null,
      "content": "422 Section 4 Polygonal Techniques\n\nFrustum Culling\n\nTo help explain the process of occlusion culling, it’s worth describing a technique for\nfield of view culling. The field of view is the area in 3D) space visible from the current\npoint of view of the camera. This area is typically described using front and back clip\nplanes and the viewing angle (see Figure 4.9.2).\n\nThe culling process uses the bounding sphere (in world space) of each objects\nmesh, and wests if ir falls inside che field of view. To perform this test, you transform\nthe bounding sphere coneer point into view space (relacive to the camera) and check\nthe new 2 value against the near and far clip planes. You can chen cest the cenecr point\nagainst the left, righe, top, and bottom clip planes. The clip planes for the field of view\nean be pre-calculated ar the stare of the render loop. Because these clip planes are in\nview space, we can simplify the clipping test. The frome anc back clip planes will be\nperpendicular two the 2-axis, so a simple compare against the 2 value can quickly\ndecide if the mesh is in front or behind the camera. The coefficients 4 and 2 in the\nequation of the plane for che left and right planes are zero (because they are vertical),\nand the planes pass through the origin (0,0,0). This means co test a poine agains the\nleft or right plane, you can use the following equation:\n\nDistanceFromGlipPlane = (x \" Plane.a) + (z \" Plane.c);\n\n‘This also applies to the top and bettem clip planes, except the coefficients 4 and\nDare now zero, and this produces the following equation:\n\nDistancarronGliprlane = (y * Plane.b) + (z * Flane.c};\n\nBack, cp plane\n\nFronl cip plane\n\nFIGUAE 4.8.2 Field of view of viewing frusnim,",
      "content_length": 1711,
      "extraction_method": "OCR"
    },
    {
      "page_number": 415,
      "chapter": null,
      "content": "48 Object Occlusion Culling 433\npS el toate rable tt eS ee\n\nH the distance of the poine from the plane is greater than the bounding sphere\nradius, then the bounding sphere is outside the area. By testing ehe bounding sphere\nagainst all the clip planes, we can find out if the mesh lies within the field of view: this\nhelps us remove all meshes that are not visible. The order we test the center point\nagainst the clip planes can be changed to mach the geomerric data; for example, a\nlandscape expands more along the Xand Z axes chan the Faxis, so we test the left and\nnght clip planes before the top and bottom clip planes. The front and back planes are\ntested first because they require less computation and can typically remove a large\nproportion of the geomenry. See Listing 4.8.1 for sample code thar implements field\nof view culling.\n\n‘As you see, we can use the plane equation to describe the boundaries of the view\ning frustum, and by first transforming the bounding sphere center point into view\nspace we can simplify che point-to-plane test. So, using this same principal, we can\ndescribe the boundaries of an ocelusion.\n\nOcclusion Culling\n\nOcclusions described in this article are four-sided flar or planar polygons, but they can\neasily use more or less sides, providing che polygon is planar. We can pre-calculate che\nocclusions clip planes in the same way as for field of view culling, except this time we\nonly need a frent plane and four edge planes (sce Figure 4.8.3).\n\nThe ocelusion area differs from the viewing fruscum in that it deseribes.a hole. If\nany mesh lies inside this hole, it won't be rendered (see Figure 4.8.4).\n\nThe front plane of the occlusion won't always be perpendicular with the front clip\nplane, so we will have co use all four coefficients of the plane equation. We also can't\nsimplify the edge planes because they too can be at any angle, The front plane is cal-\n\n-\n\nFae\nFIGURE 4.8.3 A four-sided occlusion is described with four planes, front, left, tight, top and\nbottom,",
      "content_length": 2011,
      "extraction_method": "OCR"
    },
    {
      "page_number": 416,
      "chapter": null,
      "content": "Section 4 Polygonal Techniques\n\nViewing\naction\ni This obeet\nFront ip im wigiie\nelon\n\nFIGURE 4.8.4 Objects that are behind che occlusion are invisible,\n\nculated by using three poines from the oeclusion polygon after they have been trans-\nformed into view space. The edge planes are calculated by using the camera position\n(remember in view space this is 0.0.0) and cwo points along the edge of the occlusion\npolygon (see the SetupQeelusion() function in Listing 4.6.2). Qoclusions can be\nmade two-sided by testing which way the frone plane faces and reversing the order of\nthe points used to generate the planes.\n\nWe will need to test if an object's mesh falls inside the field of view before testing\nit against the occlusions, so we have already transformed the bounding sphere center\ninto view space. To help speed up the occlusion test, we can pre-calculace a minimum\n# value (the value closest to the front clip plane) in view space for each occlusion, and\nwe can test the transformed bounding sphere center against it to quickly test if the\nmesh isin front of the occlusion (see Figure 4.8.5.)\n\nIf the bounding sphere of the mesh overlaps the edge of an occlusion, we could\ntest alll che poincs of an axis-aligned bounding box for extra precision. [fan object is\nmuch bigger along one axis (c.g., very tall), then a bounding sphere can be very waste-\nful in describing its area, bux che bounding sphere can be tested againsc a plane much\nfaster than a bounding box. So we use the bounding sphere first to quickly reject any\nmeshes char are tocally outside or inside of an occlusion.\n\nWhen building up a list of occlusions that are visible, you can also test che ocelu-\nsions against each other co remove any occluded occlusion. If an occlusion covers the\nencire viewing frustum, we can move the back clip plane closer. Ocelusions can also",
      "content_length": 1842,
      "extraction_method": "OCR"
    },
    {
      "page_number": 417,
      "chapter": null,
      "content": "FIGURE 4.6.5 A minimum 2 value can be used to speed up the test,\n\nhave their own bounding sphere, which can be used to remove any occlusions char are\nnot visible in the viewing frusum.\n\nSummary\n\nAs you can see, occlusion culling of this nature is fairly easy co implement, but it\ndoesn't have to be limited to mesh culling—ie can also be used for culling sounds.\nOcclusions can also help to prevenc time-consuming effects like skinned animarion\nfrom being applied to objects thar aren't visible.\n\nOeclusions can be made more efficient by joining several together to form com-\nplex occlusion zones, bur this is beyond this discussion.\n\nThe example code is writen with DirectX in mind (ie., it’s left-handed), but it\ncan easily be changed to suit any coordinate system. The code is designed ro illustrare\nthe algorithm, and can easily be adapeed to suit any target platform or application.\n\nListing 4.8.1: Field of View Culling Code\n\ntypedef struct VECTOR\n{\n\nTloaat x;\nTlaat y;\nfleat z:",
      "content_length": 984,
      "extraction_method": "OCR"
    },
    {
      "page_number": 418,
      "chapter": null,
      "content": "Section 4 Polygonal Techniques\n\n}VECTOR:\ntypedef struct _ PLANE\n{\nTloat a;\nTloat 6B;\nfloat ¢;\nfloat d;\n}PLANE;\ntypedet struct MATHIX\n{\nfloat 11:\nfloat _ 12:\nfloat _ 13;\nfloat 14;\nfloat 21:\nfloat 22:\nfloat 25:\nfloat 24:\nfloat 31:\nfloat 32:\nfloat 3a:\nfloat 44:\nfloat 41;\nflaat 42;\nfloat _ 43;\nfloat — 44;\nMATRIX:\n\nPLANE g FOVLeftPlane;\nPLANE 9 FOVRightPlane;\nPLANE 9 FOVTopPlane;\nPLANE g FOVEot tom? lane;\nfloat g FOVFrantclip;\nflaat g FOVBackClip;\nMATAIN g ViewTransforn;\n\nvoid Normalize (VECTOR *pi')\nff\nfloat Length , Invlength;\n\nLangth = (float) sqrtt ( pY->x \" pW-=x J +\n{ p¥->y * pi->y J + ( pW-sz * pi-ez ) 5\n\ninviength = 1.0% | Length;\n\np¥=>x j= Invlength;\n\np¥asy j= Invlength;\n\np¥=>z /= Invlength;\n\nwold GrossProduct (VECTOR \"pio , VECTOR \"pv1 ,\nVECTOR “pGrassProduct}\n{",
      "content_length": 777,
      "extraction_method": "OCR"
    },
    {
      "page_number": 419,
      "chapter": null,
      "content": "4.8 Object Occlusion Culling 427\n\nPCPOSSProduet->x = pWO-sy \" p¥i->z - pV0->z * ply;\nPCMOESPPoduct->y = pWO-s2 \" pVi-=_ - pV0->e © pi-z:\nPEPGSSProduct->2= pvO->x \" pyi-sy - pVO->y * pid->x;\n\nvoid PlaneFronPoints(VECTOR *pPO , VECTOR “pri,\nVECTOR *pP2 , PLANE \"pP lane}\n\n{\nVECTOA VO,¥1,W2;\nVO.% = APIs - pPp->x;\nWOiy © pPis>y = pPO->y;\nWO.2= pPi->z- pPO->z:\nVi.¥ = pPS->x - pPp->x:\nVicy = pP2->y = pPO->y;\nVi.z= pP2->2- pPj->z:\nGroseProdiet( avo, a, BYE):\nHornalize( av2)5\npPlané-2a = V2.2\";\npPlane->b = V2.¥;\npPPlané-»t = V2 Lz;\npPlane->d = -( VW2.x * pPO->x + V2.y \" pPO->y + ve.z #\npPO-2z jj\n}\n\nf/This function calculates the planes for describing the view\ni/frustun using 3 points. Because we are in viaw space the\nifcameras position is at 0,0,0. We use the back clip position\nf/and the viewing angle to work out a point on the edge of\nifthe frustum. The view angle is the angle between the top\nHfand Botten of the view frustum in radians.\n\nWid SetupFOVGlipPlanes( float Angle , float Aspect ,\nfloat FrantGlip , float BackClip ]\n{\n\nWECTOR PO , Fl, Pas\n\nif) Galevlate left plane using 3 points\n\nPO.x = O.0f;\n\nPO.y = O.0f;\n\nPO.z = O.0f;\n\nPt.x = -BackOlip * ( (float)tan{ Angle * O.5T ) / Aspect };\nPl.y = -BackClip * ( (flost)tan( Angle * O.5f ) 1;\n\nPl.z = BackGlip;\n\nP2.% = Plex:\n\nP2.y = -Pi.yi\n\nP2.z = Pl.z;\n\nPlaneFronPoints{ SPO, &Pi , &P2 , &p_FOVLeTtPlane };\n\nff Galewlate right plane using 3 points\nPO.x = O.0T;\nPO.y = 0.0f:\nPO.2 = 0.0?!",
      "content_length": 1444,
      "extraction_method": "OCR"
    },
    {
      "page_number": 420,
      "chapter": null,
      "content": "iy\n\nil\n\nBOO.\n\niif\n\nif\n\nif\n\nif\n\nSection 4 Poblgonal Techniques\n\nPi.x = BackClip = ({ (floatj)tan( Angle * O.5T }) | Aspect):\nPi.y = Backlip = { (float)tan{ Angle * O.5T ) 1;\n\nFl.z = BackClip:\n\nP2.4 = Pi.x;\n\nP2.y = -Pi.y;\n\nP2.z = Piz:\n\nPlaneFromPoints( &PO, 4P1 , @P2 , 49 POVRightPlane }:\n\nCalculate top plane using 3 points\n\nPO.x = O.0F;\n\nPO.y = O.0F;\n\nPO.2 = 0.0F:\n\nPi.x = -BackOlip \" [ (float)tani Angla * O.5f j / Aspect):\nPi.y = BackOlip = ( (Tloat}tan( Angle * O.5f } 4;\nPi.Z = Back€lip;\n\nP2.z = -Fi.x;\n\nP2.y = Pl.y;\n\nP2.z = P1.z;\n\nPlaneFramPaints( SPO, Fi , aP2 , £9 FOVTopP lane ‘i\n\nCalculate bottom plane using 3 paints\n\nPO.x = O.0f:\nPO.y = O.0f;\nPO.z = O.0f;\n\nPi.x = BackClip * { (float}tan( Angle * O.5f } / Aspect};\nPisy = -BackGlip * { (floatjtan{ Angla * O.5f ) };\n\nPi.z = Backtlip;\n\nPo.\" = -Pi.z;\n\nP2.y = Pliy;\n\nP2.2 = Pliz;\n\nPlaneFramPoints( &P0, &P1 , aP2 , Sg FOVBottemPlane };\n\nWesnFOVCheck(VECTOR “paaphereros ,\nTloat BSphereRadius, VECTOA \"pViewPos)\n\nfloat Dist;\n\nTransform 2 inta view space\n\npviewPos->z = g ViewTransform, 13 * pagpherePos->x +\ng_ViowTranstorn. 23 * paspherePos->y +\ng_ViewTranstorn. 33 * paSpherePos->z +\ng_ViewTransforn. 43;\n\nBehind front clip plane?\nAf{ ( pWiewPos->z + BSphereRadius ) < 9 FOvFrontGlip }\nréturn FALSE:\n\nBeyand the back clip plane?\nif( { pWiewPos-*z - Bopherefadivs } * 9 FOVBack¢lip }\nreturn FALSE;\n\nTransform X into wlew space\nPViewPos->x = g ViewTransform._11 * poSpherePos->x ¢\ngViewlrangforn. 21 * paspheraPas->y +",
      "content_length": 1476,
      "extraction_method": "OCR"
    },
    {
      "page_number": 421,
      "chapter": null,
      "content": "4.2 Object Occlusion Culling\n\nQg _ViewTranstorn. 3) \" paopherePos->z +\ngq ViewTransfarn. 41;\n\nfi Test against Left clip plane\nDist = ( pliewPos->2 \" 9g FOVLeftPlane.a } +\n{ P¥iewPas->:z \" g FOWLeftPlane.c };\nif[ Dist > BSphereRadius }\nreturn FALSE:\n\nff Test against right clip plane\nDist = ( pWiewPos->~ * g FOVAignhtPlane.a ) +\n{ pViewPos->2 \" g FOWAignhtPlane.a };\nif{ Bist >= BSpheareRadius }\nreturn FALSE;\n\nff Transform ¥ into view space\nPViewFos->y = 9 ViewTransform. 12 \" p&SpherePos->x +\nB_ViewTranstorm, 22 * poSpherePos->y +\ng_ViewTranstorm, 32 * paSpherePos->z +\no_ViewTransform, 42;\n\nff Test against top clip plane\nDist = ( p¥iewPos->y * g FOVTopPlane.b ) +\n{ pPViewPos->7 * g FOWToapPlane.¢ };\nif Dist > Bapherefadius }\nreturn FALSE;\n\nfi Test against bottem plane\nDist = [ p¥iewPos->y * g_FOVeottemPlane.b | +\n{ pWiewPoe->2z * g FOWBottosPlane.c};\nif{ Dist > BSpherafadius }\nreturn FALSE;\n\ni} Mesh as inside the field of view\nreturn TAWE;\n\nListing 4.5.2: Occlusion Culling Code\n\ntypede? struct OCCLUSION\n{\nVECTOR PO;\nVECTOR Pi;\nVECTOR P2;\nVECTOR PS;\nfloat Minz\nPLANE FrantPlane;\nPLANE FirstPlane;\nPLAME S2condP lane;\nPLANE ThirdPlane;\nPLANE FourthPlane;\n}OOCLUSION;",
      "content_length": 1177,
      "extraction_method": "OCR"
    },
    {
      "page_number": 422,
      "chapter": null,
      "content": "| 2\n\nSection 4 Polygonal Techniques\n\nwold VectorMatrixMultiplygx4 (VECTOR “pNewvector ,\n\nf\n}\n\nWECTOR *pve@ator , MATAIN “pltatrix)\n\nvead SetupOcclusian (OCCLUSION *pOcclusion ,\n\n{\n\nif\n\nfi\n\niif\n\nif\n\nMATRIX *o¥ieeTransform}\nWECTOA PO , Pi , P2 , Po , Camera:\n\nTranéferm points form world space to view Spice\n\nVectoriatrixMultiplydad( &°0 , SpOcclusion->Po ,\npViewTranstorm) ;\n\nVectoriatrisMultiplyaz4( 41 . ApOcclusien->P4\nPViewTranstorn):\n\nVectorMatrimMultiplyaa4( &P2 , spocclusion->P2\npP¥ieeTranstforn} :\n\nVectorlatrixMultiplyge4{ £P3 , Spd0celusion->P2 ,\npViewTransforn} :\n\nr\n\nPoot lusion-=Ming = Po.zs\n\nif{ P1.2 = pOeclusiLon->Winr)\npoeclusion--Winzd = Pi.z;\n\nif( P2.2 = pOcolusion->Minz)\nPOcclusdon-*WinZ = P2,z;\n\nfi PS.z = pOcelusion->Minz)\nPOcclusion-sWin? = PS.z;\n\nThe camera position in view space is 0,0,0\nCamera. x =O. Ot:\nCamera.y=0.01:\nCanara. 2-60.00;\n\nGreate front plane fron first three points\nPlaneFromPoints(&P0 , &P1 , &Fz , &plcclusion-2FrontP Lane);\n\nTest the 0 co-effecient to find which way the\nocclusion Taces\nif(p0celusion->FrantPlane.d > 0.0f}\n\n{\nPlaneFromPoints( &Ganera , SFO , ai ,\nSpdeclusion-=FirstPlane} ;\nPlaneFromPoints{ SGamera , &P1 , ap? ,\nhp0ce lusion->SacondPlane) ;\nPlaneFromPoints( &tanera , &P2 , &Pa ,\nSpec liéioan->ThirdPlane) :\nPlaneFromPoints| ACamera , &F3 , &Po ,\niphoclusion->FourthPlane) ;\n}\nelse\n{\n\nPlaneFromPoints( &P2 , APi , 4Pd\nEplcclusion->FrontPlane) :\nPlaneFronPoints{ &Gamera , &P1 , aro ,",
      "content_length": 1447,
      "extraction_method": "OCR"
    },
    {
      "page_number": 423,
      "chapter": null,
      "content": "4.8 Object Occhusion Culling\n\n}\n\n&pOcclusion->FirstPlane) ;\nPlaneFronPoints( Gamera , SP? , &Pi ,\n&pOcelusion->SecondFlane) ;\nPlanaFronPoints( EGamera , SFG , &P2\n&p0celusion:>ThirdPlana) ;\nFlaneFromPoints( &Camera , SFO , GPS\nSpOcelusion->FourthP lang) ;\n\nBOOL TestifOceludad (OCCLUSION *pOeclusion ,\n\n{\n\nVECTOR \"p¥ilewFos , Tloat BSphereAadius)\nfloat wind:\n\nMing = pViewPos-=z - Bapherefadiue:\n\nif{ pOcelusion->Wing = Winz j\nreturn FALSE;\n\na7{ ¢ | p¥iewPos->x * pOcclusion-*FrontPlane.aj 4\n(pViewPos->y \" pOcclusion-=FrontPlane.b) 4\n(pViewPos-z \" pOcclusion-=FrontPlane.c) 4\npocclusion-=FrantPlane.d) > BSphereAedius |\nreturn FALSE:\n\naft { ( pviewPos->x * pOcelusion->FirstPlane.aj +\n(pViewPos-sy * pOtelueion->FirstPlane.b) +\n(pviewPos->z * pOeelusian->FirstPlane.c) +\npOcelusion-*FirstPlane.d) > BSphereRadius |\nreturn FALSE;\n\nitt [ ( pViewPas->x * pdcelusion->SecondFlane.a) +\n(pviewPos->y * pOeclusion->SecondPlane.b}) +\n(p¥viewPos-*2 * picelusion->SecondPlane.c} +\nptcclusion-*FirstPlane.d) = BSphereAadius |\nreturn FALSE;\n\nif, { ( p¥iewPos->x * pdcelusion->ThirdPlang.a) +\n(pviewPos-2y * pOeelusion->ThirdPlane.b) +\n(p¥iewPos-2z * pOcelusion->ThirdPlane.c} +\npOcclusion-*FirstPlanée.d) > BSpheraAadius }\nreturn FALSE:\n\nif{ [ { p¥iewPos->” * pdeclusion=>+FourthPlane.a) +\n(p¥iewPos->y * pOtcelusion->FourthPlane.b} +\n(p¥viewPos->2 \" pOcelusion-+FourthPlane.c} +\npOtelusian-=FirstPlanc.d) = BSphereAadiue |\nreturn FALSE;\n\nreturn TRUE;",
      "content_length": 1440,
      "extraction_method": "OCR"
    },
    {
      "page_number": 424,
      "chapter": null,
      "content": "4.9\n\nNever Let ‘Em See You Pop—\nIssues in Geometric Level of\nDetail Selection\n\nYossarian King\n\nObjects and characters are represented in computer graphics as geometric models.\nModels can be created ar different levels of detail (LODs), with more polygons and\nanger textures for the more detailed models, and fewer polygons and smaller textures\nfor the less detailed models. Why would you want to do this? To improve rendering\nperformance and visual quality, Drawing fewer polygons when objects are far away\nfrom the camera reduces the palygon count of the scene, and so speeds up rendering.\nHaving a more detailed model for use when an object is close to the camera improves\nvisual quality. If only a single model is used, then there is always a tradeoff between\nperformance and quality—multiple levels of detail help to achieve both.\n\n‘To implement LOD rendering, multiple models are created at different levels of\nderail, and the model to be rendered is chosen, each frame based on distance from he\ncamera. As a rough rule of thumb, each level of detail should have about twice che\nnumber of polygons as the preceding level, The models are created to reduce “pop:\nping” as much as possible—when the character or object switches from one level of\ndetail to another, the visible change in geometry (especially at the silhouette edge) and\ntexturing must be minimized. The artist's job is to create models thar are as similar as\npossible when rendered at the scale where the transition will occur. The programmer's\njob is to determine when to change LODs to achieve the desired performance and\nquality while minimising the number of LOD transitions. This article explains how.\n\nNote thar for objects or characters that stay a relatively constant distance from the\ncamera (such as the hero character in a thircl-person game), level of derail selection is\nnot necessary. Also note thar this article docs not address level of detail issues for ter-\nrain rendering.",
      "content_length": 1959,
      "extraction_method": "OCR"
    },
    {
      "page_number": 425,
      "chapter": null,
      "content": "4.9 Wever Let ‘Em See You Pop 433\n\nLOD Selection\n\nThe simplest way to select which level of detail to render is to apply a threshold to the\ndistance of the object from the camera. For example, use the high detail model when\nthe objece is closer than 500 units, the medium derail model for distances of\n300-1500 unis, and the low detail model when the object is further than 1500 units\nfrom the camera. Ac first glance this seems reasonable—when the object is closer, use\nmore detail; when it is farther away, use less derail—however, there are two problems\nwith this method.\n\nFirst, it doesn’t account for che field of view of the camera. If the object is a long\nway from the camera, but the field of view is very narrow (e-¢., 2 zoom lens) then the\nobject may appear large on screen, and a derailed model may be appropriate. Simi-\nlarly, an object may be relarively close co che camera, bur if the field of view is very\nwide (a macro lens), then the object may appear small on screen and a low detail\nmodel should be used. Figure 4.9.1 shows thar the same object at the same distance\nfrom the camera does not always appear the same size on screen. Rather than distance\nfrom the camera, we really want to use the projected size of the object on the screen as\na basis for choosing the detail level. Size on screen is obviously related to distance\nfrom the camera, but che field of view must also be accounted for.\n\nThe second problem with the simple distance threshold approach is that if the\nobject remains close co the threshold distance, then there may be rapid toggling back\n\n————\n—— ——— =e\n——\na\n——\noe\npels\na\na\neal bite\nHe oS\nSs &\na a\nSha ~\na\n=\nFee ee\nary\n\nFIGURE 4.9.1 Varying the field of view changes the projected size of objects om the screen.\nTep: A narrow field of view produces a larger image on screen. Barter: A wider field of view\nproduces a amaller image. In both cases, the size of the mee and the distance from the tree to\nthe camera are the same, demonstrating thar camera distance is not sufficient for choosing\nhewel of detail.",
      "content_length": 2047,
      "extraction_method": "OCR"
    },
    {
      "page_number": 426,
      "chapter": null,
      "content": "434 section4 Polygonal Techniques\n\nand forth benween levels of detail. This can happen when a character is running across\nthe field of view close to the threshold distance. Popping once from one level of derail\nto another might be noticeable, but rapid cycling back and forth berween levels will\nbe very distracting and undesirable.\n\nFortunately, both of these problems are easily solved. A better aluernative to cam-\nera distance is a “magnification factor,” which is the screen size of the object relative ro\nits physical size, As chis ratio increases (i.e., as the object grows larger on screen), we\nchoose higher levels af detail. Screen size accouncs for both camera distance and ficld\nof view, so the firer problem is climinated. The magnification factor is cacy to calcu-\nlate, as explained in the next section.\n\nThe problem of rapid popping back and fordh is solved by using hysteresis thresh-\nolding. Normal thresholding selects an ourput based on applying a single chreshold to\nan input valuc. Hysteresis thresholding uses an upper and a lower threshold, and\ndecides which to apply based on the previous output value. As long as the input value\nremains between the upper and lower threshold, che output value doesn't change, thus\nstabilizing the thresholded ourput and, in our case, maintaining stabiliry of LOD\nselection. Details are described later.\n\nMagnification Factor\n\nThe screen size of an object could be determined by transforming and projecting the\nhighest and lowest point on the object and subtracting the screen position of cach\ncoordinate to get the screen height. This method depends on the orientation of the\nobject, and requires processing two points. The magnification factor is simpler to\ncompute and is independent of orientation. It can be computed by transforming the\nobject position into view space and then calculating:\n\nff = erealel crete\nwhere ascefr is the sealing parameter used in the projection equation:\nsconce = (spew “seule ) fevtew + center\n\nSince view coordinates are just a rocation and translation of the world coord|-\nnates, zview is measured in world unies. xeele, which relates to the camera field of\nview, has pixel units; hence, the magnificarion factor Af measures pixels per world\nunit. As Mf increases, there are more pixels per world unitz—the object is relatively\nlarger on screen and therefore should use a higher level of detail, Nore chat JM is simi-\nlar to the level of detail used for interpolating mipmapped textures, bur in the case of\nmipmapping, pixels-per-texel are che measure of interest.\n\n‘7 accounts for both camera <listance (via sede) and field of view (via xwezle), and\nmakes a much better choice for determining level of detail selection chan simple cam-\nera distance. However, applying a simple threshold to Af will have the same popping\nproblems described previously, Hysteresis thresholding is the solution.",
      "content_length": 2885,
      "extraction_method": "OCR"
    },
    {
      "page_number": 427,
      "chapter": null,
      "content": "49 Never Let ‘Em See You Pop 435\n\nHysteresis Thresholding\n\nHysteresis thresholding is a fancy term for thresholding against a range of values,\nrather than a single value. A simple threshold Tis applied as:\n\nantput =f) ifiepur > = T\n{0 inpet < “h\n\nHysteresis thresholding uses an upper and a lower threshold and remembers the\nprevious ourput value, The output doesn't change if the input is berween the upper\nand lower thresholds:\n\n{2 ifiuput >= Tiga\nantpuit) = {OsF input < I.\nfontpra(t—l) otherwite\n\nTf the inpuc is increasing, then the output wall be 0 until the input reaches Ties if\nthe input is decreasing, then the output will remain | until the input falls below Ty,\nRegardless of whether the value is increasing or decreasing, the output doesn't change\nwhen the input is berween the upper and lower thresholds. Using chis approach for\nlevel of deeail selection means there is no single point at which che object will toggle\nback and forth between levels of detail—the hysteresis cheesholding ensures thar all\nwe get is a single pop, never a toggling behavior. A visual comparison of simple\nthresholding and hysteresis thresholding is shown in Figure 4,9_2_\n\nImplementation\n\nWith the magnification faecter and hysteresis thresholding we can create a level of\ndetail selection algorithm that accounts for camera field of view and avoids rapid pop-\nping problems. Assume we have models for three levels of detail: high, medium, and\nlow. The hysteresis thresholds for moving between high and medium detail are ff aoe\nand Titer Phe thresholds for moving berween medium and low detail are Txygyper atid\nF eiue- In pseudocode, the level of detail selection algorithm looks like this:\n\nint computelod:\n\nworldpes world position of the abject\n\nlodprey devel of detail chosen in previews frame\n\nviempos = transfore{ worldpos }\nM= xscale / viewpos.z\n\nif { W< T_mlower j\n\nlod = low\nelse if ([ M = T_muppar }\nlod = lodprev hysteresis range for sediuo/low\n\nglee if ( M = T hlowar }\nlod = medium\naloe if ( M = T_hupper }",
      "content_length": 2012,
      "extraction_method": "OCR"
    },
    {
      "page_number": 428,
      "chapter": null,
      "content": "436 section 4 Polygonal Techniques\n\ncotput Simple Threshold cat put Hysteresis Threshold\n\na\nIngs Tow Thgs 9 =F\n\nFIGURE 4.9.2 Cefi: An input value is thresholded agains: a single threshold 7, Right: An input value is\nthresholded against hysteresis thresholds T),..and 7j,,, with the appropriate threshold chosen based on\nthe preceding output valuc. As long as the input remains beoween T),,, and Tyas Ubere is no change in the\noutput.\n\nled = lodprev hysteresis range for high/sedion\nelse\n\nlod = high Wo>= T_hwpper\nreturn lad\n\n}\n\nNote thar if Mis berween Tj. and T).20 then chis will always recurn che pre-\nvious level of derail, even if it was low detail. IF you expect your object to be magnify.\ning this quickly, then the algorithm is easily adapted.\n\nThe equivalent algorithm using a simple distance threshold would just use onc\nthreshold berween each level of detail, and would look like this\n\nint computelotwithpopping:\nwarldpos\nq\n\nViewpos = transfora( worldpos }\n\nif { viewpos.z = Tm }\nlad = Low\n\nGlee if ( viewpos.z =< Th }\nlod = mediun\n\nelse vieKpos.7 = Toh\nTod = high\n\nreturn lod",
      "content_length": 1087,
      "extraction_method": "OCR"
    },
    {
      "page_number": 429,
      "chapter": null,
      "content": "4.9 Never Let ‘Em See You Pop 437\n\nee\n\nAs can be seen, solving the field of view dependence and popping problems does\nnot add significantly co the complexicy of the level of detail selection.\n\nOther Issues\n\nThreshold Selection\n\nFor any thresholding method, hysteresis or otherwise, you meed to choose your\nthresholds. For level of detail selection, choasing the thresholds is a tradeoff berween\nperformance and visual quality. [f the thresholds are set too low, then the higher levels\nof detail will be drawn more often, and you will have to render more polygons per\nframe, which will slow down the rendering. If the thresholds are too high, then che\nlower quality models will be drawn more olten, and popping between levels will be\nmore mociccable.\n\n‘To reduce popping, you can implement the selection algorithm, then move che\nobject toward and away from the camera, moving the thresholds until che popping is\nacceptable. Keep in mind tharin a game-play situation with a moving object, moving\ncamera, and distracted user, the popping will be less noticeable than in a testbed envi-\nronment. Achieving performance targets is a combined effort by che artist and pro-\ngrammer to reduce the polygon counts and adjust the thresholds to achieve a suitable\nbalanoe\n\nUser Alfention\n\nSo far, we have only considered rhe size of an object an screen to determine which\nfewel of detail to render. Another factor to consider is where the user is looking. In\ngeneral, we expect the user to be paying artention ro things that are close to the cam-\nera, but we may have additional knowledge abour the particular game situation to\nhelp us know where the user is probably looking. For example, in a sports game, a\nplayer character controlled by the user will probably be che focus of attention, as will\na player character wich the ball, or one involved in the current play. This “expected\nfocus of attention” can be used in the level of detail selection algorithm by biasing the\nmagnification factor when che user is likely to be watching an object or character. In\nthe sports game example, we can multiply the magnification factor by a scaling para-\nmeter (e.g., 1.1) when the character is under user control.\n\nBiasing the Magnification Factor\n\nThe idea of biasing the magnification factor can be used in other ways as well. If there\nis a game situation in which rendering quality is more importance than performance\n(such as a non-interactive rendered cue scene), the magnification faceor for all objects\ncan be biased higher in order to render objects at higher detail. Or the magnification\nfactor can be biased dynamically depending on frame rate—when frame rate drops,\nbias the magnification lower to select more lower polygon models and improve che\n\nframe rate,",
      "content_length": 2750,
      "extraction_method": "OCR"
    },
    {
      "page_number": 430,
      "chapter": null,
      "content": "Section4 Polygonal Techniques\n\nLimiting Number of Modals or Polygons\n\nIfa scene has multiple instances of the same object, chen there may be limits on che\nnumber of objects that can be rendered at each level of detail. Such constraints may be\nimposed in order to conserve memory in the object representation, or you may sim-\nply wish co limit the maximum number of high polygon models in order to improve\nperformance. Limits on che number of models at cach level of detail can easily be\nbuilt inte the selection algorithm—sort the objects by magnification factor, and then\ntake the M largest objects ar each level of detail, demoting any remaining object wo the\nnext lower level of detail. With a little moze work, the selection algorithm can be\nmedified to select objects sa the total polygon count for all objects falls below some\n\nGurger.\n\nProgressive Meshes\n\nA final issue worth mentioning is the use of progressive meshes, or other dynamic\nlevel of detail methods. Increasing processor performance and increasing polygon\ncounts in game models are starting to make these techniques feasible, With these\ntechniques, the polygon count of objects can be varied on the fly across a continuous\nrange. A suitable polygon count still needs to be chosen for each frame, and so the\nmagnification factor is still useful. If polygon counr varies continuously, then hystere-\nsis thresholding is mo longer needed. However, this may cause distracting popping\neffects as polygons are continuously dropped from or added ro the model, so it may\nstill be desirable to use hysteresis thresholds ro decide when to change the polygon\n\nOOUNnNT.",
      "content_length": 1626,
      "extraction_method": "OCR"
    },
    {
      "page_number": 431,
      "chapter": null,
      "content": "4.10\n\nOctree Construction\n\nDan Ginsburg\n\nCulling geometry for visibilicy deterrnination and collision detection is a problem\nthat must be tackled in the development of nearly every 3D engine. There are nurmer-\nous data structures and approaches to the problem. Most solutions pur constraints on\nthe geometry and often require the 3D artises to explicitly provide information such\nas portal locations to the engine. However, an octree is a simple dasa structure that\nean be used to spatially subdivide geomenry of any form.\n\nThis article deals with the specific steps required co take an input set of polygons\nand construct an octree that spatially partitions the geomeny. The octree is best suited\nto static terrain, bur can also be usec to store attachment lists for objects that move\ndynamically in a scene. An octree can be used as a complere solurion for visibility\nculling, collision detection culling, and object management.\n\nOctree Overview\n\nAt the highest level, an octree is simply a tree (an acyclic directed graph) with a maxi-\nmum. of cipht children ar every node. It turns out chat this is an ideal structure for rep-\nresenting a three-dimensional world enclosed by cubes. The rooe node of an octree\ncontains a cube har encloses all the geometry in the world. The children at each node\nare the eight cubes of equal size that subdivide the parene into octanes (see Figure\n4.10.1). Subdivision stops when some user-defined heuristic is met: qypically, either\nthe bounding cubes are of a certain size, or some minimum number of polygons are\ncontained within each mode,\n\nThe bouncing cubes at cach node are the key to using an octree for spatial subdi-\nvision. Fach node contains pointers to all of the polygons that lie within ics volume.\nGiven this information, one can begin to see the power of the data structure. For vis-\nibility determination, the axis-aligned bounding cube of the root node of the tree will\nbe tested againse the view frustum. If it is fully visible, all of its geometry will be ren-\ndered. If partially visible, traversal will continue down te the children, If it is com-\npletely ourside the view frustum, traversal can stop: it and all of its children are not\nvisible. Further examples of using octrees will be presented later. However, first in is\nnecessary tO examine the specific steps required ta construct an octres.\n\n430",
      "content_length": 2361,
      "extraction_method": "OCR"
    },
    {
      "page_number": 432,
      "chapter": null,
      "content": "440 Section4 Polygonal Techniques\n\nFIGURE 4.10.1 Subdivision of a cube into oceans.\n\nOctree Data\n\nPartitioning the geometry using an octree is a step that is cypically performed ar the\npre-processing stage. Some tool will take the input set of geometry and produce occree\ndata as output thar can be used at run-time by the application.\n\nAta minimum, each node in the octree must contain the following data:\n\n* Bounding Cube—This is the cube in space thar the node of the occree encloses.\n\n* Geometry List—Each node encloses a number of polygons; these must be stored\nin some way at each node.\n\n* Children—Each node can have up co eight children; pointers to cach of these\nmust be stored at every node,\n\n* Neighbors—Each nede can have up to six neighbors (one for each of the cube\nfaces), Tree craversal for collision detection requires that each node have pointers to\nall of its neighbors. The scighbors allow the collision algorithm to quickly “step”\nthrough the tree along a collision ray. This will be discussed in more desail later.\n\nBullding the Tree\n\nThe first step to building the octree is eo get a list of all che polygons in the world.\nOnce this list has been created, the root node of the octree can be constructed. The\nlargest absolute value Vfor any component X, Y, or Zin the vertex list is determined,",
      "content_length": 1316,
      "extraction_method": "OCR"
    },
    {
      "page_number": 433,
      "chapter": null,
      "content": "4.10 Octree Construction 444\n\nThis value is used no create the bounding cube for the world (it spans from [-V, -¥, -\nVj two [V, MV). By definition, the geometry list for che root node will conrain all the\npolygons in the world. Starting with this root node, the world can now be subdivided\nrecursively using am octtee. Here is preudecode for the building algorithm:\n\nBuildgctree (Mode Ny)\n{\n\nif (iumPolys (Nj) > POLY THRESHOLD)\nfor(int i = 0; i =< 8; ite)\n\nBuildhede(M-=Child[i], £, WM);\nBuilddetree(N-=Child[ ij};\ni\nI\n\nBuiledetree() creates all cight children for any node that contains more than the\nminimum threshold number of polygons. Creating all eight children simplifies the\nrun-time code by allowing it eo always assume chat if any children exist for a node, all\neight do. If this assumption was not made, there could be nodes without neighbors,\nwhich would make traversal for collision detecsion difficult.\n\nThe heart of Builddetree() is Builoxede(), which creates the node dara. This\nperforms we steps:\n\n1. Creates the bounding cube far the node,\n2. Determines which polygons lic within che node's cube.\n\nCreating the bounding cube for the node is trivial. The index é can be used to\nspecify which octane the node lies in. The box will then he fully determined by taking\nthe parent's box and pantitioning it appropriately. ‘The box will have half che width,\nheight, and depth of the parent's box, and will be centered at one of eight positions,\ndepending on i.\n\nDetermining which polygons lie within che bounding cube is slighrly more emt:\nplicated. Before addressing this, it is worth addressing how to store the polygen list at\neach node. Obviously, it would be hugely memory inefficient vo store copies of the\npolygon ar every node in the tee. A polygon can exist within several nodes: a parent\nwill always contain a superset of the polygons in its children. Additionally, polygons\nmight span across node boundaries. One solution to this problem would be to split\nthe polygons along the boundaries. However, this generates additional polygen daca,\nwhich could adversely affect run-time performance. Instead, the polygons will have a\n“frame count” value, and the run-time render code will be responsible for making sure\nthat each polygon is rendered only once per frame.\n\nOne possible approach to storing the geometry for each node is no store a list of\narea IDs. Then, elsewhere in the builder, for each area ID a list of indices into a shared\npolygon rable will be stored, This requires very little data at each node and ensures\nthat polygons will not be duplicated when they span multiple nodes.",
      "content_length": 2611,
      "extraction_method": "OCR"
    },
    {
      "page_number": 434,
      "chapter": null,
      "content": "442 Section 4 Polygonal Techniques\n\nPolygon Overlap\n\nGiven the solution for storing polygon lists at each node, the mext step is to create an\nalgorithm for determining whether a polygon lies within a cube. A fast method for\ntesting whether a triangle intersects a voxel is presented in [Moller?9] (Section 10,9).\nA voxel is a cube centered ar the origin, with cach edge having a length of one. It turns\nour thar this algorithm can casily be expanded for resting whether a triangle intersects\na world-aligned cube of any size, The crick is to determine whar cranslation and scale\nwill eransform the cube into a voxel. Then, chat transform is performed on each wi-\nangle, Each transformed triangle is chen tested for intersection with a voxel. Here is an\n\noutline of that alporichm:\nTrilmGuba(Tri T, Cube ¢)\n|\n\nVector Trané= ¢.fenter;\nVector Scale= 1.0 / G.5ize;\n\nfor (int i= O; 4 = 3: d++)\nTiWert[ij= (T.Ver¢[i] — Trans) | Scale;\n\nif (TrilnVoxel (Th)\nreturn true;\n\nreturn false;\n\nNeighbors\n\n— EE EES EE EEE EE ES a\nThe primary components of each octree node are now filled in: the bou nding cube,\nthe geometry list, and the children. This is all the information needed for visibility\nculling. However, in order to use the octree for collision detection, the neighbors co\neach of the six cube faces must be determined. A neighbor for a given cube face is\ndefined to be the node of equal size or grearet that touches it. A neighbor can never be\nsealler, and the algorithm will search for the best-fit neighbor (e.¢,, the smallest pas-\nsible that is no smaller than the node).\n\nThis step needs to be performed after the tree has been fully constructed once all\nof the nodes have been created. The algorithm works by wking each cube face of each\nnode and comparing it against the cube faces of the other modes in the tree ar the same\nlevel or higher. Several conditions must be met in onder for po cube feces po be con-\nsidered neighbors:\n\n* The normals of the faces must be in opposite directions.\n* All the vertices in the source face lic on or inside the destination face.\n* The size of the source face is Jess than or equal to the size of the destination face.\n\nThe cube that meets all three conditions and has the smallest size is considered lc\nbe the neighbor.",
      "content_length": 2261,
      "extraction_method": "OCR"
    },
    {
      "page_number": 435,
      "chapter": null,
      "content": "4.10 Octree Construction 443\n\nApplications\n\nAs discussed previously, one application of the constructed octree is for visibiliry\ndetermination of static geometry. However, the octtee can also be used for managing\nthe visibiliry of dynamic objects in the world. Each ectree node in the run-time code\ncould store a list of attachment objects, and cach objece in the world could store a list\nof nodes it is attached to, Then, to render che scene, the terrain polygons in each vis-\nible node are rendered, as well as all objects attached to the mode. When an object\nmoves, it detaches itself from all che nodes it is attached to, and re-artaches ro whar-\never new nodes it now lies within. The only trick is to again store a “frame counter\"\npet abject to make sure ic only gets rendered once per frame (since an object could\neasily span multiple nodes).\n\nThe octree can now also be used for culling in collision detection. Consider the\nsimple case of a ray collision test. Two points define a collision ray: a start and an end\npoinc. The collision test begins by finding che leaf node of the actree thar the scart\npoint lics within, The segment is broken into a subsegment at each abe face it inter-\nsects. The mew subsepment is tested againse all the geometry and objects within its\nnode, ‘The next subsegment starts ar the end poine of the previous subsepment, in che\nnode that neighbors the cube face thar it intersected. This traversal through neighbors\ncontinues, colliding with the geomerry and objects at every node until the original end\npoint is reached, Several other collision tests such as axcis-aligned box and sphere cests\nalso work very well when using che oceree.\n\nConclusion\n\nThe octree is a usctul data structure in building a simple geometry culling syscem.\nThis article ts meant as a simple introduction in how 19 build an octree. There are fur-\nther optimizations and enhancements that can be made to the seructure in order to\nimprove its run-time performance as well as usefulness (c.g., adding occlusion culling\nand depth sorting). Please see che references for pointers to further informacion on\noctres and their applications in 31D graphics.\n\nReferences\n\n[Foley87] Foley, van Dam, Feiner, and Hughes, “Computer (sraphics: Principles and\nPractice 2™ Edition”, 1987, p 350-555,\n\n[Hoff] Hoff, Kenny, “Gov ABBR View-Frestiam Opetap Ter\" wwe.cs.uncedu!-holf!\nreearch/vtculler!/boxvdie/boxyfe html\n\n[Moller?9] Moller and Haines, “Real-Time Rendering”, 1999, p. 206-211, 310-312,\n\n[Suter?9] Suter, Japp “Introduction to Octrees” April 13, 1999, wweeflipcode.com/\ntutorials!tut_ocorees shel",
      "content_length": 2603,
      "extraction_method": "OCR"
    },
    {
      "page_number": 436,
      "chapter": null,
      "content": "4.11\n\nLoose Octrees\n\nThatcher Ulrich\n\nThe octree is a classic anc effective data structure for partitioning 3D darasets into\nhierarchies of bounding volumes. For datasecs with a lot of objects, octrees can greatly\naccelerate frustum culling, ray casting, proximity queries, and just abour any other\nspatial operation.\n\nHowever, ordinary octrees do have a few disadvantages. In this arricle, I will focus\non one disadvantage in particular, which is char a small object, depending on tts loca-\ntion, may be stored in an octree node with a very large bounding volume. This hap-\npens when an object straddles the boundary plane berween owo Large nodes. This\ncreates “sticky” areas in the partitioning hierarchy, keeping small objects high in the\nwee hierarchy and reducing the effectiveness of the partitioning.\n\nThere are various methods of adjusting the basic octree data structure and algo-\nnithms to mitigate or avoid this problem, and cach method has its unique tradeoffs. In\nthis amticle, I present one such alternative, the “loose octree.” Its primary advantage\nover an ordinary octree is that it avoids stickiness in the object partitioning, resulting\nin more precise spacial database queries. For certain applications, such a5 murual col-\nlision detection between numerous moving objects, the efficiency gain can be sienifi-\ncant, There is an additional minor side berscfit, in that computing a given object's\ndesired node in the tree is a simple O/) operation. A similar trick can be done using\nordinary octrees, but it’s not as straightforward,\n\nIts main weakness is that it tends to use more partitioning nodes for a given\ndataset than an ordinary octree. Limiting the depth of the cree can mitigate this, bur\nirs something to be aware of\n\nQuadtrees\n\nThe octree ts a 31D data structure. The analogous 21D data structure is the quaderee,\nwhich shares the same basic properties. This remains true of loose quaderees; they are\njust a 2D version of loose octrees. Loose quadetrees have the same cradeofls as loose\noctrecs, with respect to their conventional counterparts, 50 they can be useful in appli-\ncations thar only require hierarchical partitioning in owo dimensions.",
      "content_length": 2178,
      "extraction_method": "OCR"
    },
    {
      "page_number": 437,
      "chapter": null,
      "content": "4.11 Loose Octrees 445\n\nSince irs much easier to visualize these data structures in 2D, in this artide I'm\ngoing to use 2D) diagrams based on quaderees, However, the octree principles are\nexactly the same, and the extension to 3D is straightforward.\n\nBounding Volumes\n\nIna conventional octree, the basic node bounding volume is a cube. All objects asso-\nciated with a node must be contained completely within the node's bounding cube.\nFach nede may also have up te eight child nodes, whose bounding cubes are formed\nby slicing the parent cube into eight equal sub-cubes. The quadtree version is illus-\ntrated in Figure 4.11.1.\n\nThe bounding volumes of the child nodes nest perfectly within the bounding vol-\nume of the parent node, filling the entire space with no overlap. The child nodes can\nbe further subdivided the same way. If you examine the sizes and spacing of the\nbounding velumes, you can see thar they follow a regular pattern, Consider the edge\nlength of the bounding cubes: ar the root of the tree, che cube edge length is equal to\nthe world dimensions. Ar each level deeper into the tree, the cube edge length is half\nthe size of the previous level's cube edge length. Thus, che formula for bounding cube\nedge length is:\n\nLfdepth) = Wi (2 * depeh)\n\nwhere Wis the world size, and depth is the number of levels by which a node is sepa-\nrated from the root. The root node has depth 0.\n\ni\ni\ni\ni\n1\nue\ni\ni\ni\nLy\n1\n1\ni\n\nFIGURE 4.11.1 A quadtree node, shown with bounding square in bold, subdivided along\ndotted lines. Fach quadrant becomes a child node, The child nodes can also be subdivided as\nchown in the upper-neht quadranc.",
      "content_length": 1636,
      "extraction_method": "OCR"
    },
    {
      "page_number": 438,
      "chapter": null,
      "content": "446 Section4 Polygonal Techniques\n\nThe spacing of the bounding cubes’ centers ara given depth follows the same pat-\ntern, Ar the reor there's only one mode, so node spacing doesn't really have any mean-\ning, but starting at depth 1, the centers of the reor's child nodes are spaced W#2 units\napart from their neighboring nodes. Each subsequent level curs the node spacing in\nhalf, The formula for node spacing is:\n\nStdepeh) = W's (2 * depah)\n\nSo, for a given depth, che cube edge size and the node spacing are identical. This\nmakes sense because at a given tree level, the bounding cubes are perfectly packed into\nthe world volume with no gaps and no overlap.\n\nPartitioning Objects\n\nGiven a set of objects in a virtual world, each object having some finite bounding vol-\nume, an octrec can be used to partition the objects within the world space, to acceler-\nate various spatial operations such a¢ frustum culling, ray casting, proximity tests, etc.\nDifferent criteria can be used for partitioning, but the classic octree partitioning\nscheme is to associate a given object with the mode in the octree whose bounding cube\nmost tightly contains the entire object volume. This node can easily be found by a\nfecursive craversal of the tree. Here is some pseudocode:\n\nstruct node {\nVectora CubeCenter;\nnede* Child[ey(z)(2);\nObjectlList Objects;\n\nint Classify(plane p, volume v])\n\nif [v 2s completely brhind p) {\nreturn O\n}) else if (v is completely in front of p) {\nPeturn 15\n} else {\n{i wo atraddlas p.\nreturn 2;\n\nvoid InsertObjectintotres(node* n, Object* o}\n\nint xe = Classity(plana(1,0,0,Cubeatenter. x),\n0. Bounding¥olume) ;\n\nint yo = Glassify(plane(0,1,0,Cubatenter.y),\no.Bounding¥olume) ;\n\nint z¢ = Glassity(plane(0,0,1,CubeaCenter.z),\no,.BoundingVolume) ;",
      "content_length": 1758,
      "extraction_method": "OCR"
    },
    {
      "page_number": 439,
      "chapter": null,
      "content": "4.11 Loose Octhrees 447\nI\n\nif (xe = 2 || yoe= 2 |] ze == 2) {\n{\n\njf Object straddles one or mora of the ehild\n‘if partition planes, and so won't fit in any\ni} child mode, so store it in this node.\nObjects. Insertia);:\n} else {\nfi Object Tits in one of the child nodes. Recurse to\n!! find the correct descendant.\nInsertobjectInteTres(Ghild[ze][yoj[xe], of;\n\n}\n\nThis is a nice, straightforward hierarchical partitioning scheme that handles\nwhatever you throw at it and generally comes up with a decent partitioning. However,\nithas one disturbing oddity. Nocice that if an object straddles any one of a mode's par-\ntitoning planes, then the object is stored in char node. This happens even if the object\nis tiny and the node is huge; see Figure 4.11.2 for an example, In practice, if you have\nlors of small objects, the ones located along the roor node partitioning planes can\n“clog up® the root mode by filling it with small, poorly partitioned objects, and reduc-\ning the efficiency of spatial operations (c.g., Figure 4.11.3).\n\nPll call this problem the “sticky planes” problem, the idea being thar partitioning\nplanes high in the cee hierarchy attract excess ebjects to their associated nodes, and\nare thus “sticky.” There are various ways to solve this problem. One method is to split\nobjects on partitioning planes and then classify the pieces individually. Another\nmethod is to allow an object to be referenced by more than one node, so an object can\n\nFIGURE 4.11.2 Even though the circle is very small compared to the root node (bold\nsquare), it can't be placed ina child node because it straddles onc of the (domed) parnicioning\nlimes,",
      "content_length": 1641,
      "extraction_method": "OCR"
    },
    {
      "page_number": 440,
      "chapter": null,
      "content": "443 Section 4 Polygonal Techniques\n\nFIGURE 4.11.3 All of the objects are small, but the shaded ones are suck to higher nodes in\nthe quadtree, duc to straddling the partitioning line.\n\nbe shared by child nodes on cither side of a sticky plane, rather than being stored in\nthe parent node. For static objects, those approaches are effective, but they'te not so\ngood for handling dynamic objects.\n\nMaking It Loose\n\nThe “loose” octree method takes a differenc tack: it solves che sticky planes problem\nby adjusting the node bounding volumes. Specifically, by “loosening” che bounding\ncubes, but leaving the node hierarchy and the node centers as is. The bounding vol-\nume of a node is still a cube, but where in the conventional ocwee the cube edpe may\nhave had length J, in che loose octree the cube edge would be £0, where & > J. Thus,\nthe formula for bounding cube edge length is modified to be:\n\nLidepth) = k* Wi (2 * depth)\n\nHowever, che node spacing remains the same as in the conventional ocoree. Whar\nthis means is that a node's bounding cube now overlaps with the bounding cubes of\nits neighbors. Figure 4.11.4 shows this overlap for a loose quadtree.\n\nThis loosening of dhe bounding cubes increases che minimum size of objects\namracted by a sticky plane. Where previously an object with any size ar all chac crossed\na sticky plane would be stored in char plane's node, with looser bounding cubes,\nsmaller objects will fir within one of the child nodes (Figure 4.11.5). How small must\nan object be to avoid being caughr by a sticky plane? It depends on the tree depth of\nthe plane's node, and on the value we choose for k For a node at a given depth, no\nobject with a bounding radius smaller than (k — J) *£/2 can be stuck oo chat node\ndue to straddling a partitioning plane, Instead, since the child nodes’ bounding vol-\numes have been enlarged, such objects can fic in one of the child nodes.",
      "content_length": 1899,
      "extraction_method": "OCR"
    },
    {
      "page_number": 441,
      "chapter": null,
      "content": "441 Loose Octress 445\n\nee eee eee\n\nee ee | aS\n\nFIGURE 4.71.4 Pour nodes. The conventional bounding squares are chown with dashed\nlines. The same four nodes in a loose quadtree have bounding squares shown in black. The\nsquares have been offset so that chey can be distinguished from cach other,\n\nSo, whar’s.a good value for 4? Without fully exploring all the tradeoffs in this arti-\ncle, | propose £-2 as a useful all-around value. A wee with £ much less than 2 starts to\nsuffer from the sticky planes problem, and a wee with & too much grearer than 2\nresults in excessively loose bounding volumes.\n\nFIGURE 4.115 The crcle won't fir in any of the conventional child node bounding squares,\nbur ix will fit in the loose bounding square of the lower-right child.",
      "content_length": 758,
      "extraction_method": "OCR"
    },
    {
      "page_number": 442,
      "chapter": null,
      "content": "Section4 Polygonal Techniques\n\nAssuming a loose octree with b=2, we can write an extremely simple object inser-\ntion procedure, The basic principle is that for a given object, che depth of the con-\ntaining node can be calculated solely based on the object's size, and chen the choice of\nthe particular node at thar depch in the tree is based solely on the object's center loca-\ntion. To get che formula for depth, note that a given lewel in che loose octree can\naccommodate any object whose radius is less than or equal to 1/4 of the bounding\ncube edge length, regardless of ins position. Any object with a radius <= L/8 of the\nbounding cube edge length should go in the next deeper level in the tree. For exam-\nple, in Figure 4.11.5, notice that no matter where the object is placed, ic will fit within\nene of the nodes” bounding squares.\n\nHere's the derivation of the level-selection formula:\n\nLidepeh) = 2° Wi (2 * depth)\n\nLet Armaxfdepth) = maximum object radius thar can be accommodated at depth.\nAmax(aepit) = 144 * Cfelepeh) = 112 * Ws (2% dene)\n\nLet depeh(R} = the first cree depth that can accommodate an object of radius R\n\nRe= Rimaexfelepeh(R))\n\nRea VWs depo Rl)\ndepil(R) >= log2{Ws R}— 1\ndepth(R) =~ floor(log2(W s R))\n\nOnce the depils is known, choosing the particular node ata piven depth is sim-\nple—just find the closest node to the object’s center. Assu ming the world is centered\nat the coordinate system origin, the formula to compute the node indices ix:\n\nfndex{x.pe! = floorifobpect. (x, pr) + WI2) / Sfalepth))\n\nNote that chis procedure is not quite ideal: ir does not actually find che tightest\npossible containing node for all cases (see Figure 4.11.6). To get the last bit of tight-\nness, first find che candidate node using the above formulas, and chen cheek the child\nnode nearest to the object to see if the object firs inside it.\n\nPerforming spatial operations on loose octrees is very similar wo conventional\nocturets. For example, this is the pseudocode for rendering with frustum eulling:\n\nenum Visibility { MOTWISIBLE, PARTLY_VISIALE, FULLY_VISIBLE };\n\nvoid Kode: [Render (Frustum f, Visibility wi\n{\nif (v t= FULLY_VISIBLE) {\nv = ComputeVisibility(this,Boundinghox, Th:\nif (v == MOT_VISIBLE) return;\n}\n\nthis .bjectList.fender(#, ¥)z\n\nfor (children) {",
      "content_length": 2283,
      "extraction_method": "OCR"
    },
    {
      "page_number": 443,
      "chapter": null,
      "content": "os |\n\nLeone Octrees 451\n\nFIGURE 4.11.6 The simple placement formula would put the circle in the node bounded by\nUbe large black square, but duc vo its particular position, the circle has a bemer fir in the\nupperdctt child node, bounded by the small black square.\n\nchild Alender(?, vii\n\n}\n\nThe exact same algorithm works with conventional octrees; the only difference is\nthar this .Boundingaox would be smaller.\n\nComparison\n\nTo help in comparing loose octrees with regular octrees, | wrote a test program based\non loose quadtrees and ordinary quadtrees, The program posiss a 21) square virtual\nworld, 1000 units on a side. Some number of circular objects are generated to popu-\nlate the world. Each abject has a position and a bounding radius, which are chosen\nrandomly to fit within the world boundaries. Then a cerrain number of 7D frusta\n(Le, wedges) are generared, with a fixed field-of-view angle, and a random position\nand direction. The objects are first partitioned using a conventional quaderee, and\nthen for each frustum, the daraset is queried for visible objects. Stacistics are gathered\non the number of objects char are potentially within che frustum, and che number of\nobjects that are actually within che frustum. Then, the objects are re-classified using a\nloose quadtree, and che same frustum tests are run and che same staristies are col-\n\nlected.\n\nResults of some sample runs are summarized in Table 4.11.1.",
      "content_length": 1426,
      "extraction_method": "OCR"
    },
    {
      "page_number": 444,
      "chapter": null,
      "content": "452 Section 4 Polgenal Techniques\n\nTable 4.11.1 Results of Same Sample Runs\n\nTest Parameters ee OS USES Se Lease Quadtres\n\nfree max depth o 5 Objects Objects Objects Objects\n\n100 frusta possibly acheally Nodes possibly achuoally Hodes\nFOY = 45\" visible visible checked visible wisibbe\n\nchecked\n\n$00 objeccs\n\nobj min radius=30\n\nobj max radius=30 1ees9 ESS 276 442 6533 fied\nLOM) objects\n\nobj min radiue=15\n\nobj max radiuz=15 31133 15173 7265 22457 15173 BBS\n20h) objects\n\noby min racliges=5\n\nobj max radius] (M0 SoS) 29955 9102 4520) 29935 bs\nee a\n\nNore char the frustum queries on the loose quaderee generally renurn fewer “pos-\nsibly visible” objeers than the same queries on the ordinary quadtree. On che other\nhand, the loose quadtree queries usually have to check more modes. So, for frustum\nculling, the differences between che ovo are noticeable, bur nor terribly dramatic.\n\nThings get more interesting when looking at inter-object queries, such as colli-\nsion detection. In my test program, I added a test in which each object is checked for\ncontact with all the other objects in the dataset, and collected statistics om the checks.\nThe results for che same datasets used previously are listed in Table 4.11.2.\n\nTable 4.11.2 Test Results\n\nOO EEE\nOrdinary Quadtres Loose Quactres\n\nTest Parameters Inter-object Object-te- Object-te- Inter-pbject Objeci-tlo- Object-to-\n\ntetmaxdepth=5 contacts objecttests Node tests contacts objacttests Mode tests\n\na a ee\n\n500 objects\n\nobj min radiue=30\n\nobj max ridius=30 3034 33469 ra51 3034 91235 24859\n\n1000 objects\n\nobj min radius=15\n\nobj max radius=15 2730 115989 LB00 2730 24609 45658\n\n2000 objects\n\nobj min radius=5\n\nobj max radiue=100 FOR4 Sai F S8107 7od4 av276 BOR2\n—_—ererererov—X—X",
      "content_length": 1733,
      "extraction_method": "OCR"
    },
    {
      "page_number": 445,
      "chapter": null,
      "content": "4.11 Loose Octress $55\n\nAs you can see, for these datasets, the loose quadtree needs two do far fewer object\nto-object tests for the same query. The loose quadtree docs require many more object-\nto-nede tests, bur in aggregate, the loose quaderee is significantly more efficient for\nthis type of query.\n\nConclusion\n\nThe octree is an extremely powerful tool, However, in certain cIPCUMstances, YOU may\nwant to modify the classic octree approach to beteer fit your problem. The loose\noctet is one such variation, which avoids the sticky planes problem of rhe classic\noctree. In situations where you have a large number of interacting, dynamic objects\n(such asa particle system with ineez-particle collisions), the loose octree is a particu\nlarly good cheice over the ordinary octree. The loose octree also performs well for\ngeneral spatial partitioning casks such as fruscum culling.",
      "content_length": 881,
      "extraction_method": "OCR"
    },
    {
      "page_number": 446,
      "chapter": null,
      "content": "4.12\n\nView-Independent Progressive\nMeshing\n\nJan Svarovsky\n\nA progressive mesh (PM) is a criangle-based mesh that is able to vary its level of detail\nin real-time, at the resolucion of gaining or losing a couple of triangles at a time, while\npreserving its original shape as much as possible. Ir can be drawn at any detail level\nbetween che conventional mesh from which ic was created and a lowest detail “base\nmesh’ as defined by the detail reduction heuristic, which may be as small as no poly-\ngons ar all.\n\nTypically, chese meshes are rendered at lower detail in the distance, so that more\nsystem resources are available to draw higher-resolution meshes in the foreground.\nThe global detail level of the graphics engine can also be based on the power of the\nCOMputer it is hunning on,\n\nFirst, 1 will introduce progressive meshing, working through some of the arpu-\nments for and against different variations on the theme. Based on this discussion, I\nwill describe an algorithm to convert conventional mesh data into progressive meshes,\nand some efficient and simple code to render these.\n\nFIGURE 4.92.1. A progressive mesh varying in detail,\n\n45.)",
      "content_length": 1150,
      "extraction_method": "OCR"
    },
    {
      "page_number": 447,
      "chapter": null,
      "content": "4.12 View-Independent Progressive Meshing 455\n\nProgressive Mesh Overview\n\nThe basic principle can be simply described as taking a mesh, repeatedly deciding\nwhich is its least significant edge, and removing this edge by making the ewo vertex\npositions ac its ends equal. This edge collapse operation typically makes rwo triangles\nsharing the edge redundant. Detail is pur back into the mesh by reversing these cal-\n\nMuch work has done by people and documented in che public domain, particu-\nlarly [Hoppe96, Hoppe97, Hoppe98). Figure 4.12.2 summarizes the unit-reversible\noperation and the common terminolopy.\n\nEdge collapse (eco)\nSE\n\nVertex split (vomit)\n\nFIGURE 4.12.2 A single step of mesh refinement (vertex split) or reduction (edge collapse).\n\nVariations on the Theme\n\nGiven this basic premise, there are various decisions thar can be made abour the finer\nimplementation details. I will briefly towch on them here; see [Svaravsky99] for a\nmore leisurely discussion.\n\nWhen Vertices Collapse, Where Do They\nCollapse Ta?\n\nWhen two vertices collapse into one, there isa choice for where to put the vernex. It\ncan be calculated to lie on the imaginary smooth surface that the polygon mesh is try-\ning to represent. Alternatively, you can put the poine just halfway in between the ovo\nit replaces, which you would think was cheaper, perhaps because you wouldn't have co\nstore a pre-calculated new poinc. Last, you can just choose te preserve one or the other\nof the original vertices that are being collapsed (Figure 4.12.3).\n\nThe midpoint system has the disadvantage thar convex objects become smaller as\nthey lose derail. The clever preealculated point system takes up twice as much memory,\nor takes up extra CPU time calculating the new point online. Preserving one point or\nthe other is the simplest, takes the least memory, and objects do nor lose apparent vol-",
      "content_length": 1864,
      "extraction_method": "OCR"
    },
    {
      "page_number": 448,
      "chapter": null,
      "content": "Section4 Polygonal Techniques\n\nVOrAK\n\nFIGURE 4.12.3 Choices for position of vertices produced by edge collapses. a: Higher detail\nmesh. é: New point on hypocherical surface. ¢- Midpoint- mesh changes volume. a: Pick one\nof the points—simple.\n\nume as drastically. It is often a good representation of the original shape, particularly\nwhen, for example, collapsing the corner of a cube-like object and a vertex somewhere\nalong one of the faces of the cube shape. Though it lacks the fHlexibilicy of calculating a\nnew point, its strong advantage is thar it docs not require real-time changes 00 the ver-\ntex dara or the creation of new vertices. This is the system | will use here.\n\nView-Independent vs. View-Dependent Rendering\n\nEach sequence of vertex splits, starting with a vertex im the base mesh, can be visual-\nized as a binary tree, each vertex splitting into two new ones (though, of course, in\nthis system I just add one new vertex to an original onc). The splits can either be left\nin their tree form or can be given some fixed onder (Figure 4.124).\n\nView-independent meshes use one fixed onder for the edge collapses, which can\ntherefore be calculated offline, and this tree representation can be thrown away. IF you\nkeep the tree form in some way, you can vary which nodes you expand. This effec-\ndependent PM can be used to give more derail on parts of the mesh that are closer to\nthe viewer, or on silhouetee edges.\n\nView-dependent PM (VDPM) is able to use triangle counts more effectively,\nbecause it has more fexibiliry in the choice of edge collapse order. In my opinion,\nhowever, this is mever justified in modern systems because of the large gap in efh-",
      "content_length": 1670,
      "extraction_method": "OCR"
    },
    {
      "page_number": 449,
      "chapter": null,
      "content": "4.12 View-Independent Progressive Meshing 457\n\nFIGURE 4.12.4 A forest of vertex split trees. The dashed line represents the vertices that will\nbe wed when rendering a mesh at deaail level 5.\n\nciency between the nwo types of renderers. A VDPM renderer uses fewer triangles for\na more visually pleasing scene, bur this thriftiness is drowned our by dhe increased\nprocessor time that must be put into making more level of detail choices, and the data\nhandling involved.\n\nA view-independent PM's (VIPM) triangles and vertices in the meth can be\nordered such that the ones char disappear first are further coward the end of the list,\namd therefore are not traversed or “in the way” when che lower levels of detail are\nbeing used. This can also lead to interesting progressive file formats where the more\nyou read, the higher detail mesh you get [Hoppe8].\n\nBecause there is only one collapse order, there is only one level of detail for the\nwhole mesh, H-you are close to one part of the mesh, and therefore want that part co\nbe rendered at high detail, all che rest will have to be rendered ar high detail, too. In\npractical game situations, however, a Large object can be subdivided into independent\n(bur possibly mutually intersecting) parts that can be rendered view-independently.\nNow that you have che pieces separate, you can assign some game code to them, so\nthey become a bit more interactive, such as windows, antennac, radar dishes on a\nSpace station or individual huts, trees, and so on in a landscape.",
      "content_length": 1508,
      "extraction_method": "OCR"
    },
    {
      "page_number": 450,
      "chapter": null,
      "content": "458 Section4 Polygonal Techniques\n\nLarge sections of continuous mesh like rolling hills can be built using a custom\nrenderer thar uses fewer polygons in che distance in another way, such as the\n“ROAM? algorithm [Duechaineau97], Discussion of these other view-dependent sys-\ntems that work on specific mesh topographies is our of scope of this article, which\nconcerns itself with the progressive meshing of general criangle meshes.\n\nEdge Choice Functions\n\nI believe that once you have an edge choice system that gives fairly acceprable results,\nthere is little to be gained in trying complex evaluation functions. I leave implemen-\ntation of some of the many methods discussed in the literature as an exercise wo che\ninterested reader. 1 have included some references to different works, particularly\n[Lind=tram9] for an overview, The best thing is to build an editor chat allows artist\nintervention in your automared generation of the collapse sequence. In my experi-\nence, after having spent days building the mecsh, artists are quite willing two spend\nsome time tweaking how it looks at lower levels of detail, particularly at the very low\ndetail levels where there are only a few polygons to adjust. It is at these low levels thar\nautomated systems have the most wrouble anyway,\n\nHere I have described a very simple function that is implemented in the example\ncode on the CD. Itis based roughly on the amount of movement of the surrounding\n\nDifficult Edges\n\nlt simplifies the algorithm to ban some special ease edges. These cases stem from tri-\nangles sharing the same point in 31D space, but not sharing some other vertex data,\nsuch as vertex normals, texture type, or texture coordinates. It is an extra complication\nto have triangles pointing to shure texture coordinates and pointing to shared vertex\npositions. To avoid this, and co be friendlier toward current graphics hardware, our\nvertices contain all texture coordinates, normal and position information. This way;\nthe meth will contain multiple vertices in the same Position bur with different mater-\ntal information.\n\nIfan edge being removed contains these duplicate vertices, and therefore the tri-\nangles along the edge do not share vertices, it is handled as ewe edee collapses thar\nhappen simultaneously. The problem arises when a nearby rriangle only refers to one\nof the ends of a collapsed edge, and this is the one thar is ro disappear (Figure 4.12.5).\n\nAn extra vertex could be created for this material, which would remain redundant\nuntil needed for lower levels of detail. This inefficiency is only slight because these\nvertices are created very infrequently, You can avoid this case by just banning these\ncollapses. This will restrict the lowest polygon count that meshes will reduce to. Typ-\nically, when these edges are a significant percentage of the remaining edpes, the poly-\ngon counts will be so low that the renderer call overhead means further detail loss",
      "content_length": 2941,
      "extraction_method": "OCR"
    },
    {
      "page_number": 451,
      "chapter": null,
      "content": "4.12 View-Independent Progressive Meshing fs 455\n\n=\n\na\n\noe\n\n——$——\n—————\na\n\nFIGURE 4.12.5 ‘When an extra vertex must be generated. a: Original chape. 6: Trivial\ncollapse. Different, complicated collapse.\n\nwould noc really speed up rendering. The objects will also probably be so insignificant\n{as determined by the decision function that made them low detail anyway) thar you\ncould just noc draw them ar all! Ar che time of writing this article, most commercial\nPM systems disallow these types of enllapses.\n\nFor the sake of conciseness, the system is simplified further here. The program\ngiven contains no workarounds for multiple edges that share the same position. This\nway, we can remove all the code that checks for coincident edges, that bans certain\ncollapses, and thar makes some edge collapses happen simultaneously: This implics\nthar all meshes must be smooth and continuously tectured, bur, as can be seen in the\nexamples on the enclosed CD, careful construction of che meshes means many more\ngeneral shapes are still possible.\n\nImplementation\n\nThe Renderer\n\nFor the majority of frames, a mesh will nor change in derail, so it is essential thar the\ndata structure being used to render from is as efficient as possible for the graphics sys-\ntem. Here we can arrange the data much like we would for a standard mesh renderer:\n\nstruct FMMesh\nint NumWaterials;\nStruct Pililaterial *Materials:\n1;\nThe mesh is made of an array of matezials-:\nstruct PMMaterial\nf\nPuTexturé *Texture;\n\nstruct PiVertex *Vertices;\nint “Indices;",
      "content_length": 1526,
      "extraction_method": "OCR"
    },
    {
      "page_number": 452,
      "chapter": null,
      "content": "Section4 Poblgonal Techniques\n\naint AumVaertices, NunIndi¢ws ;\n};\n\nFach material has a texture (or peshaps several textures in a multi-pass sysem,\nsuch as a hump map, a gloss map, and the actual base texture), and an array of ver-\ntices. Ir alsa owns some triangles, which simply index into che vertex array. Note thar\ninstead of having an array of PMTriangle’s, there is an array of chree times as many\nindices into the vertex array. This is done for efficiency in the Edge(7ollapse seructure\nlater, and is trivial to change back into an array of triangles if you wish to record more\ninformation with cach wiangle.\n\nstruct PaVertex\n\ni\nVECTORS Position, Normal;\nfloat U, ¥:\n\nhi\n\nEach vertex contains position, lighting, and texcure information. In this way, the\nmaterials are quite independent of each other, and the mech looks like one continuous\nobject because the positions of same of the vertices in different materials are the same.\n\nMorph the Verticeas or Pop?\n\nNo vertex morphing will be done in this implementation—vertices pop in and our of\nexistence. [his is cheaper and, in my experience with game teams, actually looks bet-\nier than morphing. This surprising result is because, for a given polygon count, the\nmesh is as close as i can be to its proper shape, rather than being blended somewhere\nbetween the current shape and the next lower detail level. The pops in practice are less\ning to edit vertex dara).\n\nProgressive Mesh Rendering Only Affects the\nTriangle Lists\n\nBecause an edge collapse preserves one our of the two vertices involved, this renderer\nmodifies the triangle lists only, with no effect on the vertex dara. This means thar the\nvertex arrays can be left alone (and in some modern hardware, pre-processed into\nsome more efficient format), and can also be shared berween multiple instances of the\nsame mesh. The triangle lists will be modified over time, and must be duplicated once\nfor each active instance of each mesh.\n\nThis also means thar vertex position modifiers, such as animation, can happen\nfairly independently of the progressive meshing, as long as you dont mind that the\ncollapse order wont change even as the vertices move about against each other. The\nanimation system only has to handle the far chat vertices can come and go, rather\nthan be used continucusly,",
      "content_length": 2304,
      "extraction_method": "OCR"
    },
    {
      "page_number": 453,
      "chapter": null,
      "content": "4.412 View-Independent Progressive Meshing et\n\nLower Detall Triangles and Vertices First\n\nA point of note for che renderer is thac the vertices and triangles have been ordered\noffline so thar it is always the triangles and the vertices at the end of a list thar are\nmade redundant by a collapse. The renderer will always be submitting triangle and\nvertex lists starting in the same place, just of varying lengths. Discussion of che dara\nstructure generarion will show how this is possible.\n\nThis does mean that unless you create strips and fans of criangles in some other\nway, you will be always presenting the graphics hardware with an indexed list of trian-\ngies. Interesting|y, adjacent triangles in che list often share vertices, which in many sys-\ntems is as good as having triangle strips and fans. This is because ar least pairs of\n\ntriangles on either side of an edge collapse will be next co each other in the triangle list.\n\nThe Reversible Edge Collapse List\n\nThe other renderer data structure describes the reversible sequence of edge exllapses\nthar changes the level of detail of che mesh. Fach edge collapse loses ome Vertex, one or\nmore triangles, and changes which vertices some of the remaining triangles use. There\nis one edge collapse list for the whole object, though different individual collapses\naifect different materials. Alternatively, there could be a collapse list per material, but\nthese would have to be tied together somehow so that the seams of the object don't\ncome apart.\n\nStruct PMEGpecollapse\n{\n\nfloat Value;\nPiWaterdial “Material;\nint HunIndicesToLosa, MunVertigesToLose,\nHunindicasTochange:\nint *Indew¢hanges:\nint CollapseTa:\nhs\n\nThe Gollapseto member says which vertex should replace all references to the\nvertex that is being lost off the end of the list. All these changes are stored in the\nIndexChanges array. This operation is simple to reverse for vertex splitting when the\nlevel of detail is being increased apain.\n\nWhen a collapse happens, same triangles disappear (NumIndicesToLose), onc or\ntere vertices may be made redundant (munverticesTaLoze—loss of some triangles\nmay leave vertices completely unused), and some indices in remaining triangles will be\nchanged (NumindicesTochange). OF course, the reverse happens during a vertex split.\n\nBecause the materials are so independent, sometimes nwo edge collapses must be\nperformed at once, to preserve the mesh seams as much as possible. This is when, as\ndiscussed earlier, the two edges actually are the same edge in space, so must collapse\ntogether even though they refer to diflerene vertices. The engine must continually\ncompare the value of the next edge collapse or verrex split chat could be performed",
      "content_length": 2703,
      "extraction_method": "OCR"
    },
    {
      "page_number": 454,
      "chapter": null,
      "content": "Section 4 Polygonal Techniques\n\nagainst the level of detail required from the mesh based on its position and other\nvariables.\n\nIn the simple system presented here, these edges are noc taken into account, bur\nthey can be done quite well by simply giving all edges in the same place the same pr-\nority, even though they are unconnected in the data structure.\n\nOffline Calculation\n\nHere | will assume that the mesh dara has heen loaded by some means into a friendly\nformat. For the sake of readability, the algorithm will be che simplest rather than che\nmost efficient, particularly since we are not so worried abour the expense of offline\ncalculations.\n\n‘The procedure can be summarized as repeatedly deciding which is the mex bir of\nderail to be lost, and removing it fem the mesh, while generating the edge collapse\ndata thar will be needed by che renderer later. When it is decided chat a vertex should\nbe removed, all triangles thar refer to it must be changed, and any triangles thar are\nmade degenerate swapped to the end of the list. Similarly, che vertex is moved to the\nend of the remaining vertex list.\n\nOf course, swapping triangles and vertices to the ends of their lists changes all ref\nerences to them, in other edge collapse structures as well as in the remaining mesh.\nThete may be other code (such as an animation system thar is about to use the same\nmesh) that needs to know abour vertex reordering.\n\nSuggested Offline Calculation Optimizations\n\nLooking at the code, it is obvious that extra temporary connectivity informarion\nwould be useful in the mesh. For example, the code often looks for “alll triangles thar\nreference this vertex” by bruce force. Also, the code repeatedly searches through all che\ntriangles for the next edge to collapse, Huge performance improvements are possible\nif you put the edge collapse candidares into a prioriry heap.\n\nEdge Selection Improvements\n\nThe most effective edge selection improvement is to make edges thar affect dis-\ncontinuities in the mesh less likely to collapse. This makes many more mesh shapes\npossible, and also allows objects to be subdivided further into subobjects. Each mesh\nsubdivision gives an cxtra degree of freedom in level of detail choice—see the previ-\nous discussion about making huts and trees separare from the landscape mesh under-\nneath them. See Figure 4.12.6.\n\nA Further Variation on Progressive Meshing\n\nInstead of being able to change level of detail at che resolution of one verrex at a rime,\nyou could just store several pre-calculated index lists at various resolurions. The\nchanges between these levels of detail of course will be more obvious. This system",
      "content_length": 2648,
      "extraction_method": "OCR"
    },
    {
      "page_number": 455,
      "chapter": null,
      "content": "4.12 View-Independent Progressive Mashing 463\n\nPush the veriex into the other object\n= likely cobapse, Even though this is a seam i\ncan be mede less likely to\n\nCOLE Spert\n\nFIGURE 4.12.6 Whar was one mesh becomes ove subtly intersecting ones, or just wo\ncoincident ones.\n\nbecomes more useful if the polygon counts or frame rates are so high that the popping\nis not a problem.\n\nAn advantage is char you can throw away the edge collapse list, which is actually\nquite a large data structure, certainly comparable to the extra index lists you are stor-\ning in this new method. You ales lose the collapsing/ splitting code, and you don't\nneed a separate index lise for cach active instance of cach object. The renderer\nbecomes much simpler—you are back to a normal mesh renderer, bur just with code\nto select which index list to use for each object at a given moment,\n\nSource Code\n\nCode for the progressive mesh generator and the renderer is contained on the CD. It\nis written in a general manner with little system dependency.\n\nReferences\n\n[Duchaincau97] Duchaineau, M. ct al, ROAMing Terrain: Realtime Opemally\nAdapting Meshes, 1997, available online: hitp://wwwlloLgov/graphics/ ROAM/\nroam. pdf.\n\n[(Garland97) Garland, M., and Heckbert, PS., Surface Simplification Using Quadric\nError Metrics, Siggraph 1997 Proceedings, pp. 209-216, August 1997.\n\n[Hoppe96) Hoppe, H., Progressive Meshes, Siggraph 1996 Proceedings, pp. 99-108,\nAmpuse 199,\n\n[Hoppe97] Hoppe, H.. View-dependent refinement of Progressive Meshes, Siggraph\n1997 Proceedings, pp. 99-108, August 1997.\n\n[Hoppe98)] Hoppe, AH. Efficient implementation of progressive meshes, Compurers\n& Graphics, Vol. 22(1), pp. 27-36, 1998.",
      "content_length": 1681,
      "extraction_method": "OCR"
    },
    {
      "page_number": 456,
      "chapter": null,
      "content": "Section 4 Polygenal Techniques\n\na\n\n[Lindstrom?9] Lindstrom, P, and Turk, G., Evaluarion of Memoryless Simplifica-\ntion, IEEE Transactions on Visualization and Computer Graphics, VoL5(2),\nApril-June 1999.\n\n[Renfard96] Ronfard, R., and Ressignac, J,, Full-Range Approximation of Triangu-\nlated Polyhedra. Eurographics 1996 Proceedings, in Computer Graphics Forum,\n15(3), August 1996, pp. 67—-76-\n\n[Svarovsky99] Svarovsky, J., Extreme Detail Graphics, Game Developer's Conference\n1999 Proceedings, alsa available online: heop-//www-svarovsky.teeserve.co.ule/\nExtremeD.",
      "content_length": 565,
      "extraction_method": "OCR"
    },
    {
      "page_number": 457,
      "chapter": null,
      "content": "4.13\n\nInterpolated 3D Keyframe\nAnimation\n\nHerbert Marselas\n\nKeyframing is a simple and effective way of animating a 3D object. However, since\neach keyframe only represents the extremes of the object's motion, this can make che\nabject appear to jump between positions.\n\nLinear Interpolation\n\nOne solution is to add more keyframes to make che transition between keyframes less\njamming. Another more economical method is to programmatically create in-between\nanimation trames using énrerpedstion.\n\nInterpolarion—also known as blending, morphing, or tweening—is the process\nof creating a new position berween owo existing positions In this case, we are inter-\npelating two known keyirame positions py and p, co create a new position pit).\n\nThe easiest interpolation solution is linear interpolation. In this case, a line is\ndrawn between the same position in we adjacent keyframes p, and p,, and then we\ncalculate where on this line the new position p(t) exists (Figure 4.13.1).\n\n(siven the desired time of the new animation position, the total number of\nkeyframes, and the coml time of che animasion, the point berween the nwo closest\nkeyframes can be calculared.\n\nThe function caleulateFranePercentage demonstrates this. Given the total\nnumber of keyframes in the animacion, the total time of the animation, and the\ndesired time, the keyframes on either side of the new position and the percentage\nbetween che owo frames are calculared and renurnedd.\n\nae. ae ce P(t) = Po + tps - Po)\n\nFAT)\n\nFIGURE 4.13.1 Example limear interpolation and formula.",
      "content_length": 1544,
      "extraction_method": "OCR"
    },
    {
      "page_number": 458,
      "chapter": null,
      "content": "Sectlon4 Polygonal Techniques\n\nvodd calculateFranePercentaga(long dwTotalAninfranes,\nfloat TTotalaninTine, float fDesiredTine,\nlong BdwrirstFrama, long EdwsecondFrane,\nfloat &fPercentage)\n\nfi determine which frases are involved\n\nfloat TTimaPerFram = ¢TotalAninTime |\n(float) deTotalAninframes;:\n\nduriretFrane = 0;\n\nat [MDesiredTime > fTotalAninTine)\nTDesiredTime -= fTotalAninT ine;\n\nTor (float f= 0.0f; f <= fDesiredTing; f += TTimaPerFrane)\ndwFiretFrane+4 -\n\n!i sat Tiret frane\n\nif (f = tDesiredTine|\ndaFirstFrane-;\n\nit (cwFiratFrame = 0}\nOwFirstPrane = dwTotalAninFrames - 1:\nalse\nLf (deFirstFrame >= dwlotalAnioFrames}\ndwFirsthrame = Of\n\nii 38 s8cond frame\noetecandFrane = dwFrirstFrame + 1;\n\n1T (dwSecondFrane >= dwiotealAninfranes)\ndesecomdFrane = O;\n\nff calc the percentaga\n\nPercentage = (fDesiredtime - ((flont) dwFiratFrane *\nfTinePerFrame}) * TTimePerFrane:\n} ff ealeulateFramePercentage\n\nFirst, calculateFranePercentage increments through each frame until ir finds\nthe keyframe that is ight before the desired time. This assumes thar the keyframes\neach have the same duration. IF che keyframes are nor set at uniform intervals, this\nfunction will have to be changed accordingly.\n\nWith the first keyframe found, ic is checked against the number of keyframes in\nthe animation. Then, the second keyframe is determined by incrementing che first\nkeyirame number by one, The second keyframe number is alse checked against the\ntotal number of keyframes in the animation. This code assumes that the animation is\ngoing to loop back to the start of the animation after displaying the last keyframe.\n\nft should be noted thar the calculateFramePercentage function, as with all of the",
      "content_length": 1682,
      "extraction_method": "OCR"
    },
    {
      "page_number": 459,
      "chapter": null,
      "content": "4.12 Interpolated 3D Keyframe Animation 467\n\nfunctions in this article, are presented more for readabiliry chan performance. One\neasy performance improvement is to pre-compure values such as fTisePerFrane.\n\ninterpolating Vertices and Normals\n\nWith the two keyframes and the percentage berween them identified, this data can\nnow be used to generate the new animation frame. The combineVvertices function\ndemonstrates using these values to combine the vertices from the selected keyframes.\n\nvoid coabineVertices(long dwvertexCount, float fPercentage,\nvectora *pFiretFramevertices,\nvectors “pSecondFramevertices,\nweetor’ “ptonbinedVertices)\n\nfor {long i = 0;\n1 = daVertexCaunt;\ni++, PFirstFramvertices«+,\npoecondFrameVertices++, pConbinadvertices++)\n\n“plonbinedvVerticee = *pFiretFranavVertices *\nfPercentage = (\"pSecondFranmeVertices =\nSpFirsthranevertices) 5\n\n}\n}\n\nThe percentage that was calculated im calculateFramePercentage is usecl te com-\nbine the vertices from the tern keyframes irutes a single now position between them.\n\nThis same method of combining the vertices of bath keyframes ean also be\napplied rt] combining the normals of the keyframes. LF the lacy frame normals were\nnormalized before interpolating, the combined value wont need to be normalized\nunless there ix a large differenee between the normal vectors.\n\nThere can also be a performance savings if separate lists of Gee normals (for back-\nface culling) and vertex normals (for lighting) are stored in each keyframe. The face\nnormals must always be interpolated, but interpolating the vertex normals can be\nskipped if you're trying to improve performance, This means that the vertex lighting\nwon't be correct, bur in many situations, the user won't notice the difference,\n\nHermite Spline Interpolation\n\nOne drawhack to linear interpolation is that some interpolated animation frames may\nhave a tendency to deform to a greater or Iesser extent. To solve this, a slightly more\ncomplicated interpolation system must be usec, This next method, Henmite spline\ninterpolation, takes into account the two keyframes on eather side of the desired posi-\nnon (Figure 4.13.2).\n\nSumilar to calculateFramsePercentapa, calculateFramePercentagaspline deter-\nmines which keyframes are on cither side of the desired animation ume. Additionally,",
      "content_length": 2298,
      "extraction_method": "OCR"
    },
    {
      "page_number": 460,
      "chapter": null,
      "content": "Sectlon4 Polygonal Techniques\n\npit} based on Lincar interpolation Plt) based om spline incerpolation\nFIGURE 4.13.2 Lincarly interpolated position vs. spline interpolared position,\nthe frames immediately before and after chese two keyframes are also calculated.\nThese additional keyframes are used to refine the calculation for the new position.\nwold calculateFranePercentageSpline(long GuTota LANinF rames ,\nfloat fTotalAniaTine, float fDesiredTime,\nlong SdwFirstFrame, long SdwSecondFrame,\nlang &twThirdFrama, long 4dwFourthFrane,\nfloat &fFercentage)\n\nif determing which frames are involved\n\nfloat fTimaPerFrane = #TotalAninTine |\n(float) dwiotalaninFranes:\n\nduSecondrrane = 0:\n\nif (fDesiredTima > fTotalAniaTine)\nfesiredTina -= fTotalAninTime;\n\nTor (float f = 0.0%; f <= fDesiredTime; # += TTinePerframp)\ndeSecondFrana++s\n\nff set Segond Treme\n\nif (f > fOesiredTine)\ndesecondFrame --;\n\nif (dwSecondFrana < 0)\ngeSecondFrane = dwTotalAninFranes - 1;\nelse\nif (dececondFrame >= dwiotalAninfranag}\ndwSecondFrane = oO:\nff set frame before second trane\ndwFirstFrame = dwSecondFrame - 1;\n\nif (dwFirstFrame =< 0)\nGeFirstFrame = dwlotalAninFrames - 1;\n\n// sot upper frase",
      "content_length": 1162,
      "extraction_method": "OCR"
    },
    {
      "page_number": 461,
      "chapter": null,
      "content": "4.13 interpolated 3D Keyframe Animation 465\ndethirdFrane ~ dwSecondFrame + 1;\n\nif (dwihirdFrage >= dwiotalanimFranes)\ntwihirdFrane = 0;\n\nif S8¢ franée after the third frame\ndeFourthFrané = dwihirdFrame + 1;\n\nif (dwFourthFrame >= owilotalAnimFranes)\newFourthFrame = 0;\n\nff get the upper percent\n\nfPercentage = (fDesiredtime - ((Tloat) dwSecondFrame *\nfTimePerFramg)) * fTimePerFrame:\n} ff calculateFramePercentaga\n\nThe positions from the four keyframes are used to calculate the new p(t) using the\nfollowing equation:\n\nple) = (20° — 3c? +1) p, +(e — 20? +d, +(e? — ym, + (=2e? + 37),\n\nThe first and fourth keyframes are used to calculate the tangents ms; between che\nfirst and second keyframes, and the third and fourth keyframes, respectively.\n\nSpline Interpolating Vertices\n\nThe combineverticesSpline function demonstrates calculating the tangents and then\nthe Hermite spline interpolated position pit).\n\nWoid canbineVerticesSoline(loang dwVertexGount, float fTPercentaga,\nweotora *pFirstFramevVerticas,\nweetord “*pSecondFrameVertices,\nwectord “pThirdFramevVertices,\nveetorad *pFourthFramevVertices,\nweetord *pGombinadVertices)\n\nflsat t = Percentage;\nfloat t2 = t * t;\nfloat +9 = t2 * t;\nyveetord ad, mi;\n\ncanst float alpha = 0.07;\n\nfor (Leng i = 0;\ni = dwvertexGount;\ni++, pFirstFranavertices++, pSacomiFranavertices++,",
      "content_length": 1321,
      "extraction_method": "OCR"
    },
    {
      "page_number": 462,
      "chapter": null,
      "content": "470 séction 4 Polygonal Techniques\nEL Ce\n\nPThirdFraneVertices++, pFourthFramaVertices++)\n\nnd = ({1 = alpha) # 2.0f) *\n((*poecondFramVertices - “pFirstFrameVertices) 4\n*pThirdFranavertices - *phecondFrameVertices);\n\nmi = ({1 - alpha) / 2.0T) =\n((*pThirdrranevertices - \"pSecondFraneVertices) +\n“prourthFraneVertices - *pThirdFraneVvertices);\n\n\"pGosbinedVertices = (((2 * t3) - (2 * tz) +4) *\n\"pSecomdFramVertices) +\n(ite - (2 * te) * t) * mo} +\n(itd - t2) * mij} +\n((l-2 “ tay + (3 \" tep) *\n\"pThLrdFramevartices }z\n\n}\n}\n\nAnother new addition to this calculation is the variable alpha, alpha controls the\ntension of the tangent to the spline that being calculated. While alpha can be changed\nto make the tension higher (positive values), or lower (negative values), leaving alpha\nat zero is good enough for most animations,\n\nIf you've determined thar a fixed value for alpha is sufficient for your animation,\nyou can pre-calculare the first part of the tangent equation m,, ((1 — alpha) / 2), and\nreplace it with a constant, 0.5 in this case.\n\nWhy Hermite Splines?\n\nAt first glinee, it may seem an odd choice of a Hermite spline over a better known\nspline such asa B-spline. While B-splines offer additional continuity, this comes ar\nthe cost of less control over the tendency of the interpolated curve.\n\nSummary\n\nee eee\nInterpolating keyframe animations is an easy and inexpensive way of improving ani-\nmation quality. Linear interpolation can be performed for very little cost pcr Vertex.\nHermite spline interpolation improves the quality of interpolated keyframes over lin-\near interpolation, but comes at a grearer per-vertex cost.\n\nReferences\n—— a erat eee on\n[Foley96) Foley, J., van Dam, A., Feiner, 5., and Hughes, J. Corpater Graphics: Prin-\neipler ana Practice 2“ Edition. New York: Addison-Wesley Publishing Company,\nIne, 196.",
      "content_length": 1835,
      "extraction_method": "OCR"
    },
    {
      "page_number": 463,
      "chapter": null,
      "content": "4.14\n\nA Fast and Simple Skinning\nTechnique\n\nTorgeir Hagland\n\nThis article describes a skinning method that is most beneficial for lower polygon\ncharaceers (les than 500 polygons), where the artists and animators need 100% con-\ntrol aver what their vertices are doing. The method can in short be described as a\ndever way of modifying and sorting an object's vertex list and re-mapping the face list\naccordingly.\n\nWhy Low-Polygon Count?\n\nWhen dealing with low-polygon count models, each vertex has a big visual impact on\nhow the model's silhoueme looks. As an example, let's look ar your elbow. The only\nbones influencing it would be the upper and lower arms. When flexing your biceps,\nthe lower arm influences how the vertices on the inside of your elbow move. Ie pushes\nthose vertices up from the direction of your lower arm and averages it with the orien-\ntation of your upper arm. The end result looks like you have a very thick dbow, This\ntechnique only takes into account ane bone per vertex.\n\nThe Mathoad\n\nThe artist creates a single skin model; for example, a space soldier. They then dupli-\ncates this skin, scales it down fractionally, and proceeds to cut this smaller skin up into\neven smaller bits (body pares), which are used as bones. As each bone is created, it is\ngiven the same name as the skin with a number appended to in, so it can easily be rec-\nognized as a bone by our program.\n\nOnce we have identified a skin and its bomes, we take che geometry of the bones\nand store the vertices in ome big list. Each entry in this lisr contains the vertex position\nand the bone this vertex is a part off\n\nNow foreach vertex in our skin, we find the vertex in che bene list chat is dlosest\nto it. We cransform the skin vertex by the inverse marrix of the bone that the vertex\nwas closest to. This will bring the san vertex inco the local coordinate system af che\n\nar",
      "content_length": 1873,
      "extraction_method": "OCR"
    },
    {
      "page_number": 464,
      "chapter": null,
      "content": "472 Section 4 Polygonal Techniques\n\nbene (in the draw loop, the vertex is cransformed back again, so even though the\nbane-skin is smaller, ir has no impact on the end result since the position is relasive).\nThe transformed vertex is stored in a temporary list thar we accumulate, where we\nalse store the original vertex list index and a poinrer to che bone that influences it.\nThe influencing bone has a counter char keeps track of che number of vertices it rrans-\nforms.\n\nWhen all the vertices of the skin have a bone influencing them, we process the\ntemporary list that we created. This list is then sorted based on the order of the bones.\nFor each bone, the number of vertices it influences is stored in the original skin's ver-\ntex list, and the faces must remap the vertices chat they reference since we just\nchanged all the vertex indices.\n\nListing 4.14.1 contains sample code that solves for bone influences anc remaps\nthe faces accordingly, Even though this sample code uses the 3D Studio Max file\ntoolkit, the technique can easily be used with any 3D modeling package. I only use it\nto keep the source size small, and to make sure the focus of this is on the influence\nsolving and draw loop, not the model conversion, etc.\n\nAfter executing the eode in Listing 4.14.1 we have:\n\n* Askin, with each vertex transformed into the local coordinate system of the bone\ninfluencing it. The vertex list is somed by the order of the bones.\n* Alistof bones, with a counter for how many vertices each bone should transform.\n\nThe draw loop for the skin can then be as simple as Listing 4.14.2.\n\nSummary\n\nThis method is fast and simple, and warks especially well for law-polygon characters,\nFor higher-polygon characters, the edges are smoother, and you will need several\nbeames influencing each vertex. You will also then most likely store two or three pont.\ners for each vertex to the bones char influence them. This means you can no longer\npre-store the inverse transformed vertices, and for each frame you need to apply the\ninverse transform and a percentage-based roration for each bone thar influences it\nThis causes more of a problem for the tool thar creates the influence data. Commer-\ncal packages that export bone information do exist, and you no longer have to worry\nabour how the influencing is done, just how to ereate your draw loop, If you do\ndecide to create the influence tool yourself, T highly recommend making a tool char\nallows the artist to “paint” influences directly onto the geometry. This way he does\nnot have to second guess a mathematical algorithm.\n\nListing 4.14.1\n\nvold Solvabonein?luences(databasedds \"db, Skin \"skinptr)\n{\n\nf* sllecate a big workbuffer */",
      "content_length": 2680,
      "extraction_method": "OCR"
    },
    {
      "page_number": 465,
      "chapter": null,
      "content": "4.14 A Fast and Simple Skinning Technique\n\nBonePoint \"bonepaintptr=\n(BonePoint\" jmalloc( 30000 sizeot (BanePoint) ):\nBanePoint \"curbonepoint=bonepointptr;\n\nlong Nrfoneverts=0;\n\n/* Make 211 the bones’ vertices into one big vertex\nList with information on what bone each point came from */\n\nMATRIM tmpmat:\n\nBane \"boneptr=skinptr->BonePtr;\n\nwhile (boneptr}\n\n{\nmesh3ds “bonenesh=HULLs\nGetWeshbyNamesde (db, boneptr->Nane,kbonenesh) ;\nassert (bonemesh):\n\nCopySdsWatrix( topmat , bonemesh->locmetrix) ;\nInverseWatrix( tapmat ,boneptr->Watrix) :\n\npointids *“boneneshpointe=bonemesh->vertexarray;\n\nNrBoneVertst+=bonemash-snverticas;\nassert (Nrfoneverte<30000} ;\n\nfor(int 1-0; i<bonemesh->nvertices;i++)\n\n{\nCUPbonepoint-sPaint. x\"boneneshpoints->x;\ncurbonapoint-=Point.ybaneneshpoints->y3\ncurbonapoint->Point. 2-baneneshpoints:>z3\ncurbonapolnt-*BonePtrebaneptr:\nbonemashpointe+=;\ncurbonepoint++;\n\n}\n\nRe liashOih] Sis (dbonamesh) +\nbonaptr=bonepte -staxther:\n}\n\n1\n\nmashsos \"skinmeash\npointads \"skinmeashpoints Skineesh->vertexarray:\nBanePoint *ekinpointptr (BonePoint\" jrallocy\nBKInneSsh-nwvertices* sizeof (BanePoint) } 5\n\nBonePoint *curskinpeint = skinpointptr;\n\nSkingtr->ieshPtr;\n\n/* Find the closest bone vertex t6 @#ach skin vertex */\nTor (int 170) i<ekinmesh->nvertices;i++)\n\n{\ncurskinpolnt->Point.x > skingeshpoints->x;\ncurskinpoint-*Point., > skinseshpoints->y;\ncurskinpolnt->Point.z = gkinseghpoints-=z;\n\ni* need to stare original vertex index, for\nface remapping */\n\ncurskinpoint->Index me d5\n\n47a",
      "content_length": 1497,
      "extraction_method": "OCR"
    },
    {
      "page_number": 466,
      "chapter": null,
      "content": "Te yin Bastion'd: Polygonal Techniaues\n\n/* no bone is influencing this bone yet */\ncurskinpoint->BonePer = HULL:\n\ncurbonepoint=bonepaintetr;\nfloat mindist=ie6:\n\nfor(int 7=0;]«NrBoneverts: j++)\n{\nfloat dist=\nCalcisthotSquared(skinzeshpoints,\nScurbonepoint->Point) j\nif{dist<mindist)\n{\nmindist-dist;\nCUrSsKinpoint ->BonePtr=\nCuUrbane point ->BonePir:\n}\ncurbonepointe+;\n}\ncurskinpoint++;\nSkinmeshpoints++:\n\n}\n\n/* Sort all the vertices of the skin by bone,\nand remap the faces accordingly */\nskinneshpoints = skintesh«>vertexarray:\nfacegds “skinfaces - skinmesh->tacearray;\nlong CuriIndex=0;\n\nboneptr=skinptr->BonePtr;\n\nwhile(boneptr]\n\nif\n\ncurskinpoint=skinpaintptr;\nfor (i=O;i<skinmesh-*nvertices:i++)\n\n{\nif (curskinpoint->BonePtr==boneptr)\n\nTransforna(boneptr-vatrix,\n(float*}Sturskinpoint->Point,\n(float*}skinneshpoints):\nAenapFaceList(skinmesh,\ncurskinpoint->Index, Curlndexs+} ;\nbonéptr=>8rVerts++:\nSkinmeshpoints++:\n}\ncurekinpoint++;\n}\nboneptr=baneptr-WextPir:\n}\n\niM\" Clean up after the romagping «/\nCleanUpFacelist (Sskinmesh} ;\n\nfraa(skinpointptr) ;\nfrea(bonapointptr) ;",
      "content_length": 1074,
      "extraction_method": "OCR"
    },
    {
      "page_number": 467,
      "chapter": null,
      "content": "4.14 A Fast and Simple Skinning Technique\n\nListing 4.14.2\n\nvoid glfrawthar(}\n\n{\n\nmeshdds *“qashptr\nBone \"boneptr\npointads *vartptr\nfagadds “faceptr\n\nSkinPtr->MeshPtr;\nSkinPtr->BonePtr;\nhesnptr->vertexarray;\nneshptr->facearray:\n\n/* For Each bone in the skin, transform % amount\n\nof vertices with the bone’s current animation matrixt/\n\npointdds *skinptr=SkinPtr->fointPtr;\nwhila(boneptir)\n{\n\nMATHIX mat;\n\nMencpy (knat , &boneptr-sAninPtr[CurFrane],\n\neizeot (MATRIE 13\n\nfor (int i=0;isbonmeptr-=HrVerts;i++}\n\nTranstorm(mat, (flaat*)vertpers-,\n(float*)skinptre+];\n\nDOnEPTr=boneper-+hextPtr :\n}\n\n\" Then Simply draw the objeot using the tacelist*/\nskinptre2kinPtr->Poaintetr;\nglbegin(GlL TALAWGLES) ;\nglcalarat(1,1, 1p;\nfor(int i=; i¢neshptr-=ntacesiite)\n{\npointdds \"vieSskainptri faceptr-=v1] >:\nPOLNESds \"vl=Sskinptr[ faceptr->v2]*\nPOLNTSds \"vi-hskinptr[| faceptr-=vd];\n\nglvertaxdat (vis>e visay vi->Zz)7\nplvertaxdt (vi->\" .ve->y,¥2-Fz)7\nglvertexat (va->0 ve-Sy,wi-z):\nFaceptr4+;\n\n}\nglEnd():\n\nReferences\n\n475\n\n[Lander98] Lander, Jel, Game Developer Magazine, May 1998: Rerl-time Skeletal\n\nDefornuition.,",
      "content_length": 1099,
      "extraction_method": "OCR"
    },
    {
      "page_number": 468,
      "chapter": null,
      "content": "4.15\n\n476\n\nFilling the Gaps—\nAdvanced Animation Using\nStitching and Skinning\n\nRyan Woodland\n\nAs hardware becomes faster and more feature-laden, game developers are searching for\nways to make characters look more compelling, Of che many caregories that can be\nimproved, character animauon is peshaps one of the most important.\n\nCurrently, most 3D games are starting to use some sort of skeletal representation\nfor their characters as their topology for animation. These systems attach geometry to\n“bones” in a character. The bones are then animated and, consequently, the attached\ngeometry inherits che motion creating adequate animation. Usually, however, che\ngeometry used co represent characters is rigid in narure, which is not the most useful\nrepresentation for modeling organic creatures that are definitely nor rigid in nature,\n\nBeciuse the geomenry is complerely rigid, any nwo pieces that are supposed to be\nconnected to each other (an upper arm and a forearm, for example) display blatant\ndiscontinuities at the joint at which they are connected. This obviously can become a\nproblem, since the characters we are trying to represent are more often than not made\nup of a continuous skin that does not show any cracks or separazions.\n\nIn this article, I will discuss the topics of stitching and shinming as ways to create\nmore realistic organic animation. Stitching is actually just a less computationally\nexpensive subser of skinning anc will therefore be discussed firer. Both of these rech-\nniques assume one continuwows mesh that is attached to a bone structure for a charac-\nter as opposed to many meshes attached to a single bone in traditional rigid-body\nanimation. This continuous mesh is deformed relative wo the character's bone scruc-\nture, yielding a character thar does not create visible (and often very annoying) BAaps at\njoints when animating.\n\nIn the following sections, I will be using the example of an arm to demonstrate\nvarious features of stitching and skinning. The basic mesh used is picture in Figure\n4.15.1.",
      "content_length": 2039,
      "extraction_method": "OCR"
    },
    {
      "page_number": 469,
      "chapter": null,
      "content": "4.15 Filling the Gaps a7T\n\nFIGURE 4.18.1 Chor basic arm mesh,\n\nStitching\n\nSa ee\nAs mentioned earlier, sucching operates on a continuows mesh attached no a bone\nstructure. In ngid-body animation, a polygon is transformed by one matrix represene-\ning the bone to which thar polygon is attached. With stitching, cach vertex in a poly-\ngon can be transformed by a different matrix representing the bone to which che\nindividual vertex is attached. This means thar we can create polygons thar “srirch”\nmultiple bones together simply by attaching different vertices in the polygon wo dif-\nferent bones. When the bones are manipulated, this polygen should fill the gap you\nwould see in ngid-body animation.\n\nOne of the major differences between stitching and rigid-body animation is che\ndata topology for representing a character. With rigid-body animation, a bone must\nsimply have a pointer to some geometry it is to animate. The matrix yielded by the\nenrresponding bone then transforms that geometry. For stitching, it is necessary for\neach vertex in the character's skin vo keep track of the hone to which iris artached.\n\nBIFUCT Vertex\n\n{\nTlost #, +:\nTlOSE Nu, ¥, Z;\nunsigned long color;\nunsigned lang boneindex;\nhi\n\nBefore animating a character that has been correesly bound to this data topology,\nwe need to deal with the problem that our vertices are not in the correct space co be\nproperly transformed. The problem is this: a marrix used to transform a bone for ani-\nmation assumes thar the bone starts with its pivoc point at the origin of the ceardinate\nspace of the character. This makes sense if we consider a hand bone in a normal",
      "content_length": 1634,
      "extraction_method": "OCR"
    },
    {
      "page_number": 470,
      "chapter": null,
      "content": "478\n\nSection 4 Polygonal Techniques\n\nhuman. This bone should start with its pivot point at the origin of its coordinare\nspace so that we can easily rorare the bone around thar point. The bone is animared\n(roraced) and then transformed to the end of the forearm bane. This process repeats\nfor che forearm bone—the hand and the forearm are then animated and moved out to\nthe end of the upper arm bone. This continues down through the hierarchy until che\nentire skeleton has been properly transformed.\n\n(Given the spatial relationship between the skin's vertices and the bones of the\ncharacter, it is necessary to transform the vertices of the skin into the local coordinate\nspace of the bones to which they are attached befare transforming them by the bone's\nanimation matrix. To do this, we need to keep a maurix in each bone thar tells us how\nto transform geometry back into the local space of the bone. This matrix should be\nthe inverse of the matrix used to transform the bone from its local space into the char-\nacter's mesh, given che orientation of the mesh without any animation being applied.\nSee Figure 4.15.2 for a depiction of the local spaces for each bone in our arm mesh.\n\nTherefore, the data structure of our bones should look like the following:\n\nstruct Bone\n{\n\nMtx orientation:\nMtx animation;\nMtx inverseQrientation;\n\nMts final;\n\nBone “child;\nHone “sibling;\n33\n\n(nce we have this data, we are ready to animare our character, To do chis. we\nmust simply step through the vertex data and transform each vertex by the orientation\nmatrix and then the animation matrix of che comesponding bane.\n\nFIGURE 4.15.2 A depiction of the bones in our arm.",
      "content_length": 1656,
      "extraction_method": "OCR"
    },
    {
      "page_number": 471,
      "chapter": null,
      "content": "4.15 Filling the Gaps\n\n476\n\nAll of these transformations can be done faster by processing che bone hierarchy\nand generating a final wansformation matrix for each bone concatenating a bone's\nINVErse Orlentation, concatenated orientation, and concatenated animation matrices\n\ntogether and then transforming geometry by the resulting mateo,\n\nwoid Buil@Matricas ( Bone *bone, Mtx forward, Mtx orientation )\n\n{\n\n}\n\nWt« localForward;\nWt local0rientation;\n\nff COncatanate the hierarchy's orientation matrices ao\nff that wa can generate the inverse\nconcatenatea(bone->orientation, orientation ,\n1lhcalirian tation) 5\n\nff take the inverse of the orientation matrix for this bone\ninverée{localorientation, bone->inversedrisntatian) |\n\nff COnCatanate this bone's orientation onto the Torward\nff matrix\n\nConcatenate(bone-2arientation, forward, LocalForward);\n\nif canéatenste this bone's animation ante the forward matrix\nconcatenate (bone->animation, lacalFoermrd, localForward);\n\ni# build the bone's final matrix\ncondatenate (bone->inversedrientation, lacalForward,\nbone ->final};\n\nif (bone->child)\nBuildMatrices(bané->child, localForwand,\nlocaldrientatian) ;\n\nif (bone-»sibling)\nBuildMatrices(bone->sibling, forward, orientation) ;\n\nUsing the preceding technique on the arm mesh, a bend of 45 degrees and 90\ndegrees to the foreartn bone produces the images in Figure 4.15.3.\nStitching is a very valid technique, since it casily takes advantage of any hardware\nthat provides a transform engine. Ik is mecessary to generate the final stitching matrix\non the CPU, but the hardware can easily use these matrices to transform any number\nof vertices we pass it.\nAsan optimization to this technique, I suggest breaking up the continuous skin\nLi] that the verbiccs exist in the lacal Space al the hone hn which they aic attached. This\n\nprevents us from having to do an extra matrix concatenation per bone per frame of\nanimation,",
      "content_length": 1910,
      "extraction_method": "OCR"
    },
    {
      "page_number": 472,
      "chapter": null,
      "content": "480 Section 4 Polygonal Techniques\n\nFIGURE 4.15.3 2: Stitched arm mesh bent wo 45 degrees. 4: Bent oo 90 deprees.\n\nSkinning\n\nWhile stitching is a valid technique, it has some problems, In cases of extreme joint\nrotation, geometry tends to shear massively and appear quite unnatural. Using the\ntechniques discussed! earlier, a forearm notation of 120 degrees displays quite a nasty\nshear effect at the elbow. This results because we only have one polygon co span the\nendre gap berween the upper arm and the forearm. The larger this gap becomes, the\nworse the solurion looks, as shown in Figure 4.15.4.\n\n‘To prevene this, we can implement a full system of skinning where a vertex is not\nlimited to being affected by a single bone; it can instead be influenced by multiple\nbones. This makes sense if we look ar the behavior of the human body. The skin on a\nperson's elbow is not affected by the orientation of just one bone. The movements of\nboth the upper and lower arm bones affect ic. Similarly, skin in the neck and shoulder\nis affected by the orientations of the arm, neck, and chest.\n\n‘To enable this, cach vertex in a skinned mesh must contain a list of bones that\naffect it. Each vertex must also carry a weight per bone thar tells us how heavily\naffected the vertex is by the bone. For this example, we will assume linear skinning,\nwhich means all of the weights of a vertex must add up to 1.0. Because of this, given\n» bones by which a vertex is affected, we need to store #—1 weights, since the remain-\ning weight should be 1.0 — (werghr, + weight; +... + weight,_,}.\n\nBEruct Vertox\nFloat s, t;\n\nFloat x, y¥, Zi\nunsigned long color:",
      "content_length": 1640,
      "extraction_method": "OCR"
    },
    {
      "page_number": 473,
      "chapter": null,
      "content": "4.15 Filling the Gaps 4a4\n\nFIGURE 4.15.4 Uply stitched arm mesh bent co 120 degrees,\n\nunsigned long bonelndext;\nunpagned long boneindexz;\n\nfloat weight:\n\nhi\n\nAs mentioned earlier, sticching is a subset of skinning, and therefore suffers from\nthe same local-space transform issucs as stitching. Therefore, we should use che same\nbone representation as shown previously.\n\nIn order to do full skinning, we need to transform each bone by each mato\naffecting it, then multiply the result by the corresponding weight, and, finally, accu-\nmutate the results. The equation for skinning looks like:\n\n(verter * metre? right) + (vertex * matrox! * weightl) +o. +\n(vertex “ matrocN © weight)\n\nwhere the sum of all weights 0.4 = 1.0.\nWhat we are effectively doing is a linear interpolation berween transformed ver-\ntices. The following is che code used to perform this operation on a given mesh.\n\nVectaraD TransfaraVertes ( Vertex “vert, Bone \"baneArray }\n4\n\nVeetorao tenp;\n\nVectoarad final:",
      "content_length": 978,
      "extraction_method": "OCR"
    },
    {
      "page_number": 474,
      "chapter": null,
      "content": "Section4 Polygonal Techniques\n\ntemp = kFornvec(vert--poaition,\nbone] vert->bonaIndex1]->Tinal)\n\nFinal.x = temp.x © vert->waignt:\nfinal,.y = temp.y © vert-=waight;\nfinal.z = temp.z * vert->weight:\n\ntenp = kFornvec(vert->position,\nbone[ vert->bone Index? ]->tinal}\nfinal, += teap.x * (7.0 - vert->weight):\nfinaly += temp. y * (7.07 - vert->weight};\nfinal,z += temp.z * (71.0F - vert->weight};\n\nraturn final;\n\n}\n\nUsing the technique outlined previously, we were able to generate the following\noutput for forearm rotations of 45 degrees, 90 degrees, and 120 degrees, respectively.\nNote that even in the extreme 120-degree example (see Figure 4.15.5), the continuity\nafthe elbow geometry is still maintained.\n\nAs you can see, a major problem with skinning is that it is computationally\nexpensive. Unfortunately, these compurarions ate not well supported by today’s hard-\nware transform engines. An alternative way of performing the linear interpolation eal-\nculations, which potentially takes advantage of some current hardware\nimplementations, is to generate a skinning matrix to be passed to hardware co per-\nform the final transform. To calculate the skinning matrix, simply interpolate the\nmatrices linearly based on che weight:\n\nfrearriel * weaghtO) + (negtrixt *weight]) +... + { marrdcN * weight¥)\n\nwhere the sum of all weights 0..N = 1.0.\n\nThis method is only useful if dhe same skinning matrix can be used for multiple\nvertices; in other words, different vertices are weighted identically between the same\nbones. The less this case is crue, the less the gain of this method will be.\n\nFIGURE 4.15.5 «: Slonned arm mesh bene vo 45 degrees. 6: Bent to 90 depress, = Bene ro\n130 depress.",
      "content_length": 1687,
      "extraction_method": "OCR"
    },
    {
      "page_number": 475,
      "chapter": null,
      "content": "4.15 Filling the Gaps 403\n\n==\n\nTr is importane co mete that the skinning technique outlined previously is not a\ncompletely mathematically correct technique. If nonmals are wansformed using this\ntechnique, the results are nor guaranteed to be normalized. If per-vertex lighting is\nrequired for a character using this technique, post-transform normals must be re-nor-\nmalized before lighting calculations.\n\nAdvanced Topics\n\nThe skinning example assumes all the weights influencing a vertex must add up to\n1.0. It is a possibility, however, to create some compelling special effects with weights\nthat do nor sum to 1.0. For instance, it is possible no place an extra bone in an arm\nthat simulates a bicep muscle. All of the vertices in the arm's skin should be weighted\nnormally between the wpper arm, lower arm, and shoulder. However, the vertices near\nthe bicep should also be weighted based on their distance from the bicep bone—\ncloser vertices should have higher weight values. When the arm bends, apply a scale to\nthe bicep bone co creace the appearance of a muscle flexing.\n\nThe skinning technique outlined is not mathemarically correct because we are\nessentially linearly interpolating matrices. Instead of representing bones as matrices, it\nis possible 1o represent them as a quaremion. SLERP berween the quaternions based\non the per-vertex weights and chen produce a matrix from the result, This should\nyield a somewhat better-looking skinned mesh.\n\nReferences\n\n[Lander93) Lander, Jef, “Skin Them Bones: Game Programming for the Web Gen-\neration,” Game Developer Magazine (May 1998): pp. 11-16.\n\n[Terzopoulas87) Terzopoulos, Demetri, et al, “Elastically Deformable Models,”\nComputer (Graphics, Vol 21, oo.4 (SIGGRAPH 1987)- pp. 205-214.",
      "content_length": 1743,
      "extraction_method": "OCR"
    },
    {
      "page_number": 476,
      "chapter": null,
      "content": "4.16\n\nReal-Time Realistic Terrain\nGeneration\n\nGuy W. Lecky-Thompson\n\nTerrain is the centerpiece of many games, an important backdrop in same, and just\nsomething to fill the space in others. No matter how it is used, ir will still artract\nunwanted arention if it is badly represented and, by the same coken, will add to the\nanmosphere, playability, and long shelf life of the game if done well.\n\n‘The use of the term rernain conjures up images of landforms, lakes, mountains, or\neven desolate craters in airless armosphezes for most people. While this is an impor-\ntant aspect of building the game, the word ternain may be used in a much broader\nsense. It can cover objects, names and buildings, parts of the game universe that che\nplayer will interact with, and pieces chat only give support to those parts.\n\nThe aim of this article is to equip the reader with several algorithms that enable a\nrealistic terrain to be created, within which the game may be played.\n\nThe emphasis here is on generation, and not storage. That is to say, the algo-\nrithms are presented in a manner thar leans toward using them to create terrain in\nreal-time, ancl not generation for storage, with a view to replaying the contents ar 2\nlarer date, Used with the techniques defined in the Predicneble Random Nor bers arti-\ndle in this book, a powerful near-infinite universe can be generated.\n\nLandscaping\n\nThe first technique that ean be used to create basic terrain is fexzy danalcaping. Essen-\ntially, it is simply creating topography in a completely random fashion, with scant\nregard to the real world. It is presented here simply as a starting point upon which we\nmay build future algorithms that will prove of more use.\n\nHere is some pseudocode thar generates a finite grid:\n\ny= -1;\n\nwhile y =< 100 {\nx= 0;\nyoy oeed,\nsrand(y):",
      "content_length": 1809,
      "extraction_method": "OCR"
    },
    {
      "page_number": 477,
      "chapter": null,
      "content": "4.16 Real-Time Realistic Terrain Generation\n\nwhile x = 100 {\nMap(x, ¥) = rand (3);\nK=x + 1:\n\n}\n\nAAs can be seen,.chis will simply populare a 100 x 100 grid with a series of random\nnumbers between 0 and 3. We can then assign colors to the numbers such that 0) is\nblack (water), 1 is dark gray (plains), 2 is light gray (land), and 3 is white (mountain).\nThis effect is seen in Figure 4.16.1. Note also that the random number generator is\nseeded on part of the grid reference of the individual square. This ensures that we can\nalways recover the value without needing to go through the entire grid [Lecky99], bur\nonly through thar line,\n\nThis is slightly less perfect chan one would hope, since we would like to seed\nbased on a discrete square. To do chis, we would need to create our own random num-\nber generator to rid us of the annoying effect seen in Figure 4,16.1, which results from\nusing the ANSI srand function: srand (x + (x * y)) foreach grid square,\n\nGood-looking fuzzy terrain is more realistic chan chat shown in Figure 4.16.1, so\nwe need to perform some additional processing on the resulting “map.” The tech-\nnique that we shall use is one that can he applied to any of the terrain-generating algo-\n\nrithms presented here, indeed to any abstract set of random figures that require a\ngrouping trearment.\n\nFIGURE 4.76.1 A tthe 1 00 nde Pe ed ey bee",
      "content_length": 1360,
      "extraction_method": "OCR"
    },
    {
      "page_number": 478,
      "chapter": null,
      "content": "Séection4 Polygonal Techniques\n\nThe driving philosophy is to ensure that the randomness of the map is reduced by\nensuring that neighboring squares hold a similar value, but at the same time allowing\ndifferences between specific sets or areas of squares. As usual, it is far easier to watch in\naction than to explain. The pseudocode looks like this:\n\nStep = 4:\nfor y= 0) y = 100; y = ¥ + step {\nfor x = 0; x = 100; x = x + atep {\ntotal = 0;\nfor y_local = y; y local <= y + step;\ny_local = y_loeal + 1 {\nTor x_local = x; x_local <= x + step:\nx_local = x_lncal + 1 {\ntotal = total 4 map (x_local, y_local);\n}\n}\naverage = total | (etep « step);\nfor y_local = yi y local <= y + step;\ny_local = y_local + 1 {\nfor w_local = ™; x local <= x + step;\nx_local = x_local + i {\nBap (x_local, y_local) = average;\nI\n\n}\n}\n\n‘The effect of applying this smoothing algorithm can be seen in Figure 4.16.2.\n\nWhile the net result is far from perfect, the overriding feeling is thar the map has\nbecome much less random than before.\n\nIt works by dividing the grid into a series of larger squares, and then subdividing\nthem. The average value of the subdivisions is then computed and propagated\nthroughout the subdivisions. The overall effect is one of smoothing.\n\nThe choice of subdivision size here is quite important also—too large a subdivi-\nsion will create wide expanses of similar values, and too small a subdivision will not\nproduce the desired effect.\n\nAn improvement to thit algorithm is to approach ir from a slightly different\ndirection. The end result is the same, modifying discrete pointes of the terrain based\non the surrounding points. This time, however, we will select che four comer points\nof the square for the averaging process, rather than use every poine. Also, we will only\nchange the center points of cach of the four quarters of the chosen square, rather than\nevery poinc.\n\nThe following code is snipped from the terrain-generation software that appears\non the CD.\n\nTor { ant square size = width; square_siza > 1; square_size j= 2 }\n\nint randes_range = square_size;",
      "content_length": 2067,
      "extraction_method": "OCR"
    },
    {
      "page_number": 479,
      "chapter": null,
      "content": "4.16 Foal-Time Realistic Terrain Generation 487\n\nFIGURE 4.16.2 A smoothed version of our tandem terrain grad.\n\nfor { int xi = row_offset; x1 < width; «1 += square size }\n\n{\nfor { int yi = row_offset; yi < width; y1 += square_size }\ni\n\nif Galculate the four corner offsets\nint x2 = (M1 4 square size) %& width:\nint ya (yl * a9uaré Size) %& width:\n\nfi Get the values\n\nint di = this->terrain[xij[vil:\nant a@ = this->terrain|x2][v1]*\nint 23 = this->terrain[xi][y2]:\nint i4 = this->terrain[x2][y2];\n\ni? Create weighted averages, based on\n\nint pi= ({i1 \" 9) + (12 * 3) + (i3 * 3) 4+ (d4)) s 18;\ndnt pe = {£1 * 3) + (12 * op * (a3) + (a4 * 3)) Ff 185\nint pS = ((il * 3) + (12) + (13 * 8) + (i4 * 3)} / 16;\nant pt = (({il} + (42 \" 3) + (43 * 3) + (i4 * 99} / 16;\n\nff Galculate the center points of each quadrant\nInt ¥3o= (x1 + square_size/4) & width;\n\nant ya = (yl + Square_size/4) & width;\n\nMa = (xd * Square _size/2) & width:\n\nYo = (yS * square_size/2) % width:\n\nif Set the points to the averages calculated above",
      "content_length": 1007,
      "extraction_method": "OCR"
    },
    {
      "page_number": 480,
      "chapter": null,
      "content": "Section 4 Polygonal Techniques\n\nthis->terrain [x3][ya] = pi;\nthis=->terrain [x2][ya] = pes\nthis->terrain [x3] [y¥2] = Aa;\nthis->terrain [x2] [yz] = pd;\n}\n}\n\ni} For the ngxt row, move in alightly\nFow_offset = square _size/4;\n\n}\n\nFigure 4.16.3 shows the four comer points and the bounding rectangle of the\n\n~ four center points used in che calculations above.\n\nThis technique was first introduced to me by James McNeill [McNeill95], and is\nanc of the most reliable examples of “smoothing” I have seen to date. There are end-\nless variations that involve adding random offsets to the calculated points, amongst\nothers, which lead to more variable landseapes.\n\nAs an enhancement to the two techniques discussed here, we may introduce a\nthird mechanism, known as Fault Line landscape generation. Fault Line landscape\ngeneration works by choosing nwo points at random and drawing a line at a given\nheight between them. Next, nwo more points are chosen, and again, a line is drawn\nberween them. This is repeated until there are acertain number of lines on the screen,\nasin Figure 4.16.4.\n\nThe next step is simply to apply the subdivision technique explained previously\nte smpoth the differences between the points. This results in a series of “islands” beeing\ncreated as can be seen in Figure 4.16.5, See Jason Shankel’s article, Ancor! Terrain\nGenenstion—Fanilt Formation, in this volume for further information on this tech-\nnique.\n\nWhile this may seem simple ar first, the line drawing itself is in fet more com-\nplex. As the disceming reader will have noticed in Figure 4.16.5, the lines are not\n\nFIGURE 4.16.3 Subdivision coordinates.",
      "content_length": 1632,
      "extraction_method": "OCR"
    },
    {
      "page_number": 481,
      "chapter": null,
      "content": "4.16 Real-Time Realistic Tarrain Generation\n\nFIGURE 4.16.4 Random faule limes.\n\nFIGURE 4.16.5 Paul lines smoorhed inca idands.",
      "content_length": 126,
      "extraction_method": "OCR"
    },
    {
      "page_number": 482,
      "chapter": null,
      "content": "450 Section4 Polygonal Techniques\n\ndrawn at a2 constant “height.” That is, the value atcribured co each point along the line\nchanges with respect to the distance from the starting point to the ending point.\n\nThe algozichm used to decide the “height” of each point is a sine curve, whose\namplitude is based on the distance between the owo points. The following code sep-\nment shows the core line-drawing algorithm at work thar forms part of the terrain\npenerator software on the CD.\n\nda\n\n{\nthis->terrain[ (int)_etart][(int})y start] =\nnCurrentRhandomValve:\nx_start = x start + x_diff;\ny_start = yostart + y dirt:\n\nI} Apply a sine function oscillating between 0 and 255\n/}/ The sin function showld be called with values from\nii =pif2 te pife\n\nif (m_diff < y_diff)\n\nnCurrentiondonvalue = (sin(x start) \" 128) + 128:\nelse\n\nnturrentiandonValue = (sin(y start) \" 128) + 12a;\n\n} while ({iy_start < (float}this-:terroin_ width) &&\n{y_start > 0.0)) BA\n({z_start = (float) this->terrain_height) Bh\n(x_start > O.0}});3\n\nThis is performed for cach line to achicve an effect akin co 2 mountain range,\nalbeit with a very smooth oscillation.\n\nThe important point co note about all of the techniques discussed is chat the\nlandscape that is generated is repeatable. That is, using the same basic input values,\nidentical landscapes can be generared at will, They do not need so be stored anywhere.\nThis ts the underlying principle for creating terrain in general, and is the core theme\nto the remainder of this article.\n\nUsing these techniques along with the principle of generation, we can say that\nsince in theory every time we seed the random number generator, we will get a differ-\nent set of random numbers, the possibilities for generating terrain are infinite. Fur-\nthermore, since we can re-generate or re-calculate at will any point of any terrain, we\nnever need more than just man-cime storage, which leaves us space on the delivery\nmedia for much more than just level files.\n\nOme of the most common structures in the game-playing arena (if you'll pardon the\npun) is the maze. Doon uses several to good effect, for example. In addition, ladders",
      "content_length": 2136,
      "extraction_method": "OCR"
    },
    {
      "page_number": 483,
      "chapter": null,
      "content": "4.16 Real-Time Realistic Terrain Generation 454\n\nand levels-rype games also use a two-dimensional variation of the maze. These mazes\noften increase in complexity according to the skill of che player, and may be littered\nwith all manner of rreasure,\n\nToo often, though, these use up so much storage space (Oven WAD files for\nexample) thar you simply cannot put enough of chem on a (CD te satisfy the player. A\ntruly realistic terrain (in the broadest sense) requires che illusion of infinity, and so it\nwould be a great boon if we could somehow creare these containers in real time.\n\nTf no attention should be paid to the “shape” of what is being created, it is\nextremely simple to create something thar will contain passages and paths, bur with\nno rooms. (The author fondly remembers a few early arcade games like that...) Basi-\ncally, che aim is to imagine that the playing area is contained within a finite space,\nwhich we will call a box.\n\nThis box is then subdivided by drawing horizontal lines from the left-hand side ro\nthe right at random intervals. Next, these sub-bowes are divided by drawing vertical\nlines from the top of the box to the boom, again ar random intervals. A possible\nresult is shown in Figure 4.16.6,\n\nseen from this angle, this is mot very inceresting ar all, but it is all a question of\nrepresentation. Imagine the black lines to be passageways, Now imagine that che play-\ners only see the passageways from the first-person perspective; all they will know are\njunctions and passages.\n\nIn fact, it still wouldn't be especially convincing—it is still missing rooms and\ndeac-ends, Boch of these will increase the reality of the experience. Rooms are quite\neasy, because all thar is required is that any space that has dimensions exceeding che\n\nFIGURE 4.76.6 Random limes divide our be.",
      "content_length": 1809,
      "extraction_method": "OCR"
    },
    {
      "page_number": 484,
      "chapter": null,
      "content": "Section4 Palygenal Techniques\n\nsmallest box can be considered a room. Working out the dimensions of the smallest\nbox is almost roo easy,\n\nSince we know thar all the horizontal and vertical lines must meet at some junc-\nture, it follows char the smallest box is the junction of the two vertical lines with the\nsmallest horizoncal separation, and the nwo horizontal lines with the smallest vertical\nseparation. Anything larger than thar in beth directions can be considered a room;\nwhatever is left is just passageway. Based on that, what emerges is shown in Figure\n4.16.7 (here we have added a little to the sizes used to work our the passageways and\nrooms).\n\nBy placing entryways on the walls at various places, we have created a playing area\nthar can be generated entirely on the fly. Increasing the number of lines, or decreasing\nthe size used to determine what is a passageway and whar is a room, will affect the\ncomplexity and hence the case of play.\n\nHowever, it is still not very realistic. In fact, it looks more like the intersection of\na couple of streets, rather than a building. So let ws treat it like char, and determine\nhow we may turn the “roms into “buildings.” The passageways will remain streets,\n\nRather than blindly chopping the “room” into pieces as we did previously, build-\nings can be made more realistic by subdivision, Taking a square, we divide it at a ran-\ndom position into qwo pieces, vertically. Then we divide each of the two pieces into\ntwo more, horizontally. Next, we may choose to divide each of the resulting pieces\ninto two, again vertically. This can be repeated as many times as is required. In Figure\n4.16.8, we have taken one of the larger squares from our previous ¢xample.\n\n‘The algorithm for doing this is fairly complex; however, here is an acceprable\nvariant for vertical lines:\n\n1. Start at the leftmost side, at a random height.\n2. Count the number of squares to the right until a wall is encountered.\n\nFIGURE 4.16.7 a: Before line removal. 4: After line removal,",
      "content_length": 2012,
      "extraction_method": "OCR"
    },
    {
      "page_number": 485,
      "chapter": null,
      "content": "4.16 Real-Time Realistic Terrain Generation 493\n\nFIGURE 4.16.8 Rooms creaned by subdivision\n\n3. Atarandom number of squares from the left, draw a line from the top to the ber-\ntom.\n\n4, Repeat steps 1,2, and 3 to taste.\nAnd its equivalent for drawing horizontal lines:\n\n1. Start at the topmost side, at a random width.\n\n2. Count the number of squares down until a wall is encountered,\n\n3. Ata random number of squares from the cop, draw a line from the left to the\n4, Repeat steps 1, 2, and 3 to taste.\n\nOf course, the algorithm needs to ensure thar when counting from top to borrom\nfor indeed left to right), that this is performed along a line, to avoid “floating” lines\nappearing that start in the middle of the square. All lines that are drawn must have a\nstarting point and an ending point at a wall.\n\n‘The next step is to insert doors in the walls. This can be done in a variety of ways,\nbut perhaps the easiest is ro work, again from top to bottom, or left co right, and\ninsert a door in internal walls such that sections of walls have a maximum of V doors\nin them.\n\nIf this is done completely at random, we nin the risk of having some walls with\nno doors, and potentially some rooms oo which there is mo direct access. Depending\non whether this creates a problem, the algorichm must be adapted.\n\nNaming Algorithms\n\nGiving objects, places, or fearures realistic names is a real chore when it comes to most\ngame design. Five, by David Braben and lan Bell, came up with some classics (Lave,",
      "content_length": 1494,
      "extraction_method": "OCR"
    },
    {
      "page_number": 486,
      "chapter": null,
      "content": "Sectlon4 Polygonal Techniques\n\nDisa, Reidquat, Leesti, Orevre, enc.) for che first star system. The first of a sLagger-\ningly large galaxy, in a universe of near-infinite scale, Considering that the machine\nthar the game was running on (with 16K RAM) was a limined-resource second-gener-\nation microcomputer, this was a huge achievement, Clearly, dhere was no way that\nthese could have been stored (diskettes had yet to be invented), so they must have\nbeen generated,\n\nWe could begin by generating a word of six letters, each one chosen ar random.\nWe might come up with something like “ndpgbs,” which is not terribly convincing,\nWhat is required is some method by which we can ensure thar letters thar are next to\neach other fir naturally, The first step is w create a table of letter-frequency pairs, so\nthat fora piven letrer we can say that there are a limited number of possible letters that\ncan follow it, and calewlate the chance that each one may follow it.\n\nThe following listing is the key to a technique known as the Markovian List (see\nale [Dewdney0)):\n\nvoid AddLetters(char * szWord, unsigned long ulTable| 28) [28))\nint n¥ordlength, nFirstletter, nlastLetter, AlLetter;\n\nff Decapitalise the word\nTor (fAletter = 0; nletter < (int) strlen({szWord)-iinlettere+}\ntolower (szlord[nLatter]};\n\nff Add the first, and last to thea table\nmvardlength = (int}strlen(szWord);\n\nnFiretLetter = (szWord[O] = ‘a\") + 1:\nnlLastletter = (szWord[nWardlength-1] - ‘a'} 4+ la\n\nwlTable[O][nFirstLetter]*+; // Space followed by letter\nulTable[nlastlLotter][27]*4+; // Letter followed by space\n\nTor (nletter = 0; nletter < nWerdlength-2; nletter++)\n\nnFirstletter = (szverd[nLetter] - *a\")ot 1\nnLastletter = (szWord[nLettert+1] - ‘a') + 1;\n\nulTable[nFirstLetter] [mLastletter]++;\nI\n}\n\nThe algorithm represenced here needs little explanation, other than te say thar for\na given word, we specify which letters are the starting and ending ones, and add them\nta the table. Then, for each pair, we update the table such that the position referenced\nby the letters is incremented, cementing a relationship benween the nwo thar we will\nmake use of larer.\n\nAs can be seen, this requires storage space of the order of 28x28x4 bytes (3,136),\nwhich fulfills our criteria of getting it into a 1GK RAM machine. Indeed, removal of\nall the blank entries will probably reduce the space requirements even more.",
      "content_length": 2380,
      "extraction_method": "OCR"
    },
    {
      "page_number": 487,
      "chapter": null,
      "content": "4.16 Real-Time Realistic Terrain Generation 455.\n\nOnce we have passed the algorithm over a selected text, or texts, we will have a\ntable that contains all possible lecter pair frequencies for chose texrs. We should also\nstore the average word length, toa.\n\nUsing this table, we may now generate a word, starting with the firse letter. To do\nthis, we should choose a random letter such thar it may begin a word; in other words,\nit falls in a column of the table referenced by wfTable/O}, such chac wf Tabdefol fs} is\nereater than zero. In addition, we can use the values stored in chis row to determine\nthe chance of a specific cell being chosen.\n\nTo do this, we simply add the values of all the cells referenced by nfTabtefO} {i}\n(where #runs from | to 26). Next, we call che random number generator to retrieve a\nvalue between 1 and the value we have calculared. We then pass through the row\nagain, sumone the frequencies as before, uncil the random number that we have is\nless than the running cotal, This is our leer; for example afFable/Ol/4) is a “d.” The\nfollowing code shows a genetic form of this algorithm, which can be applied to any\nletter.\n\nint GetLetterPositLon(unsigned tong ulWordTable[ 28] [26], int\nnPravious }\n\nint mtounter;\nunsigned long wlFrequencyTotal, ulFrequencyRunninglotal,\nULABRGoRLetter:\n\nulFrequencyTotal - 0;\n\nfi Get the Trequeancies\nfor (nCounmter = 1; nCounter =< 27; mCounter++})\n{\nulFrequencyTotal = ulFirequencyTotal +\nulWordTable[nPrevious] [mCounter] -\nI\n\nii Choose a ‘target’ frequency\nulRendonletter = rand(} & (ulFrequencyTotal);\n\nii Mowe through the table until we hit tha ‘target’ frequency\nulFréquencyRunningTotal = O;\n\nnaCounter = 1;\n\ndo\n\nUIFrequencyRunningTotal = ulFrequencyfunningTotal +\nulWerdTable[nPrevious] [nGounter];\nACoNTEre+ 5\n} while (ulFrequencyRunningToatal < ulRandgmletter);\n\nreturn mounter;\n\n}\nIn order co build a word of six letters in length, the general algorithm would be:\n\nWard(O] = GetLetterPosation (word_table,O)",
      "content_length": 1981,
      "extraction_method": "OCR"
    },
    {
      "page_number": 488,
      "chapter": null,
      "content": "Section4 Polygonal Techniques\n\nKil\nwhile x <6 {\n\nThis is the essence of the software NameGen that appears on the CD, and for\nwhich full source code is available, The NameGen code is also used in the demonstra-\ntion program Unitsen (for creating star maps, with named planers).\n\nHowever, as it stands, the word-generarion algorithm doesn't preclude strange\nwords such as “flecee” or “nooooo” creeping in. The problem is that there are a certain\nnumber of letters that can form chains. That is, an “o” can be followed by an “o,” and\nanother “o,” almost to infinity. The random number generator may prevent this to a\ncertain extend, but even a repetition of three “o's” is a little ugly.\n\nso, our werd-building algorichm should become:\n\nWord[O] = GetletterPosition (word_table,O)\n\nx= 4\nwhile x <6 {\n\nword[x) = ((GetLatterPosition (word_table, word[x-1] — ‘a'))\n=1) + ‘a’\n\nx = RengveChain( word, x}\n}\n\nWhere che Resovethain function returns the current letter index into word if it is the\nthird ina chain of itself This could be coded as in che following listing:\n\nint Removethain( char word(M4x LENGTH], int letter_position }\n\n{\nint nPos = oO:\n\nint nOccureances = 0;\nwhile (nFos = strlendword)}\n\nif (word[nPos) == word[letter_position])\nPOCCUPEMGes++;\n\n}\n\nif (NOpcurences > 2) return letter_position — 1;\n\nreturn letter_position + 1;\n\nI\n\nThis will clean up the word, and if there is no excessive chain, increment the lee\nLer POSINON Souter,\n\nThe final step that can be taken in enswring that the word is authentic is to\naddress the last letter, and make certain thar it is one that can commonly end a natural\nword, Some letters, for example, are commonly followed by a vowel in the English",
      "content_length": 1686,
      "extraction_method": "OCR"
    },
    {
      "page_number": 489,
      "chapter": null,
      "content": "4.16 Real-Time Realistio Terrain Generation 407\n\nlanguage, such as “J.” In order thar words do not creep in that end in such letters, we\nmust perform at least two operations.\n\n‘The first operation is to ensure thar the letter may follow the one thar it is adja-\ncent to, and to ensure thar the chosen lecrer may end a ward (be followed by a space).\nIn addition, we must also he careful that such a leteer exists; otherwise, we may end up\n\nin an endless loop. To de all this, the following code is adapted from the GetLetter-\nPosition function already described.\n\nint GetEndlLettar (unsigned long ulWerdTable[28)(28], int nPreviows)\n\nJ\n\nint nGgunter;\n\nunsigned long wlFrequencyAd)sacentTotal ,\nulFrequencyAunninglotal, wlAandonletter,\nulFrequencyendingtotal:\n\nU1FrequencyAdjacentTatal = 0:\nwlFréquencyEndingTotal = 0;\n\nif Get the frequencies\nfar (mtounter = 1; nGountar =< 27: nGountert++)\n{\nWIFrequencyAdg|acentTotal = olFrequencyAdjacenttotal +\nulWordTable[nFrevious][aCaunter];\n\nUIFrequencyEndingTotal = wlFrequencyEndingiotal +\nulWordTablel 27] [Counter];\n}\n\nii Ghoose a “target” frequency\nulRandomLetter = rand() % wlFrequenoyAdjacentTotal:\n\nff Mowe through the table until we hit the ‘target’ trequency\nuIFréquencyRunningTotal = 0;\nACounter = 1:\nde\n{\nWIFraquencyRunningTotel = wlFrequencyRunningTotal +\n\nulWordTable[nPrevious) [Counter]:\nnGowuntar++;\n\naf (ulFrequencyEndingTetal > o)\naf {(ulFrequencyRunningTotal == ulRandomLetter) &&\n{ulWordTable[27][nCounter) f= oO)\nbreak;\nelse\nif (ulFrequancyRunningTotal >= ulRandonLetter)\n\nbreak;\n} whilg (1 == f):\n\nreturn nGounter:\n\n}",
      "content_length": 1579,
      "extraction_method": "OCR"
    },
    {
      "page_number": 490,
      "chapter": null,
      "content": "490 Sectlon4 Polygonal Techniques\n\n‘in improved version char selects che leteer as a function of the combined proba-\nbilities of the target leter being adjacent to the source lemrer and at the end of a word\nis left as an exercise for the reader.\n\nAdditional points to nove are that this method is limited only by the use of allpha-\n\nbet (it must be Roman), and chat no attempt has been made to capitalize che begin-\nning of words.\n\nReferences\na\n[Dewdney90] Dewdney, A. K., The Tinkertay Computer, WH. Freeman, 1990,\n\n[Lecky99] Lecky-Thompson, Guy W., Algorithms for An Infinite Universe, Gamasu-\ntra, 1999.\n\n[McNeill95) McNeill, James, SubDiv Applet, mcneja@wwe.edu.",
      "content_length": 666,
      "extraction_method": "OCR"
    },
    {
      "page_number": 491,
      "chapter": null,
      "content": "4.17\n\nFractal Terrain Generation—\nFault Formation\n\nJason Shankel\n\nIn nature, forees such as the separation of rectonic plates, mass-wasting, and shoreline\ncfosion create terrain feacures like escarpment, mesas, and seaside cliffs, In chis arti-\ncle, | will show how we can use a fault formation algorithm to generate these kinds of\n\nherrain.\n\nFault Formation\n\nSeart with an empey height field. Draw a random line through it and add an offset\nvaluc dAaight to cach value on one side of the line (See Figure 4.17.1):\n\nNeat, decrease dAfergit, draw a new line, and repear the process. Continue gener-\nating lines and decreasing f@Hefg/t uncil a sufficient level of detail is generared.\n\nFigure 4.17.2 shows cerrain height fields at 4, 8, 32, and 64 iterations (higher ele-\nvations in whire}.\n\nFIGURE 4.17.1 ‘The first sep of our heighr Geld.\n\n4o6",
      "content_length": 843,
      "extraction_method": "OCR"
    },
    {
      "page_number": 492,
      "chapter": null,
      "content": "500 Section 4 Polygonal Techniques\n\n4 iterations 8 iterations\n\n32 iterations 64 iterations\nFIGURE 4.17.2 Terrain height fields created by thir process,\n\nDecreasing dHelght\n\nWe want co decrease @Afeighr linearly with cach iteration, but we don't necessarily\nWant it to drop te zero.\nLet @Geighr, . be che value of @Feight at each iteration. The value of dHfeight a1\n\niteration #, is given as:\n\nHeight; = dHeighty + (iln\\adHeight,-dHeight,)\nGenerating Random Lines\n\nWe want our lines to intersect well with the height field, so generating purely random\nvalues for a linear equation isn't desirable, since the vast majority of lines will contain\nthe entire height field on a single side.\n\n‘To generate a line, it is best to pick owe random points within the height field and\nute them to determine the linc.",
      "content_length": 803,
      "extraction_method": "OCR"
    },
    {
      "page_number": 493,
      "chapter": null,
      "content": "4.17 Fractal Terrain Generation S04\n\nPz\n\nf\nFIGURE 4.17.3. M[lustration of choosing a “random line.”\n\nWe can determine which side of a line a poinc is on by calculating the s compo-\nnent of a three-dimensional cross product (Figure 4.17.3):\n\nLet be a line defined by che poines pl and p?\n\nLet ep be a vector in the direction pl — p2\n\nLet o be a point in the height field\n\nLet ve be a vecvor in the direction pl\n\n‘Treated as three-dimensional vectors, xp and vo have z-components of zero.\n\nLet ex = ep & pe\n\n[fens > 0, the point ¢ lies on left side of the line. If mez < 0, the point a lies on\nthe right. [fiz = 0, ¢ is on the line.\n\nErosion\n\nThe fault formation technique creares dramatic differences between neighboring cells\nin the height field. For alow number of iterations, this results in very unrealistic ter-\nrain. Even at high numbers of iterations, the terrain still looks highly aliased, like a\nPiece of paper thar has been sliced multiple times with a razor.\n\nThe problem is char we have unrealistic high-frequency data in our height field.\nIn nature, the sharp divisions berween neighboring cells would be dulled by erosion.\n\nTo simulate erosion, pass the height field chrough a low-pass image filter,\n\nRobert Krten [Krren94] suggests a simple FIR filter. A FIR. filter converts the\nSOQUCIICE X 4, 3 Ayek, OO the sequence yy, Fs. 7y--), according to the formula:\n\nKe aa + (1b;\nWhere # is a filtering constant berween 0 and 1. Low & means less erosion, high &\nmeans more. Typically, a £ of abour 0.5 works well for this application.",
      "content_length": 1543,
      "extraction_method": "OCR"
    },
    {
      "page_number": 494,
      "chapter": null,
      "content": "502 Sectlon4 Polygonal Techniques\n\n4 iterations\n\n32 iterations 64 iterations\nFIGURE 4.17.4 An eroded version of Figure 4.17.2.\n\nIf we take the FIR filter function and apply it across the rows and columns of the\nheight field im both directions, we will get a nicely eroded landscape (Figure 4.17.4).\n\nFigure 4.17.4 shows the same terrain as Figure 4.17.2 after erosion. Color Plate 1\nisa. 3D rendering of the eroded 64 iteration stage.\n\nSample Code\n\nThe algorithm in the sample code lets you set different numbers of iterations, the\nd@Height for iteration 0 and iteration m, the erosion factor (4), and che number of iter-\nations between erosion passes,\n\nReferences\naint neat ait ee ee ee ee ee\n\n[Krten94] Kren, Robert, “Generating Realistic Terrain,” Dr. Dobbs Journal (July\n194},",
      "content_length": 780,
      "extraction_method": "OCR"
    },
    {
      "page_number": 495,
      "chapter": null,
      "content": "4.18\n\nFractal Terrain Generation—\nMidpoint Displacement\n\nJason Shankel\n\nMountain ranges like the Rockies, Sierras, and Himalayas are formed by a geological\nprocess called weft. Lateral pressure from the movement of tectonic plates causes the\nsurface of the Earth to wrinkle like fabric, pushing up mountain ranges. In this arti-\nele, I will show bow we can simulare uplift with a recursive midpoint displacement\nalgorithm, also known as the plasma fraceal or the diamond-square algorithm.\n\nMidpoint Displacement in One Dimension\n\nIn one dimension, midpoine displacement works like this. Start with a line Scement\nAB (Figure 4.18.1):\n\nSens\nFIGURE 4.18.1 Line segment AB.\nTake the midpoint C and displace ir by a random value between <dHeight2 and\n\n+dAeigint/!2, for some suitable dHeight (the length of AB is a good candidate) (Figure\n4.18.2):\n\na\nik\n\nFIGURE 4.16.2. First displacement sage.\n\nReduce the value of dHeight and recurse co the segments AC and CA (Figure\n4.13.3):\n\n505",
      "content_length": 978,
      "extraction_method": "OCR"
    },
    {
      "page_number": 496,
      "chapter": null,
      "content": "Section4 Polygonal Techniques\n\nFIGURE 4.18.3. Second displacement stage.\n\nRepeat uncil you generace sufficient detail (Figure 4.18.4):\n\nA\n\nFIGURE 4.18.4. Nih displacement stage.\n\nAreach iteration, dHeight is multiplied by 2\", where ris the roughmess constant.\n\nThe magic value for ris 1. If r= 1, then dHeight is divided by 2 at each iteration,\nwhich is also the rate at which the horizontal line segment length decreases. When r-\n1, the generated terrain will be perfectly self-similar (small seetions will resemble large\nSOCIO).\n\nWhen r> 1, dHeight decreases faster chan the line segment length, so early itera-\ntions have a disproportionately large effect am the cerrain. r > 1 is good for creating\nsmooth terrain with a few prominent features (mountains or valleys).\n\nWhen r< 1, dieighs decreases slower than the line segment length, so late itera-\ntions have a disproportionately large effect on the terrain. r < 1 is goed for creating\nchaotic terrain.\n\nFigure 4.18.5 shows three terrains with varying values of r (higher elevations in\nwhite).\n\nJ r= 1/4\n\nFIGURE 4.78.5 Samples of terrain with various rvalues.",
      "content_length": 1114,
      "extraction_method": "OCR"
    },
    {
      "page_number": 497,
      "chapter": null,
      "content": "4.18 Fractal Terrain Generation 505\n\nMidpoint Displacement in Two Dimensions—\nDiamond Square\n\nJust as the line segment is the basic unit of one-dimensional midpoint displacement,\nthe rectangle is the basic unit of ewo-dimensional midpoint displacement.\n\nRectangles are a bit more complicared than line sepments, since we have to calcu-\nlate not one but five midpoins for cach rectangle, That is, we must caloulare the mid-\npoint of the rectangle irself, as well as the midpoints of each of the four line segments\nthat make up the sides of the rectangle.\n\nTn the diamond-square algorithm, the calculation of the rectangle’s midpoint is\ncalled the diamond step, and the calculation of the side midpoints is called the square\n\nstep.\nStart with a rectangle (A820), seeded with height values ar the four comers (Fig-\nure 4.18.6):\nA ff\nC fr]\n\nFIGURE 4.18.6 Square ARCO,\n\nCalculate che height at the midpoint E by averaging the values at A, B,C, and D\nand adding a random value berween -dArighn!2 and +@Heright!? (diamond step) (Fig-\nure 4.18.7):\n\nee\n\nIp\n\nFIGURE 4.78.7 First displacement saps,",
      "content_length": 1087,
      "extraction_method": "OCR"
    },
    {
      "page_number": 498,
      "chapter": null,
      "content": "Section4 Polygonal Techniques\n\nEs (Ae Be CoD + nandom(-dHeight!2, +dHeight{2)\n\nNow, calculate che heights at the midpoine of the line sepmencs (7, G, A, and J)\nby averaging the comer values and the midpoints of the adjacent rectangles, and\nadding a random value berween -dHeight!? and +dHeighe!? (square step) (Figure\n4.18.8):\n\nF\n\nG E H\nc 2... Bb\ni\nFIGURE 4.18.8. First displacement stage, continued.\n\nMultiply @Height by 27 and repeat the process for the squares AGE, FBREN,\nGECY, and FAID (Figure 4.18.9):\n\nFIGURE 4.18.9 Second displacement stage.\n\nRepeat until you've reached a sufficient level of detail.\n\nAn important thing to note about the square step is that the square values rely on\nthe diamond values af neighboring squares.",
      "content_length": 735,
      "extraction_method": "OCR"
    },
    {
      "page_number": 499,
      "chapter": null,
      "content": "4.18 Fractal Terrain Generation 507\n\nFor example:\nfos (Pelt J+ Aid + random(-dHeight'2, +dHeight(2}\n\nSo, as the algorithm iterates through each level of detail, ic must first perform the dia-\nmond step for the entire grid before performing che square step.\nTo calculate a square step value on the edge of dhe terrain (4, for example), treat\n\nthe cerrain as though it wraps. In the case of A, take £ as being adjacent to Hon both\nthe right and the left:\n\nAw (Be Di QE M4 + random (-dieight!2, +d Fleigin(2)\n\nDiamond Square in Height Fields\n\nWhen using the diamond square algorithm to fill in a height field, it is best to pick a\nsquare height field with width 2° for some integer . This ensures that the rectangle\nsize will have an inceger value at cach iteration.\n\nSee Color Place 2 for a rendering of a terrain generated into a 256x256 height\nfield.",
      "content_length": 850,
      "extraction_method": "OCR"
    },
    {
      "page_number": 500,
      "chapter": null,
      "content": "4.19\n\nFractal Terrain Generation—\nParticle Deposition\n\nJason Shanke!\n\nIn nature, volcanic mountain ranges and island systems like the Pacific Rim's \"Ring of\nFire” are generated by lava flaw. In this article, I will use a particle system borrowed\nfrom the field of molecular beam cpitaxy co simulare lava flow.\n\nMBE Models\nMolecular beam epitaxy, ar MBE, isa process for depositing thin layers of atoms on a\ncrystalline substrate. We can adapt the models used in MBE simulation to approxi-\nmate lava flow. For an in-depth analysis of che mathematics of MBE, see [Barabisi95],\n\nParticle Deposition\n\nThe idea is to drop sequences of particles and simulate their flow across a surface com-\nposed of previously dropped particles. Dropping a sufficient number of particles will\nproduce stractures that look like the flow patterns of viscous fluid (lava).\nStart with an empry height field and drop a single particle ante it (Figure 4.19.1).\nNow, drop a second particle on the first and agitate it until it comes no rest (that\nis, until none of its neighbors is at a lower altitude) (Figure 4.19.2),\n\n|\nee Pl eee\n\nFIGURE 4.19.1 A single dropped particle,",
      "content_length": 1146,
      "extraction_method": "OCR"
    },
    {
      "page_number": 501,
      "chapter": null,
      "content": "4.19 Fractal Terrain Generation : Sod\n\nFIGURE 4.19.2 Two dropped particles.\n\nContinue dropping particles (varying the drop point periodically) until you have\na decene sized pile (Figure 4.19.3).\n\nYou can control the shape of the terrain by controlling how the particle drop\npoint is moved, Keeping the drop point in a single place will create a large peak. Mov-\ning the drop point periodically will create chains of multiple small peaks.\n\nFigure 4.19.4 shows different terrains generated with this technique (higher alci-\nrudes in white).\n\nInverting the Caldera\n\nReal-world volcanoes, especially active volcanoes, have very distinctive mountaintops.\nAfter flaw stops, the lava ac the top of the volcano cools and recedes back into che\nEarth, creating a familiar bowl-shaped region at the top called a cade’ens.\n\nFIGURE 4.18.3 A collection of particles.",
      "content_length": 852,
      "extraction_method": "OCR"
    },
    {
      "page_number": 502,
      "chapter": null,
      "content": "=e\n\nSection’ Polygenal Techniques\n\nFIGURE 4.19.4 Some height helds generared with this technique.\n\nWe can generate a caldera for our particle mountain by inverting the height field\nvalues above a certain altitude about the horizontal plane defined by char altivade,\n\nImagine a height field generated by particle deposition (Figure 4.19.5).\n\nDraw a line (or rathez, a planc) through an arbitrary altioude (Figure 4.19.6).\n\nThen invert all dhe height Geld values above the line about the line (Figure 4.19.7).\n\nCuring off the peak this way can result in a highly aliased caldera edge. To make\nthe caldera look more realistic, apply am erosion filter (see the “Fracea! Terrain Gerer-\nation—Fault Formation” article} to blunt the sharp edges.\n\nApplying the caldera cutoff to the entire height field can generate undesirable\nresults. If the terrain has multiple peaks, the caldera line for one peak can interfere\nwith other peaks.\n\nPaine\n\nFIGURE 4.19.5 A height field penerated by particle deposition.",
      "content_length": 996,
      "extraction_method": "OCR"
    },
    {
      "page_number": 503,
      "chapter": null,
      "content": "4.19 Fractal Terrain Generation Sii\n\nCaldera Line\n\nFIGURE 4.79.6 The calelers line,\n\nCaldera Line : “toa\n\nFIGURE 4.18.7 [nvert the height field values above che caldera line,\n\nIt is best to implement the caldera inversion using a floocl-fill technique. Starting\nfrom an initial poine, invert the point and check ies neighbors. For each neighbor.chat\nis above the caldera line, invert it and check its neighbors, Continue until you run out\nof neighbors.\n\nColor Plate 3 is a 31D rendering of a volcanic island system generated with parti-\ncle deposition.\n\nSample Code\n\nThe sample code lets you control the number of piles, the particles dropped per pile,\nthe movement of the particle drop location, and the caldera depth. Caldera depth is\nexpressed as a percentage of peak height [0..1]. Using a caldera depth close to | will\n\npenerate sinkholes instead of mountains.\n\nReferences\n\n[Barabasi95] Barabdsi, A. L., and Stanley, H. E, Fracte! Concepes in Surface Growth\n(Cambridge University Press, 1995)",
      "content_length": 997,
      "extraction_method": "OCR"
    },
    {
      "page_number": 504,
      "chapter": null,
      "content": "9.0\n\n2D Lens Flare\n\nYossarian King\n\nLens flare is an optical effect created by interreflection between elements of a lens\nwhen the camera is pointed toward a bright light. The result is a shifting pamern of\ntranslucent shapes and colors emanating from the light seurce. The effect is often seen\nin TV broadcasts when the sun enters the video camera's Geld of view,\n\nIn real life, lens flare is considered a defect, and camera manufacturers go to great\nlengths to eliminate it through special lens coatings. Video pames, however, like to\nemphasize and exaggerate all the cooler aspects of reality, and lens flare is definitely\ncoal. Real lens flare is due to complex interactions of light with surfaces in the optical\nsystem of a camera. Video game lens flare is all about appearances. This article shows\nhow to implement an attractive lens flare effeer using only asmall amoune of code and\narmwork, without needing to know anything at all about physical optics.\n\nApproach\n\nReal lens flares are created in the lens system of the camera and so naturally appear\n“on top of” the scene being viewed. Each element of a flare is a reflection of the light\nbouncing off a secondary lens and onto the primary lens. Since the lenses are in pre-\ncise vertical alignment, the reflections fall along a lime in the final image, where the\ndistance of the reflection from the center of the image is proportional co the distance\nof the corresponding secondary lens from the primary.\n\nThese observations justify che treatment of lens flare rendering as a 2D problem.\nThe flare is rendered as an overlay on the 3D scene, and the elements of the flare are\nrendered along a line intersecting the projected position of the light and the center of\nthe screen, at sherwn in Figure 5.0.1.\n\nAt this point, we abandon all reference to physical optics and focus entirely on\naesthetics. The lens flare effect is rendered with a small collection of textures, one for\ncach style of fare element—circles, rings, hexagons, sunbursrs, and so on—as shown\nin Figure 5.0.2, The gray-scale vexrures are combined with vertex colors to produce\nsubtle coloring. Alpha blending is used to make the effect translucent. Elements are\nrendered in a variety of sizes.\n\no15",
      "content_length": 2224,
      "extraction_method": "OCR"
    },
    {
      "page_number": 505,
      "chapter": null,
      "content": "516 Sections Pixel Effects\n\nio *\ntale i ]\nat te i\n\nieee H\na ag !\nLy\nie |\nSaat\nEee\ni. \\\nI *, ane —\n\nFIGURE 5.0.1. Lene flare rendering is a 20) problem. Elemencs of che lens flare are rendered\nalong a line berween the projected position of the light source and the center of the screen.\n\nFIGURE 5.0.2. The lens flare effect is rendered using a small collection of gray-scale texpures.\n\n‘To be cruly effective, che lens flare effect must animate convincingly with camera\nmovement. The overall movement of the flare is determined by tracing the line fram\nthe projected light position through the center of the screen. Varying the size and\ntanslucency of the flare elements produces additional subrlery. This variation is\nachieved by sealing the size and alpha value of the flare elements based on the distance\nberween the projected light position and the center of the sereen; when the light is far-",
      "content_length": 896,
      "extraction_method": "OCR"
    },
    {
      "page_number": 506,
      "chapter": null,
      "content": "5.0 20 Lens Flare Bi?\n\nther from the center, the clemencs are smaller and more cransparent, and when the\nlight is closer to the center, they become larger and more opaque.\nA ample of the results of this approach are shown in Color Plate 4.\n\nimplementation\n\nPutting all this together boils down to performing the following steps for each ele-\nment of the lens flare:\n\n1. Determine position and size of the flare element.\n2. Detetmine texture, color, and manslucency of the element.\n3. Render the element as a 2D sprite with the computed properties.\n\nIn this implementation, a flare is a collection of elements. Each element has the\nfollowing static properties:\n\n* Texture. The available textures (shapes).\n\n* Distance. Proportional distance along the line from the light source to the center\nof the screen.\n\n« Size. Normalized size of the clement (before scaling).\n\n* Color, Red-green-blue (RGB) color used to shade the element while rendering,\n\n* Alpha. Translucency of the clement (before alpha scaling).\n\nThe flare also has an overall scale factor and a maximum size, used co control the\nelement size: during rendering, These properties are all determined at initialization\ntime. In the demo code, the properties can be determined randomly or loaded from a\nflare description file.\n\nDuring rendering, the dynamic properties of each lens flare clement are com-\nputed based on their static properties and the position of che light source on the\nscreen. Texture and color of the flare are unaffected, bur position, size, and alpha level\nare all dynamic, depending on the movement of the camera relative to the light\nSOUICE.\n\nIn pseudocode, the lens flare effect is rendered as follows:\n\nTunction renderflare:\n\nflara if flare object to be rendered\n(ix,1y) ff projected positien of light on scraan\n(ex,ey) ff geanter of flare (nernally center of screen)\n\n{i} Compute how far off-center the flara source is.\nMaxflaredist = sqrti(ex 2 + cy*2)\nTlaredist = sqrt({lx - cxj*2 + (ly - ey)*2)\n\n{? Deteraine overall scaling based on off-center distance.\ndistancescale = (maxflaredist - flaredist) /maxflaredist\n\n‘i? Flare is rendered along a Line from (lx,ly) to a\nf} point apposite it across the center point,",
      "content_length": 2197,
      "extraction_method": "OCR"
    },
    {
      "page_number": 507,
      "chapter": null,
      "content": "Big Section & Pixel Effects\n\ndz = cx * (ex - Lx)\noy = cy * (cy - Ly)\n\nfor each element in flare\n4\nff Position is interpolated between (lx,ly) and\nif (ox, oy).\npx = (1 - slement distance} \"le + element .distance*dx\nBy = (7 - elesent distance) \"ly + alement .distance*dy\n\nff Size of alement depends on ite scale, distance\nff scaling, and overall scale of the flare itself.\nwidth = element.size * distancescale * flara.scale\n\nff Width gets clamped, so the off-axis flares keep a\nff good size without letting the cantered e#laments\nif get too big.\nAf (width > flare .naxsize)\n\nwldth = flare.maxsize\n\nff Flare elements are square (round) so height 4s\nff just midth staled by aspect ratio.\nheight = width * aspectratio\n\nif Alpha is based on element alpha and distance scale.\naipha = ¢lement.alpha * distancescale\n\nif Oraw the element's texture with computed\n\nif propertias.\n\ndraerectangle( alement.texture, eleneat.colour,\nalpha, px, py, Width, height 4}\n\nSource Code\n\nThe lens flare demo includes OpenGL source code and a Windows executable. The\nsource code is separated into an API and sample code thar uses the API. The API\nincludes structures that deline the properties of a flare as well as the following func-\nbons;\n\n* FLARE initialize. Initialize flare elements, given a list of properties by the caller.\n* FLARE_randomize. Generate a list of flare elements with random properties.\n* FLARE_ render. Render the flare ata piven screen position.\n\nThe deme uses these finetions to create a lens flare effeecr controlled by the mouse.\nThe mouse cursor is used as the screen location of the light source, Lens flares can be\nrandomly generated or loaded from a file. See the README-TXT file included with\nthe demo for additional details on the demo ineerface.",
      "content_length": 1753,
      "extraction_method": "OCR"
    },
    {
      "page_number": 508,
      "chapter": null,
      "content": "3.1\n\nUsing 3D Hardware for 2D\nSprite Effects\n\nMason McCuskey\n\nThe past few years have seen an explosion in the 3D capabilities of graphics cards, In\nthe span of a few years, we've moved from 256 colors at 320 * 200 to fully 3D aceel-\nerated, 1,600 = 1,200, 32-bit color. Even though most of today’s cards tend co ignore\nthe 2D world and ship with feature lists tailored to 3D, a phenomenal amount of pro-\nceasing power is still available in chem, which can be harnessed to achieve stunning\n2D effects.\n\nThis article sheds some light on how to use 31) hardware co achieve 2D effects.\nSpecifically, we take a look at how to do alpha blending, sprite scaling, and sprite rota-\n\ntion.\n\nGoing 3D\n\nThe basis of this entire article is char inevitably, a 31D scene must be rendered to a 2D\nsurface for display. This is as true in Direct3D's Immediate Mode (where a 3D ren-\ndering device must be attached to a surface) as it is in OpentsL.\n\nEverything you see in a 3D scene is made up of primitives (usually triangles or\nquads), Groups of primitives are arranged together in various ways to form more\ncomplex polygons. Any group of primitives can have a “texture” applied to it, which\ngoverns how the group looks. We don't need to get into the many details of textures;\nfor the purposes of 2D effeers, all we care abour is the facr that we can load a texture\ninte OpenGL and then assign thar texture to a quad (rectangle) primitive.\n\nSetting Up the 3D Scene\n\nThe “trick” to displaying sprites using 31D hardware involves how you set up your 3D\nworld. Even though the 3D) card gives us the power to render polygons in any rotation\nand position in 3D space, the secret to achieving 2D effects is vo set up our 3D scene\nso that everything is directly Geing the camera. After all, if we set up a real-life 3D\nmodel of our 2D game, we'd realize that our 2D sprites are basically rigid pieces of\n\n519",
      "content_length": 1885,
      "extraction_method": "OCR"
    },
    {
      "page_number": 509,
      "chapter": null,
      "content": "520 Sections Pinel Effects\n\npaper at which the camera is directly pointing. In other words, in 3D), our 2D game\nlooks like a really complicated diorama. Fach sprite is a billboard, and the camera\nalways remains a fixed distance from the sprites and never moves (unless yOu Wane it\nto, which can produce some interesting effects).\n\nKeep this paradigm in mind as you read che larer sections on setting up textures\nand displaying sprites.\n\nSetting Up the Texture\nantiteieeil ited atten EEE\n\nSetting up the texture requires several OpenGL. calls:\n\ng1Pimzel Stored ((GL_UNFACK_ALIGNWENT, 1):\ngicentéextures(1, (Gluint*)anTexturelo) ;\nif (atexturelp == 9)\n{ Glanum gle-glGetErrord); /* handle errors! */ }\ngIBindTaxture (GL_TEXTURE 20, mlexturelD);\nQLTexParameteri(Gl TEXTURE 20, GL_TEXTURE_WAAP_S, GL CLAMP);\nglTexParameteri(GlL_TEXTURE_2D, GL_TEXTURE_WAAP_T, OL CLAMP):\ngliexParameteri(Gl_TEXTUAE_2D, GL_TEXTURE_MAG FILTER, GL_LINEAR)-:\nglTexParaméteri(GlL TEXTURE_2D, GL_TEXTURE_MIN FILTER, GL_LINEAR};\nglTexInagezD(GL_TEXTURE_20, 0, GL_AGEA, 128, 128, 0, GL_AGaA,\nGL_UNSIGNED BYTE, gpgtezture);\n\nThis section of code, part of the ca0Sprite::Init() method in the example program,\ninitializes our texture in OpenGL. gagtexture is a pointer co an array of RGBA pixel\nvalues (4 bytes, one cach for red, green, blue, and alpha values). The call to gl textn-\nage2D() sets up a texture using the epgrexture pixel array. The g1TexParameteri()\ncalls set various properties of the rexcure, including our wrapping mode (GL_cLAMP,\nwhich means “dont wrap the texture”), and our filters for growing and shrinking the\ntexture (in this case, we're using linear filters).\n\nDrawing the 3D Sprite\n\nNow that we've gor the texture set up, we're all ready co draw the sprite. To use a\nsprite, the client application first sets up all the parameters for the sprite (position on\nthe screen, size, transparency of alpha value, etc.). The cliene chen calls the pisplay{}\nmethod to render the sprite.\n\nThe following code comes from the CDSprite::Dieplay() method:\n\nif Set up the rotetion and translation matrices\nplPushiatrix();\n\npliranslate?(m_ix, m_iv, O};\nglfatatef(m_fAatation, 0, 0, 1);\n\nThe first thing this code does is set up the rotation and rranslation (movement)\nmatrices. Open(SL uses a matrix stack, which allows us to apply global changes to our",
      "content_length": 2330,
      "extraction_method": "OCR"
    },
    {
      "page_number": 510,
      "chapter": null,
      "content": "6.1 Using 3D Hardware for 20 Sprite Effects S21\n\nvertices as we create them. Any vertex that we create is transformed using the matrix\nat the top of the stack. Before we create any vertices, we need mo set up a matrix that\nrotates the vertices and moves them to the position where the sprite is supposed to be\n(ma_sA, m_s¥).\n\n‘To get the mamix we need, we push a new identity macrix onte the modelview\nstack, then multiply it by a wanslation matrix to the sprites position (the third argu-\nment to gl Translate is the z coordinate) and a rotation matrix using the m_fRata-\ntion variable. The second, third, and fourth arguments to glRotatet tell OpenGL\nwhich axis we want to perform the rotation around—in this case, just the z-axis. The\nz-axis is the one thar's perpendicular to your monitor; it is “going into” and “coming\nout of” che screen.\n\nThe next thing we need to do is set our blending mode and texture mode. The\nfirst several lines of code set up our blending mode. We alpha-blend our sprite with\nwhatever has already been rendered to the frame buffer The equation used is sre-\nColer\"mcAiphatdemCalor\"(I-ocAlpha), After that, we set up the texture mode, Our\ntexture mode indicates thar the pixels we're poing to render are che source color and\nalpha modulated (multiplied) by the texture. After that, we call che glBindtexture()\ncommand, which tells OpenGL that we want che following primitives to be textured\nusing aTextureZD, the ID we got when we set up the sprite’s texture earlier.\n\nI! Oree the sprite\n\nQlEnable(GL_ALEND);\n\ngiblendFunc(Gl_GhG ALPHA, OL_ONE_MIWUS SRC ALPHA);\n\ngiEnable (GL_TEXTURE_20);\n\nQLTexEnvt (GL_TEXTURE_ENV, GL_TEXTURE_ENV_IOOE, GL_MOOULATE};\nglbindTexture(GL TEXTURE 20, mTlextureZo) ;\n\nAThis glBegin() function call tells OpenGL that we're starting our\nfivertex list and will be working with quad prinitives.\n\ngifegin(GL QUADS):\n\nNow we sec up our four vertices, one vertex for cach of the four comers of our\n\nquad primitive. Each vertex has:\n\nI. A color, We're setting the color via the glColor4ub() function. In this example,\nthe color of all our verrices is pure white, RGB (Oxff, Ouff, Oxf).\n\n2. A corresponding texrure coordinate (set via the glTexCeord2f() function), which\ntells OpenGL how the texture is stretched or shrunk on Our cqusael primitive. A\ntexture coordinate of (0.0, 0.0) represents the upper-Ieftmose vexture pixel (texel};\na texture coordinate of (1.0, 1.0) represents che lower-righomost texel. In effect,\nwhat we're saying in this example is that the texture is stretched perfectly so thar\nit exactly fits the quad. (Keep in mind thar the quad itself can be any size, and the\ntexture grows and shrinks with it; all we're setting here is how the texture is\nattached to the quad.)\n\n3. A position in 3D space, set via the call to givertexat(). In chis example, we're\nputting the local origin of the sprite at its exact center, which puts the upper-left\ncomer of our quad ac (-m_iWidely!2, -m_tHeight/2). The lewer-right vertex is",
      "content_length": 2990,
      "extraction_method": "OCR"
    },
    {
      "page_number": 511,
      "chapter": null,
      "content": "S22 SectionS Fixel Effects\n\n— re\n\n(mi Wisttiv2, m_itfeight/2), where a_awidth and m_iHeight are the width and\nheight of the sprite, This effectively centers the sprite on its local origin, which is\nneeded so thar when the sprite rotates, it spins around local ro its center.\n\ngltolordub(Oxff, Oxtt, Oxtt, n_iAlpha}:\nglTextoord2f(O.0F, O.0F):\nglVertexst(-m_iMidth/2, -m_itpight/2, 0):\n\nglColordub(Oxft, Oxff, Oxff, m_iAipha);\nDQTaxCoordet(1.0F, OOF);\ngivertexst(-n_iWidth/2, m_iHeight/2, 0);\n\ngiColordub(oxtt, Oxtf, Oxf, m_iAlphah ;\nglTexCoord2f(1.0F, 1.0F);\nglVertexaf(m_iWidth/2, m_aHeignt/‘2, Oo};\n\nglColorsub(Oxff, Oxff, Oxff, m_iAlphal;\nglTexCoord2f(o.0F, 1.0F);\nglvertexaf(n_iwidth/2, -m_iteight/2, 0};\n\nAnd finally, this bit of code ends our scene and puts the graphics stare and matrix\nstack back the way they were when we entered:\n\nglEnd();\nglDisable(GL_TEXTURE 2p);\np1Disabloe(GL_BLEND);\n\nft Pop the matrix we set up above\nglFopWatrix| } f\n\nAdding Effects\nee\nNow that we've got down the basics of drawing, we can add some effects. I's a happy\nenincidence that one of the most sought-after 2D cffects—alpha blending—also hap-\npens to be very easy to do in 31D. To achieve alpha blending. we simply specify an\nalpha value for each of the vertices that make up our sprite. ‘Take anocher quick peck\nat the code above; in che calls to gitolersub(}, the fourth argument (in the example,\nthe m_fAlpha variable) i¢ the alpha value for the vertex, The alpha value is similar to\nthe red. green, or blue color values; it can be anything from 0 ro 255, with 0 repre-\nsenting complere transparency and 255 representing complete opacity. So, for exam-\nple, to create a sprite thar’s “halfway” transparent, we simply need to sct the alpha\nvalue of all four sprite vertices to 128.\nOF course, if we want to create a different kind of special effect, we can vary the\nalpha value of each verrex independently. For example, if we sct the ewo left vertices to\n0 and the ewo right vertices co 255, we get a sprite thar fades gradually from com-\npletely transparent (on its left side) to completely solid (on its right side).\nTo create some colorful effects, we can specify different colors for each of the four\nvertices in our quad primitive. We do this by pucting different RGB values in the call",
      "content_length": 2285,
      "extraction_method": "OCR"
    },
    {
      "page_number": 512,
      "chapter": null,
      "content": "S.1 Using 20 Hardware for 2D Sprite Effect: 523\n\nto git¢eloraub. OpenGL automatically blends the colors together, so if we set the left\nside of our quad blue (RGB(0,0,255)), and the night side red (RGB(255,0.0)), we end\nup with a nice gradient of color going from blue to red across the sprite. In this way,\nwe can add quick highlights of color without having co go to all the trouble of setting\nup an OpenGL light source. Please note that if you dont want OpenGL to apply a\nsmooth color/alpha gradient to your polygon, you can change the behavior by calling\nglShadeModel(GL_FLAT).\n\nScaling our 3D sprite is easy, noo. The good mews is that the 31D hardware tales\ncare of stretching the texture; all we need to de is sec up the vertices of our sprite.\nSuretching of shrinking the sprite is as easy as increasing or decreasing the width or\nheight of our quad primitive. If we wane to seretch the sprite along the x-axis by a fac\ntor of two, we simply make the width of che sprite a_iwidth*2 instead of m_iwidth.\nSimilarly, to stretch the sprire by a factor of ewo along the y-axis, we make the height\nof the sprite m_iHeight*2 instead of m_ikeight. To shrink the sprite to half its size,\nwe divide width and height by nwo. Any possible stretching combination can be\nachieved, and the great part is char you don't have to worry about the individual pix-\nels of the sprite, It’s all taken care of for you.\n\nRotating the sprite is simple, too. Again, irs just vertex position manipulation,\nWe can specify an angle (in degrees) and pass this angle to OpenGL ginotatet func-\ntion, which applies it to the current cransformarion matrix. Again, the individual pixel\nlocations are automatically caleulated by the 3D hardware.\n\nTo create another interesting effect, we might change the axis of rotation for our\nsprice. glRotatet takes an angle and three parameters; these three vector parameters,\nat their simplest, allow us to tell OpenGL which axes we want to rotate abou. It\nmight be worthwhile to rotate about the x- or y-axes, effectively flipping the sprite\nhorizontally and vertically in 3D, rather chan simply rorating abour the z-axis (spin-\nning the sprite).\n\nConclusion\n\nAc first, this approach to 2D sprites might seem like a lot of needless work; irs often\neasier and more familiar to 2D programmers to draw sprites via Aliaing fismerions\n(such as DirectDraw’s B1t() of Win32's Biteit()). However, learning how co “bli”\nwing 30) hardware pays off in the long run, since it ultimately becomes much easier\nto implement advanced 31D effects, such as alpha blending of sprite scaling. In addi-\ntion, for the typical computer system, offloading the graphics processing required for\nalpha blending or scaling to the graphics card is a smart move, since it frees the CPU\nto concentrate on other tasks, which ultimately gives you more room to make a becter\n\nSatie.",
      "content_length": 2859,
      "extraction_method": "OCR"
    },
    {
      "page_number": 513,
      "chapter": null,
      "content": "9.2\n\nMotif-Based Static Lighting\n\nSteven Ranck\n\nThis article describes a way to introduce more dynamic propertics into precomputed\nstatic lighting. The approach produces stunning animated lighting at 2 computational\ncost that is only slightly greater than conventional static lighting.\n\nMany games employ static lighting by precomputing the light colors ar each ver-\ntex. This results in convincing Gouraud lighting at almost no compuration cost, It\nalso produces very staric-looking light. This article describes an algorithm that adds\ndynamic animation to static lighting bur still executes at nearly the same speed as con-\nventional static lighting. For example, two torches close together on a rock wall pro-\nduce firelight on che wall thar flickers and interacts approprianely.\n\nConventional Static Lighting\n\nSad\n\nConventional static lighting is simply precompured Gouraud RGB values stored with\neach vertex and used in a diffuse fashion during rendering, The precomputed RGB\nvalues are generated by either a cool or the game's initialization code. In cither case, 2\ntool is used to place lighes on an object and assign characteristics such as color, inten-\nsity, radius, radial falloff, and light type (omni, directional, spot, and che like). Since\nwere dealing with static lighting, the lights and all their properties are constant. In\naddition, their positions are fixed in the object space of the object they are lighting;\nthat is, staric lights canmot move relative to the object chey arc lighting. From the light\npositions and properties, the effect of each light on each of the object’s vertices ean\neasily be computed using any desired lighting equation. Figure 5.2.1 demonstrares a\nsimplified 2D representation of this concept.\n\nFigure 5.2.1 shows an object with six vertices being statically lit by wo lights.\nVertex 3 falls within only Light A’s influence, Vertex 3 falls within only Light B's\ninfluence, Vertex 2 falls within both lights’ influences, and the remaining vertices fall\noutside boch lights’ influences. Because Light A and Light B are static, they are fixed\nin the object's coordinate space; if the object moves and rorates in world space, Lights\nAand B move and rotate along with the object. Therefore, the RGB lighting compu-\ntation at each vertex can be computed only once (because it never changes) and stored",
      "content_length": 2343,
      "extraction_method": "OCR"
    },
    {
      "page_number": 514,
      "chapter": null,
      "content": "5.2 Motif-Based Static Lighting 525\n\nLight.\n(apiece of mfr)\nTees objet beng re\nshiscadly lt. Comsiscr 2: a\nof wrstices (MEW vi = WaT Wi\nod LrSerapfieg See é a\n\nhee ee\n\nFIGURE 5.2.1. A scattcally-lit mesh objece.\n\nas part of the vertex structure. For this reason, static lighting is useful for lighting\nobjects by lights thar are attached ro the abject, Good examples of this concept are\nstreetlights lighting a street and hull lighes illuminating the spacecraft co which they\nire mounted,\n\nIn Figure 3.2.1, the staric RGB for Vertex 3 is computed simply by using the ver-\ntex’s position and normal with Light A in a conventional lighting equation. Vertex 3\nis similar, bur with Light B. Vertex 2 is influenced by both lights, so the resulting\nRGB is simply the sum of the cwo lighting equations, The remaining vertices aren't\ninfluenced by either light, so their RGB is (0,0,0), and it is then the sole responsibil-\nity of dynamic and ambient lighting to light those vertices.\n\nThe lighting equations used are completely up to the designer's preference and\ncan be as complex and computationally expensive as desized, since they are used for\nprecalculation. Regardless of the actual equations used, we can wire the lighting\n\nfunction as:\nf= ffl, ¥) (5.2.1)\nCr=lel, (5.2.2)\n@ icp\nCe = ie Es\n\nwhere\n\n2 represenes the lighr’s properties (position, intensity, radius, radial Glloff, light\ntype; and so on)-",
      "content_length": 1401,
      "extraction_method": "OCR"
    },
    {
      "page_number": 515,
      "chapter": null,
      "content": "Sections Pixel Effects\n\nrepresents the vertex'’s properties (position, normal).\nAU, Wis the lighting equation.\n/is the light’s scalar incensicy at the vertex, as computed by the lighting equation.\nLy i the light’s color (red component).\nfg is the lights color (green component).\ntn is the light's color (bluc component).\nCys the final red color component, ready to be stored in the vertex structure.\nCis the final green color component, ready to be stored in the wertex structure.\n\n(gis the final blue color component, ready to be stored in the vertex structure.\n\nHere's an example of a lighting equation for a simplified omni-light:\nJIE V) = (Dye) (R-D)/R (5.2.3)\nwhere:\n\nOv. is the unit vector from the vertex to the light.\nMyis the vertex’s unit normal.\n\nis the distance from the vertex to the lighe.\n\nAis the light’s influence radius.\n\nAn omni-light is a point light chat radiares light in all directions. The intensity\nof the light rays diminishes (attenuates) che farther the vertex is from the omai-\nlight's position. In the preceding equation, the (R — 19) /@ term performs this dis-\ntance attenuation. If the vertex lies on the light's position, 0 is O and (R-— D)/R\nreduces to 1, which is the maximum brightness. If, on che ether hand, the vertex lies\non the outer boundary of the light’s influence, D equals Rand (R— D)/ R reduces to\nO. Lf the vertex lies somewhere berween the light’s origin and its outer boundary, (R\n— 2) / 8 produces a number between 0. and 1. More sophisticated omni-lighrs use a\ndistance attenuation function that models the physical world more closely. However,\nthe linear attenuation in our equation is good enough for this example. Of course,\nwe also require that f{2, W) return © if the vertex lies outside che lighr’s influence\nradius (2) > A).\n\nThe first term in our omni-light equation, (D,,*/V¥,9. performs another attenua-\ntion based on the dor product of the lipht ray from the om ni-lighe to the vertex being\nlit and that vertex’s normal vector. This is called a diffise lighting factor and is a very\ncommon way of brightening vertices thar a higher ray hirs directly head-on and cark-\nening vertices thar a lighe ray hits more at an angle, We further imply thar f(D,\"\nis negative, we remurn O for (ZV. Thar is, if a light ray is hitting our vertex from\nbehind, we prevent the ray from lighting the vertex.\n\nEquation 3.2.3 produces a decent looking omni-light, but higher-quality results\ncould be obrained with more complex lighting equations, In any case, Equation 5.2.3",
      "content_length": 2516,
      "extraction_method": "OCR"
    },
    {
      "page_number": 516,
      "chapter": null,
      "content": "5.2 Moti-Based Static Lighting 527\n\nyields a single sealar, which is the overall intensity of the light at the vertex. Equation\n3.2.2 then multiplies cach component (red, green, and blue) of the light’s color by\nthis intensity, producing the final three-color components to be stored in che vertex\nstructure. Ar render time, these color components are simply retrieved and used\ndirectly to Gouraud light the object. Here's a possible vertex structure and the render-\nnme OpenGL code fragment to draw a starically lit wianele:\n\nPinclude \"mtxlib.h'\n\ntypede? struct {\nfloat TR, TG, TB; Jf Static AGA color (0.0 -» 7.0)\n} Coler_t;\n\ntypedef struct {\nvectors Pos; f/f This vartex's 30 position in model-space\nColor_t StaticGolor; ff RGB to be used for this vertex\n} Vertex_t;\n\nvoid OrawyTriangle( const Vertex_t \"pil,\nCONST Vertex_t “pV2Z, const Vertex_t *pwa } {\nglBegin( GL_TRIANGLES 4;\n\ngltolorsf( p¥i->StaticCelor.¢R, p¥1-2StaticColor.1c,\npVi->StaticColor.1B };\ngivertexdt( pWi->Pos.\", pVi->Pos.y, pVI->Fos.z J:\n\nGiGolorat( pi2->Staticlalor. fh, p¥v2--5taticColor.fG,\np¥2->Staticloler.#B }:\ngivertexst( pv2->Pos.4, pVv2->Pos.y, PVE-FFos.z ):\n\ngitolorst( pVa->Staticlelor.fA, pva-\"StaticGolor.tG,\npVS-=StaticColor.?e 4}\nplvertexst( pva-sFos.%, p¥a->Pos_y, pWG->Fos.z 1\n\nplend();\n}\n\n(ne drawback to conventional static lighting is that it does produce static results.\nThat is, the RGB values for the vertices are constant from one rendered frame to the\nnext. They do norvary at all. For sunlight, moonlight, and many other non-changing\nlight sources, this isnt a problem, However, for more complex light sources such as\nflickering neon tubes, torch flames, campfires, and blinking hazard lights, conven-\ntional static lights cannot be used because they require the RGB values to animate from\none rendered frame to the next. Conventional static lighting cannot achieve this result,\nat shown in the example code. This is where motif-based static lighting COmes In.",
      "content_length": 1958,
      "extraction_method": "OCR"
    },
    {
      "page_number": 517,
      "chapter": null,
      "content": "Motif-Based Static Lighting\n\nThe advantage of conventional static lighting over dynamic lighting is execution\nspeed. There simply are no run-time computations performed: RGB values are\nretricved [ram the vertex structure and Plugged clirectly inco the color values for the\nrendering vertex. However, the drawback is thar static liphring produces static results,\nThe RGB values for each vertex are precomputed, stored, and never change from\nframe to frame. Motif-based static lighting provides a more dynamic look than con-\nventional static lighting at a negligible performance hit.\n\nMotil-based staric lighting is still a form of static lighting. Thar is, the static lights\nlighting the object are fixed in the object's coordinate space, as is the case with con-\nventional static lighting. However, with motif static lighting, we are able te animate\nthe RGB components of the lights in real time, The type of animation is completely\nup to the designer. Some animations, such as a light switch on the wall of a room that\ntums on the room's light, might be under che player's concrol. Orher animations, such\nas lames, flickering lights with electrical shorts, and blinking lights, might be algo-\nnthmically controlled. Furthermore, some lights might have constant RGB values.\nEach of these animacions (including chose that are constant) is called a Highs moif.\n\nTo implement mocif-based static lighting, the game needs a motif table that con-\ntains an RGB entry for every light motif. The motif table acts as a palette, as we'll see\nlater. Figure 5.2.2 shows an example of a nine-entry mouf table. Each entry holds an\nRGB color. Depending on the cype of motif, the RGB color is either precaleulated ar\ngame-initialization time er computed dynamically once per frame. Regardless, the\nRGB values stored in the motif table are full-intensiry, unattenuared light colors.\nInstead of storing RGB colors directly in the vertex structure (as we did before with\nconventional static lighting), we now simply store an index in the vertex struceure that\nindexes into the motif table, We'll go inte detail on this concept soon.\n\nFor constant motif lights for which the color remains constant from frame to\nframe, the RGB value of the light (that is, the light’s raw, unattenuated color} is sim-\nply stored in the motif table at initialization time and left there for the duration of the\ngame or level. In Figure 5.2.2, table entries 7 and § contain the RGBs for two con-\nstant motifs: dark red and bright blue,\n\nFor mot lights for which the color is controlled by the player (eg.. a light\nswitch), the RGB value is updared when the event happens (the player flips the light\nswitch, for example). In Figure §.2.2, table entries 4 and 5 contain the RGBs for ewo\nstatic lights controlled by light switches, Initially, they might both contain\nRGB=(0,0,0), sec during initialization. When the player turns on Switch 0, the game\ncode stores the color of the light in entry 4, For example, if the light is a bright green\nlight, wed store RGB=(0,1,0) into encry 4. If the player turned the light off again,\nwed store RGB=(0,0,0) into entry 4. In Figure $.2.2, entry 5 is for another swirch\nthat controls a differenc see of lights that could be located either in an entirely differ-\nent room or in the same room. It is completely possible that the nwo lights are close",
      "content_length": 3344,
      "extraction_method": "OCR"
    },
    {
      "page_number": 518,
      "chapter": null,
      "content": "6.2 Motif-Based Static Lighting 529)\n\n——— SS\n\nenough that they affect the same vertices in the same room (similar to the way both\nLight A and Light B affect vertex V2 in Figure 5.2.1). If this is the case, the player\nexpects to see the twa lights interact and light the room properly with the actions he\nor she takes with dhe two light switches. We'll see a little later how motif static light-\ning handles cases like this one\n\nEntries 0 through 3 in Figure 3.2.2 contain ah animated RGB color for a flicker-\ning torch. Motifs such as these are algorithmically implemented and updated Once per\nframe. Here's a code fragment that generates a flickering flame motif, called once per\n\nframe =\n\n#defing FLAME SPEED 4.0f\n\nif Constants determined via axperimentation:\nfdetine FLAME Ka (0.0937 * FLAME SPEED)\nfdefine FLAME K? (0.1377 \" FLAME SPEED}\ndefine FLAME Ko (0.1957 \" FLAME SPEED)\nAdafine FLAWE K4 (D.1e6f = FLAME SPEED)\nFdefine FLAME KS (0.170 = FLAME SPEED)\n#define FLAME KG (0.287f © FLAME SPEED)\n\nii Generates the RGB color for a particular frame of the flame\n\nif motif and stores it in \"*pColor. nGameFranmeGounter is singly\n\nif the frame numier of the game's current frame and is\n\nfj inerenented once per tranc.\n\nvold GenerateFlamelotif{, unsigned int mianeFrameGounter,\nColor_t \"pGelor } {\n\nFIGURE 5.2.2. Example azotif table.",
      "content_length": 1333,
      "extraction_method": "OCR"
    },
    {
      "page_number": 519,
      "chapter": null,
      "content": "Section 5 Pixel Effects\n\ncouble @SinSun;\nfloat fIntensity, tangle;\n\nTAngle = (float}nGanerFrameCaunter;\n\ndéinsum =\nsint TAngle * ]\n+ sin( TAngle * ]\n+ sin( TAngle \" FLAME KS }\n+ sin( TAngle * Ke j\n+ sin{ fAngle * }\n+ sin{ fAngle *\n\nTintensity = (float)dSinSum * o.1f;\nintensity += 0.77:\n\ndif( TIntensity => 1.0T ) {\nfintengsity = 1.0:\n}\n\nplolor-=th = fIntensity;\nplolor->tG = fIntensity * O.4f;\npeolor->fh = O.o0f;\n\n}\n\nAr the top of each game loop, the game calls GenerateFlamemotit() ro generate the\nflame motif and then stores che resulting RGB into dor 0 of the motif rable. It's likely\nthat a room has more than one torch, and if all che torches used the same motif, they\nwould all flicker in syne and would noticeably look bad. So, in our motif table, we\noffer a variety of torch moarifs so that the desipner can assign different torch motifs to\nneighboring torches. Often, it is not necessary to write different algorithms to have a\nvariety for a particular motif. Instead, simply phase shifting the frame counter and\ncalling the same algorithm function suffices and provides stunning results for a frac-\nHon of the work,\n\nModif light algorithms are usually simple functions, but even if a more computa-\ntionally expensive function were needed, it would still be executed only once per\nframe, and so the overall performance impact on the game is likely to be negligible. In\nthe preceding code, for example, the CPU overhead of calling sim() six cimes once per\nframe is insignificant compared with the 1/60th of a second the game has to execute a\nsingle frame. Even so, the overhead could be minimized by wHiting a custom sin{)\nfunction that performed a table lookup at the sacrifice of precision, because precision\nisnt very important for lighting computations. In any case, the beauty of motif-gen-\nerator functions is that they're called only once per frame, as opposed to dynamic\nlighting calculations that are executed once per vertex per frame!\n\nNow that we have established the motif table, let’s curn our attention co the ver-\ntex structure. For conventional static lighting, the precomputed RGB color was stored\ndirectly in the vertex structure. However, for motif-based static lighting, we need to\ndefine the vertex structure differcnuly, like chis:",
      "content_length": 2264,
      "extraction_method": "OCR"
    },
    {
      "page_number": 520,
      "chapter": null,
      "content": "5.2 Motif-Based Static Lighting S31\n\ntypede? struct +\nWeCtard Pos; if This vertec's 30 position in aedel-space\nint oMatit Index; if Indax into the moti? table\nfloat fintensity; Ji Intensity of the light motif's\ni? FOB at this vertax\n} Wertex_t;j\n\n‘The vertex structure removed the StaticColor field and replaced it with the nila -\ntifindex and fintensity fields. These fields cell che rendering engine which light\nmotif from the motif table to use as well as the intensicy of the light motifs RGB ar\nthat particular vertex. Both of these values are established ac cither tool cime or game-\ninitialization time. Che motif index simply replaces the lighr’s color property; instead\nof the designer placing a campfire light and assigning ir an orange color, a motif is\nassigned instead. The designer positions the light and assigns the light properties such\nas intensity, radius, radial falloff, and light pype as usual. However, when assigning the\neolor, the designer can choos: a motif fom a set of possible motif values. For the\ncampfire example, the designer might select the torch mosif. This morif describes nor\nonly the color but also the animation of the static light. The torch motif ernulares a\nflickering flame both in color and animation of color.\n\nThe fintensity Geld is simply I from Equation 5.2.1, which is the lighting equa-\ntion we used for conventional static lighting, applied to this vertex. The position of\nthe light and the light properties thar che designer has set interace with the vertex posi-\ntion and normal to produce J, which is simply the intensicy of the lighe ar chat vertex.\nRefer to Equation 5.2.3 for an example of how all chese parameters interact to yield I\nfor an ommni-lighe.\n\nNow that we have the intensicy (from the fncensicy field in che vertex strucnure}\nand the RGB color (from the motif table encry indexed by the nMotitindex field in\nthe vertex structure), we have everything we need to compute Equation 5.2.2 for our\nvertex's final run-time RGB values.\n\nHere's an OpenGL code example char renders a motif statically lit triangle:\n\ntypedef onum {\nMOTEF_FLAMEO,\nMOTEF_FLAME1.\nMOTIF FLAME2,\nMOTIF_FLAMES,\nMOTIF _ S81 TCHO ,\nMOTIF_SW1ITCHI ,\nMOTIF_LIGHTMING ,\nMOTIF_DARK_RED,\nMOTIF_BRIGHT_BLUE,\n\nMOTIF COUNT\n} Motit_a;\n\nColor_t aMotifTabla[MOTIF_COUNT];\n\nwoid DrawlyTriamgla( const Vertex_t \"pvt,",
      "content_length": 2337,
      "extraction_method": "OCR"
    },
    {
      "page_number": 521,
      "chapter": null,
      "content": "Section Pixel Effects\n\nconst Vertex t “pW2, const Vartex_t \"pa 4) f\nGolor_t *pColor;\nfloat TR, fG, fB;\n\ng1Bagin( GL_TAIAMGLES }:\n\npeolor = SaWotifTable] pVv1->nMotifindex |;\n\nFR = pColor->fA * pV1->fIntensity;\n\n7G = pColor->f6 * pVi-=TiIntensity;\n\nTB = pColer->f8 * p¥i-=flintensity:\n\ngiteloraf( TA, fG, fB };\n\nglvertexat( pvwi->Pos.™, pV1->Pos.y, pl->Pos.z jr\n\npColor ~ SaWotitTable[ pV¥2->nuotit Index Fe\n\nTA = plolor->th * p¥ve->fIntensity:\n\nTG = plolor-23G * p¥2->fIntensity;\n\nTh = pOolor-of8 \" pv2->fIntensity;\n\ngitolorafi fh, #G, TE }:\n\npiveartexat( p¥2->Fos.x, pW2->Fos.y, pW2->Pas.z 3\n\npGolor = SaMstitTable[ pv3->nllotifindex |:\n\nTR = pColor->fR * pV3->fIntensity:\n\n7G = pColar->#G * p¥d->fIntensity;\n\nTH = pColor-2t8 * p¥a->fIntensity;\n\ngicolorati fA, TG, fo jz\n\nglvertexSt( pV3->Fos.x, pVa->Pos.y, pva->Pos.z J:\n\ngiEnd(} 3\n}\n\nThis implementation suppores only one motif per vertex, which isn't tea helpful\nwhen a model has a vertex under che influence of more than one static light (as in Fig-\nure 3.2.1). To support more than one motif, we need to extend the vertex structure so\nthat it hat a mociffintensity pair for each motif light affecting it, A general solution is\nshown here:\n\ntypedat struct {\nint nMotifindss; ff Index into the motif tabla\nTinat fiatensity; ff Intensity of the Light motif's\niy} AGB at this vertex\n} MotifEntry_t;\n\ntypedef struct {\nvectors Pos; if This vertex's 3D position in model-space\nint mMotifentryGownt; /! Number of motif entries\ni/ pointed to by pMotifentry\nMOTITENtry_t \"pMotifentry; // Pointer to an array of\n\nff Motatentry t structures\n} Vartex_t;\n\nThis implementation provides for any number of motifs, but it can be complex to\nimplement. Another solution is easier to work with bur is less flexible and could con-\nsume more memory:",
      "content_length": 1782,
      "extraction_method": "OCR"
    },
    {
      "page_number": 522,
      "chapter": null,
      "content": "5.2 Moatif-Based Static Lighting 533)\n\nAdatineg MAX_MOTIFS _PEA_VTX iy If Inpléesentation-specific value\n\ntypedef etruct {\n\nweetord Foe: Jy This vwartex's 20 position in sodel-space\nint nMotifEnteyCount; i) Musber ef motif entries in\n\niy aWotifEntry[]\nWotitEntry t aMotifEntry [WAX MOTIFS PER VTx];\n\n} Vartex_t;\n\nWe'll work with chis last implementation for darity, but advanced developers\nshould consider che more general implementation,\n\nTo support more than one light influencing a particular vertex, we simply per-\nform the motilfatenuate computation descobed carlier and then sum the colors\n\ntogether, like his:\n\nvoid ConputeVertexColar( const Vertex_t \"pv, Color_t “pColor j {\n\n}\n\nColor_t *pWotifGelor;\nTloat TH, TG, TB;\nint i;\n\nff Zere color components:\nTH = fG = fB = O.0F;\n\nff Step through all the motifs affecting this vertex\nff and sum their colors:\nfor( i-0; i<pv->niotifintrytount; i++ ) ff\npMotifColor = SavotifTable|\npy: >allotiféntry(i)-nMatitindgsx 15\nfR += plotifGolor-=fA \" p¥-Sallotitentry[i] .tIintensity:;\nf& += plotifGolor->fG * py->allotitentry[i].tintensity;\nFB += pliotifGelor->f6 * pil->allgtifentry[i]-fintensity;\n}\n\nfi Make sure final calor is from 0 to 1:\nif( fA > 1.0f ) fA = 1.0f:\nif( fG > 1.08 ) f@ = 1.0f:\nif( fh > 1.0f ) #8 = 1.0f;\n\n/? Store final colors in return variable:\n\npGolor->fH = fR;\npeolor->+f@ = fG;\npGolor->f8 = fB;\n\nvoid OrawMyTriangle( const Vortex_t \"p¥1, canst Vertax_t *pV2,\n\nconst Vertex_t \"pia ) {\nColor_t Color;\n\nplBegin( GL_TAIANGLES );\nComputéeVertexColor| pvi, &Colar j;\n\ngitelorsf( Color-fH, Color.7@, Color.fB };\npivertexst( pil->Fos.u, pYi--Pos.y, p¥1->Fosg.z );",
      "content_length": 1623,
      "extraction_method": "OCR"
    },
    {
      "page_number": 523,
      "chapter": null,
      "content": "534 ; Section Pixel Effects\n\nComputevertexGolor( p¥2, &Golor );\nglColoraft( Color.fA, Color.tG, Color. f8 };\ngivertexaf( pv2->FPos.2, PV2->Poe.y, P¥E->Pas.z j;\n\nComputeVvertextolor( pv3, &Golor );\nglGolorsf( Coler.fA, Color.?G, Color. fe };\ngivertexaf( pVad->Pos.x, pVa-=Pos.y¥, pva->Pas.z };\n\nglEnd();\n\nConclusion\n\nFor a performance cost slightly higher than thar of conventional Ligh rig and far less\nexpensive than dynamic lighting, mocif-based static lighting can help bring a scene to\nlite by providing RGB animation for precompured light data. Campfires, flickering\ntorches, electrical shorts, beacon lights, and more are now possible withour having to\nuse expensive dynamic lights.",
      "content_length": 688,
      "extraction_method": "OCR"
    },
    {
      "page_number": 524,
      "chapter": null,
      "content": "0.3\n\nSimulated Real-Time Lighting\nUsing Vertex Color\nInterpolation\n\nJorge Freitas\n\nReal-time lighting effects are an essential part of today’s 3D gaming experience but\ncan be computationally intense for systems with limined resources, On such systems,\nthe visual effect of real-time lighting can be simulared by interpolating between pre-\nealeulated sets of vertex colors.\n\nThis technique was originally developed for use with human figures in a spores\ngame, Twenty-three Heures were to be drawn each frame, using skinned models with\na multiple vertex weighted, skeletal hierarchy. The primary goal was co climinare\ncostly lighting calculations from the rendering pipeline while retaining the look of\nreal-time lighting.\n\nThe lighting in the world consisted of either the sun or four static floodlights and\nan ambient lighting value used to darken figures running into shadow, There were\nalso several special lighting effects, including the reflection of the grass color on the\nplayers’ socks and shorts, projected shadows under arms and between Ices, and col-\nored lighting based on the current weather condition or time of day, In addition, dur-\ning a night game, the lighting “hot spot” needed to be positioned relative wo che\nclosest Hoodlighe.\n\nAn inexpensive way of calculating changing lights on the figures needed wo be\nfound. Precalculation was the answer. As much information as possible regarding che\nlighting was precalculared. Ideally, the lighting for every pose and each possible rora-\ntion of the figure would have been precaleulated, but that was impractical due vo the\namount of memory required to store che information.\n\nInstead, the lighting was precalculated fora number of fixed rotations, and inter-\npolation was used to generate the vertex color values for the given figure's rotation.\n\nLighting Method\n\n‘Typically, the method for generaring real-time vertex lighting goes like this:\n\nEas ba]",
      "content_length": 1916,
      "extraction_method": "OCR"
    },
    {
      "page_number": 525,
      "chapter": null,
      "content": "536 SectionS Pixel Effects\n\n. Transform the normal for each vertex in the object.\n\nDetermine the angle at which the light is facing the vertex normal,\n\n. Using the facing angle, determine the intensity of the light at that vertex.\n. Repeat for each light illuminating the vertex.\n\n. Add the ambient light intensiry.\n\nes\n\nReal-time lighting using the above method requires many computations, which\nwe reduce dramancally using the interpolation method.\n\nIn order to fake the real-time method, we must set some constraints on our 3D\nscene:\n\n* Determine how many light positions are needed for the interpolation.\n* Determine the axis of rotation used to base the interpolation calculation.\n\nThe vertex cobor lists represent the lighting on che abject at distinct orientations of\nthe figure relarive to the lighting in the scene, whether the lighting is one light source\nof 100. A full 360-degree rotation is required, so we must determine how many vertex\ncolor lists we will use. A minimum of three positions ix necessary, each 120 degrees\napart. Note that by using more lists, we decrease the range of values we must interpo-\nlate berween, thereby increasing the accuracy of our faked lighting.\n\nArtwork Creation\n\nWe assume that the vertex color lists are generated in a 3D content creation applica-\nton. OF course, it's possible no use a real-time lighting method to generate the vertex\ncolor lists, bur the artistic task of attractively lighting a 31D scene should be left to\nthose most qualified: the artists.\n\nIn our example of human figures, the axis of rotation used to determine che light-\ning angle was assumed to be the vertical axis (typically named Yin a left-handed cour-\ndinate system) because the figures always ran around on a flat plain (a grassy field),\n\nThe example in Listing 5.3.1 uses four vertex color lists, cach penerated 90\ndegrees apart. Using a power of 2 number allows us to shortcut some of the integer\nmath by replacing multiplies and divides by shifts, and MODs with ANDs. However,\nfor the sake of clarity, the example code does not use integer shore cuts,\n\nLights are added to the 3D scene corresponding to the lights in the game world.\nAny number of lights can be used without impacting performance, since the resulting\ndata will be lists of vertex colors.\n\n‘The first vertex color list is assumed to represent the lighcing when the ebject is at\na rotation of 0 degrees. The object is artistically lit at four rotations, each 90 degrees\nfrom the previous one, The lighting for each rotation is saved asa vertex color list, cre-\nating four lists of vertex colors char will be used in real time.\n\nThe vertex colors can be tuned by the artiss in the 31D creation application to pro-\nduce some of the desired special effects. Green can be mixed into the lower leps to rep-\nresent the reflection of the grass color, the areas between the figure’s legs and under",
      "content_length": 2886,
      "extraction_method": "OCR"
    },
    {
      "page_number": 526,
      "chapter": null,
      "content": "6.3 Simulated Real-Time Lighting Using Vertex Color Interpolation Sa7\n\nthe figure's arms can be darkened to give the impression of projected shadows, and the\nfigure'’s skin can be tinted to indicare racial skin tones.\n\nInterpolated Lighting\n\nHere is an explanation of the steps necessary to gencrace the interpolated vertex light-\ning.\n\nCalculate Facing Angle to Virtual Light Source\n\nThe vertex color lists represent the lighting on the object at distinct orientations rela-\ntive to the light source. The position of the light source can be stored as a simple addi-\ntive value, representing the direction of the light in the scene. The facing angle is\ncalculated by adding the offset to che object's rotation and using the remainder from\ndividing hy the number of degrees in one full rotation (360).\n\nfacing angle = ( object rotation + additive light position } % 360\n\nNote that the light can be “rotated” around the object by cycling the additive\nlight position valuc berween 0 and the number of degrees in one full rotation.\n\nDetermine Which Two Vertex Light Sets ta\ninterpolate Between\n\nBased on the facing angle, we must determine which owo sets of vertex colors in our\ntable between which we should inrerpolare (the base color list and the target color\nlist), Each set of vertex colors was pre-generaced using the same delta, 90 degrees\napart, in. our example, We divide the current rotation by the delta value between each\nset of vertex colors, which becomes the base color list. The target color list is the next\nvertex color list in our table.\n\nbase color list = facing angle / vertex color delta\n\nif {| base color liat == last vertex color list }\ntarget color list = first vertex coler list\n\nelse\n\ntarget color list = next wartex color list\n\nCalculate Interpolation Percentage\n\nWe need to determine how far berween the owo vertex color lists to interpolace. This\npercentage represents how close to the target color list we should interpolate. The per-\ncentage is calculated by dividing the remainder of the base color list calculation by che\nvertex color delta, giving us a value berween 0.0 and 1.0,\n\npercentage = ( facing angle % wertex color delta ) / vertex colar delta",
      "content_length": 2183,
      "extraction_method": "OCR"
    },
    {
      "page_number": 527,
      "chapter": null,
      "content": "533 Section S Pixel Effects\n\nFor Each Vertex Color, Perform the Interpolation\nWe now calculare the vertex color list representing the current lighting for the object.\nTo calculate each vertex color, each color component (RGB) must be interpolated,\nand we repeat the process for each vertex in the object.\n\ncolor = old color + ( maw coler - old color } * percentage\n\nFor Each Vertex Color, Apply an Ambicnt Light AGB\nModifier and Clamp Resulting Values\n\nOptionally, we can apply an ambient light modifier to the calculared vertex color list.\n\nThe modifier can take the calculated color out of the acceptable range for each com-\nponent (0 to 255), so we must clamp each component separately.\n\ncolor component = color component + ambient color\n\nif { color conponent = 6 }\ncolor component = o\nelse\n\nif { coler conponent > 255 )\ncolor component = 255\n}\n\nNote thar the precaleulated vertex color lists can be created to ensure the ambient\nlight modifier doesn't take the calculated vertex colors our of the acceptable range. By\nlimiting the smallest and largest values for each color component and by limiting the\nsize of the ambient color modifier, the damping becomes unnecessary.\n\nConclusion\n\nThis technique is effective for reducing the number of calculations necessary to repre-\nsent real-time: lighting and has been used on PCs and game consoles. To generate a\nsingle vertex color requires only three subtractions, chree multiplies, and three adds\n(six adds if an ambient color is used). Even if real-time lighting is necessary in your\nSD game, interpolated vertex color lighting can be combined with real-time lighting\nto help relieve same of the computational burden of rendering your scene.\n\n‘To further decrease the number of computations, you need mot perform the light-\ning calculations for every rendered frame. By keeping a unique verrex color buffer for\neach object, the lighting can be calculated once every nwo, three, or four frames,\ndepending on the rate at which the object changes orientation relative to the light\nsource. Further savings can be had by alternating che objects chat are being re-lit each\nframe.\n\nAlthough this method is very simple, with it an extremely complex mathematical\nmodel can be precaleulared, Remember, we'te crying to achieve the perception of real-\nistic ligheing effects in our 3D games. The viewer doesn't care what mathematical",
      "content_length": 2373,
      "extraction_method": "OCR"
    },
    {
      "page_number": 528,
      "chapter": null,
      "content": "Ss. Simulated Real-Time Lighting Using Vertex Color Interpolation 539\n\nmethod has been employed vo create the effect, just that it makes the game world look\ncool.\n\nListing 5.3.1: Example Code\n\nFor this example code, we assume there is one vertex color per vertex in the object.\nNore thar the data structures contain only the information necessary for the vertex\n\ncolor interpolation. The divides and MODs (96) can be replaced with shifts and\nANDs, but these have been omitted for clarity.\n\nif\n—_\nif defines\nif\nif\n/* number of vertex color lists */\n\ndefine MUMBER_OF_AnGE LISTS 4 /* number of radians in 360 dagrees */\nfdefine WUMBER_OF_AADTANS 1024\n\nif\n\nif :\n\nif structures\n\nif =\n\nif\n\ntypede? struct\n\n{\nfloat alpha;\nfloat rad:\nfloat green;\nflaat blue;\n\n}ABGE_ DEF:\n\ntypedef struct\n\ni\" angle used for simulated lighting */\n\nint angleothotation:\n/* number of vertices in object */\nint nvertax;\n\n/* pointers to vertex color lists \"/\nARGE_DEF  “pARGA[ MUMBER_OF_ARGS LISTS J;\n}OSJECT_OEF;\n\nif\n\ni\n\nff variables\n\nif\n\nif\n\n‘* pointer to buffer usad to store the calculated AGH's */\n\nARGH DEF *opVartexColorautfer; |* global additive ambient light AGe */\nARGS DEF gémblentlight; /* additive value to offset light “hot epot\" */\nint glightOffset;\n\nfi\n\nie",
      "content_length": 1243,
      "extraction_method": "OCR"
    },
    {
      "page_number": 529,
      "chapter": null,
      "content": "Section’ Fizel Effects\n\nif tunetions\nif\nif\n\nPPT eee eee\n\nFunetion ; interpolateVertexAGas\nLinearly interpolates between two lists of vertex colors.\n\nInput:\nARGE DEF “piraA - pointer to first source vertex color list\nARGE_DEF *pSrch - pointer to second source vertex\n\neolor list\nARGE_DEF *pDest - pointer to storage for calculated\n\nvertex colors\n\nant nAnGE ~ number of vertex colors to interpolate\nTloat Percentage = amount to interpolate between two vertex\n\ntables (0.0 - 1.0)\n\nOutput:\nFills pOest with the caloulated vertex colors\n\nited ll et tedetettt tte L o |\n\nWedd interpolateVertexRGbs|\nARGG_DEF “para, /\" pointer te saurce vortex color data ™/\nARGG_DEF *pireBh,/\" pointer to seaurce vertex color data ™/\nAROB_DEF *plest,/\" pointer ta dest vertex color data */\nint nARGE, i\" number of vertex colors to interpolate \"/\nfloat percentage ) /* interpolation anount, O te 1 */\n\n{\nint index; \"index into arrays of ANGE DEF's *;\nfloat red, {* temporary storage tor coleulated Ra's *;\ngreen,\nblue;\n\nfor { index = 0; index < mARGB: indexe+ }\n{\nfi\nif calculate interpolated ARGE\nif\nred = pSrcA[ index ].red + { pSreBl index ]_red -\npSrcAl index ].red } * percentage:\ngreen = pGreAl index ].green + ( pareBl index |.green -\np&rcA[ index ].green } * percentage;\nblue = poreAl index ].blue + { pSrcB[ index ].blue -\nPSroA[ index ].blue } * percentage;\nif\nff add ambient Light\nif\nred += ginbientlight.rad:\ngreen += gAnbientlight. green:\nblue ‘= gAnbientLight.blue:\nif\nii clamp AGE's\nif",
      "content_length": 1476,
      "extraction_method": "OCR"
    },
    {
      "page_number": 530,
      "chapter": null,
      "content": "5.3 Simulated Real-Time Lighting Using Vertex Color Interpolation 544\n\nif ( red > 255.0 )\nred = 265.0;\nalse\n\nif { red = 9.0 }\nred = o.0;\n\n}\n\nif { green > 255.0)\ngreen = 255.0;\n\nelse\n{\nif { green < 0.0 )\ngreen = 0.0;\n}\nif { blue > 255.0 }\nBlue = 285.0;\nelse\naf ( blue < 0.0)\nblue = 0,0;\n}\nif\n{i store reselts\nif\n\npOest[ indax ].red = red;\npOest[ indax ].green = green;\npierst[ indax ].blue = blue;\n\n}\n\njtett dtd he CE eee ee ne 2\n\nFunction : caloulateSinylatadLighting\nCalculates the vertex colors used to represent tha lighting at the given\nangle of rotation.\n\nInput:\nORIEGT BEF \"ptaject - pointer to object structure\n\nhe ae ae ee ee\n\nvoid calculateSimulatedLighting( OBJECT_DEF \"pObject j\n\n{\nfloat parcentage\nint quadrant;\nint angleothoetation:\n\nARGE_OEF \"parca,\n\"pores;\n\nangletfhoetation = [ poject->angledfaatation +\nplightOtfset ) % WUNBER_OF RADIANS:",
      "content_length": 855,
      "extraction_method": "OCR"
    },
    {
      "page_number": 531,
      "chapter": null,
      "content": "SectionS Pixel Effects\n\npercentage = [tloat) (angleifRotation 4%\nHUMBER_OF_ARGB_LISTS ) /\n(float) ( NUWGER_OF_RADIANS / NUMBER_OF_ARGH LISTS };\n\nQuadrant = angleOffietation / { NUMBER_OF RADIANS |\nWIMBER_OF_ARGB LISTS ):\n\nParcA - pObject->pAnGe[ quadrant J;\n\nif ( quadrant == (NMUMBER_OF_ARGB LISTS - 1 ) }\nporch = pObject->panGsy o ];\n\nelse\nPSrch = pObject->pAnGa[ quadrant + 7 J;\n\ninterpolatevertexAGhs( péres, pares,\nopVertexColorauffer,\npObject-+nVertex, percentage 4);",
      "content_length": 473,
      "extraction_method": "OCR"
    },
    {
      "page_number": 532,
      "chapter": null,
      "content": "0.4\n\nAttenuation Maps\n\nsim Dietrich\n\nVertex lighting is good for many applications and is well known and understood. It\nhas many benefits, including the benefit of properly handling surfaces not facing the\nlight, but vertex lighting can have artifacts when the size of the triangle is large with\nrespect to the range of a poine or spotlighr,\n\nJaehe maps are another approach to calculating lighting that can avoid these cri-\nangle tessellation-relared artifacts, but they require expensive CPU operations to\nupdate for dynamic lights and require potentially slow upload to the video card. Suill,\nlight maps are a good solution for static lighting and shadows.\n\n‘This artide introduces a novel technique known as attenuation maps. This tech-\nnique can be used to implement dynamic point lights with proper quadratic attenua-\ntien using multitexture operations. In addition, the technique can be used for\nspherical, ellipsoidal, cylindrical, and rectangular lighting or CSG operations, accu-\nrate te 2 per-pixel level, wiehout using the stencil buffer.\n\nExplanation\n\nThe attenuation function for lighting is typically like se:\nx = lightPosition.™ - vartexPosition.%;\n¥ = lightPosition.¥ - vartexPosition.¥;\nZ£ = lightPesition.2 - vertexPosition.7;\nD = aget(xex # ¥*¥ + Z*z):\nAtt = 7 / (G0 + Ci\" + G2*p*p):\n\nPor our purposes, we assume that we want only quadratic attenuation, so assume\nthar COis 1 and Ci is 0, giving:\n\nAct = 1 7 qi + C2o*D);\n\n3D textures provide a simple method of encoding this function. Directly store\nthe function in a 30 rexture as a function of X. ¥ and 2 for the three texture coordi-\n\n543",
      "content_length": 1611,
      "extraction_method": "OCR"
    },
    {
      "page_number": 533,
      "chapter": null,
      "content": "Sections Pixel Effects\n\nnares. Then, simply set up texture coordinate generation to calculate dX, d¥i and di?\nrelarive to the light position, use the texture matrix to scale each dX, dV and dz by 1\nover the light’s range, and scale and bias so the center of the texture comesponds to\n(0,0,0).\n\nThe equation that the texture matrix computes in this case is:\n\n((Light.% — Wertex.x) / Liaghthange}) / 2.07) + o.5f;\n((Light.¥ = Yertex.¥) / LigntAange) | 2.0f) + o.5f:\n\n5\nT\nFR {({Light.2 -— Vertex.zZ) / LigntAange) s 2.07) + O.5T:\n\n“a6\n\nHowever, 3D textures aren't yet widely available, so we must make do with 7D\nand 11) cexqures. Even were 31D textures available, it would be advantageous to find a\nless Texture memory-intensive method of calculating attenuation.\n\nWell, first, since we have only 2D and 1D textures available, thar means chat we\ncant compute the function with only a single texture because we can't use all three\ncoordinares X, Fo and 2 at once. This means that we have to break che function ince\ntwo OF More parts.\n\nHow can we express the attenuation function in such a way that we can imple-\nment it using 2D) and 1D textures? Let's start by breaking X and Y into a 2D texture\nand # into its own 1D texture.\n\nMowe break X and Finto one texture and 4 into another, thar means chart the\nresult of the function of Nand Y, which we call ¢(x,¥), and the resulr of the function\nbased on 2, which we call g(7), must be expressible as colors.\n\nIn ether words, if we are storing che function as some combination of two tex-\ntures, we must express the final function as a sum or multiplication of two colors,\nSince colors can hold only positive values from 0 to 1, this affecrs which form of\narenuation function we can choose.\n\nThe previous attenuation function is:\n\nAtt = 1 / (1 + c2*0*D);\n\nSome samples of this function follow:\n\nAnfdj==]\nAp? )== 05\nArf Large D ) approaches 0\n\nAs D pets larger, the artenuation approaches 0.\nLets try to encode this function in nwo textures. First, we expand 2*D into its\ncomponents:\n\nBD = sqrt(xX*X + W!¥ + ZF?)\nOF = (x*x + y*y + F*Z)\n\nNow we restate the artenuation function in terms of XK and 2",
      "content_length": 2139,
      "extraction_method": "OCR"
    },
    {
      "page_number": 534,
      "chapter": null,
      "content": "5.4 Attenuation Maps HS\n\nAtt = 1 / (1 + Gae{xex + Yer « 2e7})\n\nNow ir seems we are stuck because we cant express the Act function as the sum or\nproduct of the two functions f(%,¥) and (2%) due to the face thac.¥, F. and “are all\nin the denominator. We have to find another function that we can separate.\n\nWe dont have any way of summing two colors and then taking a reciprocal, so we\nhave to find a function that has the same effect but doesn't require a reciprocal,\n\nSquaring numbers greater than one produces larger numbers, wheteas squaring\nnumber in the range (0..1) produces a smaller number. For instance, 0.5 * 0.5 equals\n0.25. This is why we had to ser che constant in our artenuation function, CO, co 1: In\nprevents really close lights from becoming brighter than they should.\n\nRemember that colors are always expressed in the range [0.1]. That means char\nthe result of f(x, ¥) and g(Z) must produce results in the same range [0..1].\n\nOne function that both does nor require reciprocals and produces results within\nthe range [0.1] is:\n\nAte = 1 = Bo\nAEE = 1 = (EP 4 ¥*¥ + 2*?7)\n\nWe can encode t(x,¥) ina 2D texture as (X*X + F*F) and g(Z) ina 1D rexeure\nas simply 2°. Figures 5.4.1 and 5.4.2 give examples of these two textures.\n\nNote how the edges of che texpures shown in Figure 5.4.1 are clamped to be\nexactly one. By adding these owe functions together via multitexturing, we can com-\n\nFIGURE 5.4.1. 7X, F) = ON + FFD",
      "content_length": 1429,
      "extraction_method": "OCR"
    },
    {
      "page_number": 535,
      "chapter": null,
      "content": "Section 5 Pixel Effects\n\nFIGURE 5.4.2. 2f2) = 272\n\npute D\"D on a per-pixel basis. Using inverse blending, we can use the alpha-blending\nunit to finish the computation and compute 1 — DD.\n\nSa, one procedure for implementing point lights with attenuation maps is as fol-\nlowes:\n\nCraw antient Light and/or global illumination in the scene\n\nFor each Point Light in the scene {\n\nFor each Object that is approximately near or within the\n\nLight's range {\n\nFor each Vartex in the Object 4\n\nSubtract the Wertex Position fram the Point Light\nPosition\n\nScale the Position by 1 / the Point Light's Aange\n\nScalé and 818s the result to range from oO to 1\nfor points inside the Light's Range\n\nStore Position.” in the & texture coordinate of\nTexture oO\n\nStore Position.¥ in the T texture coordinate oat\nTexture O\n\nStore Position.2 in the & texture coordinate ar\nTéxture 1\n\ni\n\nSet up the nultitexture hardware to choose the Light Color\nin the color unit\n\nSat up the multitexture hardware ta cespute Texture O +\nTaxture 1 in the alpha unit\n\nSat up the alpha-blender to conputa Sreteler * InvSreAlpha\n+ Framebuffer\n\nOptionally set the alpha test to raject pixels with an\nAlpha of 1. This avoids rendering pixels that are outside\nof the light range.\n\nDraw the Object\n}",
      "content_length": 1248,
      "extraction_method": "OCR"
    },
    {
      "page_number": 536,
      "chapter": null,
      "content": "5.4 Attenuation Maps 547\n\n=\n\nAlternatively, we can use texture coordinate generation and the texture matrix to\ncompute all per-vertex operations on the GPU:\n\n* Set up texture coordinate generation for the first multitexture stage to give cam-\ncra space Position.\n\n= Set up the texture matrix co subtract the light’s ¥ and ¥ position, chus giving us\n(2X, a'Y), which are stored in Sand Tof texeure 0.\n\n* Set up the second multitexture stage to use texture coordinate generation to give\nus Camicra space position, just like before,\n\n* Set up the texture matrix to rotate Z onto the X-axis, and then subtract the light’s\n# position, piving us a which is storecd in 5 for texmure 1.\n\nThis technique can be modified to fit a variery of light options. One option for\ngraphics hardware or APIs (such as OpenGL) that don't allow differing color and\nalpha-texture blending modes is to factor the light color into the rexture itself, This\nmodification also allows other blending modes, such as multiplicative frame buffer\nblending, to be employed.\n\nThe attenuation function we computed is:\n\nLaght@olor * {1 — (M°M 4+ yev + Fe?))\nMultiplying through by the LightColor gives:\nLaghtGolor — LightColor = (xX*x # v*¥ + 2*z} =\nLaghtGolor — (LightGelor * (X*X + ¥\"¥) + LightGolor * (7\"Z7)}\n\n‘This implies thar we need to pre-multiply the light color into both attenuation\nmaps to get the right effect, but we really need only one map. It curns out thar we can\njust use the center of the LightColor * OK + FY) texture for the LightColer * (Z*Z)\ncomputation. We can use the honzontal or vertical center, but the horizontal center\nrequires one less texture coordinate to specify and might provide beter texture cache\nperfonmance.\n\nComparing Attenuation Maps and Light Maps\n\nLight maps are commonly employed to stere static lighting data, such as shadows and\nlight calculated through a global illumination solution. Updating light maps ar run\ntime for point lights is complicated and cosely. Point lights performed with artenua-\ntion maps complement light maps nicely by taking over the chores of dynamic point\nlights, Instead of uploading new light maps to reflect a point light changing its color,\nrange, of location, the nearby scene can be simply rerendered using the attenuation\nmap textures to blend the lighr into the scene.\n\nCSG Effects\n\nBy using alpha test or stencil, we can vest for inclusion in perfectly spherical areas such\nas the falloff range of a point light For each pixel thar would be drawn with a point",
      "content_length": 2502,
      "extraction_method": "OCR"
    },
    {
      "page_number": 537,
      "chapter": null,
      "content": "sectionS Pixel Effects\n\nlight, we can set the stencil to a certain value or blend into che frame buffer a constant\ncolor, thus being able ro do other range-based effects.\n\nRange-Based Fog\n\nOne application of this concept is per-pixel range-based fog. Simply render the scene\nas normal with no fog applied, and chen render the scene with che amtenuarion map,\ntreating the camera position as the “light position.” Set che cexmure marrix to identity,\nand then scale the macrix by 1 over the light's range. This technique allaws per-pixel,\nPErspecthve-correct range fre.\n\nThe $0_COLOA sent to the frame buffer blending unit should be che fog color\ntimes fog density. This gives a fog density of zero at the viewer, and at the maximum\nfog range the density will be one.\n\nWhen rendering che fog pass, set up the alpha blender to perform SRC_COLOR * 1\n+ DST_COLOR * [7 — SRE_COLOR}.\n\nOther Shapes\n\nSometimes a sphere is not what is needed; co make an oblong shape, such as a rectan-\ngle or ellipse, simply select minor and major axes and align chem to the world with the\ntexture matrix. We then have co scale the major and minor axes separately,\n\nConclusion\n\nBy cleverly choosing our attenuation function, we are able te perform a per-pixel\nspherical range calculation using two texture maps. The result of this calculation can\nbe used for per-pixel point lights, fog, or CSG effects.",
      "content_length": 1377,
      "extraction_method": "OCR"
    },
    {
      "page_number": 538,
      "chapter": null,
      "content": "5.5\n\nAdvanced Texturing Using\nTexture Coordinate Generation\n\nRyan Woodland\n\nBecause today’s graphics processors are pushing more and more polygons, attention is\nstarting to turn to the use of bandwidth to create compelling texture effects. With the\naddition of multitexture abilities to many procestors, people are starting to wonder\nhow to creatively use these fearures. OF course, artist-applied texoure is the cechnique\nwith which we're all the mast firniliar, bur it's quickly being discovered thar mapping\ntexXtUres at Tun time can produce some very interesting results. Developers are starting\nto use texture coondinate generation to perform animation, lighting, reflection, refrac-\nvon, and bump mapping, ta name a few techniques. This article discusses a few of the\nMOSE COMMON fexture coordinate generation techniques.\n\nThe method of texture coordinate generation used most comfortably by most\npeople is thar of wansforming some data (postion, normals, texture coordinates) by\nsome matrix to yield a set of texture coordinates, This method is fairly easy co adopr\nbecause most 31D) programmers are familiar with the concept of macrix cransformation\nand because matrix transformation is often accelerated by hardware. This article\ndescribes only techniques that cin be performed using macrix mach.\n\nSimple Texture Coordinate Animation\n\nQuite often, games use a simple rotation or translation of texture coordinates to sim-\nulate simple effects such as reflection or to give the appearance of water or some mov-\ning material. The concept is simply this: A texture coordinate can be thought of as a\nsimple 21D point. Because programmers are accustomed to transforming points by\nmatrices, it is easy to see that a texture coordinate can be rotated, tramslaced, or sealed\nsimply by transforming it inte a 3% 3 matrix. Just as with geomenry, a homogenous\ncoordinate must be added to the s, ¢ pair to make the transformation possible. There-\nfore, the method of coordinate generation looks like this:\n\n(6D) * Sb = eh",
      "content_length": 2018,
      "extraction_method": "OCR"
    },
    {
      "page_number": 539,
      "chapter": null,
      "content": "550 Sections Pixel Effects\n\nThe illustrations in Figure 5.5.1 were generated using simple rotation and scale.\nThe first picture shows a textured quad with no transformation applied. The second\nshows a rotation of the texture coordinates by 45 degrees. The third shows a texmure\ncoordinate manslation of 0.5.\n\nTexture Projection\n\nTexture projection is useful for a number of effects. Most often it is used to simulare\nlighting effects such as spotlights or shadows. The result of texture projection is fairly\nstraightforward: A texture is projected onco some geometry from some point in space.\nFor example, we can define a sporlight ar some point in a scene and project a texture\n(probably a light circle) onto the geometry, creating the illusion of a spotlight.\n\nAgain, the concepe of rexnure projection has its roots in normal 3D geometry tech-\nniques. When simulating a camera in 3D, a projection matrix is used to project vertices\nin camera space once the near clipping plane of the camera. These points are mapped\nin the range of —1 co 1 in both Xand 1 and chen they are transformed into screen space\nby a viewport transformation, which usually involves a translation and scale.\n\nFor texture projection, instead of modeling a camera in space, we are usurally\nmodeling a light. Light space vertices are projected back onto the near clipping plane\nof the light, and the resulting X and }valucs are used as Sand T values to map a tex-\nture onto the projected geometry.\n\nA light should be modeled just as a camera usually would. The near clipping\nplane should be set to reflect the dimensions of the texture that is to be projected. For\ninstance, a square near clipping plane should be used for projecting a square texture.\n\nNow, as mentioned, geometry chat is projected onto a texture needs to be in light\nspace, just as geometry to be projected onco the screen needs to be in camera space. In\norder to do this, we need to first wransform the geometry into world space. Onee this\nis done, the lighe matrix (just like che camera matrix) must then transform the geom-\netry. The geometry can then be projected by the light’s projection matrix.\n\nOnce geometry has been projected, another problem arises. Projected geometry,\nas mentioned previously, falls in the range of -1 co 1 in both X and F with (0, 0)\n\nFIGURE 5.5.1. Examples of texture coordinate penerarion through texture matrix transformations.",
      "content_length": 2400,
      "extraction_method": "OCR"
    },
    {
      "page_number": 540,
      "chapter": null,
      "content": "6.5 Advanced Texturing Using Texture Coordinate Generation 551\n\nbeing at the center of the plane of projection as ir relates to the light. Texture coordi-\nnares usually run from 0 to Lin both Sand 7; with the origin of chat space being\nlocated at the upper-left corner of che vexture. To map the projected coordinates into\nTexture space, we must first scale chem by (1.5 00 pur them in the range from —0.5 to\n0.5 and then translate them by 0.5 co pur them in the range from 0 to 1.\n\nAll these matrices can be concarenared together to form one final projection\nmatrix for a given piece of peomesry. The order is as follows;\n\nM_obj * M_fight * M_proy * M_scale “ M_trans \"(en Oo) = fe 6 gl\nwhere:\n\n* Moby = the object's world space marrix.\n\n* M_light = the light matrix used to transform the geometry fom world space into\nlight ¢pace.\n\n* W proj =the light’s projection matrix.\n\n* M scale = (0.5 scale manrix.\n\n* M_trans = 0.5 transhtion matrix,\n\n‘The result of this calculation is 2 four-dimensional point. For simple texture pro-\njection, the r coordinate should be completely ignored, yielding an (s, ¢, q) triple. If\nthe hardware allows, pass these chree coordinares down for rasterization. The q coor-\ndinate is used to perform perspective correction: however, this must be done at raster-\nEzation time for it to be correct.\n\nFigure 3.5.2 was generated using texture projection. Ir shows the frustum of the\nlight that was used to project che circular highlight onto the sphere geomienry.\n\nBy projecting geometry in this manner, a few unexpected results can occur. First.\nTexture coordinates usually behave in a tiled manner. This means hae there is really no\n\nFIGURE 5.5.2. Texture projection example.",
      "content_length": 1703,
      "extraction_method": "OCR"
    },
    {
      "page_number": 541,
      "chapter": null,
      "content": "Section 5 Pixel Effects\n\n—— SS\n\ndifference between a set of coornlinates that rangres from 0 to | and a see cheat ranpes\nfrom —1 to 0. Therefore, cextures thar are projected nig geometry shouled usually\nbehave in a clamped manner, meaning that che ourside border of the neeture i¢ repeated\nand applied co any texture coordinare less than 0 and grearer than 1. For this reason,\nrexture borders should be colored to behave correcely with the texture combine mode\nof cheice.\n\nThe second and more complex problem is that of what | call shie-nhroneh, When\nWe Project a texture onto a sphere, for instance, the texture appears on both the front\nand back sides of the sphere as it relates eo the light. This ts because vertices on both\nthe front and back of the sphere project into the comect texnure space.\n\nThe image in Figure 5.5.3 highlights chis problem. You can see that the spotlight\ntexture projects correctly on the front of the sphere, but it also shines through to the\ngeometry on the back of the sphere.\n\nThere are a couple of ways to fix this problem of shine-through. The first is to\nperform a dot product between the vertex normal and the light normal to determine\nwhether the vertex is back facing. IF the vertex is back facing. simply set the texture\ncoordinate to something out of the range of 0 to 1.\n\nSecond, you can use the output of the standard lighting equation co determine\nwhether a vertex is back facing. Place a parallel light at the location of the texture pro-\njector Lf che color output from chis parallel light for a vertex is black, you know that\nthe vertex is back facing, because the only way for this vertex co become black is if the\nassociated normal ts facing away from che light.\n\nFIGURE 5.5.3. Shine-through in texture projection.",
      "content_length": 1763,
      "extraction_method": "OCR"
    },
    {
      "page_number": 542,
      "chapter": null,
      "content": "5.5 Advanced Texturing Using Texture Coordinate Generation 553\n\nReflection Mapping\n\nTo perform reflection mapping, I use a simple method called sphere mapping. The\nbasic idea for chis method makes two ASSL pthons.\n\nFirs, no maceer the size and shape of the object being mapped, it is assumed to\nreflect the surrounding environment like a sphere. This concept is important because,\nlogically, a point on a character's hand should reflect something different than a point\non a character's foot with the same normal. With sphere mapping, these owe points\nreflect exactly the same thing because they have the same normal.\n\nSecond, the reflective sphere like which the object will behave is assumed to be\ninfinitely small. ‘This means thar all rays from the point of the eye in the scene to any\npoint on che infinitely small sphere are parallel to each other.\n\nGiven these limitations, the sphere-mapping method operates om basic laws of\nreflection. Take, for instance, a ray from the cye poine in a scene to a poine on the\nreflective sphere. This ray should hit che sphere and reflect around the normal ar the\npoint of contact. Whatewer this reflected ray hirs should be seen reflected ar che paint\nof contact on the sphere. Figure 5.5.4 illustrates this concept.\n\nSince it is not computationally feasible co perform one-bounce ray tracing for every\npoint on a sphere, we instead create a cexrure map that contains the necessary environ-\nmental information. This map is called a spherinal reflection map, or a sphere map.\n\n—]+._ Incident Ray\nps Fofiected Fay\n\nsurface Mannal\n\nFIGURE 5.5.4. Rays are reflected around the surface normal at the point of contacton a\nreflective object.",
      "content_length": 1677,
      "extraction_method": "OCR"
    },
    {
      "page_number": 543,
      "chapter": null,
      "content": "554 Sections Pixel Effects\n\nThe basic definition of a sphere map is a single texture map thar conrains a full\n360-degree view of the environment surrounding a point in space. There is one big\ndrawback to using sphere mapping for reflection: The texture used as the reflection\nmap is viewpoint dependent. This means chat te be completely comect, the rexcure\nmap must be dynamically creared each time the camera moves. I have found, how-\never, that for some common effects such as generating a specular highlight on a car or\ncreating lighting effects on a character, refusing to update the sphere map based on\nviewpoint is often not nociceable. (For an in-depth discussion of generating sphere\nmaps see [Blythe?9].)\n\nOnce you have an adequate sphere map, texture coordinare generation is a snap.\nSimply transform an object's normals into world space using the inverse wansform of\nthe object's model matsix. Then transform the normals into view space using the cam-\nera matrix. Finally, assuming your camera is looking down the —2 axis, simply use the\nAand Ycomponcness ofa normal as the Sand T coordinates, respectively, for the asso-\nclated vertex.\n\nObviously, using this technique, normals with a <2 componenc generare the\nsame 5, J coordinare pair as the same normal with a +2 component. This warks our\nfine because any vertex with a—2 component in its associated normal is by definition\nback facing and will not be seen, since this calculation is done in view space,\n\nColor Phare 5 was produced simply by mapping a corus with a spherical reflection\nmap of an outdoor environment.\n\nUsing this technique, it is very easy to perform reflection, specular mapping, and\ndiffuse lighting using the comect texcure maps.\n\nFor a view-independent method of generating these effects, please see [Hei-\ndrich98), which describes dual-paraboloid mapping. In addition, cubic environment\nmapping is a wonderful way to generate dynamic lighting and reflection effects if the\ntarget hardware provides support for it. Please see [Nvidia00] for more information.\n\nReferences\n\n[Blythe] Blythe, David, Adnenced Graphics Progamming Techniques Useng OpenGL,\nAvailable online at heop://realiry-spicom/blythe/sig99/advanced99/ notes/nodetO\nchum, April 7, 2000.\n\n[Warr92] Ware, Alan, and Wart, Mark, Adpertced Animation and Rendering Tech\nniques, ACM Press, 1992.\n\n(Heidrich?8) Heidrich, Wolfgang, and Seidel, Hans-Peter, View-independent Envi-\nnonment /Mepr Eurographics/ACM Siggraph Workshop on Graphics Hardware\n1998, available online at www).informarik_uni-crlangen.de/ eng) research/render-\ning/envmap/, March 22 2000.\n\n[Nvidia] NVIDIA technical brief, Perfier Reflections anal Specrler Lighting Effects\nwith Cube Environment Mapping, available online at wwow.nvidia.com! Market-\ning! Developer! DevRel.nsif WhitepapersFrame?QpenFage, March 10, 2000.",
      "content_length": 2829,
      "extraction_method": "OCR"
    },
    {
      "page_number": 544,
      "chapter": null,
      "content": "5.6\n\nHardware Bump Mapping\n\nsim Dietrich\n\nBump mapping, firse described by Jim Blinn in [Blinn78], is a technique that simu-\nlates the way light reacts 0G 2 rough or dimpled surface by applying a texture to an\notherwise smooth polygonal surface. The applied texture is known as the durep map,\nhence the term bump mapping.\n\nSeveral methods of bump mapping are available in hardware today. This article\nconcentrates on elucidating the common issues around modern bump-mapping tech-\nniques thar programmers encounter when moving from “bumpy sphere” demos to\nactual game implementation. Since bump mapping is actually a lighting computa-\nten, I discus bump mapping in terms of illumination.\n\nBump-mapping techniques either caloulate or approximate a dot product\nberween the light vector £ and the surface normal Nin order to calculate diffuse light-\ning. For the sake of simplicity, | assume thar the dot product operation is calculated\non a per-pixel hasis. ‘This functionalicy ts available from several hardware vendors at\nthe time of this writing and will likely remain available in che furure-\n\nSpecular lighting can be achieved by calculating che dor product between the\nhalf-angle vector AY and the surface normal Wand then raising the result to some\npower. We concentrate on diffuse illumination, but bear in mind chat all techniques\ndiscussed can be applied ta specular bump mapping or lighting as well.\n\nDot product-based bump mapping and per-pixel lighting are huge subjects, so we\nconcentrate on explaining the problem at hand and some practical solutions. Specifi-\ncally, this article avoids discussing texrure blending modes, cube maps, texture for-\nmats, and other things at that level of implementation detail, instead concentrating\non how ta properly bump map or light an arbitrary model or mesh.\n\nHow Do | Apply a Bump Map to an Object?\n\nThe simple answer to this question is to simply texture map the object with a texture\nrepresenting the bump map. A more useful answer requires more information on\nwhat effect we are trying to achieve on which platform, Various hardware bump-map-\nping techniques require different source data for the bump-map texture, from alpha-\n\n555",
      "content_length": 2185,
      "extraction_method": "OCR"
    },
    {
      "page_number": 545,
      "chapter": null,
      "content": "556 _ Sections Pizel Effects\n\nheight maps co RGB surface normal maps and RGB @LifV maps. Since both RGB\nsurface normal maps and RGB @UWV maps can be generated from alpha-height maps,\nI assume that the original source data for the bump map is an alpha or gray-scale\nheight map.\n\nAs stated, we assume that we have a per-pixel dot product operation, thus, |\nassume we have a way of generating the appropriate texture formar thar directly\nencodes surface normals in RGB formar. One such format maps the X, ¥, and 7 vector\ncomponencs from [—1_.1] floating point into the [0255] range of the RGB channels.\n\nThe fact that we have normals stored in an RGB texture presents an interesting\nquestion: In which space are these normals defined? Model space? World space? Some\nother space?\n\nThe fundamental bump-mapping of diffuse illumination operation, © J, does\nnot care in which space the vectors are defined; it is essential, however, to ensure that\nNand £ are expressed in the same coordinate system.\n\nWe-will see thar this seemingly innocuous issue is one of the most important con-\nsiderations when evaluating dot product-based bump-mapping techniques. The next\nsection describes each option and where it might be most appropriate.\n\nChoosing a Space for the Normals\n\nLet's start with a simple example of a sphere that we want to bump map in model\nspace. We assume for now thar the bump map is uniquely cextured across the sphere;\nin other words, that each point on the sphere maps to its own section of the texture so\nthat no tiling or mirroring of the bump map occurs.\n\nIn this case, we go through cach cexel in the bump map, find where ir is mapped\non to the sphere in model space, and generate the surface normal for char location.\nNext we generate a 3 X 3 coordinate system for that location on the sphere, using the\nsurface normal as the +2 axis. This is commonly known as samgenr space because it\nrepresents a space that lies tangent 0o che surface.\n\nIn order ta generate taNgent space, wo unique vectors are required, and the third\nvector can be generated from the other owe, In this case, however, there is no obvious\nchoice for a second vector because there is an infinite number of tangent spaces with\nthe same 4.7 axis, so an arbicrary choice must be made.\n\nWe choose the + axis in model space as our second vecror. We then make a cross\nproduct of +} with our surface normal to generare the third veetor, which serves as\n+4. We can then stop or take che cross product of +2 with +X to generate a new +¥\naxis. Normalizing all three vectors gives us the three columns of our 3% 3 matrix chat\nfepresents tangent space at thar point on the sphere surface.\n\nNow we hive a basis matrix ar che appropriate point, and we can take the bump\nvector from our bump map, expressed in world space, and rotare it into local tangent\nspace using our matrix. We now have a bump vector for char particular point on the\nsphere. We can now replace che world space bump vector in the texture with the ran-\ngent space bump veccor.",
      "content_length": 3011,
      "extraction_method": "OCR"
    },
    {
      "page_number": 546,
      "chapter": null,
      "content": "5.6 Hardware Bump Mapping 557\n\nNow at ruin time we can take a light vector £ expressed in world space and norare\nic through the world to model manmrix, giving £' Since L’ is now relative co model\nspace, we can perform \"© N beoween this light vecter and the bu Mp-Map VECwors.\n\n£'is constant fora particular model space matrix, so it is valid in general only for\nthe current model hierarchy level. This is conveniens in that it allows £\" to remain\nconstant for an entire portion of the model being bump mapped.\n\nAt run time, we can sct up the texcure-blending units to compute:\n\n‘Texture - Coneane(alor\n\nWhere Texture corresponds wo the surface normal map with RGB encoded normals\nand GonstantCelor- comesponds to our constant L’ vector, converted into RGB form.\nThis technique is known as object space or model space bump mapping. Its advantage\nlies in no run-time overbead other than a single vector rotation per model hierarchy\nlevel, Its disadvantages include having to uniquely texture objects, which takes a Large\namount of texture memory. In addition, skinning or morphing objects need cheir sur-\nface normal textures regenerated every frame-\nThe desire to overcome these disadvantages leads to the next technique.\n\nAnother Approach: Using Tangent Space Bump\nMapping\n\nSince we have defined tangent space already for our sphere, chat means we have a\ntranslation from model space to a local space defined at each vertex. We can leverage\nthat information to eliminate the necessity of both unique cexcuring and of having to\nrepemerate the surface normal CEL y3 in the Case of animated models. Insread of reren-\nerating the normal maps to be relative to model space, we leave our normal maps as\nthey arc, instead generating a matrix to rotate the light vector from model space into\ntangent space.\n\nWe assume chat our original height map represencs height “out from the surface.”\nMathematically, che “owe” direction of the height map corresponds to the +7 axis of\nOUL tangent space at every point on the surface of the sphere. We use this to create a\nmathematical way of translating [rom the bump-map space co the local tangent space\nat any point on the sphere.\n\nOne way to accomplish this task is to calculare our tangene space exactly as in\nmodel space bump-mapping described previously, but only ar cach vertex of the\nsphere, and store the tangent space matrix in a data structure corresponding to that\nvertex. When lighting or bump mapping that vertex, we use che 3 % 3 tangent space\nmatrix to convert our light vector inta local tangent space. So, rather than wsing the\ntangent space macrix to convert the surface normals, as we did previously, we use the\nmatrix to convert the light vector instead. Remember thar the space in which the dot\nproduct is performed is irrelevant, as long as boch veccors are defined in the same\ncoordinate space.",
      "content_length": 2848,
      "extraction_method": "OCR"
    },
    {
      "page_number": 547,
      "chapter": null,
      "content": "Section5 Pixel Effects\n\nIn model space bump mapping described previously, the generation of a tangent\nSpace Matix occured as a preprocessing step at every poine on the sphere im order to\npenerate a unique bump map across che sphere. In tangent space bump mapping, we\nonly penerate a tangenc space macrix ac each vertex of the sphere.\n\nAt tun time, we take our 2 vector for each vertex of the sphere and rorace ir, first\nthrough the world-to-model matrix and then through the local cangence space matrix\ngenerated during preprocessing and scored ac that vertex. This gives us 2) the light\nvector in local tangent space. OF course, £' is correct on only a per-vertex basis. In\nmodel space bump mapping, £’ was constant for the whole model hierarchy level.\nNow J’ varies from vertex to vertex.\n\nSo, whereas before, we stored £*in a constant color, it now has to be interpolated\nacross a triangle.\n\nTo perform tangent space bump mapping, we can set up the texture-blending\nunits to perform:\n\nTexrure - Diffusetolor\n\nWhere Texture is our surface normal map and DiffuseCelor is an iterated color\nvalue represencing\n\nWe leverage the handware's color interpolation capability co “rotate” our £ \"vector\nfrom one space to another, We are actually performing a linear interpolation berween\nlocal £\"vecoors at each vertex, rather chan true sotation or spherical interpolation, but\nfor most purposes this works well, Note that perspective-correct color interpolation is\nareal help for these cases.\n\nOn mubtitexture hardware, it is desirable to use a cube map or paraboloid map to\ninterpolate £* instead, but char topic is beyond the scope of this article. Suffice it to\nsay thar using a linear interpolation of £' veetors leads to darkening artifacts when\nbump mapping with respecc to local lights near large triangles. This effect is caused by\nalmost opposice L* vectors being shortened when linearly interpolated across the inte-\nrior of a triangle. Cube maps can also assist with handling properly interpolated light\nVECIOM across anisotropically scaled mormal maps,\n\n‘Tangent space bump mapping is much improved over model space bump map-\nping in that bump-map textures no longer must be unique and can be dled across a\nsurface. In addition, skinned or morphed models need only regenerate the 3 x 3 ran-\ngent space matrix for each animated vertex and do not have wo recreate che surface\nnormal map each frame.\n\n‘Tangent space bump mapping is less CPU-efficient than model space bump map-\nping in char it requires more rotations of £ into local tangent space at run time. In also\nrequires updating of model data at run time, which may introduce GPU stalls or\nadditional dara copying.\n\nA more subtle disadvantage of tangent space bump mapping is not necessarily\napparent when creating a demo ofa bumpy sphere, but that can be a challenge when\nincorporating bump mapping into an actual game environment. The problem is thar",
      "content_length": 2911,
      "extraction_method": "OCR"
    },
    {
      "page_number": 548,
      "chapter": null,
      "content": "5.6 Hardware Bump Mapping 558\n\ntangent space bump mapping requires defining a relationship berween how the bump\nmap is applied and the surface of the object.\n\nIn order to generate the local tangene space matrix, we need to know more than\nthe Fact that the “out” direction of the height map corresponds to +2 in tangent space.\nThis is the same problem as in the model space bump mapping example. We must\nhave two unique vectors in order to define a three-dimensional coordinate system.\nMost bump-mapping aamples available on the Web today (cinca 2000) have an arbi-\nwary, implicit mapping whereby they simply choose a world or model space axis, such\nas +}, in onder to generace the ramgent space macric.\n\nHere is a description of our problem. Let's say a programmer and artist work\ntogether to bump map our sphere using this bump map. Now say char che artist\ncomes in the next day and rotates the bump map %) degrees on che model and\nimports it into the game. Instead of the light appearing to come from above, the light\nnow appears to come from che side! So, the programmer comes in, sees che problem,\nand updates the tangene space matrices by taking into account the *0-depree roration\nto fix the problem.\n\nThe fact thar this problem could be fixed in this way implies thar the artist is sup-\nplying informacion char the programmer is not aunomacically taking into accoune in\nthe mapping from tangent space to bump map space.\n\nThe artist knows how she wanes che bump map applied, so che program should\nrespect her choice. The bump map can be applied like any colece texmurc: thus it may\nbe stretched, warped, projected, and 20 Of. (hur simplistic fatigent Space rict hese Fails\nto take inte account how the bump map is actually applied no a model and assumes\nthat there is a simple correspondence berween the bump map and the underlying sur-\nface. Tangent space bump mapping requires knowing how the texcure was applicd—\nin other words, planar, box, spherical, or cylindrical mapping.\n\nIris this assumption thar makes tangent space bump mapping difficult to incor-\nporate into a game, especially one with existing arrwork that we dont wane co recex-\nture with bump maps in a restrictive way.\n\nA Solution: Texture Space Bump Mapping\n\nTexture space bump mapping is similar to tangent space bump mappingand primar-\nily differs in the way that the local matrices are penerated for cach vertex.\n\nRather than generating tangent space matrices at each vertex, texture space bump\nmapping creates what I call a tecture space matrix that takes into account exactly how\nthe texture was applied to the surface by the artist.\n\nTo generate this matrix, we need to look at each tangle and how ic is texture\nmapped. It may be rotated, scaled in Sor 7, flipped, or projected. It tums out that\nwhat we need to know in onler to mathematically acaount for bow the texcure is\napplied are the texture gradients, The texture gradients are nine scalar values that rep-\nresent the direction of Sand 7 with respect to the A, F and 2 ames,",
      "content_length": 3013,
      "extraction_method": "OCR"
    },
    {
      "page_number": 549,
      "chapter": null,
      "content": "8\n\nSection 5 Pixel Effects\n\nWe calculate the vexture gradients as follows; let's stam with the plane equation of\n‘OWL triangle:\n\nWe can use any three independent variables in our plane equation, so | use X, 5 and\nF, instead of X, FF and 2.\n\nfix: Are Cre DO -\n\nNow we can usc this equation to calculate our texture gradients with respect to X.\nLet's assume thar we have two unique «and two unique s values and subtract one\nfrom the other to give ws ale and ads. For this step, we assume that-tis held constant,\n\njx! + sl 4 Cr+ D= 0\n\nvic + Bila Cr+ O= G\n\nAx) + Bs + Cr+ De» Axl + Bil + Ces D\n\nAxl + Brl + Cr+ D—f Act + B+ Cr+ D) a\nAx! — Ax + Brf — Br = 0\n\nA) + Bais) = 0\nAja) = -—Ayd5)\naay = RA\n\nThe gradient of X with respect to § is thus —B/A_ This gives us 2 measure of how\nA changes with cach change in 5. The same can be computed for dT. We can then\ngenerate the gradients of Fand 2 similarly. [fA is found to be 0, we can safely set the\ngradient co 0. That simply means that S doesnt change at all with respect co 5,\n\nWe now have six scalar values that represent hew X, Fo and 2 change in model\nspace as we walk across the rexture in Sand T.\n\nWe can use this information to derive a marrix between the §, and SxT axes,\nand the X, K and 2 model space matrices:\n\njx Tx (SxT)x\nsy Ty (S*T)y\nSz fee (S507 2\n\nAt mun time, we can move the light vector into local model space using the\nmodel's hierarchical matrix stack, Then we can pur the light vector through this\nmatrix for each vertex and store che resulting vector in che diffuse or specular iterated\ncolors. Now the dot product can be computed benween the normal map and a light\nvector defined in the same space as the normal map.",
      "content_length": 1683,
      "extraction_method": "OCR"
    },
    {
      "page_number": 550,
      "chapter": null,
      "content": "5.6 Hardware Bump Mapping Sei\n\nTexture Space Issues\n\nSome of the issues that arise from generating a basis from textures are summarized.\nThe inost apparent issoe that arises when implementing this task ts flipped textures,\nSinec texoures don't have a “sidedness\" and normals do, we need to detect this case by\ncomparing the face normal of the triangle to the rexture'’s SX Taxis. If the dot product\nbetween them is negative, we can simply flip the 57 axis. At times an artist mirrors\npart of a texture on a symmetrical object. In this case, two triangles that straddle this\nboundary have opposite 5% J axes. In this case, the programmer or artist must dupli-\ncate the vertex,\n\nAt times programmers are forced to duplicate vertices for the sake of different tex-\nture coordinates, This situation can indicate a discontinuicy in how the texmure is\napplied to the surface. The way to solve this problem is to create a texture space basis\nmatrix for each triangle individually, Next find which vertices are geometrically\nthared between triangle faces—in other words, which vertices share X, ¥, 2 positions.\nNow for each vertex, take the §, T and S*T axes of each triangle that touches that\nvertex and sum them. Now normalize the resulting 5, Tand 5x7 axes, This action is\nanalogous to creating vertex normals from face normals, cxcept that we are calculating\nthree vectors at a time. The three resultant vectors now make up a mew “average tex-\nture space” to store at each vertex of the model.\n\nThe price of normalizing the resultant column vectors is chat now anisowopically\nscaled textures cant be handled properly. If we have cube maps or some other way to\nnormalize the vectors, we can skip the normalization secp and thus handle anisomrop-\nically scaled textures with ease.\n\nConclusion\n\nDot product-based bump mapping and per-pixel lighting have arrived and along with\nthem some interesting parameterization issues. The need to interpret flar texcures as\n3D surface normal vectors necessitates either regenerating the surface normal texrures\nto match the model, as in model space bump mapping, or generating a basis macrix\nfor cach vertex, as in tangent and texture space bump mapping.\n\nReferences\n\nHere are three great resources for more information on per-pixel lighting:\n\n[Blinn?8) Blinn, James, “Simulation of wrinkled surfaces,” Computer Grapher (S/G-\nGRAPH 78 Proceeatng:), vol. 12, no. 3, pp. 286-292, August 1976.\n\n[Everitt00] Everitt, Cass, “High-Quality, Hardware-Accelerated Per-Pixel Illumina-\ntion for Consumer Class OpenGL Hardware,” master's thesis, available online at\nwww. r.nu/—cass/ thesis, May 2000.\n\n[NVIDIA] NVIDIA's Developer Relations site ac wwwnvidia.com/Developer.nsf,\nMay 2000.",
      "content_length": 2706,
      "extraction_method": "OCR"
    },
    {
      "page_number": 551,
      "chapter": null,
      "content": "Ground-Plane Shadows\n\nYossarian King\n\nProjecting shadows of arbitrary objects onto other objects or arbitrary terrain is diffi.\ncult. However, if you are projecting shadows onto a flat ground plane, there is a sim:\nple solution. The “obvious” approach is vo draw a sprite of some sort at a character’:\nfeet, perhaps generated by rendering the character in profile ro an off-screen butler\n‘This method suffers from misregistration effects between object and shadow. Thi:\narticle presents a simple technique for ground-plane shadows that performs a physi-\ncally correct projection with very litde computational overhead.\n\nOne additional transform matrix is used oo “squash” the vertices in an object onte\na flat horizantal surface of arbitrary height. The direction and height of the light\nsource relative to the object determine the shadow projection matrix. Given this\nmatrix, the object is rerendered with che additional cransform to draw the shadow.\n\nTranslucent gray polygons are used in place of the textured palygons of the abject\nto create the shadow effect. The object used for the shadow need noc be the same as\nthe original ebject; typically you use an object with a lower polygon count co improve\nperformance. The polygons of the shadow object overlap after projection onto the\nground, which produces artifacts in the cranslucent rendering. These artifaccs can be\neliminated using a hardware Z-buffer.\n\nThe technique can be extended to project shadows onto any 3D) plane, nor just a\nplane aligned with the coordinate axes, Used twice, the technique can project shadows\ninto the corer berween a floor and a wall,\n\nShadow Math\n\nEEE\nShadows result when a solid object comes between a light source and a surface. A\npoint on the surface is in shadow if a ray from the light to the point intersects che\nobject. In a rendering system, the object is represented by a collection of polygons.\nCasting rays from the light through each of the vertices of the model once the surface\noutlines the areas of the surface thar are in shadow. For a single polygon of the object,\nthis method gives a projected shadow polygon on the surface.",
      "content_length": 2130,
      "extraction_method": "OCR"
    },
    {
      "page_number": 552,
      "chapter": null,
      "content": "5.7 Ground-Plane Shadows 563\n\nLinformunarely, chis method does not lend itself directly to practical real-time ren-\ndering. It is cosdy co calculate the inversection berween the ray and the surface. The\nprojected shadow polygon needs to be subdivided to conform accurately co the sur-\nface, an operation that is arbitrarily complex, depending on the complexity of che sur-\nface. An alternative to rendering the projected shadow polygons is co modify the\nvertex colors of the surface, darkening the vertices thar are in shadow, bur this has the\ndrawback of reducing the precision of the shadow and making ic dependent on che\nvertex density of the surface. Dynamic shadow map textures can be used to compute\nshading at a higher and more uniform detail chan allowed by vertex shading, but this\nprocess is also expensive.\n\nThe problem can be simplified, however, if the shadows need be cast only on 2\nhorizontal ground plane. For many gare applications such as sports simulations and\ncorridor games, horizontal surfaces are the norm, and the simplification can be used.\n\nFigure 5.7.1 shows ground-planc projection in 2D. A light at point £ casts the\nshadow of a point / onto the ground planc (dhe A-axis) ar some point 5. We want to\ndetermine «x, the X coordinate of point 5.\n\nUse of similar triangles shows chat:\n(oc — px) _ py\n(xx — ty) iy\n\nFIGURE 5.7.1. A light ata peane 2 casts a shadow of point Fionn the ground plane at\npaint 3.",
      "content_length": 1431,
      "extraction_method": "OCR"
    },
    {
      "page_number": 553,
      "chapter": null,
      "content": "| 4\n\nSection’ Pinel Effects\n\nsolving for oc\n\n= ix — &)\niy\n\nBut this expression for o: includes sx, so we haven't actually solved for the\nunknown. However, the anky use of ec on the night side of the equation is in (sx — fy),\nwhich is the horizontal distance from the shadew point to the light. By assuming thar\nthe light is relatively far away from the object relative to the length of the shadow, we\ncan approximate (sx — £:) with (ax —é,), the distance from the object to the light. This\nyields;\n\n= px t py\n\n(ox — fx)\n= pet op\nor simply:\na= pet ke” py\nwhere:\ni (ax — tx)\n\niy\n\nThe distance light source assumption is equivalent to treating the light as a direc-\ntional light rather than a point light source,\n\nExtending this to three dimensions and projecting the shadow point S onto the x-\nz plane, we per:\n\n= pet kl” py\nv=o (5.7.1)\nsf = pet kl\" py\nwhere:\na= @=4)\nly\ngoa ist =#)\nhy\n\nBy projecting cach of the vertices of the object onto the ground plane, we get a\ncollection of projected polygons that can be rendered to create the shadow of the\nobject. To do the projection, we just need to calculate the values of #7 and £2, which",
      "content_length": 1134,
      "extraction_method": "OCR"
    },
    {
      "page_number": 554,
      "chapter": null,
      "content": "5.7 Ground-Plane Shadows 565\n\n——= SS\n\nare completely determined by the relative position of the object and the light. Imple-\nmentation of chis technique is deseribed in further detail in the next section.\n\nImplementation\n\nIn a typical rendering pipeline, a model vertex ot is transformed inte a view space\npoint # before projection into screen space. This operation is written as:\n\np= OT\"\n\nwhere Tis a matrix representing the model transformation that converts model vertex\nmi inte world space, and (is the camera transformation that converts world space\ncoordinates inte view space. In order to renderan object, we transtonm each of its ver-\ntices inte vicw space, then project inte screen space and render the resulting polygons.\n\nTo easily incorporate dhe shadow projection process into the rendering pipeline,\nEquation 5.7.1 can be rewritten in macrix form as\n\nr= 5%\n\nwhere:\nc= (oxy ot, 1) is the projected shadow point in world space,\np= (pe. py pe. 1) is che point on the object in world space.\nSis the shadow projection matrix, written as\n\n1 #0 6\noe o 0 0 0\nG6 #2 1 6\noO 0 OO 1\n\nNow to render the shadow of an object, we simply insert che shadow projection\nmatrix into the vertex transformation:\n\nB= OS\n\nThis expression makes use of the shadow projection marrix to transform the\npoints of an object into the projected shadow points on the ground plane. The\nshadow projection matrix $ depends only on the constant: &f and £2, which are\ndetermined from the relative position of the object and the lighr.\n\nThis technique can be used to rerender an object projected flar onto the ground.\nIfthe shadow matrix $ is simply inserted into the pipeline and the object rerendered,\nthe result is a flattened version of the object—complete with textures, shading, and so\non, To render the object as a shadow, we con render cach verrex as a flar-shaded\ntranslucent gray, ignonng the texture information in the model. In practice, using a\nmodel with fewer polygons than the original object reduces the cost of rendering a\nshadow.",
      "content_length": 2021,
      "extraction_method": "OCR"
    },
    {
      "page_number": 555,
      "chapter": null,
      "content": "566 Section 5 Pixel Effects\n\nFIGURE 5.7.2. Projecting the teapot geometry onvo the ground plane renders the shadow of the teapot\nobject. The artifacts caused by overlapping transtucenc polygons are dliminated with the hardware Z-\nbufficr, as shown on che mehr.\n\nOne problem with this method is that the polygons projected onto the ground\nplane overlap, and when the overlapping polygons are drawn with translucency, the\noverlapping areas show up darker than the non-overlapped areas. ‘This artifact can be\ndiminated using the hardware #-buffer: After the first shadow polygon has been\ndrawn, the overlapping portion of subsequent polygons is removed by the Z-buffer. If\n#-buffer imprecision causes arcifacts, then as the shadow polygons are rendered, each\ncan be biased further away im 2, so chat the Zcompare eliminates the overlapping\nareas.\n\nFigure 5.7.2 shows a teapot rendered with a projected shadow. both with and\nwithour che use of the 2-buffer ro remove artifacts.\n\nExtensions\n\nAs presented, this article makes it easy to project shadow geometry onto a horizontal\nground plane. The method can easily be extended to other axis-aligned vertical\nplanes. With a bit more work, it can also be extended to arbitrary planes, An arbitrary\nplane can be represenced as a roration and translation of the horizontal ground plane.\nShadows are projected onto the arbitrary plane by roraring and traniating it back to\nhorizontal, projecting the shadow, and then transforming back the plane position.\nThe light position must also be transformed. By using the projection technique mul-\nHiple times, shadows can be simultaneously cast onto multiple planes, such as the cor-\nner between a wall and the floor.",
      "content_length": 1698,
      "extraction_method": "OCR"
    },
    {
      "page_number": 556,
      "chapter": null,
      "content": "0.\n\nReal-Time Shadows on\nComplex Objects\n\nGabor Nagy\nThis article presents an effictene algorithm capable of creating realistic shadows in\n\nreal-time applications. The algorithm can take advantage of today’s fast texture-map-\nping and 3D transformation hardware.\n\nIntroduction\n\nShadows are among the most important depth cues in human vision, In computer\neraphics, they can give an image the final touch of realism. Without shadows—even\nwith realistic lighting and texturing effects—computer-generated images look artifi-\ncial; the objects appear ro float in space, even when they are lying on a surface. This\ninability for humans to sense the relative position and depth im computer graphics is\nespecially apparent when the camera is not moving (no parallax information).\n\nUnuil recently, only compurationally expensive algorithms such as ray tracing and\nradiosity could produce accurate shadows, in which both the objects Cascing the shacl-\nows and the ones receiving them are of arbitrary complexity.\n\nThe algorithm presented here is optimized for real-time applications, It provides\na very good balance berween realism and rendering performance while being casily\nextendible to all situations. With the always performance-hungry game programmer\nin mind, this article highlights points at which significant optimization for perfor-\nmance is possible using hardware features.\n\nSome of che basic ideas in this article have been around for a while, bue most\npapers describing them dont deal with che importance implementation details we\ncover here.\n\nThe Light Source, Blocker Object, and Receiver\nObject\n\nConsider the simple example shown in Figure 5.8.1. The torus (footer object or\nblecwer) blocks some of the light coming from che light source, casting a shadow an\n\nS67",
      "content_length": 1772,
      "extraction_method": "OCR"
    },
    {
      "page_number": 557,
      "chapter": null,
      "content": "Section S Pinel Effects\n\nFIGURE 5.8.1. Shadow, receiver, blacker, and lighe source.\n\nthe wall. The wall receives the shadow, or “lack of light”; dherefare it is called the\nreceiver object, OF recerper.\n\nIf the light source is a poine light (infinitely small), the blocker object blocks the\nlight of char light source in a well-defined volume, usually referred to as a shaatow val-\nwane (see Figure 5.8.2), A shadow is created on a receiver object where its surface inter-\nsects with the shadow volume. As Figure 5.8.2 shows, the shadow volume has a\ntruncated, cone-like shape, starting at the blocker object and continuing to infiniry:\nWhereas the shadow volume really starts at the contours of the blocker abjecr, its\ncone-like shape originates from the light source.\n\nLet's examine how the cross section of the shadow volume changes as We Fer fur-\nther from the light source. We call the point on che blocker’s surface that is nearese to\nthe light source , and the one farthsese from it Pa\n\nWe can divide the shadow volume into three regions:\n\n1. Between the light source and P,\n2. Between P,and P-\n3. From poo infinity\n\nIt's easy to see that in Region 3, che cross-section of the shadow volume has a con-\nstant shape, but it increases in size as we get further from the light source.",
      "content_length": 1286,
      "extraction_method": "OCR"
    },
    {
      "page_number": 558,
      "chapter": null,
      "content": "5.8 Real-Time Shadews on Complex Objects 569\n\nShadow volume\n\ni\n\nFIGURE §.8.2. The shadow volume.\n\nBecause of this phenomenon, unless one or more receiver objects are in Region 2,\nthe shadow velume can be accurately modeled by projecting a pwo-dimensional mask\nfrom the position of the poine light source, Consequently, using che same projection,\nwe can map this 2D mask on the receiver objects to define che shadowed areas! This\n2D mask is called the shadow map, and it can be simply derived by drawing the\nblocker object's silhouere as sen from the light source,\n\nNotice that we cannot see the shadow cast by the torus in Figure 5.8.3a because\nthe torus exactly obscures it! This isa good indication chat indeed, we can simply use\na properly projected 2D image or mask (see Figure 5.8.3b) to define the shadow vol-\nume. This method is usually referred to as projective shadow mapping.\n\nThe Objectives of This Article\n\nTo draw shadows using the method introduced, we need no do the following:\n\n1. Create a shadow map for each light/blocker object pair.\n\n2. Calculate the shadow map (texture) coordinates to use on the receiver object's\nVertices.\n\n3. Render the receiver objeces with the shadow map applied as a 2D texture.",
      "content_length": 1222,
      "extraction_method": "OCR"
    },
    {
      "page_number": 559,
      "chapter": null,
      "content": "Section S Pixel Effects\n\nFIGURE 5.8.3. The blocker object as sen from. a, the light source, and &, ie silhowetre.\n\nCreating the Shadow Map\n\nThe first thing to do in order to render the shadow Map is SC Up a perspective projec-\nHon originating ar the light source. This projection projeas the blocker object onto a\nvirtual screen plane between the light source and the blocker object, yielding che\nshadow map shown in Figure §.6.4.\n\nShadowvolume\n\n4\n\n.\n\nshadow map\n\nFIGURE 5.6.4. The shadow map projection (also Color Plate 6).",
      "content_length": 525,
      "extraction_method": "OCR"
    },
    {
      "page_number": 560,
      "chapter": null,
      "content": "5.8 Real-Time Shadows on Complox Objects STi\n\nThe Light Coordinate System\n\nFirst, we define a new coordinare system with its origin ar the light source and its 2-\naxis pointing at the blocker object. The Z-axis of this coordinate system determines\nthe center line of the perspective projection, while its X}-plane defines the orientation\nof the screen plane on which we project the shadow map. IF we transform the blocker\nobject into this Mehr coordinate system, illustrated in Figure 5.8.5., we can easily project\nit onco this plane.\n\nTo define an arbitrary coordinate system, we need to know the position of its ori-\ngin and its orientation. We already know the position of the origin: Irs the position of\neur light source. We can describe the orientanon of the light coordinare system by the\ndirection of its three axes: Noe. Fugue and Zc, all 31D unit vectors in world! coordi-\nmates.\n\nFinding Zaye:\n\nScarting with the 2,4, axis, we can easily find X),,,and Vp... @.., 15.2 direction vector\nthat starts from the light source and points at the blocker abject. Ler's assume thar the\nblocker object is polygonal, and we have an array of all che polygon vertices that are\nused in rendering this object. Now we have a set of “target” poines in 3D space (the\nvertices of the blocker) and another point: che position of the light source. A fast and\n\nFIGURE 5.8.5. The light coordinate-system (also Color Plate 7).",
      "content_length": 1410,
      "extraction_method": "OCR"
    },
    {
      "page_number": 561,
      "chapter": null,
      "content": "STr2\n\nSection S Pixel Effects\n\nefficient way to obtain a “good” direction vector is to average the vectors that start at\nthe light source and point to each vertex. (We discuss a better approach later.)\nWre call the vector we have computed the magn direcient vector or MDV:\n\n4 Sv — Pie)\n\nMpDY=-—\n\nr\n\nwhere WV, ts the number of vertices considered in the blocker and #9... is the position\nof the light source.\n\nNormalizing MOV yields 2p.\n. MDV\n“p. =>~ =\n* |MBv\n\nOptimization Tip #1\n\nSince we will normalize A{DV, we don't have to divide the sum of light-to-wertex vec-\ntors by JV), saving one divide operation. We can also calculare P,.,.“.N, in advance and\navoid the — P.,, in the vertex loop, because:\n\nity at,\na = Pipe) 2\n\nHere is the C code to compute ick\n\ntypadet struct\nEsdType X,¥,2:\nshort Flags;\n\n} EadVertex;\n\nWold SnadowWatrix(Matrizx LelockerLocalToworloWatrix)\n\ni\nunsigned Jong L¥a, Li, LH, Le;\nfloat Mx, My, Mz, LPlightX, LPlightY, LPlightz,\nfloat LWOVX, LMOVY, LOVE, Sf Mean Direction Vector\nfloat Lelightex, Light’, L@lightz, fy Zlight weetor\n\nii Initialize Mean Direction Veotor to (0.0, 0.0, 0.0)\nii\nLOWE = LMOVY = LMDWZ = 0.0;\n\nLvartex = Lilesh-sVertices;\n\ni] AVEPage Vertex-to-Light vectors\nI",
      "content_length": 1209,
      "extraction_method": "OCR"
    },
    {
      "page_number": 562,
      "chapter": null,
      "content": "5.8 Real-Time Shadows on Complex Objects 873\n\nLin = LMesh-=huadt vertices;\n\nLUD = LPLightx * Lyn;\n\nLWOvY = LPLlightY * Lin;\n\nLUDVZ = LPLight2 * Lin;\n\nfor(LvG = OL WG = LWn} LVO++, L¥ertax++}\n\nMx=LVartex->X3 Wy=L¥ortes-2¥3 Wz=LVertex->Z;\nESdM_MateixTransformax4 (LBlockarLocalToworldMatrix, LX, LY, LZ};\n\nLWOVX -= LX;\nLMOWY -= LY:\nLMOWZ -= L?:\n\n}\n\n/i Hormalize Mean Direction Vactor (MoV)\n\nff\n\nLVF = sort (LMOV%* LVS 4+ Ley\" Levy +LMDV2* LED?)\n\nLVF = 7.0 / LVF: {/ We can save 2 divisions by doing this in\nff @tvance...\n\nLflight’ = LHW * LVF;\nL2lightY = LMOWY = LVF;\nLflight2 = LMEW2 * LVF;\n\n}\n\nEsdM_WatrixTransfarm3x4 isa macto function thar transforms a 31D vector given by\nfx, dy, and Mz with a3 * 4 matrix (actually the top-left part of a i x 4 matrix).\n\nFor the rest of the source code, please refer to the example program on this book's\ncompanion CD-ROM.\n\nFinding Xjeeq amd ¥ijots\n\nThe projection to map the shadow-map texture on the receiver object is the same as\nthe one used to draw the shadow map; therefore, the orientation of the shadow map\n{rotation around the Z),4, axis) does not matter. In other words, rotating the Might\nplane around #,,,, does not make any difference. This means that for the Ass, axis, we\ncan use any unit vector chat is perpendicular to 7,4, (refer back co Figure 5.8.5). We\ncan get thar vector as the cross-product OF Zinte and any other vector that i noe paral-\nlel wich 2;..- Let’s call this “helper” vector V\n\nWe know that at least two of the X, Kf or 2-axes of the world’ coordinare system\nmicet these criteria, 3¢ for simplicity, we use a unit vector V[x,y,<), with one coordinate\nbeing 1, the ochers 0,\n\nA vectors largest component (X, Foor 2) determines its dominant direction:\ntherefore, to get a vector that points far enough away from Zijgie We set CO 1 the com-\nponent of V'that has the smallest absolute valuc in 2)... This eliminates floating-point\nprecision worries when performing 2 vector cross-product operation on 2,4, and V-",
      "content_length": 1980,
      "extraction_method": "OCR"
    },
    {
      "page_number": 563,
      "chapter": null,
      "content": "sections Pixel Effects\n\nFor example:\n\nIf 2,¢=(0-381, 0.889, 0.254), Vwill be: (0.0, 0.0, 1-0) = 7, iy\n\nIf #5,@(-0,889, 0.254, 0.381), Vwill be: (0.0, 1.0, 0.0) =\nand soon.\n\nThe cross-product of 4.4, and V yields a third vector thar is perpendicular to\nboth of them. After normalization, this vector yields X;,.,,, the X-axis of the light coor-\ndinate system:\n\nae Ee xV¥\n\nWith AZ, and 2)... given, the ¥4,4, axis is just another cross producr away:\n\nNote that this step gives usa unit vector, so we dont have co normalize ¥;,,,,\nsince:\n\n[age| = 1 and |Z,4.| = Land Rep tZig = Nag, X Zaye] =I\n\nWith Aggie Vigge and 4). and P,., known, we can create the matrix that trans-\nforms a point from world coordinates to fight coordinates hy simply filling in these\nvalues\n\nYotXya Yor Fiy FokZiy 0.0\nZokXn4, ZotVig, ZofZ,,, 0.0\n-Xof Py, —YofP.,, —ZofF,,, 1.0\n\nM pantrretighr =\n\nThis is why we used Ap. Fi.-and 2;,,00 describe the orientation of the light\ncoordinate system.\n\nThe next step is to pre-mulciply this marrix with the blocker object's /onsl-te-\nwertd matrix. This step gives us the Jocal-to-Nght matrix for the blocker.\n\n!M tact rLacalT Ligic = Mi ncoberiacalTi Weed M ts nidTetight\n\nAs the name implies, the matrix transforms 2 point defined in the focal coordinate\nsystem of the blocker into the light coordinase system. Such wansformed X and ¥\ncoordinates define the paneifel or artbogomal projection of the blocker object onto che\nshadow-map plane (which is parallel with the XY plane of the light coordinate sys-",
      "content_length": 1517,
      "extraction_method": "OCR"
    },
    {
      "page_number": 564,
      "chapter": null,
      "content": "5.8 Real-Time Shadows on Complex Objects Ts\n\nDefining the Perspective Projection\n\nTo make this 2 perspective projection, we need a field of view, or the Xand ¥ “projec-\ntion ratios.” We can find the projection ratios (Ry and Ry) for cach vertex of the\nblocker object by transforming che vertex with Mitctertocetitigie and dividing the resul-\ntant Yand Yooordinates by the 2 coordinare:\n\npo | Vac,\n: Vere\n\nAdaptive Projection\n\nWe could always use the same rario for che projection, but that would lead to the\nblocker object's silhowette changing size in the shaclow map if we move the light\nsource closer or farther away from it. The same problem arises if we change the size of\nthe blocker or if the light source looked ar ir from a different angle. These changes\ncould result in a tiny image of the blocker in the middle of the shadow map or an\noversized image thar doesn't fit in the shadow map (see Figure 5.8.6). In the first case\n(Figure 5.8.Ga), we get a low-resolution shadow map with bad artifacts on the receiver\nobjects. This is a waste of shadow-map merry,\n\nThe latter (Figure $.8.6b) causes incorrect shadow shapes and possibly “shadow\nleaking” (see the section “Texture Coordinates and Shadow-Map Coordinates\"). In\nthis case, the shadow-map size is not large enough,\n\nInstead of one fixed valuc, we use the largest Ry (Ay...) a8 the horizontal ratio for\nthe projection, whereas the largest Ay (Ay,,,.) gives the vertical ratio. This makes che\nperspective projection adaprve for boch the X and ¥ direction, meaning thar che\nblockers silhouette always properly fills the shadow map, making the best usc of all\nthe picels in it.\n\nFIGURE 5.8.6. Non-adapaive (@ and &) and adapuve blocker orojecdion [rh",
      "content_length": 1711,
      "extraction_method": "OCR"
    },
    {
      "page_number": 565,
      "chapter": null,
      "content": "Section 5 Pixel Effects\n\n‘This concept is very important because we want to use the minimum necessary\ntexture size, for the following reasons:\n\n* ‘Texture memory is always a scarce resource, and the maximum texcure size might\nbe limited by other factors.\n\n* On some hardware, alter drawing the shadow map image, we have to transfer it\nfrom the frame buffer to a dedicated texture memory, and the speed of this crans-\nfer is limited by bus and memory bandwidth.\n\nNow we can fill our a standard perspective projection matrix for the blocker\nobject:\n\nO85 SMap Wideh 0 0 0\nA razz\n0 pee cea eeat 0 0\nF moe\n\nMH choPainaioe = rg Al\n0 0 ne\n\ncee = © ke\n\nfo\n\nwhere Sidap Wide and SiMapHeight are the horizontal and vertical resolutions of the\nshadow map in pixels, Z_,,and Z¢, are the distances of the near and far clipping planes\nof the viewing frustum from the lighe source.\n\nPre-multiplying this matrix with dM sicheri seat totigte Feels the 4% 4 macrix that per-\nforms a perspective projection from blocker local coordinares ro shadow-map coordi-\nnates:\n\nMaictertacelTathadnatteg = Mp chertocel tatigte *! Vl peecherPrecenien\n\nIn OpenGL, we can simply load an idenocy macrix inco the PROJECTION matrix\nand JM nihertscaTiShednitee INOO the MODELVIEW macrix and start drawing the shadow map\nusing the blocker's local coordinaces.\n\nOptimization Tip #2\n\nTo decrease the time it takes to create the shadow map, we can wee owe or three differ-\nent versions of the blocker object geometry for the various rendering stages:\n\n* To set up the shadow map projection, we blocker geometry with a minimum\nnumber of vertices. We wont need connectivity data (e.g., polygons) or normal\nveotors here. All thar matters is that no polygons of the blocker should be ourside\nthe projected shape of this volume, no matter the angle from which we look ar ir,\nbecause that would draw on the one-pixel edge of the shadow map, ruining texture",
      "content_length": 1909,
      "extraction_method": "OCR"
    },
    {
      "page_number": 566,
      "chapter": null,
      "content": "5.6 Heal-Time Shadows on Complex Objects\n\naT?\n\nCamping and causing “shadow Icaking.” We might even use a “good” bounding\nvolume such as che blocker's bounding-box, which could eliminate the need to\ncompute MDW (just use a vector from the light source to the center of the bound-\n\ning bene).\n\n* ‘To draw the shadow ALP, Wc blocker geometry witha Minimum or oo Surpance de\n\ntar! but Necessary contour detail\n\n* And, of course, to draw the blocker object, we need the geometry with all che sur\nface detail and surface properties (c.g., normal vectors) to make the object look\n\nspiky.\n\nOptimization Tip #3\n\nif che rendering engine is programmable, we can use a very simple (and possibly fast)\n\nrenderer code to draw the shadow map:\n\n* No lighting needed; a simple “Hat-color” renderer will do.\n* Wo clipping needed (the blacker’s image always firs in the shadow map!).\n\n* Wo depth testing (4-buflering) needed.\n\nProjecting the Shadow Map on a Receiver Object\n\nNow we have a shadow map associated with a blocker object and a light source. This\nshadow map can be projected on any number of receiver ebjeces, and because it is ap-\nplied as a texture, the receiver objects can have any complex shape (curves, holes,\n\nridges, and so om).\n\nAs mentioned before, we use the same projection to project the shadow map on a\nreceiver as we used to create the shadow map, The only differences are the image offset\nand scaling factors, because we use the [0..1] coordinate range as opposed to the\n\n[0...Sreap Wish] or [0..SrapHeight] ranges.\nThis is the appropriate projection matrix:\n\nOA? SMap Width a\nMian\n0.49\ni ——* Slap Alcighe\nAM a cteePrajucrive = ae\nth 0.5\n0 th\n\nThe next thing co do is to pre-multiply chis matrix with Mops arorces!\n\n=",
      "content_length": 1725,
      "extraction_method": "OCR"
    },
    {
      "page_number": 567,
      "chapter": null,
      "content": "Section S Pixel Effects\n\nMeacrmsintundinsT = Ml teutecigte ” 1M poriverPajecsion\n\nThe resulting manix cansforms a point from world coordinates to shadew-map\nrexture coordinates (the resuling Xand F give Sand 7 respectively).\n\nPre-multiplying Mos usmsutusiesr With the receiver's local-to-warld matrix yiclds\nthe marrix that we need co go from receiver local space directly to shadow-map texture\nspace.\n\nAM inka TeSbasheasMeg ST = DE peter igte . AM pcotnertrejerriaw\n\nTexture Coordinates and Shadow-Map Coordinates\n\nThe shadow map is an image with a finite number of pixels and integer coordinate val-\nues—for example, 256 % 256. However, texture coordinates are usually normalized\nfloating-point values, meaning char che range [0..1] refers co pixel coordinanes [0.255]\nhorizontally and [0.255] vertically. So what happens oucside the [0..1] range? We have\nto make sure char che rexel used on che receiver is che color used for “no shadow\" (black\nin Figure 5.8.7).\n\nOn most 31D hardware with texture mapping, you have at least reo options\n\n* ‘Texture repeat. Outside the [0..1] range, the texture is simply repeated—aa, for\nexample, in che [—1_.0] range of texture coordinates, the texture produces the same\nimage as the [0..1] range.\n\n* Texture clamping. The pixel on the edge of the texture image is repeated every-\nwhere ourside the [0_.1] range, or you can define a specific “border color” that is re-\npeated ourside the normal range.\n\nIt's easy to see thar we have to use texture clamping because we want a uniform ef\nfect on the receiver object outside the [0.1] texture coondinare range.\n\nTexture clamping effectively saves us from vesting the receiver objects for intersec-\ntion with the shadow volume. Because not all 3D hardware and APIs provide a separate\ntexture border color, we have to leave a one-pixel-thick border on the shadow map. If\nwe accidentally draw in this border, that pattern would be repeated on the receiver, pro-\nducing a leaking effect (shadow leaking\"). To make sure that nothing is drawn in chis\nborder, we have to slightly decrease the Xand F scaling factors in the projection macri-\nces (elemencs (0, 0) and (1,1)). This is the reason for using the value 0.98 (instead of\n1.0) in Mp ceePrejcsien aNd 0.49 (instead of 0,5) in Mp vetserPepersiee Nove thar these values\ndepend on the resolution of the shadow map. (See the example program on the CD for\nthe proper formulas to calculate them.)\n\nRendering the Receiver Objects\n\nThere are many differenc ways to draw the object receiving the shadew. The two most\neormrmon mechods are",
      "content_length": 2563,
      "extraction_method": "OCR"
    },
    {
      "page_number": 568,
      "chapter": null,
      "content": "5.8 Real-Time Shadews on Complex Objects 57g\n\n* Single-pass rendering, If there is no other texture on the receiver object, we can\n\ndraw it in one pass, applying a black-on-white shadow map asa texture and using\nthe light source ro illuminate the object.\n\n* Multipass rendering with subtractive blending. [fa receiver already has a texture\n\non itand the hardware doesnt support multitexturing, we need multiple passes:\n\n1. Draw the receiver abject normally.\n\n2. Draw the shadow pass with subtractive pixel blending, using a white-on-black\nshadow map. This successively decreases the surface color intensity where\nthere is a shadow cast. Use “GREATER-OR-EQUAL” or “LESS-THAN-OR-\nEQUAL” Z comparison functions for drawing multiple passes. This way, if\nyou pass the same primitive, it overwrites or blends the current pass with the\nprevious one,\n\nPor a brief description of pixel blending, please refer to the “Convincing-Looking\n\n(class for Games” article elsewhere in this book.\n\nExtensions and Enhancements to the Basic\n\nAlgorithm\n\nSimplicity and high performance usually come at a price. This projective shadow-map-\nping algorithm is ne exception to thar rule: It has some limitations. However, most of\nthese limitations are very easy to overcome, and the algorithm can be extended to han-\ndle these cases.\n\nBack-face Shadow Elimination\n\nOne side effect of projective shadow mapping is that it normally maps a shadow on the\nside of the receiver facing away from the light source.\n\nhal\n\nWe can correct ehis problem by either:\n\n- Determining whether a triangle is facing away from the light source and, if it is,\n\nassigning out-ofrange shadew map coordinates for all its vertices. (The example\ncode on the CD-ROM that accompanies this book does this.)\n\n. Setting up the rendering of the receiver in such a way char the receiver is com-\n\npletely black on the side facing away from the light source (no ambient lighting).\nThis is the proper method because it is closer co what happens in reality, How-\never, if there is more chan one light source in the scene, the “back” fee of the\nblocker can be lit by another light. In this case, we have to use multipass render-\ning and add the ambiente light and light coming from other light sources in sepa-\nfate drawing Passes.\n\nReceiver Is Behind the Light Source\nYou have to explicitly check for this case and not map a shadow on the receiver object.",
      "content_length": 2391,
      "extraction_method": "OCR"
    },
    {
      "page_number": 569,
      "chapter": null,
      "content": "Bao SectionS Pizel Effects\n\nMultiple Light Sources\n\n‘This case requires multipass rendering with subtractive blending on the receiver object.\nUse a receiver rendering pass for cach shadow map. The multiple passes successively de-\ncrease the intensity (RGB values) in the shadowed areas on the surface of the receiver,\nmaking even the shadow intersections look correct.\n\nMultiple Blockers\n\nThis case also needs multiple passes. There is one difference, though: The cumularive\neffect of shadow inrersections is incorrect because the owo blockers block the light of\nthe sane light source. Use the stencil buffer te mer daw in the screen area where there\n\nis already a shadow drawn.\n\nReferences\n\n[Blinn €8] Blinn, James, “Me and My (Fake) Shadow,” jive: Bint Commer, pages 53-61,\nJanuary 1988.\n\n[Foley90] Foley, etal., Comparer Graphic: Principles and! Practice, second edition, pages\n745-753, Addison-Wesley, 1990.\n\n[Blythe96) Blythe, David, and MeReynolds, Tom, Programming swith Opentl- Ad-\nnamed Rendering, SIGGRAPH \"96 Course Notes, August 1996.\n\n[Heckbert96] Heckbert, Paul, and Herf, Michael, Rar Soft Shadows, SIGGRAPH \"96\nVisual Proceedings, page 145, August 1996.\n\n[Heckbert97] Heckbere, Paul, ancl Herf, Michael, Steevdeting Sof? Shadows with Graph\nier Hardware, CMU-CS-97- 104, Computer Science Deparument, Carnegie Mel-\nlon Universicy, January 1997.\n\n[Woo97] Woo, Mason, Neider, Jackic, and Davis, Tom, OpenGL Programming Guide,\nsecond edition, Addison-Wesley Developers Press, Silicon Graphics, 1997.",
      "content_length": 1510,
      "extraction_method": "OCR"
    },
    {
      "page_number": 570,
      "chapter": null,
      "content": "9.9\n\nImproving Environment-\nMapped Reflection Using\nGlossy Prefiltering and the\nFresnel Term\n\nAnis Ahmad\n\nIn order co render a realistic scene, we must be able oo handle surfaces that can reflect\nthe environment around them. Environment mapping [Blinn76] has been used to\nimplement approximate reflections in real time. Wicw-independent implementations\n(such as dual parabolic maps [Heidrich®9) for older hardware or cube maps on newer\nhardware} area recent enhancement to environment maps,\n\nEnvironment maps map the scene around a particular point (the Maps origin) to\none or more texture maps. This is accomplished by associating each rexel no a vector\non the unit sphere. The value of cach texel is the amount of light arriving at the map's\nongin through the texel’s associated unit vector. Consequently, the environment map\ncan be indexed hy generating and converting unit vectors to texture coordinares or, in\nthe case of cube maps, by using the vector itself as a texture coordinate. Thus, by con-\nverting reflected view vectors to texture coordinates, one can index the corset points\non the environment map to allow for simulated reflections.\n\nAlthough simple and elegant, these environment maps only simulate the appear-\nance of shiny surfaces—surfaces whose reflections behave like perfect mirrors, regard-\nless of the viewing angle. A common enhancement to this approach is to combine the\nchvironment map with a diffuse texture map. Although this enhancement does\nimprove the quality of the image, it does mor address che underlying problem of an\noverly simplified reflection model, This article discusses the assumptions that lead co\ntus simplified model and deseribes two techniques, glossy prefiltering and Fresnel\ntemm weighting, which improve and extend existing approaches to using environment\nmaps.",
      "content_length": 1815,
      "extraction_method": "OCR"
    },
    {
      "page_number": 571,
      "chapter": null,
      "content": "a2 oe Section 5 Pixel Effects\n\nThe First Incorrect Assumption\n\nThe primary faule with ceaditional environment maps is che assumption thar all sur-\nfaces thar reflect light do so perfecely—thar is, che assumption char every incoming\nphoton char hits a sweface has all its energy reflected in one particular direction. This\nsimplified view of reflection is appropriate only for mirrors or for other highly specu-\nlar surfaces. For other cypes of reflective surfaces (dull metals, organic surfaces, and\nthe like), a more general view of reflection is meeded.\n\nAS shown in Figure Ie surhees generally Sitter light if miLhy directions. The\namount of energy reflected in a particular direction depends on properties of the sur-\nface involved, particularly its roughness. The result ts a somewhat blurrier reflection\n(since the light contributing co che image you see did noc cravel along a single, simple\npath from the lighe source to your eye).\n\nIn order to help describe how lighe scamers on reflection, computer graphics\nresearchers have introduced the bidirectional reflecnnce ditribusion funcrion (BRDF)\nthat serves as an abstraction thar models surface reflection. A BRDF computes che\nprobabiliry thac a photon arriving ac the surface in a given (incoming) direction will\nbe reflected in a particular (ourgoing) direction. Whereas a BRDF can take an arbi-\ntrary number of parameters (including surface attributes, the wavelength of light, and\n\nFIGURE 5.9.1. a: Simplified view of the reflection of light. b:A more realistic view of the\nrellection of ght.",
      "content_length": 1554,
      "extraction_method": "OCR"
    },
    {
      "page_number": 572,
      "chapter": null,
      "content": "5.9 Improving Environment-Mapped Reflection 583\nEee\n\nso on), the two meresary parameters are the light’s incoming direction and the desired\nourgoing direction. BRDFs are usually used to model reflectance in global illumina-\ntion solvers, Now, we see how they can be used to improve environmenc maps.\n\nWolfgang Heidrich and Hans-Peter Seidel deseribe a technique, called glossy pre-\nfiltering, that uses the Phong BRDF to apply appropriate blurring vo environment\nmaps. Fach texel of the filtered environment map is produced by finding its corre-\nsponding unit vector (used as the outgoing direction) and computing the color at that\ntexel with the following integral:\n\n!\npref(o) = s-¢-[ plo i) - arig(i) - deol)\nth\n\nwhere:\n\nereg is the original texture map.\n\nprefis the prefileered texture map.\n\nris the roughness parameter (reciprocal of the Phong exponent).\nsis the coefficient of specularicy.\n\ncis the Phong correction factor, (+41) / 1.\n\niand o are the incoming and outgoing directions (respectively).\np(x) is a function thar returns x if x >= 0 and rerurns 0 otherwise.\n£1 is che domain of the integral, che unit sphere.\n\naioli) is the measure of the solid angle in the direction of i.\n\nIn order to be practical, glossy peeliltering requires an input texture with a high\ndynamic range, that is, a texture whose values extend beyond the [0..1] range. This\nrange is needed te model the relatively high intensity of energy coming from light\nsources compared with the intensity of energy reflected off non-emitting surfaces, A\nnormal texture can be converted to one with a high dynamic range by multiplying all\ntexels corresponding to 2 light source by a large-scale factor. Note thar che preceding\nequation is used to apply the Phong BRDF to environment maps. Jan Kautz and\nMichael McCool [Kaur(0] describe a technique that allows for the use of any iso-\ntopic BRDF to prefilter environment maps.\n\nGlossy prefiltering has many advantages: The prefiltering need be done only\nonce, irs flexible, it’s fairly easy to implement, and it requires no change vo the ren-\ndering pipeline, since it merely filters traditional environment maps as a pre-process,\nThe disadvantages of glossy prefiltering are that ir's slow to compute (and can't be\nused for dynamic environment maps), it increases che memory requirements for tex-\ntures (since each surface type requires an entirely new set of maps), it requires input\ntextures with a high dynamic range, and it requires integrating over a sphere, which is\nmOn-Crivial,",
      "content_length": 2507,
      "extraction_method": "OCR"
    },
    {
      "page_number": 573,
      "chapter": null,
      "content": "k3\n\nSection S Pinel Effects\n\n8 eee\n\nThe Second Incorrect Assumption\n\nAnother assumption made when using environment maps is that the reflecting sur-\nface is metallic, When non-metallic surfaces reflect, che reflectance depends on the\nangle between incoming direction and the surface normal. The Fresnel term\n[Foley90] is used to simulate this dependency by modulating the reflectance. It uses\nthe incoming lighr’s angle and the surlace’s index of refraction to compute the appro-\npriating weighting. The formula for the Fresnel term is:\n\np-tene? |, [Ast =)\nMeth | [te O +i)\n\nwhere\n&=cos8\nGis che angle between the incoming direction and the surface normal\nf= +e —1\n\n1). is the index of refraction of the surface divided by the index of refraction of che\nTransmitting medium, as a function of wavelength, Sinec the index of refraction\nfor air is 1, you can usually simply supply the index of refraction of the surface.\n\nBecause in games you typically deal with surfaces and atmospheres thar have a\nconstant index of refraction, the only variable in the above equation is & Thus, the\nFresnel term can be written as a function of &, which is a variable in che range [10.1].\nThus, as noted by Heidrich and Seidel, we can precompure the Fresnel term and store\nit as a one-dimensional texture. By rendering the Fresnel term tinea che alpha channel,\nwe can incorporate it into the rendering pipeline using cither of the following meth-\nods:\n\nC=C, 7 F+Cy or C=C, \"F+C,*(1-F)\nwhere:\n\nC; C,. Cyare the final (output), mirror, and diffuse color values, respectively.\nFis the Fresnel term.\n\nUsing the Fresnel term in this way provides a more realistic reflection while con-\nsuming very litte memory. The disadvantage is that using it could require an addi-\ntional pass.\n\nConclusion\n\nWith the high performance of texture-mapping hardware and the increasing size of\nTexture memory, ic makes sense 00 use texture-mapping techniques to improve the:",
      "content_length": 1932,
      "extraction_method": "OCR"
    },
    {
      "page_number": 574,
      "chapter": null,
      "content": "6.9 Improving Environment-Mapped Reflection 585\n\nquality of rendered images. In this article, two such techniques were presented. Each\nis simple and requires very linle work to incorporate into existing rendering pipelines.\n\nAcknowledgments\n\nI would like to thank Michael Mefool, Michael Anttila, Sim Dietrich, and Mark\n\nDeLoura for reviewing this article.\n\nReferences\n—— ee\n[Blinn76] Blinn, J., and Newell, M., “Texture and Reflection in Computer:\n(Generated Images,” Communications of rhe ACM, 19:542-546, L976,\n[Heidrich99] Heidrich, W., and Seidel, H.-P, “Realistic, Hardware-Accelerared Shad-\ning and Lighting,” SIGGRAPH \"99 Praceedings, pages 171-178, August 1999.\n[Foley90] Foley, J.. van Dam, A., Feiner, 5., and Hughes, J., Computer Graphics: Prin-\ncipier and Practice, pp. 766-770, 1990,\n[Kaucz00] Kautz, J, and McCool, M.. “Approximation of Glossy Reflection with Pre-\nfiltered Environment Maps,\" Proceedings Graphice Interface",
      "content_length": 938,
      "extraction_method": "OCR"
    },
    {
      "page_number": 575,
      "chapter": null,
      "content": "5.10\n\nConvincing-Looking Glass for\nGames\n\nGabor Nagy\n\nThis article presents a few extensions to the algorichms most widely used to render\nglass objects in real tine.\n\nIntroduction\n\nRendering good-looking glass objects at interactive frame rates has long been a chal-\nlenge. Unul we have computer hardware char is fast enough for real-time ray tracing,\nwe MUSE compromise somewhere.\n\nTransparent Objects\n\nThere are three main visual properties of glass. A glass object i¢ usually:\n\n* Transparent. [¢ lets through some of the light hitting it, malang objects behind ix\npartly visible.\n\n® Refractive. It refracts light going through it and distorts che environment that\nshows through.\n\n® Reflective. It reflects some of the light hitting it, making the environmenr show\n\non its surtace.\n\nThis article mainly deals with the wansparent and reflective properties of glass.\n\nRasterizer, Frame Buffer, Z-Buffer, and Pixel\nBlanding\n\nTo draw a transparent object with today's 3D hardware, we usually use che fearure\ncalled pixel bienaing, or simply blending. Pixel blending is implemented in the last\nstage of a rendering pipeline, in the pexel renderer, after rasterization.\n\nThe rasterizer does the conversion of a primitive (triangle, line, and so on) into\npixels with Nand screen coordinares and a depth (4) value.",
      "content_length": 1308,
      "extraction_method": "OCR"
    },
    {
      "page_number": 576,
      "chapter": null,
      "content": "5.10 Convincing-Looking Glass for Games 587\n\nA simple pixel rendered with 2-buffering enabled will:\n\n= Compute the 2 (depth) value of a pixel to be drawn.\n\n* Compare thar value with the Z value stored at the corresponding position in the\n#-bulfer.\n\n* If itis determined that the pixel to be drawn is closer co the viewer (iris in font\nof the object or objects already drawn at that location), it simply overwrites the\npixel color and Z value im their respective buffers; if not, it does not change the\nframe buffer or 2-buffer at all.\n\nIn OpenGL, a smaller 2 value means that a pixel is closer to the viewer. Before\ndrawing a scene, the 2-buffer is initialized (cleared) vo che maximum Z value at each\npeel. This value depends on dhe bit-clepth of dhe 2-buffer. Note thar this value might\nbe the exact opposice, depending on your 3D API and hardware.\n\nOpaque Objects vs. Transparent Objects\n\nBecause the standard Z-buffer technique simply overwrites a pixel if it belongs to a\nsurface that is closer to the viewer than the one already drawn, it is only capable of\ndrawing perfectly opaque surfaces. To draw a transparent surface, instead of overwrit-\ning the pixel color in the frame buffer with the incoming (source) color, we need to\nsomehow blend che ewo colors.\n\nIn OpenGL, we can use the blending function to perform this task. We can\ndefine the blending function by calling:\n\ngiblendFunc(stactor, dfactor};\n\nThe color to put in the frame buffer is usually determined by:\nROB pate = ROB sume” sfactor + RGB gemseion * dfizctor\n\nwhere RGB. represents the red, green, and blue eamponents to be pur in the frame\nbuffer, AGH. is the incoming pixel components, and RGB... is the value\nalready in the frame buffer at the corresponding pixel.\n\nDepending on the OpenGL version, sfactor and dfactor can have many different\npredefined constants. For example:\n\ng1BLlendFunc(GlL_Ow, GL_ZERO):\ndoes a simple overwrite, because:\nRGB ote = RGB iam £ + RGB gunn 0\n\nin the frame buffer, we can call:\n\nQiblandFunc(GlL_ONE, GL_ONE};",
      "content_length": 2018,
      "extraction_method": "OCR"
    },
    {
      "page_number": 577,
      "chapter": null,
      "content": "Sao iu Sections Pixel Effacts\n\nThis gives us che following blending formula:\nAre eres Ait, Le *I4 RGB ga inatien vty\nTo make pixel blending work in OpenGL, we have to enable it by calling:\n\nglEnabie(GL_ALEND);\n\nFor a full description of pixel blending. please refer to your OpenGL manual\n[Woot].\n\nSince we have to consider the # values, we refer to pixels as AGRZ.\n\nWhen rendering a 3D scene with transparent objects, we can have one of the fol-\nlowing cases. The pixel currently being rendered (RGRZ,,.) belongs to either an\nopaque object or a transparent one and:\n\n* Tis Z value indicates that it is closer co che viewer chan che corresponding pixel\n(RGB Z pevweriee! already in the frame buffer (it is in front of the object or objects\nalready drawn at that location).\n\n* tis further from the viewer than RGA...\n\n* Ttis at the same distance as AGAZ\n\nDrawing Opaque Objects\n\nLet's examine what happens when we draw an opaque object. If RGAZ,,.,,,, 13 Closer ta\nthe viewer than GRE secure WE CAN Simply overwrite che frame buffer + Sti it. Hew-\never, if KGAZ,,., is further than RGOBZ gine WE Might scill have to draw it if it is\n\n“behind” a transparent object! Usually, we can simply avoid this problem by drawing\nall the opaque objects firsr.\n\nDrawing Transparent Objects\n\nWe use the valuc A,r (ijehe or Opacity valuc) co define how opaque the currently\ndrawn pixel is. A,_..-0.0 means that che pixel i completely rransparenc; 1-0 means it's\ncompletely opaque. If the pixel being drawn (AGE...) is in rove of the one in the\nframe bulfer (RGBZ cei!) WE Reed this formula to determine the resulting color:\n\nBlend Formula A: RGB.) = ROB oe * Aur * ROB gina” (LOA ee)\nIf RG BZ, one is behind RGBRZ,,,..<.. We Deed this formula:\nBlend Formula B: RGB, = RGB ace (1 0—A gerinmrion + RGB ennrnion ~A daiamsinn\n\nThis formula uses the presence of alpha-bivplanes in the frame buffer to keep\ntrack of the opacity of each pixel; see [Woo!7] for more details, We alsa have co\nupdate the alpha values of the pixels drawn.",
      "content_length": 2010,
      "extraction_method": "OCR"
    },
    {
      "page_number": 578,
      "chapter": null,
      "content": "5.10 Convinelng-Looking Glass for Games S65\n\nClearly, we have cwo different blending functions, or owo different courses of\naction to take, depending on whether AGBZ,__. is in front of RGAZ,___...or behind\nit. Since we can define only one blending function at a time, we have co find a work-\naround for this problens.\n\nDepth Complexity\n\nThe core of the problem is dpe compledty: che possibly multiple pixels (belonging to\ndifferent primitives) occupying the same screen position but with different depth values.\n\nAv depth complexity of 1 means char there are no primitives overlapping on che\nscreen. We would not even need 2-buflering in this case. When drawing a transparent\nprimitive, we only have to blend it with the background color, using Blend Formula A.\n\nA depth complexity of 2 means that the number of oveslapping primitives ar each\npixel is 2_ In this case, an opaque pixel cither obscures che background or a transpar-\nent pixel or itis behind only ame_opaque of transparent pixel.\n\nNote that the depth complexity of a 31 scene can change when the camera\nmoves.\n\nFortunately, OpenGL gives us some control over how the Z-buffering is per-\nformed. Specifically, we can disable # overwriting, so when a pixel is drawn, only che\nRGB values are changed in the frame buffer. Combined with some other features, this\nallows us to find solutions for most cases.\n\nA Simple Solution\n\nTo draw opaque and transparent objects in the same image, we can take a nor per-\nfectly correct but simple approach:\n\n* (lear che 2-buffer.\n\n* Draw all the opaque primitives (triangles, lines, and the like) with Z-resting and\n<-overwticing enabled,\n\n* Drew transparent primitives with back-face culling enabled (to minimize depth\ncomplexity between transparent pixels), <-werwnting disabled, and using Blend\nFormula A.\n\nThis method makes sure that opaque surfaces always obscure wansparent ones\nand that opaque surfaces behind transparent ones show through. Ir also guarantees\nthat two transparent surfaces always blend correctly if both surfaces have an alpha\nvalue of 0,5, because 0.5 = 1.0 — 0.5, so Blend Formula A and Blend Formula B are\nequivalent. Therefore, it does not matter if che currently drawn transparent pixel is\nbehind or in front of the one im the frame buffer. For alpha values other than 0.5 or\nmore than two transparent objects behind cach other, the results are not accurate but\nare still acceptable in many cases.",
      "content_length": 2421,
      "extraction_method": "OCR"
    },
    {
      "page_number": 579,
      "chapter": null,
      "content": "Section S Pixel Effects\n\n\"Simple\" Solution #2\n\nThis method is designed to solve the problems mentioned in the previous section by\nmaking sure thar the currently drawn primitive is always in front of the one already in\nthe frame buffer:\n\n* Clear “buffer.\n\n* Draw all the opaque primitives (criangles, lines, and so on).\n\n* Sort all transparent primitives by depth and draw chem in farthest-to-nearest\nender,\n\nThis way we need only Blend Formula A.\n\nThe major caveat of this approach is char the depth sorting might cause a signift-\ncant performance hit, especially if there are many transparent objects in different hier-\narchy nodes. There are also cases in which a primitive is neither complerely in front\nnor completely behind another (as in Figure 5.10.1). so we need a per-pixel depth\nsort, which would be extremely computationally expensive.\n\nAs long as the depth sorting works correctly, there is no limit to the depth com-\nplexity this method can handle, Note thar with chis method, we don't have to draw\nthe opaque objects first, but doing so could simplify the process.\n\nA Slightly Different Approach\n\nOpenGL lets us choose a depo fiunerion for #-buffering. The depth function deter-\nmines which # values pass the #-comparison. In OpenGL, ir is ustially dessthan,\nwhich means that if a pixel’s £ value is less chan the value in the Z-buffer, the pixel is\n\nFIGURE 5.10.1. Indeterminate depth order of triangles.",
      "content_length": 1419,
      "extraction_method": "OCR"
    },
    {
      "page_number": 580,
      "chapter": null,
      "content": "§.10 Convincing-Looking Glass for Games 5o4\n\ndrawn. This allows us to split the drawing of a primitive into nwo steps, using two dif\nferenc blending formulas. We need the presence of alpha values in the frame buffer for\nthis method.\n\nThe process is shown below:\n\n1. Clear 2-bufler\n2. Clear the alpha-buffer with value 0 (transparent).\n\n3. Set function to prearer-ohan (draw behind), use Blend Formula A, and draw the\nfirst transparenc primitive with 2 overwriting disabled. In addition, write the\nalpha value of the primitive into the frame buffer so chat subsequent pixels\nbehind it are blended correctly.\n\n4. Set 2 function to fee-than-or-equal (draw in frone), use Blend Formula A, and\ndraw this primitive again with Z overwriting enabled. Write the alpha value of the\nprimitive in the frame buffer so char subsequent pixels behind it are blended car-\nrectly.\n\n3. Repeat the last owo steps for cach transparent primitive.\n\n6. Ser 2 function to greater-than (draw behind), use Blend Formula B, and draw all\nopaque primitives with 2 overwriting disabled. The alpha value co write in the\nframe buffer is 1.0 (or che maximum integer valuc),\n\n7. Set Z function to fess-than-or-equal (draw in frome) and draw all opaque primi-\ntives with # overwriting enabled and blending disabled.\n\nUnforcunarely, if more than one pixel is drawn in any given position of the frame\nbutter (with differenc deprhs}, the opacity of this piel can no longer he represented\nby a single value. It depends on the depth or how many pinels there are in front of che\none being drawn. This is caused by the height-field-like narure of the #-buffer: It can\nstore only one depth value on a pixel, with subsequence pixels overwriting the old val-\nwes. In orher words, the 2-bufter has a fixed-depth complexicy of 1.\n\nTake the example in Figures 5.10.23 and 5.10.2b, Assuming that there are owo\nsurfaces drawn in the frame buffer:\n\n® Srofie, —Alpha: A, = 05\n* Sropftce, — Alpha: A, = 075\n\nIf, the pixel being drawn, is between Surface, and Surfaces Ageccien i 0.5 (only\nSurfitee, is in front of P). However, if? is behind both Surface, and Surfaces Ay cin\nis the cumuderite opacity ot Surface, and Surface, which is A,*A;-0.475.\n\nThis approach is slightly more flexible chan the one described in our simple solu-\ntion, without having to depth-sort the transparent primitives, but it has more limita-\nions and is more complicated than Solution #2. Furthermore, the frequent changing\nof the depth function at each primitive might cause a noticeable performance hic. A\nslight “tuning” of this method is recommended, depending on the application (espe-\ncially reeardine che modification of the aloha values in the frame buffer).",
      "content_length": 2689,
      "extraction_method": "OCR"
    },
    {
      "page_number": 581,
      "chapter": null,
      "content": "Section 5 Pixel Effects\n\nE\n\nP\n\nFIGURE 5.10.2. a; Effect of a single transparent SUrtace OF a pizel behind it 6: Cumulative effect of\ntultiple transparent surfaces.\n\nNon-Planar Glass Objects\n\nIf we look at a glass bowle or cup, we notice thar it appears darker at the edges, where\nthe surface normal starts to point away from the viewer, This is because light coming\nthrough the object is refracted at higher angles, so less of it reaches the viewer. We can\nsimulate this effect by illuminating the object with a light source char is always ar the\nSale position als chee CAT fa ia “head-lighe’). Such a light SLICE produces less illurrii-\nnation the more the surface normal poinss away from the viewer. A simple diffuse\nbead-light is very easy to implement and is computationally imexpensive.\n\nReflections\n\nFor simulating reflections, we can use sphere- of cube-environment mapping.\nOpenGL supports the use of spherical environment maps (with fish-cye images as\nenvironment maps). After initializing a texture, we can enable sphere mapping with\nthe following calle\n\nglTexGeni (Gl §, GL_TEXTURE_GEM MODE, GL_SPHERE_MAP) ;\n\nglTexGeni (Gl 1, GL_TEXTURE_GEM_WODE, 6L_ SPHERE_MAP) ;\n\nglEnable (GL_ TEXTURE _GEN 8);\npl&nable (GL_TEXTURE GEN T);\n\nThere are rin excellent articles on this subject, ET +] please refer co chem for fur=\nther details (see References).\n\nColored Glass\n\nUntil now, we referred to the opacity of a surface as a single value. If a surface is\nbehind a transparent one, the surface in front evenly decreased the R. G, and B color",
      "content_length": 1543,
      "extraction_method": "OCR"
    },
    {
      "page_number": 582,
      "chapter": null,
      "content": "5.10 Convincing-Looking Glass for Games Bad\n\ncomponent: of the one behind. We can use different opacity values for the R, G, and\nB componeats to describe the pigment in a piece of colored glass. This might require\nthe use of multiple drawing passes as described in the following sections,\n\nPutting It All Together\n\nSingle-pass Rendering\nWe can render the glass object in a single pass with:\n\n= An environment map applied as a 2D texture, the texture coordinates computed\nby a sphere-mapping algorithm\n\n* “MODULATE” texturing algorithm and a head-lighe\n\n* The proper pixel blending and 2 testing set up to draw it as a transparent object\n(as described in our earlier solutions)\n\nMultipass Rendering\n\nTo gain more control over che final appearance, we can perform two rendering passes:\n1. Pixel blending and 2 testing set up to draw it as a transparent object (as described\npreviously), We can also apply lighting on the object co simulate a diffuse surface\n\non the glass.\n\n2. Render the reflections on top, using additive blending (as in the single-pass case).\n\nWith two passes, we can define both the opacity and the reflectivicy of an object\nby changing the blending factors at each pass, We can also apply more complex for-\nroulas with multiple passes.\n\nImplementation\n\nFor implementation details with OpenGL, please refer to the sample program and the\ncomments in the source code on the included (D thar accompanies this book,\n\nTo see whar this technique looks like in action. take a look ar Color Plates 8-11.\nThese images were rendered on a Sony PlayStation 2.\n\nReferences\n\n[Greene86] Greene, Ned, “Environment Mapping and Ozher Applications of World\nProjections,” JEEE Computer Graphics and Applications, volume 6. number 11,\npp. 21-29 November 1986,\n\n[Woo97] Woo, Mason, Neider, Jackie, and Davis, Tom, OpenGL Programming Guide,\nsecond edition, Addison-Wesley Developers Press, Silicon Graphics, 1997,",
      "content_length": 1908,
      "extraction_method": "OCR"
    },
    {
      "page_number": 583,
      "chapter": null,
      "content": "3.11\n\nRefraction Mapping for\nLiquids in Containers\n\nAlex Viachos and Jason L. Mitchell\n\nIn chis article, we Present a concise and practical method of refraction-mapping lige\nuids in opaque containers on real-time consumer 3D) accelerators. Refraction, reflec\nton, and Fresnel terms are computed for water simulations at interactive rates.\nMethods for enhancing realism, including caustic effeers and particulate matter are\nalso addressed.\n\nIntroduction\n\nThe goal of this article is to present a rendering solution only. We are nor constrained\nby the water simulation used. For the sample code provided, however, we have chosen\nto use surface simulations based on Erik Larsen's newave sample (available online at\nhop:!/realicy-s¢j.com/opengl/glur3/ehuc3.html).\n\nThe illumination equation computed by this rendering method is fairly typical in\nthat it incorporates refractive, reflective, and Fresnel cerms, The Fresnel term is exsen-\ntally used asa blend factor between the refractive and reflective terms [T#'087):\n\nRemit = Fresnel * Refraction + (1-Fresnel) * Reflection\n\nThis is also a common practice in RenderMan shaders [Apodaca99].\n\nAdditionally, we address techniques for iNuminating the interior of the container\nas well as computing caustic effects. For all these techniques, we assume thar che\nviewer is outside the container and that the container is opaque.\n\nRefraction Term\nce arbre pe tasted a Pa\n\nSnell's Law\n\nA ray from the eye co cach vertex in the warer simulation is computed. This is the eye\nray in Fipure 5.11.1. Snell’s Law is chen used to refract the eye ray for each of these\nvertices. This mesh of polygons represents the interface berween the air and warer.",
      "content_length": 1683,
      "extraction_method": "OCR"
    },
    {
      "page_number": 584,
      "chapter": null,
      "content": "5.11 Rofraction Mapping for Liquids in Containers. 595\n\nEye Ray\n\nea Water Normal\nasa:\n\nFIGURE 5.17.1. Snell's Low in practice.\n\nSince the ratio of indices of refraction of water te air is 1.33, we use this value to com-\npute the refracted ray asa function of the water normal ar the given vertex, a: shown\nin Figure 3.11.1.\n\nReferring to Figure 5.11.1, the angle berween the water normal and the eye ray\n(@) is known as the angle of wecidence. The angle between the refracted ray and the\nnegated water normal (@)) is known as the angle of refraction. Snell's Law expresses the\nrelationship between these two angles and the ratio of the indices of refraction of the\nnwo media (air and water) as\n\nan in(@) = ae(Oo oor fh nse (GO) = snfO)\n\nFor the air-to-water interface, n, / n, is 1.3393, which gives us a simple formula for\ncomputing @, from ©:\n\nO, = resin [1333 sin(Q)]\n\nFrom here it is a simple matter to compute the refracted ray from the eye ray 30\nthat we can then decemmine the intersection with the container.\n\nintersecting with the Contalner\n\nOnce the refracted ray is computed, it i: necessary to determine the point of intersec-\ntion of the refracted ray with the container. This step ts the key to giving the visual\nimpression of a container of a particular shape. Paraboloid or hemisphere intersection\nvests, although simple and efficient, invariably give the impression of a dish-shaped\ncontainer, particularly if the viewer can move interactively in the scene. The water\ndemo used ar the Microsoft X-Box launch is an example of this [McQuade2000). To\ngive the impression of a more complex and realistic container, we have experimented\nwith a number of geometrically simple containers, and the results have been quite\nconvincing, In chis article, we stick with a simple parallelepiped container for brevity.",
      "content_length": 1820,
      "extraction_method": "OCR"
    },
    {
      "page_number": 585,
      "chapter": null,
      "content": "FIGURE 5.11.2. The refraction map (also see Color Plate 12).\n\nReferring back to Figure 5.11.1, we are now interested in intersecting the\nrefracted ry with the walls of the container, In this case, our container is made up of\nfive rectangular faces. Ray-plane intersections are computed fer each face until che\nintersection with the container is found, Once this point is known, we convert this\nposition on the inside of che container to a texture coordinate in a single refraction\nmap, which shows all five faces of che container, as in Figure 5.11.2,\n\nIn Figure 5.11.1, the refracted ray intersects the bowom face of the pool. This\ngenerates a texture coondinate in the corresponding region of the refraction map\nshown in Figure 5.11.2.\n\nWumination af the Container Interior\n\nIt ts possible to pre-light the interior of the container to further integrate the con-\ntainer into the rest of the scene. This is an importance visual cwe to consider when\nusing your water simulation im a larger scene. The source code included on the CD",
      "content_length": 1031,
      "extraction_method": "OCR"
    },
    {
      "page_number": 586,
      "chapter": null,
      "content": "5.11 Refraction Mapping for Liquids in Containers 507\n\nthat accompanies this book demonstrates the cechnique without additional geometry\nsurrounding the water pool, but the same technique, with the pre-lit refraction map\nshown in Figure $.11.2, has been incorporated inno the ne@idT/on graphics engine\nand is shown in Color Plates 13-16.\n\nReflection Term\n\nAny typical parameterization can be used for the reflective term of the illumination.\nWe chose to use 2 single-paraboloid environment map [Heidrich98] for our static\nscenes because this is supported on a wide array of hardware. A cube map could casily\nbe used for dynamic scenes. A dynamically updated planar reflection map can also be\n\nappropriate in same circumstances.\n\nFresnel Term\n\nNow thar the reflection and refraction terms have been computed, they must be com-\nbined using a Fresnel cerm. For details on the Fresnel equations, see the article\n“Improving Environment-Mapped Reflection Using Glossy Prefilrering and the Fres-\nnel Term” elsewhere in chis book. For the purposes of this article, the Fresnel equa-\ntions determine the ratio of reflected light to refracted light at a point on the water\nsurface as a function of the viewer's angle to the surface. In computer graphics, this\nterm is usually treated as simply a blend factor between the refractive and reflective\nterms, but it can also work well when multiplied only with the reflection map\n[Ts'o8? 1, [Apodaca99].\n\nAdditionally, che function itself can be modeled as a simple sinusoid or sinusoid-\nsquared falloff in the range of zero to one and tuned to caste. The sample program on\nthe accompanying CD computes the dot product berween the water normal and the\neye ray at each vertex. This gives the cosine between the vectors, which can be used\ndirectly as the Fresnel term or squared fora different look.\n\nThis equation can be cvaluaned directly at each vertex and linearly interpolated\nacross each polygon, as in the sample on the CD, or it can be computed per pixel as 2\nrexture lookup [Bastos?9)) .\n\nRendering with Hardware\n\nAll these computations have generared texture coordinates for the vertices in the mesh\nrepresenting the interface berween the air and warer. The texture maps used are static,\nand the mesh can be rendered in a single pass on consumer-level hardware that sup-\nparts at least pwo-texture multitextuning, the EXT_texture_énv_combine extensicn\nand the EXT_texgen_reflection extension, fora single paraboloid covironment map.\nThe Fresnel term serves as the blend factor between the two maps and is stored in the",
      "content_length": 2561,
      "extraction_method": "OCR"
    },
    {
      "page_number": 587,
      "chapter": null,
      "content": "Soe SectionS Pixel Effects\n\nprimary color interpolator’s alpha channel. Recall chat our goal is to compute the fol-\nlowing equation:\n\nRemalt = Fresnel * Refraction + (1-Fresnel) * Reflection\n\nWith the reflection map in texture zero, the refraction map in texture 1, and the\nFresnel term in the primary colors alpha channel, we can do this blend using\nARG_multitexture and ExT_teaxture_env_combine:\n\nglActiveTexture(GL_ TEXTURED ARB) ;\n\nglTexEnvt (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COWBINE_EXT):\n\nglTexEnvé (GL_TEXTURE_ENV, GL_SOURCEO_AGB_EXT, GL_TEXTURE);\n\nglTéexEnv? (GL TEXTURE ENV, GL_OPERANDO RGB EXT, GL_SAC_ COLOR);\n\nglTexEnvt (Gl _TEXTURE_ENV, GL_SOURCE1 RGB_EXT,\nGL_PRINARY_GOLOR EXT);\n\nglTexEnvt (GL_TEXTURE_ENV, GL_OPERAND1_RGB_EXT, GL_SAC_ALPHA);\n\nglTexEnvt (GL_TEXTURE_ENV, GL_COMBINE_RGB_EXT, GL_MOOULATE};:\n\nglTexEnvt (GL TEXTURE ENV, GL AGS SCALE ExT, 1.0%);\n\nglTexEnv? (GL TEXTURE EMV, GL_SOUACEO ALPHA ExT,\nGL_PRIWARY_GOLOR_ENXT):\n\nglTexEnvt (Gl_TEXTURE_ENV, GL_OPERANDO_ALPHA_EXT, GL_SRC_ALPHA):\n\nglTexEnv? (Gl TEXTURE_EMV, GL_COMBINE ALPHA EXT, GL_REPLACE);\n\ngLTexEnvt (GL_TEXTURE_EMV, GL_ALPHA SCALE, 1.0f);\n\nglactiveTexturea(GL TEXTURE1 ARB);\n\nglTexEnvt (GL_TEXTURE_EMV, GL_TEXTURE_ENV_ MODE, GL_COMBINE EXT);\nglTexEnvt (GL_TEXTURE_EMV, GL_SOURGED_RGB_EXT, GL_TEXTURE):\nglTexEnvt (GL_TEXTURE_EMV, GL_OPERANDO_AGS EXT, GL_SAC COLOR);\nglTaxEnvt (GL_TEXTURE_EMV, GL_SOURCE1_AGS_EXT, GlL_PREVIOUS ExT);\nglTexEnvt (GL_TEXTURE_ENV, GL_OPERAND1_AGS_EXT, GL_SRC COLOR):\nglTextnvt (GL_TEXTURE_ENMY, GL_COWIBINE _FAG3_EXT, GL_ADO};\ngiTexEnvt (GL_TEXTURE_ENY, GL_RGB SCALE EXT, 1.01);\n\ngLTaxEnvt (GL_TEXTURE_ENY, GL_SQURCEG_ALPHA EXT, GL PREVIOUS ExT);\nglToxEnvt (GL_TEXTURE_ENY, GL_OPERANDO_ALFHA EXT, GL_SRC ALPHA);\ng1TaxEnvt (GL_TEXTURE_ENY, GL_COMBINE_ALPHA EXT, GL_REPLACE) -\nglToxEnvf (GL_TEXTURE_ENY, GL_ALPHA_SCALE, 1.0);\n\nSince this is just 2 blend berween two static textures, the stress put on the render-\n\ning system is minimal; this technique is so far just a method for computing texture\ncoordinates. In spire of this simplicity, the visual results are surpcisingly realistic.\n\nFuture Extensions to This Technique\n\nWe have outlined a simple equation for water that includes reflection, refraction, and\nFresnel germs. Ocher viswal phenomena, such 2s caustics and Scattering due to partic-\nulate matter, can be modeled as well,\n\nCaustics Inside the Container\n\nOne of the most importane extensions to this technique is the use of caustic effects on\nthe interior of che container. One way to incorporate caustics into the scene is to",
      "content_length": 2559,
      "extraction_method": "OCR"
    },
    {
      "page_number": 588,
      "chapter": null,
      "content": "5.11 Refraction Mapping for Liquids in Containers 599\neach cn oo oa cele La\n\nmodel the refraction of light rays from a given light source and their intersection with\nthe container in much the same way that we are modeling this for the viewer's pasi-\ntion. Light transported along these rays could then be accumulated into a dynamic\n“caustic map,” which would be composited with the refraction map using multitex-\nture [Stam96]. Then again, for some applications, it might suffice to simply use a sta-\nTic caustic map thar scrolls along the interior of the pool over time. See the article\n“Advanced Texturing Using Texture Coordinate Generation” for a discussion of how\nto use the texture matrix to scroll texture coordinates frame to frame. This inexpen-\nsive technique was used in the Zora’s Domain level of The Legend of Zelda: The Oca-\nring of Time co give the impression of caustics refleceed off the surface of a lake onte\nthe surrounding cave walls.\n\nModeling Particulate Matter\n\nModeling the particulate matter present in the warer is an important visual cue thar\ncan casily be added co this system. In fact, the distance thar the refracted ray travels\nthrough the medium in the container is computed as.a by-product of the intersection\ntest, Using this term, is is possible to blend in a “water color\" at the vertices in much\nthe same way that terrain engines and flighe simulators blend in a fog color to simu-\nlate atmospheric effects. It should be noted char only the refractive term is affected Ley\nparticulate macter in the water.\n\nConclusion\n\nWe have presented a concise method of simulating refractive, reflective, and Fresnel\neffects of liquids in simple geometric containers in real time on consumer 3D hard-\nware. The technique was designed from the ousset co run efficiently on consumer\neraphics accelerapors. As such, the technique im its current state merely computes new\ntexture coordinates for the reflection and refraction maps and does no updates to the\ntextures themselves.\n\nWe have also presented some areas for extending the technique to include caustics\nand particulate matter as well as ideas for implementing these extensions.\n\nReferences\n\n[Apodaca99) Apedaca, A., and Grr, L, Adbanced Renalerifan: Creating CGI _for\nJfonan Picture, Morgan Kaufmann, 1999.\n\n[Bastos99) Bastos, R., Hott, K., Wynn, W., and Lasera, A., “Increased Phororealisin\nfor Interactive Architectural Walkthroughs,” ACM Sympostwnr on Interactive 3.D\nGraphres, pp. 183-190, 199.\n\n[Heidrich98] Heidrich, Wi, and Seidel, H.-P, “ fiew-independent Environment\nMaps,\" EurographicYACM SIGGRAPH Workshop on Graphics Hardware,\n1998.",
      "content_length": 2624,
      "extraction_method": "OCR"
    },
    {
      "page_number": 589,
      "chapter": null,
      "content": "E\n\nSection 5 Pixel Effects\n\n[McQuade(}0] McQuade, L., Perona! Communication, 2004).\n\n(Is'o87] Tso, P, and Barsky, B., “Modeling and Rendering Waves: Wave ‘Tracing\nUsing Beta-Splines and Reflective and Refractive Texture Mapping,” ACS Trans-\nactions on Graphics (6), pp. 191-214, L987.\n\n[Saam96] Stam, J. “Random Caustic: Natural Textures and Wave Theory Revis-\nited,” SIGGRAPH , available online at www.syntim.ingia.fe/syntimy research!\nstam/causticsheml, 1996.",
      "content_length": 461,
      "extraction_method": "OCR"
    },
    {
      "page_number": 590,
      "chapter": null,
      "content": "APPENDIX\n\n6.0\n\nThe Matrix Utility Library\n\nDante Treglia II and Mark A. DeLoura\n\nMatrix libraries are an integral part of game programming, and essencial in a wide\nvariety of applications such as advanced graphics, physics, collision detection, cte. It\nwas inevitable thar many of the articles would need to use some matrix operations\noutside of the OpenGL matrix functions. Therefore, with the input of many contrib-\nutors, a (C++ matrix library was written for all accompanying demo software to utilize.\nIt was intentionally designed to be an instructional nool, easy to read, and general pur-\npose, so very few optimizations have been added. We encourage you ro customize the\nlibrary for your game, and optimize it for your environment.\n\nSpecification\n\nThe libraries contain five main classes: vactor2, vactora’, vectors, matrixa3, and\nmatrixes. These represent vectors and marices of the corresponding size (e.g,\nmatrinégé is a 4x4 matrix). Vectors have public members called x, y, 2, and mw, and\nmatrices are composed of arrays of vectors. This library was designed ta provide the\nsame functionality and format as the OpenGL mamix functions; therefore, matrices\nare maintained in columm-row order. Most of the standard matrix and vector opera-\ntors have been overloaded; however, the cross product and dot product operations are\nprovided as utility functions for a more coherent notation.\n\nWOttors VRt5\nweotors veci(0.0, 1.0, 0.0);\nvectors vecz(1.0, 0.0, 0.0);\nmatrixa4 mtx = RotateRadWatrixes('x\", DegToAad(45.0));\nWeo = mtx * GrossFroduct (vac, VEC);\nLISTING 6.0.1. Answer vec = (0.0, 0.707107, 0.707 107]\n\nThere are a few things to keep in mind when using these libraries. First of all, the\ndefault constructors do not initialize members of each dass, This diminares redun-\n\n604",
      "content_length": 1786,
      "extraction_method": "OCR"
    },
    {
      "page_number": 591,
      "chapter": null,
      "content": "B02 : Appendix 6.0 The Matrix Utility Library\n\ndant operations for instances of vectors or mamrices whose members are immediaccly\nset. The classes provide appropriate initialization constructors and set methods. Sec-\nond, a point class is not provided. You will need to ensure char a homogenous com-\nponent is set (usually to 1-0) for vectors that are treated as points. Finally, if you need\nto load a marrix onto the OpenGL matrix stack, it is safe to casta pointer-to-matrix44\nto a pointer-to-floar. Enjoy!\n\nvectord pointa;\n\nmatrindd tranMtx = TranslateMatrix44(-10.0, 0.0, 8.0};\n\nPoints.set(d.0, 0-0, 0.0, 1,0}:\npoints = tranktx * pointd:\n\nLISTING 6.0.2. Answer; points = [-10.0, 0.0, 5.0, 1.0]\n\nSource Code\n\nThe code for the entire matrix library is on the CD. Please refer to the library for\n\nmore informacion on hew to use it,\n\nAcknowledgments\n\nSpecial thanks to everyone who contribured to chis library, especially Stan Melax,\nMiguel Gomez, Pete Isensee, Gabor Nagy, Score Bilas, James Boer, and Eric Lengyel.",
      "content_length": 1016,
      "extraction_method": "OCR"
    },
    {
      "page_number": 592,
      "chapter": null,
      "content": "APPENDIX\n\n6.1\n\nThe Text Utility Library\n\nDante Treglia II\n\nThere comes a point in every game's development when output is necessary. For such\npurposes, it fs very convenient to have this output displayed on che sereen, expecially\nif your game uses full screen mode. Many games today have “console” modes, which\nin mext cases were used by the programmer during the development of the game. You\nmay find it beneficial to write such a library and incorporate it inte your game. This\ntext library is a basic implementation of an ourpur text library written for OpenGL, It\nis small, easy to use, and most importantly, easy to hack! The texture used to create\neach 8x8 character is only 16K Bytes, so this library is perfect for debugging and pro-\nfiling.\n\nSpecification\n\nThe texe utility library is composed of one class named TextBox. It provides two\nmethods for drawing text to the screen. The first is by providing a screen coordinate\nand a string. The library automatically pushes the necessary orthographic projection\nto draw che text in screen space. It also pops the matrix, which preserves the previous\nmatrix state. The second method i: a customized version of the first. It requires that\nyou initialize an area of che screen to be the “text box.” Then, all the text printed\nthis box (there can be multiple boxes) will wrap and scroll within the box, much like\na standard shell, A convenient printf () function, similar to the standard C function,\nis used to print text. Unlike che first method, the text is stored in memory until the\nnext screen is drawn, so the printf() funetion can be used at any point during the\ngame. Text can be printed in any color with a transparent or opaque background.\n\nSource Code\n\nThe entire source code for the rext utility library is contained on the CD, along with\na demo. Please see che code for more details on how to use it.",
      "content_length": 1865,
      "extraction_method": "OCR"
    },
    {
      "page_number": 593,
      "chapter": null,
      "content": "APPENDIX\n\n6.2\n\nAbout the CD-ROM\n\nMark A. DeLoura\n\nEnclosed with this book you will find a CD-ROM thar is filled with all of the code\nfrom this volume and more! We feel very strongly thar for this book co really be of use\nro you, you need to have the source code in a form that you can use.\n\nHere are a few of the things you'll find on the CD-ROM:\n\n* All the source code listed in each article.\n\nComplete demos of many of the technologies described in this book. The demos\nrun under Windows and Linux.\n\nThe pliSerup Monolithic version.\n\nThe GLUT (OpenGL Unilicy Toolkit) disibution.\n\nThe Matrix Unilicy Library.\n\nThe Text Unilicy Library.\n\nLinks to groovy game programming sites.\n\nComplete installation and usage instructions are included on the CD-ROM in the\nAbour This: D hom file. Please read this firsc.\n\nAlso, be sure to check out the Website, www.gameprogramminggems.com/ for\nmore information about the book and about game programming in general!",
      "content_length": 951,
      "extraction_method": "OCR"
    },
    {
      "page_number": 594,
      "chapter": null,
      "content": "Index\n\nA® alporchm\naesthetic opimnanens, 24-271\nMaster Node List and Priotiry Queue Open Lim\n\nimplemenation, 283-296\nnaviration meshes and. 744-705\npachfinding. 2h)\npath plannins with, 254-2462\npriorizy queues for specd, 291-282, 283-286\nipeed optimmations for, 272-287\nweaknesses of, Db1—262\n\nALL See Arrificaal Intelligence {Al}\n\nAligniacne, 305-306\n\nAlpha-bera proning, 251-253\n\nAlpha blending, 195, $22-523\n\nAninarions\nkeviraming for, 465-170\nlight moaif, 528-534\nrexture coordinate animadon, 549-550\n\nArray Prey cla. 103\n\nArrays\nbit arrays, 101-103\nCampiled Vertes Asays (CWA), 356-358, 399-360\nSee ake Vocors\n\nAgtificial latdligenor (An\nengine desten, 221-2396\nfintic-state machine, 2737-248\nfuery logic, 319-329\nncuital nets and, 330.350\nscriprine behavior matshde godke, 234\nin scmpes, &\n\n@imert maar, 109-114\neopy-and-pate, 113-114\ncIAnoMmizing. Li=tbS 112-114\nembedding and, 110-111\n“Ignore Always\" opcion, 112-113\n{potasicn implometaton, 113\n\nAoclanen\naulo-anel heterozecration, 334\nHopiteld nets for, 345-350\nneural nets and, 342, 336\n\nAmenustion maps, 43-348\n\nAustanomous agents, 305\nAomidance, Fb\n\nBarefissoarce class, H-33\nBasic object memory manager, 68\nEefl, Tan, 133\nBirary trees, wavelets princple and, 182-184\nBitArray class, 101-102\nBeAr 2) clas, 102-103\nBitArray 2 class, 102-103\nBieProcp clase, 10\nBirwise eperations, 101-103\nBiistine fanctions, 529\nBoids, 305\n(CBoid class, 311=312, 314-317\nconsents on, JOR-309\nperceptian range of, Ma\nBenes, Sr Skeletal pqprescotations\nBat creation, 6\nBounding volumes, 380\nactress and, 440, 445146\niphere collisson deesction aleorithn, 4-395\nBrben, David, 133\nBranching instruction in script linguapes, 5\nB-spline:\ncamer come cures, I74-F76\nex. bermice splines, 470\nBugs. Sor Dicbagging\nBuildings, 49)—894\nalzonthms for, 492-453.\nKump mapping\nnormals, etre space fine. 556-557\nBeret dpace hump mapping, 957=959\ntexture space bump mapping, 559-561\nBRaoyaney, dioulating, 191-193\n\nCaldera. inverting, 09-410\nCalling conventions, 61-62\n(alls\n\nprofiler, 123\n\n605",
      "content_length": 2018,
      "extraction_method": "OCR"
    },
    {
      "page_number": 595,
      "chapter": null,
      "content": "606\n\nAppendiz 6.0 The Matrix Utility Library\n\nEchos procedure cally (RPC), S6—5%\nanieras\nB-spline cueves for conerod, 374-376\ncontrol technaques for, A71={379\ndamping, 377-478\nexposed functionality of, 3\neye space and depah value, 363-304\nfirst-person cameras, SF 1-3F3\nlens flare siemolations, $15—518\nlevel of derail and, 433-434\norientation of 36h, 375\nquaternions and onmcrel of, 379\nsonpicd camera, 37-377\nthird-person comers, 378\nVethot cainonad, 366-470\nZooming, ay\nCanmnull-Rom spline. 266, 267, 376-377\nCaunic, simelating, 598-599\nCBoid class, 311-312, 514-317\nCitor das, 49-310\nCarel mOrsineepolason clas, 144\nCED iid in rerpalerion lass, 147\nChor Ganiainiepeition class, 147-145\nCKlock class, 310-511, 312-314\nChaus, adding via messaging, 223\nChisses, 4\ncoupling, avoiding. 15—16\n\ndesigsing in Objex-Oricated Programming (OOP),\n\nll-12\nfinire-arare machine class, 257-245\nhandle clax, 70\nFreaker clases, 15-16\nprooy dace, 102-105\nClineartnferpelsion, 1438\nCade\nin-game profiling, 120-130\nreusing, 6\nCohesion, 305-36\nCollision detectnn, 390-402\nbounding sphere, 390-393\nLine-plane intercon, 34-35\nootree cansmucrion for culling, 43o444\nproitst-in-tintanple text, Sh—5O7\ntriangle “flamening.” 3952595\ncreingle-to-seianple, SMb, 39-397\nCompiled Vervex Arrays (CWA), 356-398, 359-300\nCorn pélers\ncalling conventions af, &162\nlimitations of, 24, 31\n\ntemplares 25 virrual, 20-22\nConupoution, 12\nCompression meghoeds\n\nimage compression, 1H5=186\n\nwavelets, | B2-1 8G\nConsole gare prices\n\ndoce loading. 9091]\n\ndebugging, 113-119\n\ndeprh-of-play technique, 133-140\nConstane, in data-driven dozen, 3-4\n(Concaimers\n\nEarnie comcaimers, “AZ\n\neohtasner adapter, 42, 53-54, 21-22\n\nmaps, 10=53\n\nSTL 41-42\n(Containment, 12\n(oats\n\narrival costs, 295\n\nhesirimic com, LF G27\n\npath function cost, 259=760, Fi 265\nCoupling of clases, avoiding, 15-16\nCrisp eres, 319-320\nCroustalk, 3-537\nCalling\n\nField of Wiew Cullieg Code, 425-429\n\nFrustam culling, 422-423\n\nexclusion culling, 421-931\n\nGOIree consmucrion for, 439-445\nCylinder-Erustam iittersection test, 300-35)\n\nalgorithms, 382-384\n\nradii, calculation of effective, 3E2, 3B3\nGrlindess, peneralized, 258\n(Cinder tests, $H0-389\n\nDaniping, 377-375\nDaca\nbig arrays foe, 11-103\nduplicue dase syndrome, 6-7\ninliemance, 6-7\njunk dara and security, 107\nloadin: quickly, 85-91\npreprocessing, HH\n=avIng, fa\ntenes for ercating.\nwarelers as analysis onl, 195=186\nDatalases, handle-lasce| roars manager for, GSP 4\nDara-driwen design, 2-7\nela plicate cata, os\nediting tools in, 7\nhard coding arnl, 3-5\ntext files and, 3\nDebupping\nconsole game syecems, 115=1 15\n\nreal-time in-game profiling, 120-130",
      "content_length": 2623,
      "extraction_method": "OCR"
    },
    {
      "page_number": 596,
      "chapter": null,
      "content": "Index oT\nSS ee\n\nStats aysnem. for, 1152119\nDcharzification methods, 327-328\nDep valucs of vertex, 341264\nDreques, 41—42\nStarland Templar: Library (311), 48-50\nDesigning, Li-12\nDerail, levels of, 433-j58\nView-independent progressive mevhes, 454464\nDiagenalizing, 156\nDiamond-square algorithm, 505-507\nDpijketra’s algorithm, 294\n1 + Computing, 417110)\nDLLs, generic fiinction-binding. 96\nDoom, 490-49]\nDouble-ended quewes, 41-12, 48-50\nDuplicace data syndrome, 67\nDynamic Link Libraries (IXLLs), generic friction\nbinding, 56, Gt\n\nEdges\ndifficule, 458549\nedpe choice functions, 458\nedge collapic, 455, 441-462\nsclecgiam Improwssnecnte, lit\nEditing noobs\nin data-driven dese, F\nmame bevel, 7\nState sytem for data-editing, 115-119\nEigenvaluss and eigenvectors, 15\nElite, 153, 499495\nEmbedding, 12\nSe Mao and imformason embedding, 110-111\nEnceyptian\nonline games and, 14-108\nrevere eiginecring and, 107\nEnemy Nations, 307\nEngines, Al\nevent-driven wi, polling objeces, 221233\nideal characteristics of, E21\nricsage abject, 222233\nstare machines, 235-3235\nEnginet, physics, 30-102\nEngines. scripting, 36-67\nEqvitonment mapping, 193-194\nExquarions\nNewton-Ealer cqpuations, 140-160\nfor simulating rigid bady motion, 140-160\nErosion, tcrrain, HM S2\nEaler angles, 196, 307-308, 37 1=<372\nEuler method\naccinacy of 1ED-181\nEuler angles, 196, 307-308, 371372\nexplicit, 1FB=179\n\npambal lock and Euler anples, 196\nimplicit, 179-181\nnusnerical srabiliry and, 177-151\nTigd body motion, 150—1m0\nEverr-driven objec, 271-223\nExclusvesor (MCR) operons, 107, 108\nExremigns, OpenGL, 357-358\nEye space, 363-364\n\nFarade pattem, 15-16\nFactonal cemplatcs, 22-33\nFactory pattems, 18-19\nFaults, fractal terrain generation, 455-903\nPeedhack, in Hopfield iets, 346-347\nFeet, for game objects, (4\nFtbonaced rimbers, 2-27\nField-ol-view culling, 422424, 425429\nFintte-srare machines (FSh{s), 237-248\ncresting stares for, 247243\nusing FiMoler, 243\nFire, liste mocif, 528-534\nFIR filrers, 301-902\nFloating objects, warer simulation and, 191-193\nFlocking, 305-318\ndignmend, 305-306\navonbiner, 3\ncohesion, 35-306\nniesiery and, 306\nScparuon, 5 —G\nsteenng behaviors, 305—20G\nFag, Tange-hared, 548\nFractal retrain generation\nFault formation, 499502\nmidpoint displaccenent, 203-507\nFrigmencarios, memory, 92-100\nFrames\nas handles, 3%\nmicmory allocarion, frame-based, 92-100\nFresnel eeriri\nfor reflections, 381-945\nrefraction mzpping, $4\nPrati\ncylindes-{rasnom imtersoction tex, 340-389\nFrustara culling, 422—(23\nview frustumes, 361383\nP3Mb (finite-state machines), 257-248\nFunctionality, exporting, $6=67\nFunction abjeces, 52\nFunction everhead, 353-454\nFunctions\ncalling functions, 63-44\ndomains and ranges of. 163-166\nFunctions, exporring, $6—67",
      "content_length": 2701,
      "extraction_method": "OCR"
    },
    {
      "page_number": 597,
      "chapter": null,
      "content": "608\n\na\n\nFunnccors, 52\n\nFisezy loge, 319-329\ndelumificaion metheds, $27—328\nFurey eoavinal, 322-3268\nfurzy landscaping, 424-485\nFurey sets, 520-321\nlingruisric variables of, 325\noperations, 321-322\na, Caditional logic, 31-320\n\nGame-path planning, 244-262\nCoame urees, 249-753\nalpha-beta pruning, 251-253\nmovesondering meiads, 152-155\nmamas alporithin, ZHI-251\nGenPrafiletn Simary, 179-130\nGimbal flock, 16\n(Zhes, rendering, 586-593\ncolored plas, 392-395\nmultipass, 593\nreflections an, 392\nsingle-pass, 393\nGlobal objects\nry. singlerons, ay\nCordis\ncaloulsting neighboring eeanes, 259\nrectangular pod space parccions, 255\nserch space apriminions, 2735\nwitd in mapping, 403\nCoraups\nflocking behaviors, 305-318\nmoving, 27]\nGuided miile, shore arc quacemion and, 214-215\n\nHaar warelecs, 1 #41\nHackers, online gums pemoieds, 104-108\nHall-Life, 307\nHanelleMgr clave, rif\nHandles\nframes and memory. 15-96\nhandle das, 70\nAandiler cls, 71-72\nim ftexiiamager, £5865\nreamed Manager and, 69-70\nHard coding. avoiding, c=\nHarelware\nbump mapping, 555-54]\nrendering tefeacton with, S97-S98\nHash eables, 280.781\nHeaders, 104\nHebb, Donald, 345\nHebbian nets, 345-346\nHebb necs, 345-346\n\nHerding, 305-318\n\nHeemice iplines, keyframing and, 467—i70\nHeuristic cos algorithm, Py ere, |\nHicrurchical pathfinding, 775-276\nHierarchy design, 12\n\nHophield, John, 346\n\nHopfield ners, HiG=-350\n\nHorizon cfect, 253\n\nHunparn nos, 21]\n\nHoystereus thresholding, 435\n\nIdentity matrices, 26-27\n“Tgeore Always” option in\\asert, 112-113\nImages\n\nrenopaition and moural ners, 41-44\nwavelers for compresiian, 185— 12\n\nImmediare nome functmonms, 353-354\n\nInfinite universes, algoerirhurss for, 124-159\n\nInheritance, 6, 12\n\nIniial value problems, 177-178\n\nIecrahiliry, explicar a. implicant methods, 177-178\n\nInteraction detection, multi-resolution maps far,\n\n403-411\n\nInrerfaces\nscibene function-binding incerface, $37\nSTG stem wed during protacyping, 119\n\nInterpolations, 141-149\nCRadethuliereryoleron, 144\nCfurGan Girne ero ieian, 17\nCFaseOutShifilnerpolasion, 147-148\nChinar!aterpedatrom, 148\nRoaring-paine mach im, 141-142\nfragec-rate-dependent ease-cur, l4l-Lad\nfranve-cate-independent case-in and -our, 144-146\nfranve-rate-independenc linear innerpolarion, 144\ninceger mash in, 142-144\nlimitations of. 146\nlinear interpolation (lerp), 2065, 209-211\nspherical cubic interpolation (sized), 207-208\napheneal line interpolation (slerp), ho—207\nspline inrerpolarians, 28, 711-215\n\nThins, 2 boursdary conditions, 10\n\nberated deepening, 252-153\n\nTreranoes, rovers, 44151)\n\nKeytraming\n\nhermite spline, A676\n\nintespolaced 3D, 465-170\n\nlinezr msterpolarian, 465\n\napline interpolating vertices, 469-470\n\nrerriacs and normals, interpolating of, 467\nKinomatis, tamslation and rocarion, 14154\nKline, Ohristapher, 317-318",
      "content_length": 2767,
      "extraction_method": "OCR"
    },
    {
      "page_number": 598,
      "chapter": null,
      "content": "609\na\n\nKren, Rehert, HP]\n\nLagrange series, 162=176, 172-175\neg, Taylos series, 174-175\nLandscaping, 44-10\nalgorithms for, 465-490\nFool: Line generation, 488-450\nFlcexy landscaping, 484-185\nSee abe Torain\nLava flows, simulating, 508-511\nLayering, 12\nLearning alporithims, 345-350\nLerss flare simulations, 519-318\nLerp, 206, 709-371\nLevels of detail (LOD, 432-458\n\nStandard Tomplace Library (STL), 46-49.\nSTL contaimers, 4142\n\nLoads, optimizing, BE-91\nLocations, parh search states, 757299\nLogic\n\nichipting, 46\nin scripes, $6\npa, daca in dary driven desipn, 3\n\nLogic fanctions\n\nAND, 358-24]\nOR, 353-341\nMOR. 358-Hi\n\nLogs of messages and state transitions, 232-233\nLook-ar urilities, 471\n\nalgorithm for selection, 435-437\nhysteresis thresholding, 435\nimplementsrien, 435-137\nmagnitication factors, 434, 437\ntlecman of, 455434\n\nthreshold selection, 437\nview-independent progrestive mebes, 4544-4\nLighting\n\nambaenr, 419-420\n\nattensstion maps, 343-548\n\nbump mapping for, $55-$61\n\nchange, 419420\n\nof conrainer interiors, 996-497\nconventional static lighting, 324-527\ndiffuse lighting faciors, 524, 555-556\nfog, tanger based, 548\n\night coordinate seems, 57 1—$74\nmocif-based scaric lighting, 528-554\nomni-clights, 526-527\n\nrealtime simularions, 455-942\nreflections, $$3-—554, $41-$85, 592\ntefraction chrouph water, 193-194\ntransparency, rendering, $86-593\nvertex color interpolation for, 537-542\nSer abe Shadows\n\nMGteros\nAssert macros, 109-1 14\nCpstylc forstue machine, 25-227\nMagnifscarion Eeetore, 454, 437\nManaper classes, 19-16\nAflaps\nbump maps for texmuring, 55561\nenvironmens maps, 193, 581\ngrid-based maps, 403\nLigh ieverdinane sytem foe, 571-974\nbphr maps, 343-548\neuulte-resolution mapy, 405-411\n,Sivironment mapped, $41-5845\nrefraction mapping, $4600\nshadow map, $67—5E0, 570\nHite variation problens, 403104\nsphenical reflection maps, 544-934\nSrandard Template Library, 50-53\nMaster mode lige, 282\nAiarrinca\nefficiency of templarized, 2-30\nidentity marrives, P4237\ninitialization of, 27\nfoval-to-waeld matte, J48-370\nmatriz-based cameras, 466-370\n\nLinear invespolition, 2G, 209-211\n\nLine-plase intorecrioa in collision derection, 394-395\nLinguistic variables, 323\n\nLiquids. refraction maps for, $4600\n\nmultiplication of, 229\n\nProjection matrix, 3451-362\n\nquatermions 24 feplacemend for, 195—] es\nSmale Wanaition mani, 238\n\ncaustic effeor inside container, 5O8—599\nomntaine and, 595-597\n\nFresnel werm, 594, $97\n\nparticulate marcer, medetine, $99\nSoell's Law, 34-995\n\nSee abe Wane\n\nLists\n\nOpen lets, AIF Rs\n\npalypon cwverlap, 442\n\niralsposition ak, £7-28\nMirrix-quaternion comversdons, 200-204\nMazes, 40195\n\nalporithms, 492493\nMBE (molecular beam epitaxy), 508\nMoCullock-Dins nes, 333-341\nMemory\n\nAS algorithm and, 2 Zr, 278-200\n\nCOUP ol, IS",
      "content_length": 2741,
      "extraction_method": "OCR"
    },
    {
      "page_number": 599,
      "chapter": null,
      "content": "610\n\ni EE EEE\n\nMemory (tCoee,!\n\nflocking and, 346\n\nfrapenentarien, preverricen of, 92-100\n\nfrume-based allocaion of, 92-100\n\nheaps, 94-96\n\nIberatiee dubeueocieing menor, 347, 330\n\nleaks, prevencion. nt Es\n\nmanagement af, 80-87\n\nmoral meta ad, 342, 346\n\nOpenGL extensions and, 357-358\n\nrelraseng, 95—100)\n\nibomEp, avraiding, A=) 1\n\nvootom, 45, 45\nMeshes\n\nnavigation meshes, 288-304\n\nprogressive, 438, itt\n\nvertex collapse and split, 445-455\n\nview-dependent and sindependene, 456-458\nMessage objec, 222-223\nMesrage Reuter, 75-1\nMaange\n\ndelayed sending, 229-230, 236\n\nlogging actraty and state transitions, 232-235\n\nnuacieg, 227-229, 245-246\n\nscope definition, 231-232\n\nseneing, 229-150\n\nsnooping, sailing, or peeking, 227\n\nunique [Dy in, 230\nMetaprogramming, templates, 20-35\nMethaxis, begin Oand eva (4213\nMicrosoft Developer Network Library, 66\nMielpoxinr displicemenc, rerun penerarion, 503-50\"\nMolecular beam opitaxy (MIBE), S08\nMamentuimt, near and anpulag, 14\nMotion\n\nflockieg implemeneszias, Sy7—309\n\nsimuluing med body motion, 150-160\nMountains\n\ncolderas, inverting, 09-511\n\nfractal terrain peneration, M3-S0\"\nMovement, navigation meshes and 3D, 288-304\nMoave-ordcring methods, 232-255\nMulrieresolurion mapa, 405—41 1\n\nNanve-manpling faciliry of (++, 65\nNance and naming, 10-11\nal peamtium for realistic names, 499-498\nHaimgariain Ritalion convention, 9-11\nnamme-manging Goality of Co4, 65\nNavigenenGell E92\nNavigation mesh\ncomsnuction of, 25)\n\nNastgation Mek, 292-293\n\ncontrollaay object etry eiiei£, 2a 95\nNavimesh, TH\nNegus: PSIG T Ot Sania algeridun, 240-751\nNerworks, prococals for online games, 104-108\nNeural ners, 3M 35h\nalponcium for, 345-350\nbiological analogs fer, 34-531\nclassification and reonpmizion, 34 1—=<244\ngame applications for, 331-332\nHebbaan neural meas, 345-346\nHopGchd nosral nom, 346-350\nnenenbes, 232-358\nplascmciny of, 330\nsrabilary, 336\ntemporal topes, 335-356\nMeurodes, 332-338\nMewton-Euka equations, 14-160\nincegracing. 158-159\nNodes, pathfinding, 278-280\ndecoupling. 27H-179\nmaster neue Gar for inorage, 2B0-28 |\n\nObjet Oeecnecel Pregeeaieienin (OOP), B19\n\nclasses, destening, 11-12\n\ncoding stybes in, 9-11\n\ndesign techniques and, B-19\n\nfagade pattcn in, 13-16\n\nEectory purer in, 18=19\n\nHungarian moracion, 9-11\n\nmingleson partes. 13-15\n\nanglaona, io\n\nStale paren in, 16-15\nOhpren, cveniabriven os, polling, 221-222\nOelwien Culiieg Gods, 429-131\nDOechusons, 425\n\nculling, 421431\n\nbounding volumes of, 445-446\ncansoruction of, 449-443\ndaa contained in, 440\nloose octrees, 446-153\nneighbors, 442\npolygon overlap lies, 442\nfer ray colligon teers, 41-15\nrepular os, loeec ocorees, 4514535\nised petites objec, 446-448\nHine alculaoon, progeesne meothes and, 462\nOnanislighrs, 526-527\nOnline games: network prococel for, 104-108\nOpacity et. tramipaneecy, 587-398\nOpen Gelds, hierarchical pachdinding, 269-2770",
      "content_length": 2840,
      "extraction_method": "OCR"
    },
    {
      "page_number": 600,
      "chapter": null,
      "content": "Index\n\nOpenGL\nExtemions for, 357-358\n‘Optimizing verncx submiwion for, $53=3400)\nspnine effeces, 19-424\n\nOpen lists, 262-286\n\nOricnration, P7308\n\nOrthoganality, 347-338\n\nPacker, 104\nrelay arracks, 103-106\ntampering, 104\nParallel proceuing, in warer simulations, 110-191\nParticle deposition, fractal terrain generation, 50—§1]\nParinoning\nlows: octress used fee, 445-148\nnerd et ai, IS6—3497\nspace, 257-259\nPachfineding,\nwith navigation meshes, 294\nnavigation mesic far, 228-304\nPath planning, 754-244\nA\" for, 254-262\ncost finctions for padhs, 259-260\nFunction costs, 259-200\nneighboring srates, 2 “]\nPARitioning space for, 257-159\nParhs\nacsthetic optimizacions for, 204-271\nB-spline cures, ST4-476\nCatznaill-Rom spline, 266-267, 376-377\ndecoupling pachfinding data, 278279\nhierarchical pathing, 268-270, 275-276\nAIT ne responiiveriess, 270-27 |\nnavigation meshes, Seb\nmode dare, 273-250\npauses, 270, 276\nsmboch paths, bS—2i\nstraight paths, 264-355\nwisibiliry teviny., 2M\nSee alo Pachiinding: Pada planning\nPatrolling, 2335 :\nPatterns, designing, 12-19\nPauses, 270, 276\nPayloads, 1M=105\nPerception ranges, 303\nPhysics engines, 390102\nPirch, 37-38, 371-372\nPla fractal alporichen, 4-07\nPlasticity, neural nets and, 336\nPainters, 6\nIn preproccmang daca, He\nTSOWIEE management and,\nuied im saving dat. 89\n\n617\n\nex. unique IDs in messaging, 230\nSoares pest, 306-457\nPolling objec, 221-222\nPolygon floors, 273-274\nPolygon overlaps algorithm, 442\nPolynomeals, 162-163\n\nAPPTOiTeAss Eo Pr poRomerric Aanesicite,\n\n1e-176 :\n\ndiscontinuities and. 175-176\n\ndomains and ranges of, 163-166\n\neven and add. 166-L67\n\nLagrange series, 172-175\n\nTaylor series, 167-171\nPopping,\n\nreducing, 432-828\n\npr. morphing venice, S60\nPrefiltering, glossy, 581-585\nPriority Quewe Object, 283\nPriarire quctc., 34.\n\nAY sped opsimizerons, 291-282, 283-286\nProjil:Begin, 124-125, 126\nProfiteDeonpOsrrarTeSwfer, 128-129\nProfifeEsd 124-125, 127-124\nProfiles\n\ncalls, adding, 123\n\nimplementation, 123-124\n\nreal-time in-game profiling, 120-130\nProjecnion riatrice:, 361362\nProximary pes, reducing number of, 403-411\nProxy clases, 102-109\nPhendo Rendon lacs, 156\n\nQed, 444145\nspace parrimoning, 254\nQhevtermons, 195—199\ncaoloalus Firnetions of, 20S 006\nemer. concal and, 374\naeteniion of complex members, 17-198\ninterpalating techniques, 205=213\nfincas interpolation {lerp), 206, 209-211\nMAEMO converons, Ti) 30g\nai macrix noplacemencs, 195-16\nnumestcal stability and shortest arc, F14—217\nphysical sigmifcance af numbers in, |-197\nfitations represented by, 19\nshores are quatemion, 214—218\nsphencal cubic interpolation (squad), 207-208\nspherical linear interpolation (dep), 205-207,\n209-211\nspline intcrpolations, 208, 211-213\n(Quatemion-to-martix conversion, SO-201\nQaecics, 4.\nof sare machines, 733",
      "content_length": 2757,
      "extraction_method": "OCR"
    },
    {
      "page_number": 601,
      "chapter": null,
      "content": "612\n\nRand fonction, 114i\nRandomness\nfractals, random line generatian, “M-})1\nRandom numbers\nalporithm for, 135-136\npredaccable, 134-140)\npredicrable, algorithm for generating, 135-135\nmind search, 154-135\nsrand, 134-135\nRay collision texts, octrees for, 443\nReceiver objects, shadow maps, 578979\nReflecians\nenvironment mapped, FAL=5R5\nFresnel tem and, 581-555, 397\non glass, 592\nTEppAryp, 5595-554\nRefraction\nmapping. 193\nSnell's Law, 34-595\nRamos procedure calle (RPC), 3-30\nReplay, packer apracks, 105-106\nRetifemager dass, 83-06\nResolucion, macto- and micro-infinite, 133-134\ninfinite uniwerses, 137\nResource manner:\nhavc object memory manager, 63\nhandle-basnd, G8-79\nhandles, 65-70\nIneo ry Tanager afud, A087\npointers, 69\nResources, locking and unlocking, 86\nResponsivencs, comimoller, 270-27 |\nRepnoldz, Craig, 205-306\nRigid bodies, special properties of, 1535-153\nRigid body motion\ndynamics of, 154\nkinematics, [50-154\nqaateri ier POAnion,. 214-215\nfocetian, 14-154\nsimulating, 130-lG0\nRall, P7308, 371-372\noreo re () poumne, 2142218\nRocomons\nguaternios foramions, 20\nquaternions for nepreseneing, 199\n\nRouters, mare machine mesape route, 227-229,\n\n335-136\nRumga-Kutta method, U77=178\n\nScaling S25\nSerepeing fanguapes,\nSorpes, ith\n\nAl engines and, 234\n\nbranching instructions in, 3\n\n34 Findse se machines, 5\n\nscripted cameras, 373-377\n\nScripting engines, 3-67\n\nPca 6\n\nSearch algorithms, 254-262\naniline gaming feanures, 4-108\nreverse cnginecring bor, 10?\n\nSending random peneraror, algorithm for. 139\n\nSeparation, 305-306.\n\nSequencer containers, 42\n\nShadows:\nadaptive projections, 575-577\nan comple: cbpece, 567-340\neroumd-plane shadows, 562=5i0\nlight coordinate srstemes fier maps, 571-574\nligsher pource, blockers, and reserves, 567—569,\n\noFr—3Fo\n\nmathematics of, Hi2—=565\nmubiple light sources, 550\npempective projections, 575\nrendering implementation, 563-366\nwadumes of, SOR—9\n\nShine-through, 552\n\nShoreline, at boundasy comdinions, 1M)\n\nSimonyi, Charles, 9\n\nSinglerans, 36-10\naunemaric singleton utility, 440\nsingleton pacenns, 13-15\n\nSime of game objects, 403—404\nmagmalicatien facnors, 434i\n\nSkelesal repreentaiions\nfast skinning method, 471-472\nGEeNNors Co shone matnecs in. 13-196\nsutching, 477420\n\nSkinning, 480-103\nfast and simple mecthoel foe, 471-173\nslitching and, 476-463\n\nSlerp, 206-207\n\nSnell's Law, 394-395\n\nSpace\n310 movement, 283-504\nflecking amd local space, 207\nlocal space optimézation, 368-370\ntoded space, D8\nneural nets as partitioning, aaG-337\npattizioriing, 2572259\nseach space optimizations, 272-27\nsimplified movement in 3D, 288-204\nrangent space, 555-559\nworld spain. Sp8-359",
      "content_length": 2613,
      "extraction_method": "OCR"
    },
    {
      "page_number": 602,
      "chapter": null,
      "content": "Index\n\nSpeed. optimising for\nA* optiouzanons, 272-257\ndara losing, 34-91\nFist math template mereprogramming, 20\nmemory allocation, 42-100\nated visual qealicy, 14\nSphere mapping, $53-554\nSpherical cubic innerpolation (squad), 207-208\nSphereal linc mterpolacion (lerp), 206-207\nSpinning whject, shortest an quaremion, 711-219\nSplashes, stmulacing, 191\nSpline istenpolations, MY, 211-215\nSpeite effects, 519-523\nalphe blending, $22-523\ndrawing 3D), 520-522\nrotazing, 523\nscaling, 423\ntextures for, 524\nSquad, 207-208\nSrand, 134-135\nSeacks, $3-4\nSondand Terplate Library, Ca+ (STL), 41-45\nalgormthmes, 42\ncomainer adapter, 53-54\ncontuners, 41—42\ndeques, 48-40\ntteranacs, 2\nlisrs, 446-44\nmaps, P33\nPriory qQuacd, $4, 221-282\nquewes, 54\nranger, method to dercomine, 4243\nstacks, 53-44\nvector, 43-45\nState machines, 275-735\n(ome macros for, 275-237\ndeleting pame objec within, 230\nevent-driven using messages, 225-225\nFinice Stare Machines (FSM), 237-248\nMhikeage rouring, 277-229\nmultiple stare machines, 233\npucuscmde for, 224\nqueues af, 235\nswappeng, 233\nSaabe pacers, 16-18\nSearen, 257\nAY adporichn for push planning, 254=255\ncrearung for FSM, 249-243\nPSM state, 739-140\neeiphboriog states, 259\nTransat Matrices, 238\nSee abe Stare machines\nScaristics, real-time and in-game debugging, 115-119\n\n613\n\nSreering belavtars, 305—\n\nSticky plane problem, loose cctrees for, 444453\nStitching, 4774 9h\n\nSTL. Se Standard Templare Library, Cre (ST)\nSere Orafiiele Hivary, 120-130\n\nSeating, 305-318\n\nTangent space, 356-399\nTaylor, Chis, 7\nTador series, 161-162, 167-171\ntruncated, 171\nat, Lagratees sericx, 174-175\nTemplates\nCr+ senda compliance, 25\nGesonal, 22=235\nFibonacci numbers, 2-27\nPACE Operations. 25-30\nfar merprogrumiming, 20-35\nfor uiganomecny, 23-25\nas virtual oompilers, 20-22\nTemplaces, Cre, I-35, 41-45\nTemporal topic: and meural nets, 335-5:\nTerrain\nbuildenpe, Saas\nerosion dimuon, 301-02\nfault line gemeration, 488490, 499-502\nfractal cerrain pemeration, 499-511\nfurry hondscaging, 44485\nlandecaping. A849)\nmazes, 49493,\nmountings, Mk=911\nparticle depewition, 50B—51 8\nreal-time, realistic, 444-498\nvolcan, SOR—5] |\nTeor files in parse development, 3\nTextiarcs\nbump mapping for, $55-$61\nprojection of, 550-551\nreflection mapping, 553-554\nthadow maps and. 578\nshine-thorough problem, $52\ntexture coordinare peneration, 54-554\nThresholds\nhysteresis thresholding, 435\nseleccion, 437\nTorquc, 134\nToral Annilzilarses, *\nTrickball, virtual, 717\nTraffic, furey logic for modeling, 372-528\nTraniparency\ngis, 75-399\nrendering. 199\n\nTrees",
      "content_length": 2530,
      "extraction_method": "OCR"
    },
    {
      "page_number": 603,
      "chapter": null,
      "content": "614\n\nIndex\n\nbinary, 182-184\n\nPaine trees, 249754.\nquodereess, 258, 444 j45\nSee ade Chores\n\nTriangle-co-nriang}e collision detection algorithm, 390,\n\n647\nTrigonomerric functions\npolynomial approaimstions for, 161-176\nTreo filrray class, 105\nTwo-dincnonal sprice effects, 519-925\n\nUnreal, 307\nUplift, simulating, 503-307\n\nVectors, 4) 12, 43-44\nassert macro for normalizing, 109-111\neqgenvectors, 156\nlacking implemensation, 307-208\nmamary af, 15\northepon alin of, S738\nrepresenting finite mtation wick, 151-144\ntied by vector cumeras, 367-37\nWertices\neoinpiled vertex amays, 3-347\ndata formar for submission, 3568-359\ninterleaved daca, 354-554\noprimizing slbmasson for Open, 353-360\npopping ex. morphing, 460\nprojected depeh valucs, 361=365\nrendering poformance, a55\nstrided and wecanmed data, 355-356\nverte: collapse and splir, 455-156\nVideo game comeoley\ndata loading, 90-91\ndebugging for, 115-119\ndepth of ply rechniques, 135-140\n\nViewpeunts, 196\nVWesibiliny\nmochesion culling, 421-45]\npeing of, 258, 274-275\nvisibility texing, 296\nWisual qualiry\nlevels of devail, 432-435\nPopping, 432-435\nWolcanos, terrain pemeration, 502-511\nWovels, 43\n\nWaver amulaion\nalpha blending Eng alssparency. 193:\nbuoyant objects, 191-193\ninstability of integration method, 190\ninteractive simulations, 187-14\nlight neftaction, 199-164\nparallel processing, 14-191\npaniculate matter im, 55)\nrendering, 193-194\napecd and visual qualiry, 194\nsplashes, 191\nwave oquanons, 1e7—La>\n\nWave equations, LAT-199\n\nWaveless, 182-156\nHaar waveless, 184-186\nimage oeniproasion, 185—186\n\nMOB (oochisive-or operator), 107, 108\nnee) octs and, 338-341\n\nYaw, 307-408, 371-372\n\nJette pares, 249\nfoaming, cameras, 377",
      "content_length": 1674,
      "extraction_method": "OCR"
    }
  ],
  "enrichment": {
    "version": "1.0.0",
    "generated_by": "generate_chapter_metadata.py",
    "contains": [
      "keywords",
      "concepts",
      "summary"
    ]
  }
}