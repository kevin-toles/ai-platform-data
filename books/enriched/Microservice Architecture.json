{
  "metadata": {
    "title": "Microservice Architecture",
    "author": "Irakli Nadareishvili, Ronnie Mitra, Matt McLarty, Mike Amundsen",
    "publisher": "O'Reilly Media",
    "edition": "1st Edition",
    "isbn": "978-1491956250",
    "total_pages": 144,
    "conversion_date": "2025-11-08T12:43:04.471026",
    "conversion_method": "PyMuPDF + OCR fallback",
    "source_pdf": "Microservice Architecture.pdf"
  },
  "chapters": [
    {
      "number": 1,
      "title": "Segment 1 (pages 1-8)",
      "start_page": 1,
      "end_page": 8,
      "detection_method": "topic_boundary",
      "chapter_number": 1,
      "summary": "Youll learn about the\n‘experiences of organizations aound the globe that have successfully\nadopted microservices,\n\nIn three parts, this book explains how these services work and what it\n‘means to buld an application the microservices way Key topics include microservice, design, and architecture. Covers design.",
      "keywords": [
        "Microservice Architecture",
        "microservices",
        "Architecture",
        "Mike Amundsen",
        "Ronnie Mitra",
        "Microservice Architecture Mcroservices",
        "Matt McLarty",
        "design",
        "Irakli Nadareishvili",
        "Microservice Architecture Benefits",
        "PRINCIPLES",
        "Microservice Architecture Goals",
        "microservices design",
        "Microservice Design Principles",
        "Microservices System Designer"
      ],
      "concepts": [
        "microservice",
        "design",
        "architecture",
        "architectural",
        "principles",
        "practices",
        "practical",
        "business",
        "culture",
        "cultural"
      ],
      "similar_chapters": [
        {
          "book": "Building Microservices",
          "chapter": 1,
          "title": "Microservices",
          "relevance_score": 0.7,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservice APIs Using Python Flask FastAPI",
          "chapter": 9,
          "title": "Segment 9 (pages 72-80)",
          "relevance_score": 0.68,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 3,
          "title": "Segment 3 (pages 17-25)",
          "relevance_score": 0.68,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 30,
          "title": "Segment 30 (pages 296-304)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 2,
      "title": "Segment 2 (pages 9-16)",
      "start_page": 9,
      "end_page": 16,
      "detection_method": "topic_boundary",
      "chapter_number": 2,
      "summary": "This chapter covers segment 2 (pages 9-16). Key topics include microservices, design, and chapters.",
      "keywords": [
        "Microservice Architecture",
        "Microservices",
        "Book",
        "Safari Books Online",
        "Books Online",
        "Architecture",
        "Design",
        "Safari Books",
        "Guidance",
        "System",
        "practices",
        "microservice systems",
        "Press",
        "Online",
        "Preface"
      ],
      "concepts": [
        "microservices",
        "design",
        "chapters",
        "thank",
        "preface",
        "architecture",
        "architectural",
        "press",
        "service",
        "book"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.84,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 3,
          "title": "Segment 3 (pages 17-25)",
          "relevance_score": 0.77,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 7,
          "title": "Segment 7 (pages 68-75)",
          "relevance_score": 0.77,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 30,
          "title": "Segment 30 (pages 296-304)",
          "relevance_score": 0.75,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservice APIs Using Python Flask FastAPI",
          "chapter": 3,
          "title": "Segment 3 (pages 17-24)",
          "relevance_score": 0.7,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 3,
      "title": "Segment 3 (pages 17-24)",
      "start_page": 17,
      "end_page": 24,
      "detection_method": "topic_boundary",
      "chapter_number": 3,
      "summary": "This chapter covers segment 3 (pages 17-24). Key topics include microservices, traffic, and architecture. Covers architecture. It turns out that\nthe recipe for traffic safety is a combination of all of these things, delivered by an\ninnovative program called Vision Zero.",
      "keywords": [
        "Microservices",
        "microservice architecture",
        "system",
        "Safety",
        "software",
        "road",
        "microservice system",
        "n’t",
        "adopting microservices",
        "architecture",
        "traffic",
        "microservices style",
        "Vision",
        "software systems",
        "microservices systems fit"
      ],
      "concepts": [
        "microservices",
        "traffic",
        "architecture",
        "architectural",
        "designed",
        "road",
        "software",
        "developed",
        "teams",
        "systems"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 3,
          "title": "Segment 3 (pages 17-25)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 30,
          "title": "Segment 30 (pages 296-304)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 9,
          "title": "Segment 9 (pages 86-94)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 4,
      "title": "Segment 4 (pages 25-32)",
      "start_page": 25,
      "end_page": 32,
      "detection_method": "topic_boundary",
      "chapter_number": 4,
      "summary": "This chapter covers segment 4 (pages 25-32). Key topics include software, speed, and service. Covers architecture.",
      "keywords": [
        "microservice architecture",
        "Microservices",
        "speed",
        "microservice architecture benefits",
        "software",
        "safety",
        "architecture",
        "software system",
        "business",
        "change",
        "system",
        "software delivery speed",
        "delivery speed",
        "scale",
        "services"
      ],
      "concepts": [
        "software",
        "speed",
        "service",
        "microservices",
        "change",
        "changing",
        "business",
        "independence",
        "independent",
        "technological"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.74,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 7,
          "title": "Segment 7 (pages 68-75)",
          "relevance_score": 0.74,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 3,
          "title": "Segment 3 (pages 17-25)",
          "relevance_score": 0.73,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 9,
          "title": "Segment 9 (pages 86-94)",
          "relevance_score": 0.73,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 30,
          "title": "Segment 30 (pages 296-304)",
          "relevance_score": 0.72,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 5,
      "title": "Segment 5 (pages 33-40)",
      "start_page": 33,
      "end_page": 40,
      "detection_method": "topic_boundary",
      "chapter_number": 5,
      "summary": "Network-\naccessible modularization facilitates automation and provides a concrete means of\nabstraction Key topics include service, microservices, and design. Covers architecture.",
      "keywords": [
        "microservice architecture",
        "microservice",
        "Cohesive Microservice Architecture",
        "architecture",
        "Microservice Architecture Goals",
        "Modularized Microservice Architecture",
        "Systematized Microservice Architecture",
        "microservice architecture benefits",
        "system",
        "Average",
        "microservice architecture layer",
        "average pilot",
        "Cohesive Microservice",
        "Approach",
        "benefits"
      ],
      "concepts": [
        "service",
        "microservices",
        "design",
        "approach",
        "goal",
        "architectural",
        "pilot",
        "daniels",
        "benefit",
        "level"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 3,
          "title": "Segment 3 (pages 17-25)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "Software Architecture",
          "chapter": 8,
          "title": "Segment 8 (pages 63-71)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.61,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 30,
          "title": "Segment 30 (pages 296-304)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "Building Microservices",
          "chapter": 12,
          "title": "Bringing It All Together",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 6,
      "title": "Segment 6 (pages 41-49)",
      "start_page": 41,
      "end_page": 49,
      "detection_method": "topic_boundary",
      "chapter_number": 6,
      "summary": "Throughout the remaining chapters of this book we will dive deeper into the\ndetails of microservice adoption Key topics include designing, standardized, and standardization. Covers design.",
      "keywords": [
        "system",
        "Designing Microservice Systems",
        "microservice system",
        "Microservice",
        "good microservice system",
        "design",
        "microservice system behavior",
        "Microservices Design Process",
        "system behavior",
        "Designing Microservice",
        "behavior",
        "system design",
        "work",
        "Systems Approach",
        "services"
      ],
      "concepts": [
        "designing",
        "standardized",
        "standardization",
        "standardize",
        "microservice",
        "services",
        "decisions",
        "decision",
        "architecture",
        "architectural"
      ],
      "similar_chapters": [
        {
          "book": "Building Microservices",
          "chapter": 1,
          "title": "Microservices",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 3,
          "title": "Segment 3 (pages 17-25)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 29,
          "title": "Segment 29 (pages 279-295)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        },
        {
          "book": "Building Microservices",
          "chapter": 11,
          "title": "Microservices at Scale",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservice APIs Using Python Flask FastAPI",
          "chapter": 9,
          "title": "Segment 9 (pages 72-80)",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 7,
      "title": "Segment 7 (pages 50-57)",
      "start_page": 50,
      "end_page": 57,
      "detection_method": "topic_boundary",
      "chapter_number": 7,
      "summary": "A single optimization goal (like the\n34 \n| \nChapter 3: Designing Microservice Systems Vision Zero goal of zero traffic-related fatalities) provides the most clarity and has a\nhigher likelihood of succeeding Key topics include designing, goals, and change. Covers design.",
      "keywords": [
        "system",
        "Microservices System Designer",
        "system design",
        "microservice system",
        "system design process",
        "Microservices Design Process",
        "design process",
        "design",
        "goals",
        "microservices",
        "system optimization goal",
        "Microservices Design",
        "process",
        "Optimization Goals",
        "change"
      ],
      "concepts": [
        "designing",
        "goals",
        "change",
        "chang",
        "teams",
        "microservice",
        "make",
        "making",
        "right",
        "culture"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 4,
          "title": "Segment 4 (pages 26-50)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 30,
          "title": "Segment 30 (pages 296-304)",
          "relevance_score": 0.52,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 3,
          "title": "Segment 3 (pages 17-25)",
          "relevance_score": 0.51,
          "method": "sentence_transformers"
        },
        {
          "book": "Designing Machine Learning Systems An Iterative Process for Production-Ready Applications",
          "chapter": 7,
          "title": "Segment 7 (pages 50-57)",
          "relevance_score": 0.48,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservice APIs Using Python Flask FastAPI",
          "chapter": 9,
          "title": "Segment 9 (pages 72-80)",
          "relevance_score": 0.47,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 8,
      "title": "Segment 8 (pages 58-65)",
      "start_page": 58,
      "end_page": 65,
      "detection_method": "topic_boundary",
      "chapter_number": 8,
      "summary": "This chapter covers segment 8 (pages 58-65). Key topics include principles, goals, and services. But thanks to the efforts of generations of technologists we have access\nto proven methods for boosting both speed and safety.",
      "keywords": [
        "Principles",
        "Goals",
        "speed",
        "microservice",
        "build",
        "Netflix",
        "component",
        "tools",
        "microservice architecture",
        "Unix",
        "Release",
        "service",
        "Cost",
        "important",
        "Increase Release Speed"
      ],
      "concepts": [
        "principles",
        "goals",
        "services",
        "microservice",
        "tools",
        "building",
        "developer",
        "release",
        "releasing"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 9,
          "title": "Segment 9 (pages 86-94)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 7,
          "title": "Segment 7 (pages 68-75)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 30,
          "title": "Segment 30 (pages 296-304)",
          "relevance_score": 0.59,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 9,
      "title": "Segment 9 (pages 66-73)",
      "start_page": 66,
      "end_page": 73,
      "detection_method": "topic_boundary",
      "chapter_number": 9,
      "summary": "This chapter covers segment 9 (pages 66-73). Key topics include teams, services, and company. Common database technologies (MySQL, Cassandra, etc.) and other software-\nimplemented infrastructure is another example of shared services.",
      "keywords": [
        "team",
        "services",
        "Shared",
        "Culture",
        "Shared Capabilities",
        "organizations",
        "shared services",
        "tools",
        "Netflix",
        "Code",
        "make",
        "Capabilities",
        "Amazon",
        "innovation",
        "Communication"
      ],
      "concepts": [
        "teams",
        "services",
        "company",
        "shared",
        "tooling",
        "innovation",
        "innovative",
        "innovate",
        "communication",
        "communicate"
      ],
      "similar_chapters": [
        {
          "book": "Software Architecture",
          "chapter": 27,
          "title": "Segment 27 (pages 257-266)",
          "relevance_score": 0.76,
          "method": "sentence_transformers"
        },
        {
          "book": "Building Microservices",
          "chapter": 12,
          "title": "Bringing It All Together",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        },
        {
          "book": "Release It! Design and Deploy Production-Ready Software",
          "chapter": 25,
          "title": "Segment 25 (pages 200-207)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Reliable Machine Learning",
          "chapter": 42,
          "title": "Segment 42 (pages 360-367)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 10,
      "title": "Segment 10 (pages 74-81)",
      "start_page": 74,
      "end_page": 81,
      "detection_method": "topic_boundary",
      "chapter_number": 10,
      "summary": "Summary\nIn this chapter we’ve reviewed the common set of platform capabilities called Cock‐\ncroft’s “microservices concerns” and cited examples of how a number of organiza‐\ntions provide these platform capabilities to their teams Key topics include microservices, services, and developers. Covers design.",
      "keywords": [
        "microservice",
        "microservice boundaries",
        "system",
        "bounded contexts",
        "Hootsuite",
        "design",
        "service",
        "context",
        "team",
        "Service Design",
        "Model",
        "microservice architecture",
        "DDD",
        "boundaries",
        "Bounded"
      ],
      "concepts": [
        "microservices",
        "services",
        "developers",
        "designing",
        "modeling",
        "data",
        "teams",
        "business",
        "evans",
        "way"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 4,
          "title": "Segment 4 (pages 26-50)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 3,
          "title": "Segment 3 (pages 17-25)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "Building Microservices",
          "chapter": 1,
          "title": "Microservices",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 30,
          "title": "Segment 30 (pages 296-304)",
          "relevance_score": 0.6,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 11,
      "title": "Segment 11 (pages 82-89)",
      "start_page": 82,
      "end_page": 89,
      "detection_method": "topic_boundary",
      "chapter_number": 11,
      "summary": "We will discuss some of those tools later in this chapter, in\nparticular when we look into data storage for microservices Key topics include apis, microservice.",
      "keywords": [
        "API Design",
        "Design",
        "data",
        "APIs",
        "microservices",
        "API",
        "event sourcing",
        "web",
        "Service Design",
        "bounded context",
        "Web APIs",
        "event",
        "services",
        "microservice component design",
        "hypermedia APIs"
      ],
      "concepts": [
        "api",
        "apis",
        "microservice",
        "data",
        "design",
        "values",
        "web",
        "service",
        "independence",
        "independently"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 9,
          "title": "Segment 9 (pages 86-94)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "Building Microservices",
          "chapter": 12,
          "title": "Bringing It All Together",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservice APIs Using Python Flask FastAPI",
          "chapter": 6,
          "title": "Segment 6 (pages 43-51)",
          "relevance_score": 0.64,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservice APIs Using Python Flask FastAPI",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 7,
          "title": "Segment 7 (pages 68-75)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 12,
      "title": "Segment 12 (pages 90-97)",
      "start_page": 90,
      "end_page": 97,
      "detection_method": "topic_boundary",
      "chapter_number": 12,
      "summary": "As it turns out, we need one more\ndesign pattern, CQRS, to complement event sourcing and we will be well on our way\ntoward being able to design effective data storage for microservices with data persis‐\ntence models that can avoid data sharing at even very small microservice sizes Key topics include events, microservices, and transactions.",
      "keywords": [
        "Shipment Management microservice",
        "Data",
        "event sourcing",
        "microservice",
        "Shipment Management",
        "event",
        "Tracking microservice",
        "CQRS",
        "Shipping",
        "Shipment Tracking microservice",
        "Shipment",
        "Shipment Tracking",
        "model",
        "contexts",
        "Data model"
      ],
      "concepts": [
        "events",
        "microservices",
        "transactions",
        "transaction",
        "contexts",
        "modeling",
        "states",
        "manage",
        "management",
        "query"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 10,
          "title": "Segment 10 (pages 95-107)",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 11,
          "title": "Segment 11 (pages 108-118)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 9,
          "title": "Segment 9 (pages 86-94)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "Designing Data-Intensive Applications",
          "chapter": 46,
          "title": "Segment 46 (pages 459-473)",
          "relevance_score": 0.56,
          "method": "sentence_transformers"
        },
        {
          "book": "Software Architecture",
          "chapter": 30,
          "title": "Segment 30 (pages 290-300)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 13,
      "title": "Segment 13 (pages 98-105)",
      "start_page": 98,
      "end_page": 105,
      "detection_method": "topic_boundary",
      "chapter_number": 13,
      "summary": "This chapter covers segment 13 (pages 98-105). Key topics include microservices, data, and design. Covers architecture. In such a scenario, every microservice manages and\nembeds its database, key-value store, search index, queue, etc.",
      "keywords": [
        "microservice",
        "data",
        "microservice architecture",
        "Design",
        "dependencies",
        "Service Design",
        "Service",
        "mobility",
        "architecture",
        "deployment",
        "deployability",
        "data storage",
        "n’t",
        "independent deployability",
        "sharing"
      ],
      "concepts": [
        "microservices",
        "data",
        "design",
        "deployment",
        "deployments",
        "embedding",
        "operationally",
        "operational",
        "service",
        "pack"
      ],
      "similar_chapters": [
        {
          "book": "Microservice APIs Using Python Flask FastAPI",
          "chapter": 6,
          "title": "Segment 6 (pages 43-51)",
          "relevance_score": 0.73,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.72,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 9,
          "title": "Segment 9 (pages 86-94)",
          "relevance_score": 0.71,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.7,
          "method": "sentence_transformers"
        },
        {
          "book": "Building Microservices",
          "chapter": 12,
          "title": "Bringing It All Together",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 14,
      "title": "Segment 14 (pages 106-114)",
      "start_page": 106,
      "end_page": 114,
      "detection_method": "topic_boundary",
      "chapter_number": 14,
      "summary": "This chapter covers segment 14 (pages 106-114). Key topics include microservices, contain, and deploys. Covers architecture. This company stores\nand operates sensitive customer information including demographic and financial\ndata for its customers.",
      "keywords": [
        "microservice architecture",
        "microservices",
        "Docker",
        "API",
        "API Gateway",
        "containers",
        "architecture",
        "Servers",
        "Management microservice",
        "application",
        "System",
        "Docker containers",
        "Customer Management microservice",
        "Customer Management",
        "service"
      ],
      "concepts": [
        "microservices",
        "contain",
        "deploys",
        "deployments",
        "docker",
        "host",
        "operational",
        "operates",
        "operations",
        "operating"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.76,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.72,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservice APIs Using Python Flask FastAPI",
          "chapter": 3,
          "title": "Segment 3 (pages 17-24)",
          "relevance_score": 0.71,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 7,
          "title": "Segment 7 (pages 68-75)",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        },
        {
          "book": "Python Microservices Development",
          "chapter": 2,
          "title": "Segment 2 (pages 9-16)",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 15,
      "title": "Segment 15 (pages 115-122)",
      "start_page": 115,
      "end_page": 122,
      "detection_method": "topic_boundary",
      "chapter_number": 15,
      "summary": "This chapter covers segment 15 (pages 115-122). Key topics include microservices, team, and service. If the team is building this system using a microservice architecture, they could end\nup creating two microservices for the main functionality:\n1.",
      "keywords": [
        "microservice architecture",
        "microservices",
        "API",
        "Product Metadata microservice",
        "API Gateway",
        "system",
        "Inc.’s microservice architecture",
        "service",
        "teams",
        "API client",
        "architecture",
        "Metadata microservice",
        "microservice APIs",
        "Consul",
        "microservice system"
      ],
      "concepts": [
        "microservices",
        "team",
        "service",
        "apis",
        "organizational",
        "architectural",
        "design",
        "mobile",
        "containing",
        "problem"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 3,
          "title": "Segment 3 (pages 17-25)",
          "relevance_score": 0.78,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.76,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 4,
          "title": "Segment 4 (pages 26-50)",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 30,
          "title": "Segment 30 (pages 296-304)",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        },
        {
          "book": "Software Architecture",
          "chapter": 27,
          "title": "Segment 27 (pages 257-266)",
          "relevance_score": 0.62,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 16,
      "title": "Segment 16 (pages 123-130)",
      "start_page": 123,
      "end_page": 130,
      "detection_method": "topic_boundary",
      "chapter_number": 16,
      "summary": "This chapter covers segment 16 (pages 123-130). Key topics include microservices, teams, and change. What we are primarily interested in is a method for making changes to the organiza‐\ntion in a way that is safe.",
      "keywords": [
        "microservice system",
        "microservices",
        "system",
        "organization",
        "services",
        "team",
        "security",
        "Adopting Microservices",
        "component",
        "microservice architecture",
        "organizational",
        "make",
        "design",
        "service teams",
        "organizational design"
      ],
      "concepts": [
        "microservices",
        "teams",
        "change",
        "changed",
        "service",
        "organization",
        "organizations",
        "organism",
        "components",
        "processes"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 29,
          "title": "Segment 29 (pages 279-295)",
          "relevance_score": 0.75,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 3,
          "title": "Segment 3 (pages 17-25)",
          "relevance_score": 0.68,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 4,
          "title": "Segment 4 (pages 26-50)",
          "relevance_score": 0.66,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 30,
          "title": "Segment 30 (pages 296-304)",
          "relevance_score": 0.65,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.63,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 17,
      "title": "Segment 17 (pages 131-142)",
      "start_page": 131,
      "end_page": 142,
      "detection_method": "topic_boundary",
      "chapter_number": 17,
      "summary": "This chapter covers segment 17 (pages 131-142). Key topics include microservice, architectural, and architectures. Covers architecture. As someone responsible for making sure IT practices keep in alignment with business\ngoals and objectives, you’ll find lots of opportunity for “wins,” but they might look a\n115 bit different than you’d expect.",
      "keywords": [
        "microservice architecture",
        "microservice",
        "Microservice Architecture Reading",
        "Design",
        "microservice system design",
        "architecture",
        "system",
        "service design",
        "Architecture Reading List",
        "system design",
        "software",
        "service",
        "practical guidance",
        "principles",
        "API design"
      ],
      "concepts": [
        "microservice",
        "architectural",
        "architectures",
        "changes",
        "changing",
        "design",
        "services",
        "principles",
        "goals",
        "data"
      ],
      "similar_chapters": [
        {
          "book": "Microservices Up and Running",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.77,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 7,
          "title": "Segment 7 (pages 68-75)",
          "relevance_score": 0.77,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 3,
          "title": "Segment 3 (pages 17-25)",
          "relevance_score": 0.75,
          "method": "sentence_transformers"
        },
        {
          "book": "Microservices Up and Running",
          "chapter": 30,
          "title": "Segment 30 (pages 296-304)",
          "relevance_score": 0.74,
          "method": "sentence_transformers"
        },
        {
          "book": "Building Microservices",
          "chapter": 12,
          "title": "Bringing It All Together",
          "relevance_score": 0.69,
          "method": "sentence_transformers"
        }
      ]
    },
    {
      "number": 18,
      "title": "Segment 18 (pages 143-144)",
      "start_page": 143,
      "end_page": 144,
      "detection_method": "topic_boundary",
      "chapter_number": 18,
      "summary": "This chapter covers segment 18 (pages 143-144). Key topics include architecture, apis. Covers architecture. Amundsen has authored numerous books and papers on programming over the last\n15 years.",
      "keywords": [
        "API Academy",
        "API",
        "Nadareishvili is CTO",
        "Academy",
        "architecture",
        "York health tech",
        "tech startup Refer",
        "API Architecture",
        "Irakli Nadareishvili",
        "Design",
        "APIs",
        "Authors",
        "shell",
        "CTO and cofounder",
        "York health"
      ],
      "concepts": [
        "architecture",
        "apis",
        "api",
        "designing",
        "snail",
        "help",
        "fonts",
        "family",
        "cowry",
        "cowrie"
      ],
      "similar_chapters": [
        {
          "book": "Game_Engine_Architecture",
          "chapter": 42,
          "title": "Segment 42 (pages 849-853)",
          "relevance_score": 0.58,
          "method": "sentence_transformers"
        },
        {
          "book": "AI Agents In Action",
          "chapter": 39,
          "title": "Segment 39 (pages 341-346)",
          "relevance_score": 0.57,
          "method": "sentence_transformers"
        },
        {
          "book": "AI Agents and Applications",
          "chapter": 1,
          "title": "Segment 1 (pages 1-8)",
          "relevance_score": 0.55,
          "method": "sentence_transformers"
        },
        {
          "book": "AI Agents In Action",
          "chapter": 12,
          "title": "Segment 12 (pages 95-102)",
          "relevance_score": 0.54,
          "method": "sentence_transformers"
        },
        {
          "book": "AI Agents and Applications",
          "chapter": 42,
          "title": "Segment 42 (pages 363-371)",
          "relevance_score": 0.53,
          "method": "sentence_transformers"
        }
      ]
    }
  ],
  "pages": [
    {
      "page_number": 1,
      "chapter": null,
      "content": "Irakli Nadareishvili, Ronnie Mitra, \nMatt McLarty & Mike Amundsen\nMicroservice\n Architecture\nALIGNING PRINCIPLES, PRACTICES, AND CULTURE",
      "content_length": 136,
      "extraction_method": "Direct"
    },
    {
      "page_number": 2,
      "chapter": null,
      "content": "O'REIL\n\nMicroservice Architecture\n\nMcroservices can have 3 postive impact on your enterpnse—jst ask\n“Amazon and Netfix-but youcanfallato many tas fyoudont approach\n‘them inthe night way Ths practical gd covers the entire mecroservces\nlandscape including the einciples, technolopes, and methodologies\n(ofthis unique, modular style of system bulding. Youll learn about the\n‘experiences of organizations aound the globe that have successfully\nadopted microservices,\n\nIn three parts, this book explains how these services work and what it\n‘means to buld an application the microservices way. Youll explore 3\ndesign-based approach to meroservice architecture with guidance\nfor implementing various elements. And youl gta set of recipes and\npractices for meeting practical organzational, and cutural challenges to\n‘mcroservice adoption\n\n1 Lea how microservices can help you drive business\nobjectives\n\n'= Examine the principles, practices and culture that define\nrmicroservice architectures\n\n1 Explore amodel for creating complex systems anda design\nprocess fr bulking microservice architecture\n\n1 Leam the fundamental design concept frindividual\nmiezoserwces\n\n1 Dele into the operational elements of amicroservice\narchitecture, including containess and service discovery\n\n1 Discover how to handle the challenges of introducing\nrmicoservice architecture in your organization\n\n“This book will he\nimportant questi\nWhat problems do\nfor, and how should\n\ncultures be sot up to\n\nsucceed?”\n\nAdvan ockerott\n\nWal Nadareisit = CTO ad\nefounder of New York heath\ntechstatp Rete\n\nRone mari eectoof\nDesa atthe APL Academy aA\nTedcogies\n\nMatt McLarty (@matindryte)\n‘eis Presdent of he AP\nease 20a Tecreloges.\nMike amundsen Over of\nDecseacr forthe AP academy\nMCA Tecaoges\n\nNON i\n\nTwitter: @oceilymedia\nfacebook comforeily",
      "content_length": 1797,
      "extraction_method": "OCR"
    },
    {
      "page_number": 3,
      "chapter": null,
      "content": "Praise for Microservice Architecture\nThe authors’ approach of starting with a value proposition, “Speed and Safety at Scale and\nin Harmony,” and reasoning from there, is an important contribution to thinking about\napplication design.\n—Mel Conway, Educator and Inventor\nA well-thought-out and well-written description of the organizing principles \nunderlying the microservices architectural style with a pragmatic example of \napplying them in practice.\n—James Lewis, Principal Consultant, ThoughtWorks\nThis book demystifies one of the most important new tools for building robust, scalable\nsoftware systems at speed.\n—Otto Berkes, Chief Technology Officer, CA Technologies\nIf you’ve heard of companies doing microservices and want to learn more, Microservice\nArchitecture is a great place to start. It addresses common questions and concerns about\nbreaking down a monolith and the challenges you’ll face with culture, practices, and\ntooling. The microservices topic is a big one and this book gives you smart pointers \non where to go next.\n—Chris Munns, Business Development Manager—DevOps,\nAmazon Web Services\nAnyone who is building a platform for use inside or outside an organization should read\nthis book. It provides enough “a-ha” insights to keep everyone on your team engaged,\nfrom the business sponsor to the most technical team member. Highly recommended!\n—Dave Goldberg, Director, API Products, Capital One",
      "content_length": 1415,
      "extraction_method": "Direct"
    },
    {
      "page_number": 4,
      "chapter": null,
      "content": "A practical roadmap to microservices design and the underlying cultural and\norganizational change that is needed to make it happen successfully.\n—Mark Boyd, Writer/Analyst, Platformable\nAn essential guidebook for your microservices journey, presenting the concepts,\ndiscussions, and structures supportive of this architectural pattern as well as the\npragmatic ground work to become successful.\n—Ian Kelly, Experimenter and Contributor, CA Technologies",
      "content_length": 451,
      "extraction_method": "Direct"
    },
    {
      "page_number": 5,
      "chapter": null,
      "content": "Irakli Nadareishvili, Ronnie Mitra, \nMatt McLarty, and Mike Amundsen\nMicroservice Architecture\nAligning Principles, Practices, and Culture\nBoston\nFarnham\nSebastopol\nTokyo\nBeijing\nBoston\nFarnham\nSebastopol\nTokyo\nBeijing",
      "content_length": 218,
      "extraction_method": "Direct"
    },
    {
      "page_number": 6,
      "chapter": null,
      "content": "978-1-491-95625-0\n[LSI]\nMicroservice Architecture\nby Irakli Nadareishvili, Ronnie Mitra, Matt McLarty, and Mike Amundsen\nCopyright © 2016 Mike Amundsen, Matt McLarty, Ronnie Mitra, Irakli Nadareishvili. All rights reserved.\nPrinted in the United States of America.\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\nO’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are\nalso available for most titles (http://safaribooksonline.com). For more information, contact our corporate/\ninstitutional sales department: 800-998-9938 or corporate@oreilly.com .\nEditors: Brian MacDonald and Holly Bauer\nProduction Editor: Kristen Brown\nCopyeditor: Christina Edwards\nProofreader: Kim Cofer\nIndexer: WordCo Indexing Services, Inc.\nInterior Designer: David Futato\nCover Designer: Karen Montgomery\nIllustrator: Melanie Yarbrough\nJune 2016:\n First Edition\nRevision History for the First Edition\n2016-06-02: First Release\n2016-07-18: Second Release\nSee http://oreilly.com/catalog/errata.csp?isbn=9781491956250 for release details.\nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Microservice Architecture, the cover\nimage, and related trade dress are trademarks of O’Reilly Media, Inc.\nWhile the publisher and the authors have used good faith efforts to ensure that the information and\ninstructions contained in this work are accurate, the publisher and the authors disclaim all responsibility\nfor errors or omissions, including without limitation responsibility for damages resulting from the use of\nor reliance on this work. Use of the information and instructions contained in this work is at your own\nrisk. If any code samples or other technology this work contains or describes is subject to open source\nlicenses or the intellectual property rights of others, it is your responsibility to ensure that your use\nthereof complies with such licenses and/or rights.",
      "content_length": 1956,
      "extraction_method": "Direct"
    },
    {
      "page_number": 7,
      "chapter": null,
      "content": "Table of Contents\nPreface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  ix\nPart I. \nUnderstanding Microservices\n1. The Microservices Way. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3\nUnderstanding Microservices                                                                                        4\nAdopting Microservices                                                                                                  5\n“What are microservices? Don’t I already have them?”                                          6\n“How could this work here?”                                                                                      7\n“How would we deal with all the parts? Who is in charge?”                                  8\nThe Microservices Way                                                                                                   9\nThe Speed of Change                                                                                                   9\nThe Safety of Change                                                                                                   9\nAt Scale                                                                                                                        10\nIn Harmony                                                                                                                 10\nSummary                                                                                                                         11\n2. The Microservices Value Proposition. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13\nMicroservice Architecture Benefits                                                                            13\nDeriving Business Value                                                                                               15\nDefining a Goal-Oriented, Layered Approach                                                          17\nModularized Microservice Architecture                                                                17\nCohesive Microservice Architecture                                                                       18\nSystematized Microservice Architecture                                                                18\nMaturity Model for Microservice Architecture Goals and Benefits                   19\nApplying the Goal-Oriented, Layered Approach                                                      20\nSummary                                                                                                                         21\nv",
      "content_length": 2733,
      "extraction_method": "Direct"
    },
    {
      "page_number": 8,
      "chapter": null,
      "content": "Part II. \nMicroservice Design Principles\n3. Designing Microservice Systems. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  25\nThe Systems Approach to Microservices                                                                   25\nService                                                                                                                          27\nSolution                                                                                                                        28\nProcess and Tools                                                                                                       28\nOrganization                                                                                                               28\nCulture                                                                                                                         29\nEmbracing Change                                                                                                     29\nPutting it Together: The Holistic System                                                                30\nStandardization and Coordination                                                                          30\nA Microservices Design Process                                                                                  33\nSet Optimization Goals                                                                                             34\nDevelopment Principles                                                                                            35\nSketch the System Design                                                                                         35\nImplement, Observe, and Adjust                                                                             36\nThe Microservices System Designer                                                                       38\nSummary                                                                                                                     38\n4. Establishing a Foundation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  41\nGoals and Principles                                                                                                      42\nGoals for the Microservices Way                                                                             42\nOperating Principles                                                                                                  45\nPlatforms                                                                                                                         49\nShared Capabilities                                                                                                     50\nLocal Capabilities                                                                                                       52\nCulture                                                                                                                             54\nFocus on Communication                                                                                        55\nAligning Your Teams                                                                                                 55\nFostering Innovation                                                                                                 56\nSummary                                                                                                                         58\nPart III. \nMicroservices in Practice\n5. Service Design. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  61\nMicroservice Boundaries                                                                                              62\nMicroservice Boundaries and Domain-Driven Design                                        62\nBounded Context                                                                                                       64\nSmaller Is Better                                                                                                         65\nUbiquitous Language                                                                                                 66\nvi \n| \nTable of Contents",
      "content_length": 4329,
      "extraction_method": "Direct"
    },
    {
      "page_number": 9,
      "chapter": null,
      "content": "API Design for Microservices                                                                                      67\nMesssage-Oriented                                                                                                     67\nHypermedia-Driven                                                                                                   68\nData and Microservices                                                                                                70\nShipping, Inc.                                                                                                              70\nEvent Sourcing                                                                                                            72\nSystem Model for Shipping, Inc.                                                                              75\nCQRS                                                                                                                           76\nDistributed Transactions and Sagas                                                                            78\nAsynchronous Message-Passing and Microservices                                                80\nDealing with Dependencies                                                                                          81\nPragmatic Mobility                                                                                                    84\nSummary                                                                                                                         86\n6. System Design and Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  89\nIndependent Deployability                                                                                           89\nMore Servers, More Servers! My Kingdom for a Server!                                         91\nDocker and Microservices                                                                                            93\nThe Role of Service Discovery                                                                                     94\nThe Need for an API Gateway                                                                                     97\nSecurity                                                                                                                        97\nTransformation and Orchestration                                                                         98\nRouting                                                                                                                      100\nMonitoring and Alerting                                                                                            101\nSummary                                                                                                                       101\n7. Adopting Microservices in Practice. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  103\nSolution Architecture Guidance                                                                                104\nHow many bug fixes/features should be included in a single release?             104\nWhen do I know our microservice transformation is done?                             104\nOrganizational Guidance                                                                                            105\nHow do I know if my organization is ready for microservices?                        105\nCulture Guidance                                                                                                        106\nHow do I introduce change?                                                                                   106\nCan I do microservices in a project-centric culture?                                          108\nCan I do microservices with outsourced workers?                                             108\nTools and Process Guidance                                                                                      109\nWhat kinds of tools and technology are required for microservices?              109\nWhat kinds of practices and processes will I need to support\nmicroservices?                                                                                                       110\nHow do I govern a microservice system?                                                             111\nServices Guidance                                                                                                        112\nTable of Contents \n| \nvii",
      "content_length": 4547,
      "extraction_method": "Direct"
    },
    {
      "page_number": 10,
      "chapter": null,
      "content": "Should all microservices be coded in the same programming language?       112\nWhat do I do about orphaned components?                                                       113\nSummary                                                                                                                       113\n8. Epilogue. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  115\nA. Microservice Architecture Reading List. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  117\nIndex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  121\nviii \n| \nTable of Contents",
      "content_length": 754,
      "extraction_method": "Direct"
    },
    {
      "page_number": 11,
      "chapter": null,
      "content": "Preface\nMicroservice architecture has emerged as a common pattern of software develop‐\nment from the practices of a number of leading organizations. These practices\nincludes principles, technologies, methodologies, organizational tendencies, and cul‐\ntural characteristics. Companies taking steps to implement microservices and reap\ntheir benefits need to consider this broad scope.\nWho Should Read This Book\nYou should read this book if you are interested in the architectural, organizational,\nand cultural changes that are needed to succeed with a microservice architecture. We\nprimarily wrote this book for technology leaders and software architects who want to\nshift their organizations toward the microservices style of application development.\nYou don’t have to be a CTO or enterprise architect to enjoy this book, but we’ve writ‐\nten our guidance under the assumption that you are able to influence the organiza‐\ntional design, technology platform, and software architecture at your company.\nWhat’s In This Book\nThis book promotes a goal-oriented, design-based approach to microservice architec‐\nture. We offer this design-centric approach because, as we talked to several companies\nabout their programs, we discovered one of the keys to their success was the willing‐\nness to not stick to a single tool or process as they attempted to increase their compa‐\nny’s time-to-market while maintaining—even increasing—their systems’ safety and\nresilience.\nThe companies we talked to offered a wide range of services including live video and\naudio streaming service, foundation-level virtual services in the cloud, and support\nfor classic brick-and-mortar operations. While these companies’ products vary, we\nlearned that the principles of speed and safety “at scale” were a common thread. They\nix",
      "content_length": 1797,
      "extraction_method": "Direct"
    },
    {
      "page_number": 12,
      "chapter": null,
      "content": "each worked to provide the same system properties in their own unique ways—ways\nthat fit the key business values and goals of the company.\nIt’s the properties and values that we focus on in this book, and the patterns and prac‐\ntices we see companies employ in order to reach their unique goals. If you’re looking\nfor a way to identify business goals for your microservices adoption, practical guid‐\nance on how to design individual microservices and the system they form, and tips\non how to overcome common architectural challenges, this is your book!\nThe Outline\nThe book is organized into three parts. The first part (Chapters 1–2) identifies the\nprinciples and practices of microservice architecture and the benefits they can pro‐\nvide. This section will be valuable to anyone who needs to justify the use of microser‐\nvices within their organization and provide some background on how other\norganizations have started on this journey.\nThe second part (Chapters 3–4) introduces a design-based approach to microservice\narchitecture, identifies a series of common processes and practices we see repeated\nthrough successful microservice systems, and provides some implementation guid‐\nance on executing the various elements for your company’s microservice implemen‐\ntation.\nThe third and final part (Chapters 5–7) provides a set of practical recipes and practi‐\nces to help companies identify ways to introduce and support microservices, meet\nimmediate challenges, and plan for and respond to the inevitably changing business\nenvironment ahead.\nHere’s a quick rundown of the chapters:\nChapter 1, The Microservices Way\nThis chapter outlines the principles, practices, and culture that define microser‐\nvice architecture.\nChapter 2, The Microservices Value Proposition\nThis chapter examines the benefits of microservice architecture and some techni‐\nques to achieve them.\nChapter 3, Designing Microservice Systems\nThis chapter explores the system aspects of microservices and illustrates a design\nprocess for microservice architecture.\nChapter 4, Establishing a Foundation\nThis chapter discusses the core principles for microservice architecture, as well as\nthe platform components and cultural elements needed to thrive.\nx \n| \nPreface",
      "content_length": 2234,
      "extraction_method": "Direct"
    },
    {
      "page_number": 13,
      "chapter": null,
      "content": "Chapter 5, Service Design\nThis chapter takes the “micro” design view, examining the fundamental design\nconcepts for individual microservices.\nChapter 6, System Design and Operations\nThis chapter takes the “macro” design view, analyzing the critical design areas for\nthe software system made up of the collection of microservices.\nChapter 7, Adopting Microservices in Practice\nThis chapter provides practical guidance on how to deal with common chal‐\nlenges organizations encounter as they introduce microservice architecture.\nChapter 8, Epilogue\nFinally, this chapter examines microservices and microservice architecture in a\ntimeless context, and emphasizes the central theme of the book: adaptability to\nchange.\nWhat’s Not In This Book\nThe aim of this book is to arm readers with practical information and a way of think‐\ning about microservices that is timeless and effective. This is not a coding book.\nThere is a growing body of code samples and open source projects related to micro‐\nservices available on the Web, notably on GitHub and on sites like InfoQ. In addition,\nthe scope of this domain is big and we can only go so deep on the topics we cover. For\nmore background on the concepts we discuss, check out our reading list in Appen‐\ndix A.\nWhile we provide lots of guidance and advice—advice based on our discussions with\na number of companies designing and implementing systems using microservice\narchitecture patterns—we do not tell readers which product to buy, which open\nsource project to adopt, or how to design and test component APIs. Instead, we offer\ninsight into the thinking processes and practices of experienced and successful com‐\npanies actually doing the work of microservices. If you’re looking for simple answers,\nyou’re likely to be disappointed in some of the material here. If, on the other hand,\nyou’re looking for examples of successful microservice companies and the kinds of\nprinciples, practices, and processes they employ, this book is for you.\nConventions Used in This Book\nThe following typographical conventions are used in this book:\nItalic\nIndicates new terms, URLs, email addresses, filenames, and file extensions.\nPreface \n| \nxi",
      "content_length": 2175,
      "extraction_method": "Direct"
    },
    {
      "page_number": 14,
      "chapter": null,
      "content": "Constant width\nUsed for program listings, as well as within paragraphs to refer to program ele‐\nments such as variable or function names, databases, data types, environment\nvariables, statements, and keywords.\nConstant width bold\nShows commands or other text that should be typed literally by the user.\nConstant width italic\nShows text that should be replaced with user-supplied values or by values deter‐\nmined by context.\nThis element signifies a tip or suggestion.\nThis element signifies a general note.\nThis element indicates a warning or caution.\nSafari® Books Online\nSafari Books Online is an on-demand digital library that deliv‐\ners expert content in both book and video form from the\nworld’s leading authors in technology and business.\nTechnology professionals, software developers, web designers, and business and crea‐\ntive professionals use Safari Books Online as their primary resource for research,\nproblem solving, learning, and certification training.\nSafari Books Online offers a range of plans and pricing for enterprise, government,\neducation, and individuals.\nMembers have access to thousands of books, training videos, and prepublication\nmanuscripts in one fully searchable database from publishers like O’Reilly Media,\nxii \n| \nPreface",
      "content_length": 1256,
      "extraction_method": "Direct"
    },
    {
      "page_number": 15,
      "chapter": null,
      "content": "Prentice Hall Professional, Addison-Wesley Professional, Microsoft Press, Sams, Que,\nPeachpit Press, Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kauf‐\nmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders,\nMcGraw-Hill, Jones & Bartlett, Course Technology, and hundreds more. For more\ninformation about Safari Books Online, please visit us online.\nHow to Contact Us\nPlease address comments and questions concerning this book to the publisher:\nO’Reilly Media, Inc.\n1005 Gravenstein Highway North\nSebastopol, CA 95472\n800-998-9938 (in the United States or Canada)\n707-829-0515 (international or local)\n707-829-0104 (fax)\nTo comment or ask technical questions about this book, send email to bookques‐\ntions@oreilly.com.\nFor more information about our books, courses, conferences, and news, see our web‐\nsite at http://www.oreilly.com.\nFind us on Facebook: http://facebook.com/oreilly\nFollow us on Twitter: http://twitter.com/oreillymedia\nWatch us on YouTube: http://www.youtube.com/oreillymedia\nAcknowledgments\nThe authors would like to thank Brian MacDonald, Holger Reinhardt, Ian Kelly, and\nBrian Mitchell for helping to clarify, focus, and structure the content of the book. We\nwould also like to thank John Allspaw, Stu Charlton, Adrian Cockcroft, Mel Conway,\nJames Lewis, Ruth Malan, and Jon Moore for helping to guide our thinking along the\nway.\nA number of early microservice adopters provided insight for the book. We would\nlike to thank Greg Bell, Ken Britton, Beier Cai, Steve Cullingworth, Bill Monkman,\nMike Sample, and Jeremy Skelton of Hootsuite; Chris Munns of Amazon; Clay Gar‐\nrard and Patrick Devlin of Disney; and Christian Deger of AutoScout24.\nThe book would not have been completed without the support of CA Technologies.\nWe would like to thank Alex Jones, Jeff Miller, Ryan Blain, Jaime Ryan, Sam Macklin,\nand many others for their help. We would also like to thank Leia Poritz, Heather\nPreface \n| \nxiii",
      "content_length": 1964,
      "extraction_method": "Direct"
    },
    {
      "page_number": 16,
      "chapter": null,
      "content": "Scherer, Rachel Roumeliotis, Sharon Cordesse, Kristen Brown, Christina Edwards,\nand the team at O’Reilly Media.\nFinally and most importantly, the authors would like to thank their families. Mike\nthanks Lee, Shannon, Jesse, and Dana for putting up with his usual travel and writing\nshenanigans. Matt thanks Chris, Daniel, and Josiah for their love and support. Ronnie\nthanks his father for putting him in front of a computer. Irakli thanks Ana, Dachi,\nMaia, Diana, and Malkhaz for their unconditional support and encouragement.\nxiv \n| \nPreface",
      "content_length": 542,
      "extraction_method": "Direct"
    },
    {
      "page_number": 17,
      "chapter": null,
      "content": "PART I\nUnderstanding Microservices\nBalancing Speed and Safety\nIf you drive around Sweden you’ll see variations of the same road markings, road\nsigns, and traffic signals that are used everywhere else in the developed world. But\nSweden is a remarkably safer place for road users than the rest of the world. In fact, in\n2013 it was among the safest countries in road traffic deaths per 100,000 people.\nSo, how did the Swedes do it? Are they better drivers? Are the traffic laws in Sweden\nstricter than other countries? Are their roads just better designed? It turns out that\nthe recipe for traffic safety is a combination of all of these things, delivered by an\ninnovative program called Vision Zero.\nVision Zero has a laudable goal—reducing all road accident–related deaths to zero. It\naims to achieve this by designing road systems that prioritize safety above all other\nfactors, while still recognizing the importance of keeping traffic moving. In other\nwords, a road system that is designed first and foremost with safety in mind.\nAt its core, Vision Zero is about culture change. Policymakers, traffic system design‐\ners, and citizens have a shared belief that the safety of pedestrians and drivers is more\nvaluable than the need to move from place to place as quickly as possible. This cul‐\nture of safety drives individual behavior, which can result in a more desirable out‐\ncome for the traffic system.\nIn addition, the road system itself is designed to be safer. Traffic designers apply\nspeed limits, road signs, and traffic movement patterns in a way that benefits the\noverall safety of the system. For example, while it is necessary to ensure the move‐",
      "content_length": 1661,
      "extraction_method": "Direct"
    },
    {
      "page_number": 18,
      "chapter": null,
      "content": "ment of cars on the road, speed is limited to a level that the human body could with‐\nstand in a collision given the technical standards of the vehicles and roads that exist.\nWhile speed limits may impact drivers’ ability to get to their destination as quickly as\npossible, the design decision is always driven by the requirement to protect human\nlife. Where most road systems are designed to facilitate movement (or speed) in a safe\nway, Vision Zero systems incorporate movement into a system primarily designed for\nsafety.\nThe road designers are continuously making trade-offs that favor the safety of its\nusers. Instead of solely relying on skilled drivers who know how to avoid common\nmistakes, Vision Zero designers create roads that account for the errors and miscal‐\nculations that many human drivers inevitably make. While it is the driver’s responsi‐\nbility to adhere to the rules of the road, the system designers must do their best to\nprotect humans even in situations where drivers do not conform.\nAll in all, the Vision Zero approach seems to work. While they haven’t reduced fatali‐\nties to zero yet, the program has been so successful in improving safety within Swe‐\nden that other cities like New York and Seattle are adopting it and hoping to see\nsimilar results in their own traffic systems. In the end, this success was made possible\nby combining improvements to policy, technology, and infrastructure in a holistic\nmanner. Vision Zero adopts a systematic approach to design in a safety-first manner.\nJust like traffic systems, software systems become more complex as their scale—in the\nform of scope, volume, and user interactions—increases. And like road designers,\nsoftware architects and engineers must maintain a balance of speed and safety in their\nsoftware systems. Software development organizations have used microservice archi‐\ntecture to achieve faster delivery and greater safety as the scale of their systems\nincrease. The holistic, consciously designed approach of Vision Zero suggests an\napproach to microservice architecture that organizations can take to achieve the bal‐\nance of speed and safety that meets their goals.",
      "content_length": 2156,
      "extraction_method": "Direct"
    },
    {
      "page_number": 19,
      "chapter": null,
      "content": "CHAPTER 1\nThe Microservices Way\nMicroservices are a thing these days.\n—Phil Calçado, former Director of Engineering, SoundCloud\nBuilding solutions with speed and safety at scale.\nIf you’re like most software developers, team leaders, and architects responsible for\ngetting working code out the door of your company, this phrase describes your job in\na nutshell. Most of you have probably struggled at this, too. Getting to market quickly\nseems to imply giving up a bit of safety. Or, conversely, making sure the system is safe,\nreliable, and resilient means slowing down the pace of feature and bug-fix releases.\nAnd “at scale” is just a dream.\nHowever, a few years ago people started talking about companies that were doing just\nthat. Shortening their time-to-market on new releases, actually improving their sys‐\ntem reliability, and doing it all in runtime environments that were able to respond\nsmoothly to unexpected spikes in traffic. These companies were “doing microservi‐\nces.”\nIn this chapter we’ll explore what microservices are and what it means to build an\napplication the microservices way. To begin with, we’ll explore the meaning of the\nterm microservices by learning about its origin. Next, we’ll take a look at some of the\nbiggest perceived barriers to adopting microservices. Finally, we share a simple per‐\nspective on application development that will help you better understand how all the\npieces of microservices systems fit together, a balancing act of speed and safety that\nwe call the microservices way.\n3",
      "content_length": 1531,
      "extraction_method": "Direct"
    },
    {
      "page_number": 20,
      "chapter": null,
      "content": "Understanding Microservices\nTo better understand what microservices are, we need to look at where they came\nfrom. We aren’t going to recount the entire history of microservices and software\narchitecture, but it’s worth briefly examining how microservices came to be. While\nthe term microservices has probably been used in various forms for many years, the\nassociation it now has with a particular way of building software came from a meet‐\ning attended by a handful of software architects. This group saw some commonality\nin the way a particular set of companies was building software and gave it a name.\nAs James Lewis, who was in attendance, remembers it:\nAt the end of our three-day meeting, one of us called out a theme—that year it had\nbeen clear that many of the problems people were facing in the wild were related to\nbuilding systems that were too big. “How can I rebuild a part of this,” “best ways to\nimplement Strangler,” etc.\nTurning that on its head, the problem became “how can we build systems that are\nreplaceable over being maintainable?” We used the term micro apps, I seem to\nremember.\n—James Lewis\nJames’ recollection of the microservices origin story is important not only for histori‐\ncal record, but also because it identifies three concepts that are principal to the style:\nMicroservices are ideal for big systems\nThe common theme among the problems that people were facing was related to\nsize. This is significant because it highlights a particular characteristic of the\nmicroservices style—it is designed to solve problems for systems that are big. But\nsize is a relative measure, and it is difficult to quantify the difference between\nsmall, normal, and big. You could of course come up with some way of deciding\nwhat constitutes big versus small, perhaps using averages or heuristic measure‐\nments, but that would miss the point. What the architects at this gathering were\nconcerned with was not a question of the size of the system. Instead, they were\ngrappling with a situation in which the system was too big. What they identified\nis that systems that grow in size beyond the boundaries we initially define pose\nparticular problems when it comes to changing them. In other words, new prob‐\nlems arise due to their scale.\nMicroservice architecture is goal-oriented\nSomething else we can derive from James’ recollection of the day is the focus on a\ngoal rather than just a solution. Microservice architecture isn’t about identifying a\nspecific collection of practices, rather it’s an acknowledgment that software pro‐\nfessionals are trying to solve a similar goal using a particular approach. There\nmay be a set of common characteristics that arise from this style of software\n4 \n| \nChapter 1: The Microservices Way",
      "content_length": 2744,
      "extraction_method": "Direct"
    },
    {
      "page_number": 21,
      "chapter": null,
      "content": "development, but the focus is meant to be on solving the initial problem of sys‐\ntems that are too big.\nMicroservices are focused on replaceability\nThe revelation that microservices are really about replaceability is the most\nenlightening aspect of the story. This idea that driving toward replacement of\ncomponents rather than maintaining existing components get to the very heart of\nwhat makes the microservices approach special.\nIf you are interested in learning more on the history of microservi‐\nces, visit http://api.co/msabook.\nOverwhelmingly, the companies that we talked to have adopted the microservices\narchitectural style as a way of working with systems in which scale is a factor. They\nare more interested in the goal of improving changeability than finding a universal\npattern or process. Finally, the methods that have helped them improve changeability\nthe most are primarily rooted in improving the replaceability of components. These\nare all characteristics that align well with the core of the microservices ideal.\nAdopting Microservices\nIf you are responsible for implementing technology at your company, the microservi‐\nces proposition should sound enticing. Chances are you face increasing pressure to\nimprove the changeability of the software you write in order to align better with a\nbusiness team that wants to be more innovative. It isn’t easy to make a system more\namenable to change, but the microservice focus on building replaceable components\noffers some hope.\nHowever, when we’ve talked to people interested in adopting microservice-style\narchitectures they often have some reservations. Behind the enthusiasm for a new\nway of approaching their problem is a set of looming uncertainties about the poten‐\ntial damage that this approach might cause to their systems. In particular, after learn‐\ning more about microservices methods, potential adopters frequently identify the\nfollowing issues:\n1. They have already built a microservice architecture, but they didn’t know it had a\nname.\n2. The management, coordination, and control of a microservices system would be\ntoo difficult.\nAdopting Microservices \n| \n5",
      "content_length": 2139,
      "extraction_method": "Direct"
    },
    {
      "page_number": 22,
      "chapter": null,
      "content": "3. The microservices style doesn’t account for their unique context, environment,\nand requirements.\nWhile we don’t believe that microservices is the answer to every question about a\npotential architecture choice, we do feel that these particular fears should be better\nunderstood before dismissing an opportunity to improve a system. Let’s take a look at\neach of these barriers to adoption in more detail.\n“What are microservices? Don’t I already have them?”\nEarlier in this chapter we shared the story of how microservices got their name, but\nwe never actually came up with a concrete definition. While there is not one single\ndefinition for the term “microservice,” there are two that we think are very helpful:\nMicroservices are small, autonomous services that work together.\n—Sam Newman, Thoughtworks\nLoosely coupled service-oriented architecture with bounded contexts.\n—Adrian Cockcroft, Battery Ventures\nThey both emphasize some level of independence, limited scope, and interoperability.\nWe also think that it is important to view “a microservice” in the scope of an existing\nsystem. For that reason our definition of microservices also includes the architectural\nelement:\nA microservice is an independently deployable component of bounded scope that sup‐\nports interoperability through message-based communication. Microservice architec‐\nture is a style of engineering highly automated, evolvable software systems made up of\ncapability-aligned microservices.\nYou may find much of what is described in the preceding definition familiar. In fact,\nyour organization is probably doing something like this already. If you’ve imple‐\nmented a service-oriented architecture (SOA), you’ve already embraced the concept\nof modularity and message-based communication. If you’ve implemented DevOps\npractices you’ve already invested in automated deployment. If you are an Agile shop,\nyou’ve already started shaping your culture in a way that fits the microservices advice.\nBut given that there is no single, authoritative definition, when do you get to pro‐\nclaim that your architecture is a microservice architecture? What is the measure and\nwho gets to decide? Is there such a thing as a “minimum viable microservice architec‐\nture”?\nThe short answer is we don’t know. More importantly, we don’t care! We’ve found that\nthe companies that do well with microservices don’t dwell on the meaning of this sin‐\ngle word. That doesn’t mean that definitions are trivial—instead, it’s an admission\nthat finding a universal meaning for the microservices style is not important when it\ncomes to meeting business goals. Your time is better spent improving your architec‐\n6 \n| \nChapter 1: The Microservices Way",
      "content_length": 2693,
      "extraction_method": "Direct"
    },
    {
      "page_number": 23,
      "chapter": null,
      "content": "ture in a way that helps you unlock more business value. For most organizations this\nmeans building applications with more resilience and changeability than ever before.\nWhat you call that style of application is entirely up to you.\nIf you are considering adopting a microservice architecture for your organization,\nconsider how effective the existing architecture is in terms of changeability and more\nspecifically replaceability. Are their opportunities to improve? Could you go beyond\nmodularity, Agile practices, or DevOps to gain value? We think you’ll stand a better\nchance at providing value to your business team if you are open to making changes\nthat will get you closer to those goals. Later in this chapter we’ll introduce two goals\nthat we believe give you the best chance at success.\n“How could this work here?”\nEarlier in this chapter we shared perspectives on microservices from Newman, Cock‐\ncroft, Lewis, and Fowler. From these comments, it is clear that microservice applica‐\ntions share some important characteristics:\n• Small in size\n• Messaging enabled\n• Bounded by contexts\n• Autonomously developed\n• Independently deployable\n• Decentralized\n• Built and released with automated processes\nThat’s a big scope! So big that some people believe that microservices describe a soft‐\nware development utopia—a set of principles so idealistic that they simply can’t be\nrealized in the real world. But this type of claim is countered with the growing list of\ncompanies who are sharing their microservice success stories with the world. You’ve\nprobably heard some of those stories already—Netflix, SoundCloud, and Spotify have\nall gone public about their microservices experiences.\nBut if you are responsible for the technology division of a bank, hospital, or hotel\nchain, you might claim that none of these companies look like yours. The microservi‐\nces stories we hear the most about are from companies that provide streamed con‐\ntent. While this is a domain with incredible pressure to remain resilient and perform\nat great scale, the business impact of an individual stream failing is simply incompa‐\nrable to a hotel losing a reservation, a single dollar being misplaced, or a mistake in a\nmedical report.\nDoes all of this mean that microservices is not a good fit for hotels, banks, and hospi‐\ntals? We don’t think so and neither do the architects we’ve spoken to from each of\nAdopting Microservices \n| \n7",
      "content_length": 2423,
      "extraction_method": "Direct"
    },
    {
      "page_number": 24,
      "chapter": null,
      "content": "those industries. But we have found that the particular way your organization needs\nto implement a microservice system is likely to differ from the way that Netflix imple‐\nments theirs. The trick is in having a clear goal and understanding where the dials are\nto move your organization toward it. Later in this book we’ll shed some light on the\nprinciples and practices that help microservices companies succeed.\n“How would we deal with all the parts? Who is in charge?”\nTwo microservices characteristics that you might find especially concerning are\ndecentralization and autonomy. Decentralization means that the bulk of the work\ndone within your system will no longer be managed and controlled by a central body. \nEmbracing team autonomy means trusting your development teams to make their\nown decisions about the software they produce. The key benefit to both of these\napproaches is that software changes become both easier and faster—less centraliza‐\ntion results in fewer bottlenecks and less resistance to change, while more autonomy\nmeans decisions can be made much quicker.\nBut if your organization hasn’t worked this way in the past, how confident are you\nthat it could do so in the future? For example, your company probably does its best to\nprevent the damage that any single person’s decisions can have on the organization as\na whole. In large companies, the desire to limit negative impact is almost always\nimplemented with centralized controls—security teams, enterprise architecture\nteams, and the enterprise service bus are all manifestations of this concept. So, how\ndo you reconcile the ideals of a microservice architecture within a risk-averse culture?\nHow do we govern the work done by microservices teams?\nSimilarly, how do you manage the output of all these teams? Who decides which\nservices should be created? How will services communicate efficiently? How will you\nunderstand what is happening?\nWe’ve found that decentralization and control are not opposing forces. In other\nwords, the idea that there is a trade-off between a decentralized system and a gov‐\nerned system is a myth. But this doesn’t mean that you gain the benefits of decentrali‐\nzation and autonomy for free. When you build software in this way, the cost of\ncontrolling and managing output increases significantly. In a microservice architec‐\nture, the services tend to get simpler, but the architecture tends to get more complex.\nThat complexity is often managed with tooling, automation, and process.\nUltimately, you must come to terms with the fact that asserting control and manage‐\nment of a microservice system is more expensive than in other architectural styles.\nFor many organizations, this cost is justified by a desire for increased system change‐\nability. However, if you believe that the return doesn’t adequately outweigh the bene‐\nfit, chances are this is not the best way to build software in your organization.\n8 \n| \nChapter 1: The Microservices Way",
      "content_length": 2959,
      "extraction_method": "Direct"
    },
    {
      "page_number": 25,
      "chapter": null,
      "content": "The Microservices Way\nWhen you first begin learning about microservice architecture it’s easy to get caught\nup in the tangible parts of the solution. You don’t have to look hard to find people\nwho are excited about Docker, continuous delivery, or service discovery. All of these\nthings can help you to build a system that sounds like the microservice systems we’ve\nbeen discussing. But microservices can’t be achieved by focusing on a particular set of\npatterns, process, or tools. Instead, you’ll need to stay focused on the goal itself—a\nsystem that can make change easier.\nMore specifically, the real value of microservices is realized when we focus on two key\naspects—speed and safety. Every single decision you make about your software devel‐\nopment ends up as a trade-off that impacts these two ideals. Finding an effective bal‐\nance between them at scale is what we call the microservices way.\nSpeed and Safety at Scale and in Harmony.\n—The Microservices Way\nThe Speed of Change\nThe desire for speed is a desire for immediate change and ultimately a desire for\nadaptability. On one hand, we could build software that is capable of changing itself—\nthis might require a massive technological leap and incredibly complex system. But\nthe solution that is more realistic for our present state of technological advancement\nis to shorten the time it takes for changes to move from individual workers to a pro‐\nduction environment.\nYears ago, most of us released software in the same way that NASA launches rockets.\nAfter deliberate effort and careful quality control, our software was burned into a per‐\nmanent state and delivered to users on tapes, CDs, DVDs, and diskettes. Of course,\nthe popularity of the Web changed the nature of software delivery and the mechanics\nof releases have become much cheaper and easier. Ease of access combined with\nimproved automation has drastically reduced the cost of a software change. Most\norganizations have the platforms, tools, and infrastructure in place to implement\nthousands of application releases within a single day. But they don’t. In fact, most\nteams are happy if they can manage a release in a week. Why is that? The answer of\ncourse is that the real deterrent to release speed is the fragility of the software they’ve\nproduced.\nThe Safety of Change\nSpeed of change gets a lot of attention in stories about microservice architecture, but\nthe unspoken, yet equally important counterpart is change safety. After all, “speed\nkills” and in most software shops nobody wants to be responsible for breaking pro‐\nduction. Every change is potentially a breaking change and a system optimized purely\nThe Microservices Way \n| \n9",
      "content_length": 2670,
      "extraction_method": "Direct"
    },
    {
      "page_number": 26,
      "chapter": null,
      "content": "for speed is only realistic if the cost of breaking the system is near zero. Most develop‐\nment environments are optimized for release speed, enabling the software developer\nto make multiple changes in as short a time as possible. On the other hand, most pro‐\nduction environments are optimized for safety, restricting the rate of change to those\nreleases that carry the minimum risk of damage.\nAt Scale\nOn top of everything else, today’s software architect needs to be able to “think big”\nwhen building applications. As we heard earlier in this chapter, the microservices\nstyle is rooted in the idea of solving the problems that arise when software gets too\nbig. To build at scale means to build software that can continue to work when\ndemand grows beyond our initial expectations. Systems that can work at scale don’t\nbreak when under pressure; instead they incorporate built-in mechanisms to increase\ncapacity in a safe way. This added dimension requires a special perspective to build‐\ning software and is essential to the microservices way.\nIn Harmony\nYour life is filled with decisions that impact speed and safety. Not just in the software\ndomain, but in most of your everyday life; how fast are you willing to drive a car to\nget where you need to be on time? How does that maximum speed change when\nthere is someone else in the car with you? Is that number different if one of your pas‐\nsengers is a child? The need to balance these ideals is something you were probably\ntaught at a young age and you are probably familiar with the well-worn proverb,\n“haste makes waste.”\nWe’ve found that all of the characteristics that we associate with microservice archi‐\ntecture (i.e., replaceability, decentralization, context-bound, message-based commu‐\nnication, modularity, etc.) have been employed by practitioners in pursuit of\nproviding speed and safety at scale. This is the reason a universal characteristic-\ndriven definition of microservices is unimportant—the real lessons are found in the\npractices successful companies have employed in pursuit of this balancing act.\nWe don’t want to give you the wrong idea—microservice architecture is not limited to\na simple series of decisions regarding speed and safety of change. The microservices\ndomain is actually fairly complex and will require you to understand a wide breadth\nof concepts that have a great depth of impact. If it was any other way, this would be a\nvery short book.\nInstead, we introduce the microservices way in order to help you understand the\nessence of the microservices style. All of the significant properties and patterns that\nare commonly adopted for this style of architecture reflect attempts to deal with the\ninterplay between these forces. The companies that do this best are the ones that find\nways to allow both safety and speed of change to coexist. Organizations that succeed\n10 \n| \nChapter 1: The Microservices Way",
      "content_length": 2901,
      "extraction_method": "Direct"
    },
    {
      "page_number": 27,
      "chapter": null,
      "content": "with microservice architecture are able to maintain their system stability while\nincreasing their change velocity. In other words, they created a harmony of speed and\nsafety that works for their own context.\nThe pursuit of this harmony should shape the adoption decisions you make for your\nown system. Throughout this book we will introduce principles and patterns that\nhave helped companies provide great value to their business. It will be tempting to\nsimply replicate the patterns in your own organizations in exactly the same way. But\ndo your best to first pay attention to the impact of these types of changes on your own\norganization’s harmony. We will do our best to provide you with enough information\nto connect those dots.\nIt also means that you may not find your balance in the same way as other companies.\nWe don’t expect your organization to work the same as the ones we’ve highlighted in\nthis book and we don’t expect your microservices implementation to be the same\neither. Instead, we hope that focusing on the way that microservices applications are\nbuilt will help you identify the parts that could work for you.\nSummary\nIn this chapter we introduced the original intent of the microservice architecture con‐\ncept—to replace complex monolithic applications with software systems made of\nreplaceable components. We also introduced some of the concerns that first-time\nimplementers often have, along with some of the practical realities. Finally, we intro‐\nduced the microservices way, a goal-driven approach to building adaptable, reliable\nsoftware. The balance of speed and safety at scale is key to understanding the essence\nof microservices and will come up again throughout this book. In the next chapter\nwe’ll take a closer look at the goals of speed and safety in the context of actual micro‐\nservice implementations.\nSummary \n| \n11",
      "content_length": 1855,
      "extraction_method": "Direct"
    },
    {
      "page_number": 28,
      "chapter": null,
      "content": "",
      "content_length": 0,
      "extraction_method": "OCR"
    },
    {
      "page_number": 29,
      "chapter": null,
      "content": "CHAPTER 2\nThe Microservices Value Proposition\nThe microservice architectural style was defined based on common patterns observed\nacross a number of pioneering organizations. These organizations did not con‐\nsciously implement a microservice architecture. They evolved to it in pursuit of spe‐\ncific goals.\nIn this chapter, we will explore the common benefits of microservice architecture and\nhow they drive the higher-order goals from Chapter 1—speed, safety, and scale; illus‐\ntrate how the goals of microservice architecture deliver business value; define a\nmaturity model for microservice architecture benefits and goals; and finally, apply\nthis information using a goal-oriented approach to microservice architecture.\nTo start with, let’s survey the motivations of some early microservice adopters.\nMicroservice Architecture Benefits\nWhy are organizations adopting microservices? What are the motivations and chal‐\nlenges? How can the leaders of these organizations tell that taking on the challenges\nof managing a collection of small, loosely coupled, independently deployable services\nis actually paying off for the company? What is the measure of success? Surveying the\nearly adopters of microservices, we find that the answers to these questions vary quite\na bit. However, some common themes emerge and tie back to the mantra of “balanc‐\ning speed and safety at scale.”\nWerner Vogels of Amazon describes the advantages of their architecture as follows:\nWe can scale our operation independently, maintain unparalleled system availability,\nand introduce new services quickly without the need for massive reconfiguration.\n—Werner Vogels, Chief Technology Officer, Amazon Web Services\n13",
      "content_length": 1691,
      "extraction_method": "Direct"
    },
    {
      "page_number": 30,
      "chapter": null,
      "content": "By focusing on scalability and component independence, Amazon has been able to\nincrease their speed of delivery while also improving the safety—in the form of scala‐\nbility and availability—of their environment.\nUK e-retailer Gilt is another early adopter of microservice architecture. Their Senior\nVice President of Engineering, Adrian Trenaman, listed these resulting benefits in an\nInfoQ article:\n• Lessens dependencies between teams, resulting in faster code to production\n• Allows lots of initiatives to run in parallel\n• Supports multiple technologies/languages/frameworks\n• Enables graceful degradation of service\n• Promotes ease of innovation through disposable code—it is easy to fail and move\non\nThe first three points help speed up software development, through organizational\nalignment and independent deployability, as well as polyglotism. The last two points\nspeak to a safe environment that facilitates replaceability of services.\nSocial media pioneer Hootsuite has observed efficiency benefits in their microservice\nadoption based on the tunability of the system:\nSome services require high availability, but are low volume, and it’s the opposite for\nother services. A microservice approach allows us to tune for both of these situations,\nwhereas in a monolith it’s all or nothing.\n—Beier Cai, Director of Software Development, Hootsuite\nWith a more granular set of components, Hootsuite is able to independently manage\ntheir services and achieve greater efficiency.\nClay Garrard, Senior Manager of Cloud Services at Disney, found that although there\nwas work done to modularize the code base of their monolithic applications, the\ndomain boundaries were not clear. This meant that small changes often led to large\ndeployments.\nWith microservices, we have reduced the time it takes to deploy a useful piece of code\nand also reduced the frequency of deploying code that hasn’t changed. Ultimately we\nstrive to be flexible in our interpretation of microservice architecture, using its\nstrengths where we can, but realizing that the business does not care about how we\nachieve results, only that we move quickly with good quality and flexible design.\n—Clay Garrard, Senior Manager of Cloud Services, Disney\nThe primary driver here is speed, as requested directly from the business. However,\nthere is also an emphasis on safety—through independent deployability and testabil‐\nity—as well as future-proofing through composability.\n14 \n| \nChapter 2: The Microservices Value Proposition",
      "content_length": 2494,
      "extraction_method": "Direct"
    },
    {
      "page_number": 31,
      "chapter": null,
      "content": "Lastly, SoundCloud sought to solve the following problem when they evolved to a\nmicroservice architecture:\nThe monolithic code base we had was so massive and so broad no one knew all of it.\nPeople had developed their own areas of expertise and custodianship around submod‐\nules of the application.\n—Phil Calçado, former Director of Engineering, SoundCloud\nBy embracing microservices, they were able to overcome this issue and improve the\ncomprehensibility of their software system.\nThere are common goals and benefits that emerge from these implementation stories.\nThe goal of improving software delivery speed as functional scope grows is realized\nthrough greater agility, higher composability, improved comprehensibility, independ‐\nent service deployability, organizational alignment, and polyglotism. The goal of\nmaintaining software system safety as scale increases is achieved through higher\navailability and resiliency, better efficiency, independent manageability and replacea‐\nbility of components, increased runtime scalability, and more simplified testability.\nNow let’s explore how these goals and benefits derive business value for organizations\nthat employ microservice architecture. \nDeriving Business Value\nSuccessful companies do not focus on increasing software delivery speed for its own\nsake. They do it because they are compelled by the speed of their business. Similarly,\nthe level of safety implemented in an organization’s software system should be tied to\nspecific business objectives. Conversely, the safety measures must not get in the way\nof the speed unnecessarily. Balance is required.\nFor each organization, that balance will be a function of its delivery speed, the safety\nof its systems, and the growth of the organization’s functional scope and scale. Each\norganization will have its own balance. A media company that aims to reach the wid‐\nest possible audience for its content may place a much higher value on delivery speed\nthan a retail bank whose compliance requirements mandate specific measures around\nsafety. Nonetheless, in an increasingly digital economy, more companies are recogniz‐\ning that software development needs to become one of their core competencies.\nIn this new business environment, where disruptive competitors can cross industry\nboundaries or start up from scratch seemingly overnight, fast software delivery is\nessential to staying ahead of the competition and achieving sustainable growth. In\nfact, each of the microservice architecture benefits that drive delivery speed contrib‐\nute real business value:\nDeriving Business Value \n| \n15",
      "content_length": 2597,
      "extraction_method": "Direct"
    },
    {
      "page_number": 32,
      "chapter": null,
      "content": "• Agility allows organizations to deliver new products, functions, and features\nmore quickly and pivot more easily if needed.\n• Composability reduces development time and provides a compound benefit\nthrough reusability over time.\n• Comprehensibility of the software system simplifies development planning,\nincreases accuracy, and allows new resources to come up to speed more quickly.\n• Independent deployability of components gets new features into production more\nquickly and provides more flexible options for piloting and prototyping.\n• Organizational alignment of services to teams reduces ramp-up time and encour‐\nages teams to build more complex products and features iteratively.\n• Polyglotism permits the use of the right tools for the right task, thus accelerating\ntechnology introduction and increasing solution options.\nLikewise, digital native consumers expect always-on services and are not shy about\nchanging corporate allegiances. Outages or lost information can cause them to take\ntheir business elsewhere. A safe software system is indispensable. The safety-aligned\nbenefits discussed earlier also provide particular business value:\n• Greater efficiency in the software system reduces infrastructure costs and reduces\nthe risk of capacity-related service outages.\n• Independent manageability contributes to improved efficiency, and also reduces\nthe need for scheduled downtime.\n• Replaceability of components reduces the technical debt that can lead to aging,\nunreliable environments.\n• Stronger resilience and higher availability ensure a good customer experience.\n• Better runtime scalability allows the software system to grow or shrink with the\nbusiness.\n• Improved testability allows the business to mitigate implementation risks.\nClearly, microservice architecture has the potential to provide numerous business\nbenefits. However, not every organization needs every benefit, and not every micro‐\nservice architecture is capable of delivering all of them. With that in mind, let’s now\nlook at how an organization can combine its business objectives with the potential\nbenefits of microservice architecture to tailor a goal-oriented approach.\n16 \n| \nChapter 2: The Microservices Value Proposition",
      "content_length": 2218,
      "extraction_method": "Direct"
    },
    {
      "page_number": 33,
      "chapter": null,
      "content": "Defining a Goal-Oriented, Layered Approach\nIn spite of the fact that microservice architecture was originally a reaction to the limi‐\ntations of monolithic applications, there is a fair amount of guidance in the industry\nthat says new applications should still be built as monoliths first. The thinking is that\nonly through the creation and ownership of a monolith can the right service bound‐\naries be identified. This path is certainly well trodden, given that early microservice\nadopters generally went through the process of unbundling their own monolithic\napplications. The “monolith first” approach also appears to follow Gall’s Law, which\nstates that, “A complex system that works is invariably found to have evolved from a\nsimple system that worked.” However, is a monolithic application architecture the\nonly simple system starting point? Is it possible to start simple with a microservice\narchitecture?\nIn fact, the complexity of a software system is driven by its scale. Scale comes in the\nform of functional scope, operational magnitude, and change frequency. The first\ncompanies to use microservice architecture made the switch from monolithic appli‐\ncations once they passed a certain scale threshold. With the benefit of hindsight, and\nwith an analysis of the common goals and benefits of microservice architecture, we\ncan map out a set of layered characteristics to consider when adopting microservice\narchitecture.\nModularized Microservice Architecture\nModularity … is to a technological economy what the division of labor is to a manu‐\nfacturing one.\n—W. Brian Arthur, author of The Nature of Technology\nAt its most basic level, microservice architecture is about breaking up an application\nor system into smaller parts. A software system that is modularized arbitrarily will\nobviously have some limitations, but there is still a potential upside. Network-\naccessible modularization facilitates automation and provides a concrete means of\nabstraction. Beyond that, some of the microservice architecture benefits discussed\nearlier already apply at this base layer.\nTo help software delivery speed, modularized services are independently deployable.\nIt is also possible to take a polyglot approach to tool and platform selection for indi‐\nvidual services, regardless of what the service boundaries are. With respect to safety,\nservices can be managed individually at this layer. Also, the abstracted service inter‐\nfaces allow for more granular testing.\nThis is the most technologically focused microservice architecture layer. In order to\naddress this layer and achieve its associated benefits, you must establish a foundation\nfor your microservice architecture. This will be discussed in detail in Chapter 4.\nDefining a Goal-Oriented, Layered Approach \n| \n17",
      "content_length": 2776,
      "extraction_method": "Direct"
    },
    {
      "page_number": 34,
      "chapter": null,
      "content": "1 http://api.co/kay-systems\nCohesive Microservice Architecture\nThe greater the cohesion of individual modules in the system, the lower the coupling\nbetween modules will be.\n—Larry Constantine and Edward Yourdon, authors of Structured Design: Funda‐\nmentals of a Discipline of Computer Program and Systems Design\nThe next layer to consider in your microservice architecture is the cohesion of serv‐\nices. In order to have a cohesive microservice architecture, it must already be modu‐\nlarized. Achieving service cohesion comes from defining the right service boundaries\nand analyzing the semantics of the system. The concept of domains is useful at this\nlayer, whether they are business-oriented or defined by some other axis.\nA cohesive microservice architecture can enable software speed by aligning the sys‐\ntem’s services with the supporting organization’s structure. It can also yield composa‐\nble services that are permitted to change at the pace the business dictates, rather than\nthrough unnecessary dependencies. Reducing the dependencies of a system featuring\ncohesive services also facilitates replaceability of services. Moreover, service cohesion\nlessens the need for highly orchestrated message exchanges between components,\nthereby creating a more efficient system.\nIt takes a synthesized view of business, technology, and organizational considerations\nto build a cohesive system. This can be addressed through service design, which is the\nfocus of Chapter 5.\nSystematized Microservice Architecture\nThe key in making great and growable systems is much more to design how its mod‐\nules communicate rather than what their internal properties and behaviors should be.1\n—Alan Kay, 1998 email to the Squeak-dev list\nThe final and most advanced layer to consider in a microservice architecture is its\nsystem elements. After breaking the system into pieces through modularization, and\naddressing the services’ contents through cohesion, it is time to examine the interre‐\nlationships between the services. This is where the greatest level of complexity in the\nsystem needs to be addressed, but also where the biggest and longest-lasting benefits\ncan be realized.\n18 \n| \nChapter 2: The Microservices Value Proposition",
      "content_length": 2223,
      "extraction_method": "Direct"
    },
    {
      "page_number": 35,
      "chapter": null,
      "content": "There are two ways speed of delivery is impacted in a systematized microservice\narchitecture. Although a single service may be understandable even in a modularized\nmicroservice architecture, the overall software system is only comprehensible when\nthe connectivity between services is known. Also, agility is only possible when the\nimpacts of changes on the whole system can be identified and assessed rapidly. This\napplies on the safety side as well, where runtime scalability is concerned. Lastly,\nalthough individual components may be isolated and made resilient in a modularized\nor cohesive microservice architecture, the system availability is not assured unless the\ninterdependencies of the components are understood.\nDealing with complex systems requires a careful approach based on influence versus\ncontrol. The system aspects of microservice architecture are discussed in detail in\nChapters 3 and 6.\nMaturity Model for Microservice Architecture Goals and Benefits\nThese layered characteristics—modularized, cohesive, and systematized—help to\ndefine a maturity model that serves a number of purposes. First, it classifies the bene‐\nfits according to phase and goal (speed or safety) as discussed previously. Secondly, it\nillustrates the relative impact and priority of benefits as scale and complexity increase.\nLastly, it shows the activities needed to address each architectural phase. This matur‐\nity model is depicted in Figure 2-1.\nNote that an organization’s microservice architecture can be at different phases for\ndifferent goals. Many companies have become systematized in their approach to\nsafety—through automation and other operational considerations—without seeking\nthe speed-aligned system-level benefits. The point of this model is not for every orga‐\nnization to achieve systematized actualization with their microservice architecture.\nRather, the model is meant to clarify goals and benefits in order to help organizations\nfocus their microservice strategies and prepare for what could come next.\nDefining a Goal-Oriented, Layered Approach \n| \n19",
      "content_length": 2070,
      "extraction_method": "Direct"
    },
    {
      "page_number": 36,
      "chapter": null,
      "content": "Figure 2-1. A maturity model for microservice architecture goals and benefits\nApplying the Goal-Oriented, Layered Approach\nNow we have a good understanding of how a microservice architecture can bring\nvalue to an organization, and a model for understanding what characteristics can\nbring what goals and benefits at what stage of adoption. But what about your organi‐\nzation? What are your business goals? What problems do you need to solve? It is a\ncommon misstep to start down the microservices path for its own sake without\nthinking about the specific benefits you are targeting. In other cases, some organiza‐\ntions aim for a high-level goal and then only implement one aspect of microservices\nwhile ignoring its founding conditions. For example, an organization with a high-\nlevel divide between development and operations—an organizational red flag—might\nexecute a containerization strategy on their existing applications and then wonder\nwhy they didn’t speed up their software development sufficiently. A broad perspective\nis needed.\nTo begin with, define the high-level business objectives you want to accomplish, and\nthen weigh these against the dual goals of speed and safety. Within that context, con‐\n20 \n| \nChapter 2: The Microservices Value Proposition",
      "content_length": 1265,
      "extraction_method": "Direct"
    },
    {
      "page_number": 37,
      "chapter": null,
      "content": "sider the distinct benefits you are targeting. You can then use the maturity model to\ndetermine the complexity of the goal, and identify the best approach to achieve it.\nHolger Reinhardt, CTO of the German digital media group Haufe-Lexware, provides\nan example of a goal-oriented approach in action. One of Haufe’s initial attempts at\nmicroservice architecture was on their monolithic service platform, which included\nfunctions such as user management and license management. The first attempt was\nexplicitly focused on changing the architecture from monolith to service-enabled\nsoftware system. The results were not positive. However, when they evaluated the\nmain issues with the application—particularly the operational inefficiencies around it\n—they changed their approach from refactoring the existing architecture to automat‐\ning the problematic deployment process. Through a small investment, they were able\nto take their service platform deployment downtime from 5 days to 30 minutes. Their\nnext iteration will focus on reducing QA time through automation and a switch in\nmethodology from white-box to black-box testing. Following these methodological\nchanges, they will identify the domains in their monolithic application that require\nthe greatest speed of innovation and unbundle those first. By taking an iterative\napproach tied to clear goals, they are able to measure success quickly and change\ncourse if needed.\nSummary\nThis chapter has covered a lot of ground that should help you define a strategy for\napplying a microservice architecture in your organization. We first analyzed the rea‐\nsons the early adopters of microservice architecture chose this style. Next, we looked\ninto the common goals and benefits of microservices, how they relate to each other,\nand what business objectives they can drive. Lastly, we defined a maturity model that\ncan be used to target the right goals and benefits for applying a microservice architec‐\nture in your organization. You should now be ready to roll up your sleeves and learn a\ndesign-based approach to microservice architecture.\nSummary \n| \n21",
      "content_length": 2103,
      "extraction_method": "Direct"
    },
    {
      "page_number": 38,
      "chapter": null,
      "content": "",
      "content_length": 0,
      "extraction_method": "OCR"
    },
    {
      "page_number": 39,
      "chapter": null,
      "content": "PART II\nMicroservice Design Principles\nThe Flaw of Averages\nIn the 1950s, the US Air Force launched a study into the causes of pilot errors and\npart of that study focused on the physical dimensions of the pilots and their cockpit\ncontrol systems. The cockpits had been initially designed based on assumed physical\naverages of pilots and it was assumed that pilots had grown larger over time and that\nthe design needed to be updated.\nThis story comes from the book The End of Average by Todd Rose\n(Harper Collins, 2016). Rose has given a TEDx talk on the subject\nof averages and is a leading proponent of an interdisciplinary field\ncalled “The Science of the Individual”.\nIt fell to 23-year-old Lt. Gilbert Daniels to lead the painstaking process of carefully\nmeasuring over 4,000 pilots on 140 different physcial dimensions and then analyze\nthe results. Along the way, Daniels got the idea to go beyond the initial plan to com‐\npute the averages of all 140 dimensions in order to construct what the military\ndeemed the “average pilot.” Daniels wanted to know just how many of the 4,000 pilots\nhe had measured actually were average—i.e., how many fit the computed values the\nmilitary was aiming to use to redesign the airplane cockpits?\nBy taking just ten of the many dimensions he was working with (height, chest size,\nsleeve length, etc.), Daniels constructed what he defined as the average pilot. Daniels\nalso posited that anyone who fell within a 30% range of the target number for a\ndimension would be included in his list of average pilots. For example, the average",
      "content_length": 1570,
      "extraction_method": "Direct"
    },
    {
      "page_number": 40,
      "chapter": null,
      "content": "pilot height turned out to be 5’9”. So, for Daniels, anyone who measured 5’7” to 5’11”\nwould be counted as average for height. Daniels then proceeded to check each of his\n4,000 subjects to discover just how many of them would score within the average for\nevery dimension. He was looking for all the pilots who could be considered com‐\npletely average. To everyone’s surprise, the total count was zero. There was not one\nsingle pilot that fell within 30% of the average for all ten dimensions. As Daniels\nwrote in his paper The “Average Man”?:\nAs an abstract representation of a mythical individual most representative of a given\npopulation, the average man is convenient to grasp in our minds. Unfortunately he\ndoesn’t exist.\n—Lt. Gilbert Daniels, The “Average Man”?\nIt turns out there is no such thing as an average pilot. Designing a cockpit for the aver‐\nage pilot results in a cockpit configuration that fits no one. Intuitively, this makes\nsense to most of us. While averages are helpful when looking for trends in a group,\nthe resulting “profile” from this group does not exist in real life. Averages help us\nfocus on trends or broad strokes but do not describe any actual existing examples.\nThe reason for this difference between real pilots and the average pilot can be sum‐\nmed up in what Rose calls the principle of jaggedness. When measuring individuals on\na multidimensional set of criteria (height, arm length, girth, hand size, and so forth),\nthere are so many varying combinations that no one individual is likely to exhibit the\naverage value for all dimensions. And designing for an individual that exhibits all\nthose averages will result in a poor fit for every actual person.\nThis principle of jaggedness is important to keep in mind when designing software\narchitecture, too. Designing for an ideal or average is likely to result in a model that\nfits no single purpose well. Guidance that calls out specific measurements of an ideal\nmicroservice or canonical model for microservices is likely to have traits that fit no\nexisting microservice implementation. Ideals are just that—not realities.\nThe solution that eventually worked for the US Air Force was to incorporate variabil‐\nity into the design of airplane cockpits. For example, creating an adjustable seat, the\nability to modify the tilt and length of the steering column, and moving the foot ped‐\nals forward or back are all examples of designing in variability. This works because\nthe exact dimensions of any single element in the design are not as important as the\nability to identify the important dimensions that need to support variability.",
      "content_length": 2622,
      "extraction_method": "Direct"
    },
    {
      "page_number": 41,
      "chapter": null,
      "content": "CHAPTER 3\nDesigning Microservice Systems\nSo far we’ve learned that companies building applications in the microservices way do\nmore than just implement small components. We now know that there isn’t a strict\ndefinition for what constitutes a microservice architecture. Instead, the focus is on\nbuilding applications that balance speed and safety at scale, primarily through repla‐\nceability. Throughout the remaining chapters of this book we will dive deeper into the\ndetails of microservice adoption. But considering what you’ve learned about micro‐\nservices systems so far, one thing should be clear—there are a lot of moving parts to\nconsider. The hallmark of a microservice architecture might be smaller services, but\nfollowing the microservices way will require you to think big. You’ll need to tune your\nculture, organization, architecture, interfaces, and services in just the right way to\ngain the balance of speed and safety at scale.\nIn this chapter we will lay the groundwork for thinking about your application in a\nway that helps you unlock the potential value of a microservices system. The concepts\nintroduced are rooted in some pretty big domains: design, complexity, and systems\nthinking. But you don’t need to be an expert in any of those fields to be a good micro‐\nservice designer. Instead, we will highlight a model-driven way of thinking about\nyour application that encapsulates the essential parts of complexity and systems\nthinking. Finally, at the end of this chapter we will introduce an example of a design\nprocess that can help promote a design-driven approach to microservices implemen‐\ntation.\nThe Systems Approach to Microservices\nWe’ve found that many first-time adopters of microservices tend to focus on the serv‐\nices that need to be built. But in order to develop applications in the microservices\nway, you’ll need to conceptualize the design as much more than isolated, individual\nservice designs. That doesn’t mean that the design of services can be ignored—just\n25",
      "content_length": 2003,
      "extraction_method": "Direct"
    },
    {
      "page_number": 42,
      "chapter": null,
      "content": "like cars and pedestrians are essential to a traffic system, services are the key ingredi‐\nent of a microservice system. But thinking in services terms alone isn’t enough;\ninstead you’ll need to consider how all aspects of the system can work together to\nform an emergent behavior. Emergent behaviors are the ones that are greater than the\nsum of their parts and for a microservices application this includes the runtime\nbehavior that emerges when we connect individual services together and the organi‐\nzational behavior that gets us there.\nEmergence is an essential part of the science of complexity and is a\nkey indicator of system complexity. Complexity scientist Melanie\nMitchell (known for her work at the Santa Fe Institute) often uses\nant colonies to illustrate emergence and complexity: predicting the\nbehavior of a single ant is trivial, but predicting the behavior of an\nentire ant colony is much more difficult.\nA microservices system encompasses all of the things about your organization that\nare related to the application it produces. This means that the structure of your orga‐\nnization, the people who work there, the way they work, and the outputs they pro‐\nduce are all important system factors. Equally important are runtime architectural\nelements such as service coordination, error handling, and operational practices. In\naddition to the wide breadth of subject matter that you need to consider, there is the\nadditional challenge that all of these elements are interconnected—a change to one\npart of the system can have an unforeseen impact on another part. For example, a\nchange to the size of an implementation team can have a profound impact on the\nwork that the implementation team produces.\nIf you implement the right decisions at the right times you can influence the behavior\nof the system and produce the behaviors you want. But that is often easier said than\ndone. Grappling with all of these system elements at the same time is difficult. In fact,\nyou might find it especially challenging to conceptualize all of the moving parts of the\nmicroservice system in your head. What we are learning is that microservice systems\nare complex!\nComplexity scientists face a similar challenge when they work with complex systems.\nWith all of the interconnected parts and the complex emergence that results, it is very\ndifficult to understand how the parts work together. In particular, it is difficult to pre‐\ndict the results that can arise from a change to the system. So, they do what scientists\nhave always done—they develop a model.\nThe models mathematicians develop to study complex systems allow them to more\naccurately understand and predict the behavior of a system. But this is a field in its\ninfancy and the models they produce tend to be very complicated. We don’t expect\nyou to understand the mathematics of complexity, nor do we think it will be particu‐\nlarly helpful in creating better microservice applications. But we do believe that a\n26 \n| \nChapter 3: Designing Microservice Systems",
      "content_length": 3022,
      "extraction_method": "Direct"
    },
    {
      "page_number": 43,
      "chapter": null,
      "content": "model-based approach can help all of us conceptualize our system of study and will\nmake it easier for us talk about the parts of the system.\nWith that in mind, Figure 3-1 depicts a microservice design model comprised of five\nparts: Service, Solution, Process and Tools, Organization, and Culture.\nFigure 3-1. The microservice system design model\nIn truth, each of these design elements are deserving of their own book and we point\nyou to some great sources in the reading list in Appendix A. But the goal of this\nmodel is to highlight the major areas of concern and the parts of the system you need\nto influence in order to succeed with this architectural style.\nService\nImplementing well-designed microservices and APIs are essential to a microservice\nsystem. In a microservice system, the services form the atomic building blocks from\nwhich the entire organism is built. If you can get the design, scope, and granularity of\nyour service just right you’ll be able to induce complex behavior from a set of compo‐\nnents that are deceptively simple.\nIn Chapter 5 we’ll give you some guidance on designing effective microservices and\nAPIs.\nThe Systems Approach to Microservices \n| \n27",
      "content_length": 1181,
      "extraction_method": "Direct"
    },
    {
      "page_number": 44,
      "chapter": null,
      "content": "Solution\nA solution architecture is distinct from the individual service design elements\nbecause it represents a macro view of our solution. When designing a particular\nmicroservice your decisions are bounded by the need to produce a single output—the\nservice itself. Conversely, when designing a solution architecture your decisions are\nbounded by the need to coordinate all the inputs and outputs of multiple services.\nThis macro-level view of the system allows the designer to induce more desirable sys‐\ntem behavior. For example, a solution architecture that provides discovery, safety, and\nrouting features can reduce the complexity of individual services.\nWe will dive into the patterns that you can employ to produce good microservice sys‐\ntem behavior in Chapter 6.\nProcess and Tools\nYour microservice system is not just a byproduct of the service components that han‐\ndle messages at runtime. The system behavior is also a result of the processes and\ntools that workers in the system use to do their job. In the microservice’s system, this\nusually includes tooling and processes related to software development, code deploy‐\nment, maintenance, and product management.\nChoosing the right processes and tools is an important factor in producing good\nmicroservice system behavior. For example, adopting standardized processes like\nDevOps and Agile or tools like Docker containers can increase the changeability of\nyour system. In Chapters 4 and 6 we will take a closer look at the processes and tools\nthat can have the biggest impact on a microservices system.\nOrganization\nHow we work is often a product of who we work with and how we communicate.\nFrom a microservice system perspective, organizational design includes the structure,\ndirection of authority, granularity, and composition of teams. Many of the companies\nthat have had success with microservice architecture point to their organizational\ndesign as a key ingredient. But organizational design is incredibly context-sensitive\nand you may find yourself in a terrible situation if you try to model your 500+\nemployee enterprise structure after a 10-person startup (and vice versa).\nA good microservice system designer understands the implications of changing these\norganizational properties and knows that good service design is a byproduct of good\norganizational design. We will dive deeper into team design concepts in Chapter 4.\n28 \n| \nChapter 3: Designing Microservice Systems",
      "content_length": 2447,
      "extraction_method": "Direct"
    },
    {
      "page_number": 45,
      "chapter": null,
      "content": "Culture\nOf all the microservice system domains, culture is perhaps the most intangible yet\nmay also be the most important. We can broadly define culture as a set of values,\nbeliefs, or ideals that are shared by all of the workers within an organization. Your\norganization’s culture is important because it shapes all of the atomic decisions that\npeople within the system will make. This large scope of influence is what makes it\nsuch a powerful tool in your system design endeavor.\nMuch like organizational design, culture is a context-sensitive feature of your system.\nWhat works in Japan may not work in the United States and what works in a large\ninsurance firm may not work at an ecommerce company. So, you’ll need to be cau‐\ntious when attempting to emulate the practices that work in a company whose culture\nyou admire. There is no recipe or playbook that will guarantee you the same results.\nAs important as it is, the culture of an organization is incredibly difficult to measure.\nFormal methods of surveying and modeling exist, but many business and technology\nleaders evaluate the culture of their teams in a more instinctual way. You can get a\nsense of the culture of your organization through your daily interactions with team\nmembers, team products, and the customers they cater to.\nHowever you gauge it, culture is often an indication of the impact of other parts of\nyour system. Shared ideals shape how people do their work and how they work will in\nturn shape their organizational view. This is the interconnected nature of the system.\nEmbracing Change\nTime is an essential element of a microservice system and failing to account for it is a\ngrave mistake. All of the decisions you make about the organization, culture, pro‐\ncesses, services, and solutions should be rooted in the notion that change is inevita‐\nble. You cannot afford to be purely deterministic in your system design; instead, you\nshould design adaptability into the system as a feature.\nThere is good reason for taking this perspective: first, trying to determine what the\nend state of your organization and solution design should look like is a near impossi‐\nble task. Second, it is unlikely that the context in which you made your design deci‐\nsions will stay the same. Changes in requirements, markets, and technology all have a\nway of making today’s good decisions obsolete very quickly.\nA good microservice designer understands the need for adaptability and endeavors to\ncontinually improve the system instead of working to simply produce a solution. We\ngive you some practical patterns and tools for improving system adaptability in the\nthird part of this book.\nThe Systems Approach to Microservices \n| \n29",
      "content_length": 2696,
      "extraction_method": "Direct"
    },
    {
      "page_number": 46,
      "chapter": null,
      "content": "Putting it Together: The Holistic System\nWhen put together all of these design elements form the microservices system. They\nare interconnected and a change to one element can have a meaningful and some‐\ntimes unpredictable impact on other elements. The system changes over time and is\nunpredictable. It produces behavior that is greater than the behavior of its individual\ncomponents. It adapts to changing contexts, environments, and stimuli.\nIn short, the microservices system is complex and teasing desirable behaviors and\noutcomes from that system isn’t an easy task. But some organizations have had enor‐\nmous success in doing so and we can learn from their examples.\nStandardization and Coordination\nTo be precise, one cannot speak of leaders who cause organizations to achieve superla‐\ntive performance, for no one can cause it to happen. Leaders can only recognize and\nmodify conditions which prevent it.\n—Dee Hock, author of The Art of Chaordic Leadership\nAlmost all of us work in organizations that operate within constraints. These con‐\nstraints arise because the wrong type of system behavior can be harmful to the orga‐\nnization, even resulting in the organization failing as a result of particularly bad\nbehavior. For example, a banking technology system that makes it easy to steal some‐\none else’s money or a tax system that fails to protect its users’ private information are\nunacceptable.\nWith the cost of unwanted system behavior so high, it’s no wonder that so many\narchitects and designers do their best to control system behavior. In practice, the sys‐\ntem designer decides that there is some behavior or expectation that must be univer‐\nsally applied to the actors within the system. Policies, governance, and audits are all\nintroduced as a way of policing the behavior of the system and ensuring that the\nactors conform. In other words, some parts of the system are standardized.\nBut true control of this type of complex system is an illusion. You have as much\nchance of guaranteeing that your banking system will be perfectly secure as a farmer\ndoes of guaranteeing that his crops will always grow. No matter how many rules,\nchecks, and governance methods you apply you are always at the mercy of actors in a\nsystem that can make poor decisions.\nInstead, all of these mechanisms of control act as system influencers that greatly\nincrease the likelihood of the results you want. Mastering the system you are design‐\ning and making it do the things you want requires you to develop the right standards,\nmake sure the standards are being applied, and measure the results of the changes\nyou are making.\n30 \n| \nChapter 3: Designing Microservice Systems",
      "content_length": 2672,
      "extraction_method": "Direct"
    },
    {
      "page_number": 47,
      "chapter": null,
      "content": "However, control of the system comes at a steep price. Standardization is the enemy\nof adaptability and if you standardize too many parts of your system you risk creating\nsomething that is costly and difficult to change.\nIn his book Structure in Fives, organizational designer Henry Mintzberg identifies\nsome of the coordination mechanisms and standards that make the biggest differ‐\nences for organizational systems. In particular, he identifies standardization of work\noutputs, worker skills, and work processes as having the most impact.\nDon’t be scared off by our use of the word “standardization”! When\nwe talk about standards, we mean the established norms and\naccepted ways of working that exist within an organization. The\ngoal of this section is to understand the system impact when stand‐\nardization is focused on different parts of the company.\nStandardizing process\nWe’ve already talked about how processes and tools are important for the behavior\nthat emerges from our system. By standardizing the way that people work and the\ntools they use, you can influence the behavior in a more predictable way. For exam‐\nple, standardizing a deployment process that reduces the time for component deploy‐\nment may improve the overall changeability of the system as the cost of new\ndeployments decreases.\nStandardizing how we work has broad-reaching implications on the type of work we\ncan produce, the kind of people we hire, and the culture of an organization. The Agile\nmethodology is a great example of process standardization. Agile institutionalizes the\nconcept that change should be introduced in small measurable increments that allow\nthe organization to handle change easier. One observable system impact for Agile\nteams is that the output they produce begins to change. Software releases become\nsmaller and measurability becomes a feature of the product they output. There are\nalso usually follow-on effects to culture and organizational design.\nIn addition to process standardization, most companies employ some form of tool\nstandardization as well. In fact, many large organizations have departments whose\nsole purpose is to define the types of tools their workers are allowed to utilize. For\nexample, some firms forbid the use of open source software and limit their teams to\nthe use of centrally approved software, procured by a specialist team.\nThe microservices tooling space is moving very quickly and we are certain that any\ndiscussion of particular microservice tools would be out of date by the time this book\nis published. But we make an effort to describe the type of tools that are particularly\nimportant to standardize in Chapter 4, along with some examples of tools that are\nparticularly relevant at the moment.\nThe Systems Approach to Microservices \n| \n31",
      "content_length": 2783,
      "extraction_method": "Direct"
    },
    {
      "page_number": 48,
      "chapter": null,
      "content": "Standardizing outputs\nWe can define a team as a group of workers who take a set of inputs and transform\nthem into one or more outputs. Output standardization is way of setting a universal\nstandard for what that output should look like. For example, in an assembly line the\noutput of the line workers is standardized—everyone on the line must produce\nexactly the same result. Any deviation from the standard output is considered a fail‐\nure.\nIn a microservices system, a team takes a set of requirements and turns those into a\nmicroservice. So, the service is the output and the face of that output is the interface\n(or API) that provides access to the features and data the microservice provides. In\nfact, from the microservice consumer perspective, the API is the output, as they have\nno visibility of the implementation behind it.\nIn the microservices context, output standardization often means developing some\nstandards for the APIs that expose the services. For example, you might decide that\nall the organization’s services should have an HTTP interface or that all services\nshould be capable of subscribing to and emitting events. Some organizations even\nstandardize how the interfaces should be designed in an effort to improve the usabil‐\nity, changeability, and overall experience of using the service. In Chapter 5 we will\ndive deeper into the types of API standardization that make sense for microservice\nsystems and the benefits and costs of different types of interface styles.\nStandardizing people\nYou can also decide to standardize the types of people that do the work within your\norganization. For example, you could introduce a minimum skill requirement for\nanyone who wants to work on a microservice team. In fact, many of the companies\nthat have shared microservice stories point to the skill level of their people as a pri‐\nmary characteristic of their success.\nStandardizing skills or talent can be an effective way of introducing more autonomy\ninto your microservices system. When the people who are implementing the services\nare more skilled they have a better chance of making decisions that will create the sys‐\ntem behavior you want.\nAll organizations have some level of minimum skill and experience level for their\nworkers, but organizations that prioritize skill standardization often set very high\nspecialist requirements in order to reap system benefits. If only the best and brightest\nare good enough to work within your system, be prepared to pay a high cost to main‐\ntain that standard.\n32 \n| \nChapter 3: Designing Microservice Systems",
      "content_length": 2569,
      "extraction_method": "Direct"
    },
    {
      "page_number": 49,
      "chapter": null,
      "content": "Standardization trade-offs\nStandardizing helps you exert influence over your system, but you don’t have to\nchoose just one of these standards to utilize. But keep in mind that while they aren’t\nmutually exclusive, the introduction of different modes of standardization can create\nunintended consequences in other parts of the system.\nFor example, you might decide to standardize on the APIs that all microservices\nexpose because you want to reduce the cost of connecting things together in your sol‐\nution architecture. To do this you might prescribe a set of rules for the types of APIs\nthat developers are allowed to create and institute a review process to police this\nstandardization. As an example, many organizations standardize a way of document‐\ning the interfaces that are created. At the moment Swagger (also called OpenAPI) is a\npopular example of an interface description language, but there are many others\n(WADL, Blueprint, RAML, etc.).\nBut we may find that constraining the types of APIs our people are allowed to pro‐\nduce limits the types of tools they can use to create them. It might be the case that the\ndevelopment tool we want everyone to use doesn’t support the interface description\nlanguage we have already chosen. In other words, the decision to standardize the\nteam’s output has had unintended consequences on the team’s work process. This\nhappens because standardization is an attempt to remove uncertainty from our sys‐\ntem, but comes at the cost of reducing innovation and changeability.\nThe benefit of standardization is a reduction in the set of all possible outcomes. It\ngives us a way to shape the system by setting constraints and boundaries for the\nactions that people within the system can take. But this benefit comes at a cost. Stand‐\nardization also constrains the autonomy of individual decision-makers.\nThe challenge for designers is to introduce just enough standardization to achieve the\nbest emergent system outcome, while also employing standards and constraints that\ncomplement each other. Throughout this book we will highlight standardization\ntechniques that will be useful for you in your microservices system, along with the\npossible repercussions of using them.\nA Microservices Design Process\nThe very first step of a service design process is to design the process itself.\n—Marc Stickdorn, author of This is Service Design Thinking\nProfessional designers know that the secret to great design is using the right design\nprocess. Where others apply expert advice or make false assumptions about the\nimpact of their design decisions, a good designer employs a process that helps them\ncontinually get closer to the best product. This doesn’t mean that you never have to\nmake assumptions or that expert guidance is necessarily wrong. Instead, it means that\nA Microservices Design Process \n| \n33",
      "content_length": 2841,
      "extraction_method": "Direct"
    },
    {
      "page_number": 50,
      "chapter": null,
      "content": "your best chance at designing the microservice system you want is to work with a\nprocess that helps you understand the impact of your assumptions and the applicabil‐\nity of advice as you change the system.\nFigure 3-2 illustrates a framework for a design process that you can use in your own\nmicroservice system designs. In practice, it is likely that you’ll need to customize the\nprocess to fit within your own unique constraints and context. You might end up\nusing these design activities in a different order than given here. You may also decide\nthat some activities aren’t applicable to your goals or that other steps need to be\nadded.\nFigure 3-2. Microservice system design process\nSet Optimization Goals\nThe behavior of your microservice system is “correct” when it helps you achieve your\ngoals. There isn’t a set of optimization goals that perfectly apply to all organizations,\nso one of your first tasks will be to identify the goals that make sense for your particu‐\nlar situation. The choice you make here is important—every decision in the design\nprocess after this is a trade-off made in favor of the optimization goal.\nNote that optimization doesn’t mean that other system qualities are undesirable. In\nfact, it is extremely likely that you will initially list many desirable outcomes for the\nsystem you create. But as you go through the system design process you will find that\nit is difficult to pull your system into many directions at the same time. A smaller set\nof optimization goals is easier to design for. A single optimization goal (like the\n34 \n| \nChapter 3: Designing Microservice Systems",
      "content_length": 1612,
      "extraction_method": "Direct"
    },
    {
      "page_number": 51,
      "chapter": null,
      "content": "Vision Zero goal of zero traffic-related fatalities) provides the most clarity and has a\nhigher likelihood of succeeding.\nFor example, a financial information system might be optimized for reliability and\nsecurity above all other factors. That doesn’t mean that changeability, usability, and\nother system qualities are unimportant—it simply means that the designers will\nalways make decisions that favor security and reliability above all other things.\nIn Chapter 4 we will identify the goals that we have most commonly seen among\ncompanies that have embraced the microservices way and the principles that help\nsupport them.\nIt is possible that you may need to change your optimization goals\nat some point in the lifetime of your application. That is OK; it just\nmeans that you need to follow the design process and implement\nsmall changes to guide your system toward the new goal. If the goal\nchange is quite different from your original design goal this may\ntake some time. If the optimization goal is radically different from\nyour original goal, you may even create a new system design\nentirely.\nDevelopment Principles\nUnderpinning a system optimization goal is a set of principles. Principles outline the\ngeneral policies, constraints, and ideals that should be applied universally to the\nactors within the system to guide decision-making and behavior. The best designed\nprinciples are simply stated, easy to understand, and have a profound impact on the\nsystem they act upon.\nIn Chapter 4 we will look at some of the principles that Netflix employs toward its\noptimization goals.\nSketch the System Design\nIf you find yourself building the application in a greenfield environment with no\nexisting organization or solution architecture in place, it is important that you estab‐\nlish a good starting point for your system design. You won’t be able to create the per‐\nfect system on your first try and you aren’t likely to have the time or information to\ndo that anyway. Instead, a good approach is to sketch the important parts of your sys‐\ntem design for the purposes of evaluation and iteration.\nHow you do this is entirely up to you. There is a wealth of modeling and communica‐\ntion tools available to conceptualize organizational and solution architectures; choose\nthe ones that work well for you. But the value of this step in the design process is to\nserialize some of the abstract concepts from your head into a tangible form that can\nA Microservices Design Process \n| \n35",
      "content_length": 2482,
      "extraction_method": "Direct"
    },
    {
      "page_number": 52,
      "chapter": null,
      "content": "be evaluated. The goal of a sketching exercise is to continually improve the design\nuntil you are comfortable moving forward.\nThe goal is to sketch out the core parts of your system, including organizational\nstructure (how big are the teams? what is the direction of authority? who is on the\nteam?), the solution architecture (how are services organized? what infrastructure\nmust be in place?), the service design (what outputs? how big?), and the processes\nand tools (how do services get deployed? what tools are necessary?). You should eval‐\nuate these decisions against the goals and principles you’ve outlined earlier. Will your\nsystem foster those goals? Do the principles make sense? Do the principles need to\nchange? Does the system design need to change?\nSketching is powerful when the risk of starting over is small. Good sketches are easy\nto make and easy to destroy, so avoid modeling your system in a way that requires a\nheavy investment of time or effort. The more effort it takes to sketch your system the\nless likely you are to throw it away. At this early stage of system design, change should\nbe cheap.\nMost importantly, remember that the purpose of the iterative sketching stage is to\nparticipate in the process of designing. The goal is to form new ideas, consider the\nimpact of proposed designs, and experiment in a safe way. The goal is not to create a\nset of beautiful design documents or prescriptive plans.\nImplement, Observe, and Adjust\nBad designers make assumptions about how a system works, apply changes in the\nhope that it will produce desired behavior, and call it a day. Good designers make\nsmall system changes, assess the impact of those changes, and continually prod the\nsystem behavior toward a desired outcome. But a good design process is predicated\non your ability to get feedback from the system you are designing. This is actually\nmuch more difficult than it sounds—the impact of a change to one small part of the\nsystem may result in a ripple of changes that impact other parts of your system with\nlow visibility.\nThe perfect microservice system provides perfect information about all aspects of the\nsystem across all the domains of culture, organization, solution architecture, services,\nand process. Of course, this is unrealistic. It is more realistic to gain essential visibility\ninto our system by identifying a few key measurements that give us the most valuable\ninformation about system behavior. In organizational design, this type of metric is\nknown as a key performance indicator (KPI). The challenge for the microservice\ndesigner is to identify the right ones.\nGathering information about your system by identifying KPIs is useful, but being able\nto utilize those metrics to predict future behavior is incredibly valuable. One of the\nchallenges that all system designers face is the uncertainty about the future. With per‐\n36 \n| \nChapter 3: Designing Microservice Systems",
      "content_length": 2924,
      "extraction_method": "Direct"
    },
    {
      "page_number": 53,
      "chapter": null,
      "content": "fect information about how our system might need to change we could build bound‐\naries in exactly the right places and make perfect decisions about the size of our\nservices and teams.\nWithout perfect information we are forced to make assumptions. Designers working\non existing applications can observe the existing and past behavior of the system to\nidentify patterns—components that change often, requirements that are always in\nflux, and services that can expect high usage. But designers who are working on new\napplications often have very little information to start with—the only way to identify\nthe brittle points of the application is to ship the product and see what happens.\nThe risk of making poor decisions is that we steer the system in a direction that\nincreases our “technical debt” (i.e., the future cost of addressing a technical defi‐\nciency). If we go too far along the wrong path we risk producing a system that\nbecomes too expensive to change, so we give up.\nThe classic microservices example of this is the cautionary tale of the “monolith.” A\nteam creates an initial release of an application when the feature set is small and the\ncomponentry has low complexity. Over time, the feature set grows and the complex‐\nity of the deployed application grows, making change ever more difficult. At this\npoint, the team agrees that the application needs to be redesigned and modularized to\nimprove its changeability. But the redesign work is continually deferred because the\ncost of that work is too high and difficult to justify.\nAt the other end of the scale is a system that is so overdesigned and overengineered\nfor future flexibility that it becomes impractical. An incredibly complex, adaptable\nsystem that is built for massive amounts of change that never seems to happen.\nRather than trying to predict the future, a good microservices designer examines the\ncurrent state and makes small, measurable changes to the system. This is a bit like\ntaking a wrong turn on a long road trip—if you don’t know that you’ve made a mis‐\ntake you might not find out you’re going the wrong way until it is too late to turn\nback. But if you have a navigator with you, they may inform you right away and you\ncan take corrective action.\nWhen you are driving a car, taking a corrective action to steer your car back in the\nright direction is fairly straightforward, but what should a corrective action look like\nin a microservices system? A system that is designed with a high degree of visibility\nmight give us a lot of information about what is happening, but if the cost of chang‐\ning the system is too high we won’t be able to make any course corrections. This\nproblem of costly change presents itself when you need special permission, additional\nfunds, more people, or more time to make the changes you want to the system.\nA Microservices Design Process \n| \n37",
      "content_length": 2866,
      "extraction_method": "Direct"
    },
    {
      "page_number": 54,
      "chapter": null,
      "content": "So, in order to design a microservice system that is dynamic you’ll need to identify\nthe right KPIs, be able to interpret the data, and make small, cheap changes to the\nsystem that can guide you back on the right course. This is only possible if the right\norganization, culture, processes, and system architecture are in place to make it cheap\nand easy to do so.\nThe Microservices System Designer\nThroughout this chapter we’ve referred to the work that the microservices system\ndesigner needs to undertake. But we haven’t identified who this system designer is or\nwhere she might fit into your existing organization.\nTo be most effective, the microservices system designer should be able to enact\nchange to a wide array of system concerns. We’ve already identified that organization,\nculture, processes, solution architecture, and services are significant concerns for the\nsystem designer. But the boundaries of this system haven’t been properly identified.\nYou could decide that the system boundaries should mirror the boundaries of the\ncompany. This means that the changes you enact could have a broad-reaching\nimpact. Alternatively, you could focus on a particular team or division within the\ncompany and build a system that aligns with the parent company’s strategic goals. In\nfact, this type of nested set of systems is fairly common and we see it all around us in\nthe physical world (e.g., consider the complex systems of the human brain, the\nhuman, and the human community).\nUltimately, the microservices system designer or software system designer is respon‐\nsible for all the elements of the bounded system. The implication is that there is a\nworld within the system and world outside of these borders. The system designer’s\ntask is to introduce small changes within the system in order to produce behavior that\nwill align with the desired goal. Not very different than the traditional executive,\nmanager, or CIO’s mission.\nBut outside of these managerial positions there aren’t many roles in the technology\ndomain that allow for this systematic solution view. Instead, responsibilities are segre‐\ngated among specialists who may not share the same objectives: The solution archi‐\ntect focuses on the coordination of services, the team manager focuses on the people,\nand the service developer focuses on the service design. We believe that someone or\nsome team must be responsible for the holistic view of the entire system for a micro‐\nservices system to succeed.\nSummary\nIn this chapter we introduced the microservices system model and a generic design\nprocess for influencing the system. Throughout the rest of the book we will be diving\ninto each of the model’s domains in much greater detail. Remember that each of the\n38 \n| \nChapter 3: Designing Microservice Systems",
      "content_length": 2781,
      "extraction_method": "Direct"
    },
    {
      "page_number": 55,
      "chapter": null,
      "content": "decisions you make about organizational design, culture, solution architecture, pro‐\ncess, and automation can result in unintended consequences to the system as a whole.\nAlways maintain your holistic perspective and continue to observe and adjust as\nrequired.\nA Microservices Design Process \n| \n39",
      "content_length": 297,
      "extraction_method": "Direct"
    },
    {
      "page_number": 56,
      "chapter": null,
      "content": "",
      "content_length": 0,
      "extraction_method": "OCR"
    },
    {
      "page_number": 57,
      "chapter": null,
      "content": "CHAPTER 4\nEstablishing a Foundation\nNow that we have a general model for establishing complex systems, we also need to\ncome up with goals, principles, and guidelines for actually designing the system. A\ncommon challenge in creating a microservice architecture for your company is find‐\ning the right set of principles to govern the work. One easy answer is to just copy\nsomeone else’s successful model—to adopt the same goals, principles, and implemen‐\ntation patterns they used. This can work if the company you decide to mimic has the\nsame general goals as your company. But that is not often the case. Each company has\na unique set of priorities, culture, and customer challenges and simply taking on a\nfully formed model from some other organization is not likely to get you where you\nneed to go.\nIn this chapter, we’ll review a capabilities model for microservices environments.\nWe’ll also introduce the platform that represents the tools and services you provide\nyour developer and operations teams to allow them to meet their objectives. The\nquality and fit of these tools has an important impact on your teams’ productivity. We\nwill also review how company culture—including team size—can affect the resulting\noutput of your teams.\nFollowing that, we’ll focus on teams themselves; their size, communication modes,\nand the level of freedom they have to innovate within their own scope of work. There\nis quite a bit of research that shows that varying the size of the team has a direct\nimpact on the quality of the code that team produces. And establishing support for\ncreative thinking is another common trait for many of the companies we talked to in\npreparation for this book.\nBy the time you complete this chapter, you should have a better understanding of the\nrole goals and principles have in establishing a successful microservice environment\nand how you can use platforms and innovation culture to improve the general output\nor your teams.\n41",
      "content_length": 1956,
      "extraction_method": "Direct"
    },
    {
      "page_number": 58,
      "chapter": null,
      "content": "Goals and Principles\nRegardless of the software architecture style you employ, it is important to have some\noverall goals and principles to help inform your design choices and guide the imple‐\nmentation efforts. This is especially true in companies where a higher degree of\nautonomy is provided to developer teams. The more autonomy you allow, the more\nguidance and context you need to provide to those teams.\nIn this section, we’ll take a look at some general goals for a microservice architecture\nand some example principles. Along the way we’ll list our own suggested principles\nfor you to consider.\nGoals for the Microservices Way\nIt is a good idea to have a set of high-level goals to use as a guide when making deci‐\nsions about what to do and how to go about doing it. We’ve already introduced our\nultimate goal in building applications in the microservices way: finding the right har‐\nmony of speed and safety at scale. This overarching goal gives you a destination to aim\nfor and given enough time, iterations, and persistence, will allow you to build a sys‐\ntem that hits the right notes for your own organization.\nThere is of course a glaring problem with this strategy—it might take a very long time\nfor you to find that perfect harmony of speed and safety at scale if you are starting\nfrom scratch. But thanks to the efforts of generations of technologists we have access\nto proven methods for boosting both speed and safety. So, you don’t need to reinvent\nestablished software development practices. Instead, you can experiment with the\nparameters of those practices.\nFrom our research, we’ve been able to distill four specific goals that lead to practices\nthat aid both safety and speed of change. These goals aren’t unique to microservice\narchitecture, but they are useful in shaping your journey. Here are the four goals to\nconsider:\n1. Reduce Cost: Will this reduce overall cost of designing, implementing, and main‐\ntaining IT services?\n2. Increase Release Speed: Will this increase the speed at which my team can get\nfrom idea to deployment of services?\n3. Improve Resilience: Will this improve the resilience of our service network?\n4. Enable Visibility: Does this help me better see what is going on in my service net‐\nwork?\nLet’s look at these in a bit more depth.\n42 \n| \nChapter 4: Establishing a Foundation",
      "content_length": 2331,
      "extraction_method": "Direct"
    },
    {
      "page_number": 59,
      "chapter": null,
      "content": "Reduce cost\nThe ability to reduce the cost of designing, implementing, and deploying services\nallows you more flexibility when deciding whether to create a service at all. For exam‐\nple, if the work of creating a new service component includes three months of design\nand review, six months of coding and testing, and two more weeks to get into produc‐\ntion, that’s a very high cost—one that you would likely think very carefully about\nbefore starting. However, if creating a new service component takes only a matter of a\nfew weeks, you might be more likely to build the component and see if it can help\nsolve an important problem. Reducing costs can increase your agility because it\nmakes it more likely that you’ll experiment with new ideas.\nIn the operations world, reducing costs was achieved by virtualizing hardware. By\nmaking the cost of a “server” almost trivial, it makes it more likely that you can spin\nup a bunch of servers in order to experiment with load testing, how a component will\nbehave when interacting with others, and so on. For microservices, this means com‐\ning up with ways to reduce the cost of coding and connecting services together. Tem‐\nplated component stubs, standardized data-passing formats, and universal interfaces\nare all examples of reducing the costs of coding and connecting service components.\nIncrease release speed\nIncreasing the speed of the “from design to deploy” cycle is another common goal. A\nmore useful way to view this goal is that you want to shorten the time between idea\nand deployment. Sometimes, you don’t need to “go faster,” you just need to take a\nshortcut. When you can get from idea to running example quickly, you have the\nchance to get feedback early, to learn from mistakes, and iterate on the design more\noften before a final production release. Like the goal of reducing costs, the ability to\nincrease speed can also lower the risk for attempting new product ideas or even\nthings as simple as new, more efficient data-handling routines.\nOne place where you can increase speed is in the deployment process. By automating\nimportant elements of the deployment cycle, you can speed up the whole process of\ngetting services into production. Some of the companies we talked with for this book\nspend a great deal of time building a highly effective deployment pipeline for their\norganization. Many of them have such a well-designed deployment model that they\nrelease to production multiple times a day (sometimes over 100 times a day!). Auto‐\nmating release can go a long way toward increasing the speed of your microservice\nimplementation.\nImprove resilience\nNo matter the speed or cost of solutions, it is also important to build systems that can\n“stand up” to unexpected failures. In other words, systems that don’t crash, even when\nerrors occur. When you have an overall system approach (not just focused on a single\nGoals and Principles \n| \n43",
      "content_length": 2908,
      "extraction_method": "Direct"
    },
    {
      "page_number": 60,
      "chapter": null,
      "content": "component or solution) you can aim for creating resilient systems. This goal is often\nmuch more reasonable than trying to create a single component that is totally free of\nbugs or errors. In fact, creating a component that will have zero bugs is often impossi‐\nble and sometimes simply not worth the time and money it takes to try.\nOne of the ways DevOps practices has focused on improving resilience is through the\nuse of automated testing. By making testing part of the build process, the tests are\nconstantly run against checked-in code, which increases the chances of finding errors\nin the code. This covers the code, but not the errors that could occur at runtime.\nThere are companies that run what they call end-to-end tests before releasing to pro‐\nduction but many companies rely on a practice that Jez Humble calls blue-green\ndeployment. In this case, a new release is placed in production with a small subset of\nusers and, if all goes well during a monitoring phase, more users are routed to the\nnew release until the full userbase is on the new release. If any problems are encoun‐\ntered during this phased rollout, the users can all be returned to the previous release\nuntil problems are resolved and the process starts again.\nEnable visibility\nAnother key goal should be to enable runtime visibility. In other words, improve the\nability of stakeholders to see and understand what is going on in the system. There is\na good set of tools for enabling visibility during the coding process. We often get\nreports on the coding backlog, how many builds were created, the number of bugs in\nthe system versus bug completed, and so on. But we also need visibility into the run‐\ntime system.\nThe DevOps practices of logging and monitoring are great examples of this level of\nruntime visibility. Etsy’s John Allspaw has said, “If it moves graph it. If it matters, alert\non it”. Most effort to date has been to log and monitor operation-level metrics (mem‐\nory, storage, throughput, etc.). However, there are some monitoring tools that can\ntake action when things go badly (e.g., reroute traffic).\nTrade-offs\nEach of these are important goals and sometimes they are competing goals. There are\ntrade-offs to consider. You might be able to reduce your overall costs, but it might\nadversely affect runtime resilience. Or, you might be able to speed up deployment but\nthat might mean you lose track of what services are running in production and\nreduce visibility into the larger service network. In the end, you’ll need to balance\nvarious goals and find the right mix for your organization.\nYour organization may have some other high-level goals you want to consider and\ndocument. Whatever these turn out to be, one of the next things you need to do is\nconvert those goals into a set of actionable principles.\n44 \n| \nChapter 4: Establishing a Foundation",
      "content_length": 2851,
      "extraction_method": "Direct"
    },
    {
      "page_number": 61,
      "chapter": null,
      "content": "1 http://slideshare.net/adrianco has better links and a full annotated Netflix architecture workshop deck that\nshould be the basis for these references.\nOperating Principles\nAlong with a set of goals for a microservice approach, it is important to have a set of\nprinciples. Unlike goals, which are general, principles offer more concrete guidance\non how to act in order to achieve those goals. Principles are not rules—they don’t set\nout required elements. Instead, they offer examples on how to act in identifiable situa‐\ntions. Principles can also be used to inform best practices. Many of the organizations\nwe looked at when doing research have their own set of principles within their\ncompany.\nNetflix\nOne company that has been open about their own journey toward creating a success‐\nful microservice architecture is Netflix. In 2013, Adrian Cockcroft, Netflix’s Cloud\nArchitect, presented a day-long workshop on Netflix’s cloud architecture and operat‐\ning principles.1 We’ll highlight a few of them here.\nWe’ve called out just a few of Netflix’s principles here. You can\nlearn more about these and other key elements of the Netflix oper‐\nating model by checking out the slides and video from Adrian\nCockcroft’s 2013 talk, “Cloud Native Architecture.” From 2014 on,\nAdrian left Netflix and has continued presenting on microservices,\nDevOps, and related technology issues. You can find these presen‐\ntations and videos in a different SlideShare account.\nAntifragility\nNetflix works to strengthen their internal systems so that they can withstand\nunexpected problems. “The point of antifragility is that you always want a bit of\nstress in your system to make it stronger.” There are several things Netflix does to\npromote this, including their “Simian Army” set of tools, which “enforce archi‐\ntectural principles, induce various kinds of failures, and test our ability to survive\nthem”. Software has bugs, operators make mistakes, and hardware fails. By creat‐\ning failures in production under controlled conditions, developers are incentiv‐\nized to learn to build more robust systems. Error reporting and recovery systems\nare regularly tested, and real failures are handled with minimal drama and cus‐\ntomer impact.\nImmutability\nCockcroft says the principle of immutability is used at Netflix to assert that auto-\nscaled groups of service instances are stateless and identical, which enables Net‐\nGoals and Principles \n| \n45",
      "content_length": 2429,
      "extraction_method": "Direct"
    },
    {
      "page_number": 62,
      "chapter": null,
      "content": "flix’s system to “scale horizontally.” The Chaos Monkey, a member of the Simian\nArmy, removes instances regularly to enforce the immutable stateless service\nprinciple. Another related technique is the use of “Red/Black pushes”. Although\neach released component is immutable, a new version of the service is introduced\nalongside the old version, on new instances, then traffic is redirected from old to\nnew. After waiting to be sure all is well, the old instances are terminated.\nSeparation of Concerns\nThe Netflix microservice architecture arises because of separation of concerns\n(SoC) in the engineering team organization. Each team owns a group of services.\nThey own building, operating, and evolving those services, and present a stable\nagreed interface and service level agreement to the consumers of those services.\nInvoking Conway’s law, an organization structured with independent self-\ncontained cells of engineers will naturally build what is now called a microservice\narchitecture.\nSo these are the three key principles: antifragility, immutability, and separation of\nconcerns. Some of these same ideas were expressed in slightly different terms in 1978\nby Douglas McIlroy when describing the Unix operating system.\nUnix\nA succinct set of software architecture principles appears in the foreword for the 1978\nedition of Bell Labs’ “UNIX Timesharing System” documentation. The four points\n(listed next) were offered as a set of “maxims that have gained currency among the\nbuilders and users of the Unix system.”\nHere is the list Douglas McIrloy and his colleagues called out:\n1. Make each program do one thing well. To do a new job, build afresh rather than\ncomplicate old programs by adding new features.\n2. Expect the output of every program to become the input to another, as yet\nunknown, program. Don’t clutter output with extraneous information. Avoid\nstringently columnar or binary input formats. Don’t insist on interactive input.\n3. Design and build software, even operating systems, to be tried early, ideally\nwithin weeks. Don’t hesitate to throw away the clumsy parts and rebuild them.\n4. Use tools in preference to unskilled help to lighten a programming task, even if\nyou have to detour to build the tools and expect to throw some of them out after\nyou’ve finished using them.\nOne of the interesting things about these four principles is that they offer general\nguidance on how to think about writing software. Phrases like “do one thing well” and\n“build software … to be tried early” can lead developers to adopt what is known in\nthe Unix world as “The Rule of Parsimony” when writing code (“only write a big pro‐\n46 \n| \nChapter 4: Establishing a Foundation",
      "content_length": 2681,
      "extraction_method": "Direct"
    },
    {
      "page_number": 63,
      "chapter": null,
      "content": "gram when nothing else will do”). This along with other Unix rules provides develop‐\ners with a set of guidelines for which programming languages or libraries to use.\nThese principles are also meant to shape developers’ thinking.\nSuggested principles\nHaving a set of principles to guide software developers and architects makes a lot of\nsense. As we learned from the story at the top of this chapter, the jaggedness principle\napplies here as well. There is no one set of principles that matches every company.\nEach organization needs to create a set that works for their company.\nWith this in mind, we offer a set of eight principles that reflects aspects of the other\nexamples we’ve looked at so far. You can use these as starter material in putting\ntogether your own unique set for your company, or tune these until they fit.\nDo one thing well\nMany microservice implementations adopt the essential message—“do one thing\nwell,” which leads to the challenge of deciding what constitutes “one thing” in\nyour implementation. For some, “one thing” is managing user accounts. For oth‐\ners, “one thing” is finding a single user record. We’ll get a chance to talk about\nhow they decide where these types of boundaries are drawn for your organization\nin Chapter 5.\nBuild afresh\nThe second part of McIlroy’s first principle (“build afresh”) is also important. Part\nof the Unix philosophy is to create a collection of powerful tools that are predict‐\nable and consistent over a long period of time. It is worth considering this as an\nadditional principle when implementing microservices. It may be better to build\na new microservice component rather than attempt to take an existing compo‐\nnent already in production and change it to do additional work. This also maps to\nNetflix’s immutability principle.\nExpect output to become input\nAnother important principle for Unix developers is the notion that one program’s\noutput is another program’s input. For Unix systems, this leads to reliance on text\nstrings as the primary data-passing medium. On the Web, the data-passing\nmedium is the media type (HTML, HAL, Siren, Collection+JSON, etc.). In some\ncases, you can even use HTTP’s content-negotiation feature to allow API provid‐\ners and consumers to decide for themselves at runtime which format will be used\nto pass data.\nDon’t insist on interactive input\nIn the Unix world, there is a desire to create scripts that tie a number of\ncommand-line tools together to create a “solution.” This means humans don’t\nneed to be engaged every step of the way—the scripts handle both the input and\nGoals and Principles \n| \n47",
      "content_length": 2607,
      "extraction_method": "Direct"
    },
    {
      "page_number": 64,
      "chapter": null,
      "content": "the output on their own. Reducing the need for human interaction increases the\nlikelihood that the component can be used in unexpected ways.\nHuman interaction isn’t something that microservice components need to deal\nwith at runtime. But when we expand our scope of focus to the microservice sys‐\ntem, it’s easy to find countless human interactions that could benefit from this\nprinciple. Reducing the dependency on human interaction in the software devel‐\nopment process can go a long way toward increasing the speed at which change\noccurs.\nTry early\nAdopting the point of view that your microservice components should be “tried\nearly” fits well with the notion of continuous delivery and the desire to have\nspeed as a goal for your implementations. Another advantage of this “try early”\nprinciple is you will learn your mistakes early. It turns out “try early” is also a way\nto encourage teams to get in the habit of releasing early and often. The earlier\nyou release (even when that release is to a test environment), the earlier you get\nfeedback and the quicker you can improve.\nDon’t hesitate to throw it away\nThis is a difficult one for some developers. Being willing to throw something\naway can be hard when you’ve spent a great deal of time and effort building a\ncomponent. However, when you adopt the “try early” principle, throwing away\nthe early attempts is easier.\nIt is also important to consider this “throw it away” principle for components that\nhave been running in production for a long time. Over time, components that\ndid an important job may no longer be needed. You may have applied the “build\nafresh” principle and replaced this component with one that does the job better. It\nmay be the case that the “one thing” that component does is simply no longer\nneeded. The important thing is to be willing to throw away a component when it\nno longer serves its intended purpose.\nToolmaking\nThe “use tools” principle covers the notion that, when working to build a solu‐\ntion, you sometimes need to build the “right tool” for the job. One of the impor‐\ntant elements in the developmental history of humans was the ability to create\ntools. These tools were created in order to reach a goal. In other words, tools are\na means, not an end. This is also an important principle for microservice archi‐\ntecture.\nWhile doing research for this book, we found several examples of companies that\ncreated their own developer and deployment tool chains in order to improve\ntheir overall developer experience. Sometimes these tools are built from existing\nopen source software projects. Sometimes the tools are, themselves, passed into\n48 \n| \nChapter 4: Establishing a Foundation",
      "content_length": 2680,
      "extraction_method": "Direct"
    },
    {
      "page_number": 65,
      "chapter": null,
      "content": "open source so that others can use them and contribute to improving and main‐\ntaining them. The important element here is to recognize that, in some cases, you\nmay need to divert from building your solution and spend some time building\ntools to help you build that solution.\nPlatforms\nAlong with a set of general goals and concrete principles, you’ll need tangible tools to\nmake them real—a platform with which to make your microservice environment a\nreality. From a microservice architecture perspective, good platforms increase the\nharmonic balance between speed and safety of change at scale. We typically think\nabout speed and safety as opposing properties that require a trade-off to be made but\nthe right tooling and automation give you an opportunity to cheat the trade-off.\nFor example, the principle of immutability primarily improves the safety of changes\nthat are made to the system. There is also an inherent release cost for immutability as\neach deployable unit needs its own associated release mechanisms, infrastructure,\nand management. On its own, the added cost can reduce the speed at which changes\ncan be made. However, the introduction of containerization tools like Docker make\nindependent deployability easy and greatly reduce the associated costs. When immut‐\nability is combined with containerization, both speed and safety of changes are opti‐\nmized, which may explain the rapid adoption of Docker in large organizations.\nWith a platform we pass from the conceptual world to the actual world. The good\nnews is that there are many examples of companies establishing—and even sharing—\ntheir microservice platforms. The challenge is that it seems every company is doing\nthis their own way, which presents some choices to anyone who wants to build their\nown microservice environment. Do you just select one of the existing OSS platforms?\nDo you try to purchase one? Build one from scratch?\nIt would be a mistake to just select one of the popular company’s platforms and adopt\nit without careful consideration. Does this company provide the same types of serv‐\nices that mine does? Does this company optimize for the same things that mine will?\nDo we have similar staffing and training environments? Are our target customers\nsimilar (priorities, skills, desired outcomes, etc.)?\nInstead of focusing on a single existing company’s platform, we’ll look at a general\nmodel for microservice platforms. One of the ones we like was described by Adrian\nCockcroft in 2014. He outlined a set of capabilities that he said all microservice\nimplementations need to deal with, which he called “microservice concerns.” We will\ndivide them into two groups: shared capabilities and local capabilities.\nPlatforms \n| \n49",
      "content_length": 2722,
      "extraction_method": "Direct"
    },
    {
      "page_number": 66,
      "chapter": null,
      "content": "Shared Capabilities\nIt’s common in large enterprises to create a shared set of services for everyone to use.\nThese are typically centered around the common infrastructure for the organization.\nFor example, anything that deals with hardware (actual or virtual) falls into this cate‐\ngory. Common database technologies (MySQL, Cassandra, etc.) and other software-\nimplemented infrastructure is another example of shared services.\nShared capabilities are platform services that all teams use. These are standardized\nthings like container technology, policy enforcement, service orchestration/interop,\nand data storage services. Even in large organizations it makes sense to narrow the\nchoices for these elements in order to limit complexity and gain cost efficiencies.\nEssentially, these are all services that are provided to every team in the organization.\nIt is important to note that shared services does not mean shared\ninstance or shared data. Just because all the teams use a single type\nof data storage technology (e.g., Datomic, Mongo, Cassandra, and\nMySQL) does not mean they all use the same running instance of\nthe data storage and all read and write from the same tables.\nWhile shared capabilities offer potential cost savings they are ultimately rooted in the\nmicroservices goal of change safety. Organizations that highly value safety of changes\nare more likely to deploy centralized shared capabilities that can offer consistent, pre‐\ndictable results. On the other hand, organizations that desire speed at all costs are\nlikely to avoid shared components as much as possible as it has the potential to\ninhibit the speed at which decentralized change can be introduced. In these speed-\ncentric companies, capability reuse is less important than speed of delivery. As with\nall things in the microservices way you will need to experiment with different forms\nof shared capabilities to see what works best for your unique context.\nThe following is a quick rundown of what shared services platforms usually provide:\nHardware services\nAll organizations deal with the work of deploying OS- and protocol-level soft‐\nware infrastructure. In some companies there is a team of people who are\ncharged with accepting shipments of hardware (e.g., 1-U servers), populating\nthose machines with a baseline OS and common software for monitoring, health\nchecks, etc., and then placing that completed unit into a rack in the “server room”\nready for use by application teams.\nAnother approach is to virtualize the OS and baseline software package as a vir‐\ntual machine (VM). VMs like Amazon’s EC2 and VMWare’s hypervisors are\nexamples of this technology. VMs make it possible to automate most of the work\nof populating a “new machine” and placing it into production.\n50 \n| \nChapter 4: Establishing a Foundation",
      "content_length": 2802,
      "extraction_method": "Direct"
    },
    {
      "page_number": 67,
      "chapter": null,
      "content": "A more recent trend is the use of containers to solve this problem. Docker is the\nmost popular player in this field. We’ll talk more about Docker in Chapter 6. But\nthere are others. CoreOS Rocket is one. By the time you read this there may be\nmany more container products in the space.\nCode management, testing, and deployment\nOnce you have running servers as targets, you can deploy application code to\nthem. That’s where code management (e.g., source control and review), testing,\nand (eventually) deployment come in. There are quite a few options for all these\nservices and some of them are tied to the developer environment, especially test‐\ning.\nMost microservice shops go to considerable lengths to automate this part of the\nprocess. For example, the Amazon platform offers automation of testing and\ndeployment that starts as soon a developer checks in her code. Since the process\nof automation can be involved and posting to production can be risky, it is a\ngood idea to treat this as a shared service that all teams learn to use.\nData stores\nThere are many data storage platforms available today, from classic SQL-based\nsystems to JSON document stores on through graph-style databases such as Riak\nand Neo4J. It is usually not effective for large organizations to support all possible\nstorage technologies. Even today, some organizations struggle with providing\nproper support for the many storage implementations they have onsite. It makes\nsense for your organization to focus on a select few storage platforms and make\nthose available to all your developer teams.\nService orchestration\nThe technology behind service orchestration or service interoperability is\nanother one that is commonly shared across all teams. There is a wide range of\noptions here. Many of the flagship microservice companies (e.g., Netflix and\nAmazon) wrote their own orchestration platforms. We’ll cover more on this in\nChapter 5.\nSecurity and identity\nPlatform-level security is another shared service. This often happens at the\nperimeter via gateways and proxies. Again, some companies have written their\nown frameworks for this; Netflix’s Security Monkey is an example. There are also\na number of security products available. Shared identity services are sometimes\nactually external to the company. We’ll talk more about this in Chapter 6.\nArchitectural policy\nFinally, along with shared security, sometimes additional policy services are\nshared. These are services that are used to enforce company-specific patterns or\nmodels—often at runtime through a kind of inspection or even invasive testing. \nPlatforms \n| \n51",
      "content_length": 2603,
      "extraction_method": "Direct"
    },
    {
      "page_number": 68,
      "chapter": null,
      "content": "One example of policy enforcement at runtime is Netflix’s “Simian Army”—a set\nof services designed to purposely cause problems on the network (simulate miss‐\ning packets, unresponsive services, and so on) to test the resiliency of the system.\nAnother kind of policy tooling is one that standardizes the way outages or other\nmishaps are handled after the fact. These kinds of after-action reviews are some‐\ntimes called postmortems. For example, Etsy created (and open sourced) a tool\nfor standardizing postmortems called Morgue. Whether in the form of runtime\nmonitors or postmortem analysis, policy services ensure that varying teams\nadhere to the same guidance on how to handle both resiliency and security in\ntheir implementations.\nLocal Capabilities\nLocal capabilities are the ones that are selected and maintained at the team or group\nlevel. One of the primary goals of the local capabilities set is to help teams become\nmore self-sufficient. This allows them to work at their own pace and reduces the\nnumber of blocking factors a team will encounter while they work to accomplish their\ngoals. Also, it is common to allow teams to make their own determination on which\ndeveloper tools, frameworks, support libraries, config utilities, etc., are best for their\nassigned job. Sometimes these tools are selected from a curated set of “approved”\nproducts. Sometimes these tools are created in-house (even by the same team). Often\nthey are open source, community projects.\nFinally, it is important that the team making the decision is also the one taking\nresponsibility for the results. Amazon’s Werner Vogels’ describes it this way:\nYou build it, you run it.\n—Werner Vogels, Amazon CTO\nIn small organizations, it is likely that the local capability elements\nwill be the same for the entire company (e.g., the small startup is\njust a single team anyway). However, as the company grows,\nacquires new products, and expands into new technology and mar‐\nket spaces, forcing everyone to continue to use the same developer\ntools, routing implementations, etc., does not scale well. At that\npoint, it makes sense to allow product groups to start making those\ndecisions for themselves.\nMost local capabilities services are ones that access and/or manipulate the shared ser‐\nvice. For example, Netflix created a tool to make it easy for teams to spin up Amazon\nmachine images (or AMIs) called Aminator, and another tool to make deploying\ncode to those cloud images (called Asgard). Both of these tools make dealing with\nAMIs and deployments a “self-service” experience. Dev teams don’t need to rely on\n52 \n| \nChapter 4: Establishing a Foundation",
      "content_length": 2636,
      "extraction_method": "Direct"
    },
    {
      "page_number": 69,
      "chapter": null,
      "content": "someone else to spin up machines or install software on them—the team does that\nthemselves.\nHere’s a rundown of the common local capabilities for microservice environments:\nGeneral tooling\nA key local capability is the power to automate the process of rolling out, moni‐\ntoring, and managing VMs and deployment packages. Netflix created Asgard and\nAminator for this. A popular open source tool for this is Jenkins.\nRuntime configuration\nA pattern found in many organizations using microservices is the ability roll out\nnew features in a series of controlled stages. This allows teams to assess a new\nrelease’s impact on the rest of the system (are we running slower?, is there an\nunexpected bug in the release?, etc.). Twitter’s Decider configuration tool is used\nby a number of companies for this including Pinterest, Gilt, and Twitter. This\ntool lets teams use configuration files to route traffic from the “current” set of\nservices to the “newly deployed” set of services in a controlled way. In 2014, Twit‐\nter’s Raffi Kirkorian explained Decider and other infrastructure topics in an\nInfoQ interview. Facebook created their own tool called Gatekeeper that does the\nsame thing. Again, placing this power in the hands of the team that wrote and\nreleased the code is an important local capability.\nService discovery\nThere are a handful of popular service discovery tools including Apache Zoo‐\nkeeper, CoreOS’ etcd, and HashiCorp’s Consul. We’ll cover the role of discovery\ntools in Chapter 6. These tools make it possible to build and release services that,\nupon install, register themselves with a central source, and then allow other serv‐\nices to “discover” the exact address/location of each other at runtime. This ability\nto abstract the exact location of services allows various teams to make changes to\nthe location of their own service deployments without fear of breaking some\nother team’s existing running code.\nRequest routing\nOnce you have machines and deployments up and running and discovering serv‐\nices, the actual process of handling requests begins. All systems use some kind of\nrequest-routing technology to convert external calls (usually over HTTP, Web‐\nSockets, etc.) into internal code execution (e.g., a function somewhere in the\ncodebase). The simplest form of request routing is just exposing HTTP end‐\npoints from a web server like Apache, Microsoft IIS, NodeJS, and others. How‐\never, as service requests scale up, it is common to “front” the web servers with\nspecialized routing proxies or gateways. Netflix created Zuul to handle their rout‐\ning. There are popular open source services like Netty (created by JBoss) and\nTwitter’s Finagle. We’ll talk more about gateways in Chapter 6.\nPlatforms \n| \n53",
      "content_length": 2732,
      "extraction_method": "Direct"
    },
    {
      "page_number": 70,
      "chapter": null,
      "content": "System observability\nA big challenge in rapidly changing, distributed environments is getting a view of\nthe running instances—seeing their failure/success rates, spotting bottlenecks in\nthe system, etc. There are quite a few tools for this. Twitter created (and open\nsourced) Zipkin for this task, and there are other similar frameworks that pro‐\nvide visibility into the state of the running system.\nThere is another class of observability tooling—those that do more than report\non system state. These tools actually take action when things seem to be going\nbadly by rerouting traffic, alerting key team members, etc. Netflix’s Hystrix is one\nof those tools. It implements a pattern known as the Circuit Breaker to improve\nthe resiliency of running systems.\nCulture\nAlong with establishing goals and principles and arming your organization with the\nright tools for managing platform, code, and runtime environments, there is another\ncritical foundation element to consider—your company culture. Culture is important\nbecause it not only sets the tone for the way people behave inside an organization, but\nit also affects the output of the group. The code your team produces is the result of\nthe culture.\nBut what is culture? Quite a bit has been written about culture in general—from\nmany perspectives including anthropological as well as organizational. We’ll focus on\nthe organizational point of view here. In her 1983 paper, “Concepts of Culture and\nOrganizational Analysis”, Linda Smircich describes culture as “shared key values and\nbeliefs” that convey a sense of identity, generate commitment to something larger\nthan the self, and enhances social stability.Damon Edwards of DTO Solutions and\none of the organizers of the DevOpsDays series of events defines culture as “why we\ndo it the way we do it”.\nSo, how does culture affect team output? And, if it does, what kinds of team culture\nimprove team performance and work quality? We’ll look at three aspects of culture\nthat you should consider as a foundation for your microservice efforts:\nCommunication\nResearch shows that the way your teams communicate (both to each other and to\nother teams) has a direct measurable effect on the quality of your software.\nTeam alignment\nThe size of your teams also has an effect on output. More people on the team\nmeans essentially more overhead.\n54 \n| \nChapter 4: Establishing a Foundation",
      "content_length": 2385,
      "extraction_method": "Direct"
    },
    {
      "page_number": 71,
      "chapter": null,
      "content": "Fostering innovation\nInnovation can be disruptive to an organization but it is essential to growth and\nlong-term success.\nFocus on Communication\nOne of the best-known papers on how culture affects team output is Mel Conway’s\n1968 article in Datamation magazine, “How Do Committees Invent?” The line most\noften quoted from this short and very readable paper is:\nOrganizations which design systems … are constrained to produce designs that are\ncopies of the communication structures of these organizations.\n—Mel Conway, author of “How Do Committees Invent?”\nPut simply, communication dictates output.\nThis quote was identified in 1975 by Fred Brooks as “Conway’s law” and it provides\nsome important insights on the importance of organizational structure affecting the\nquality of the final product of the company. Conway’s paper identifies a number of\nreasons for this assertion as well as directives on how to leverage this understanding\nto improve the group’s output. A 2009 study for Microsoft Research showed that\n“organizational metrics are significantly better predictors of error-proneness” in code\nthan other more typical measures including code complexity and dependencies.\nAnother key point in Conway’s article is that “the very act of organizing a team means\ncertain design decisions have already been made.” The process of deciding things like\nthe size, membership, even the physical location of teams is going to affect the team\nchoices and, ultimately, the team output. This gives a hint to the notion of applying\nConway’s law when setting up your team structure for a software project (sometimes\nreferred to as a “reverse Conway”). By considering the communication needs and\ncoordination requirements for a software project, you can set up your teams to make\nthings easier, faster, and to improve overall communication.\nAligning Your Teams\nTeam alignment is important—it affects the quality of code. What can we do to take\nadvantage of this information? Using the information from the start of this chapter,\nwhat “tunable” elements can we use to improve the alignment of our team structures\nto meet our goals for increasing speed, resilience, and visibility for our microservice\nefforts?\nIn his 1998 paper, “The Social Brain”, British anthropologist Robin Dunbar found\nthat social group sizes fall into predictable ranges. “[T]he various human groups that\ncan be identified in any society seem to cluster rather tightly around a series of values\n(5, 12, 35, 150, 500, and 2,000).” These groups each operate differently. The first (5)\nrelies very much on a high-trust, low-conversation mode: they seem to understand\nCulture \n| \n55",
      "content_length": 2641,
      "extraction_method": "Direct"
    },
    {
      "page_number": 72,
      "chapter": null,
      "content": "each other without lots of discussion. Dunbar found that, as groups get larger, more\ntime is spent on maintaining group cohesion. In his book Grooming, Gossip and the\nEvolution of Language, Dunbar suggests that in large primate groups up to 40% of\ntime is spent in grooming just to maintain group stability. He points out that this\ngrooming behavior in primates is replaced by gossip and other trivial conversations\nin humans.\nDunbar’s “grooming” in primates is analogous to meetings, emails, and other forms\nof communication in organizations that are often seen as time wasters. The possibility\nof increasing the number of internal meetings with large groups at Amazon in the\nearly days of their AWS services implementation prompted Jeff Bezos to quip:\nNo, communication is terrible!\n—Jeff Bezos, Amazon founder and CEO\nThis led to Bezos’ now famous “two-pizza team” rule. Any team that cannot be fed by\ntwo pizzas is a team that is too big.\nFred Brooks’ 1975 book The Mythical Man Month contains the classic observation\nthat “adding [more people] to a late software project makes it later.” This maxim\nspeaks directly to the notion that adding people increases communication overhead,\nsimilar to the findings of Dunbar.\nAs the size of the group grows, the number of unique communication channels grows\nin a nonlinear way. This instance of combinatorial explosion is a common problem\nand needs to be kept in mind as you design your teams.\nWhen we talk to companies working in the microservices way, they commonly cite\nteam sizes that match closely to Dunbar’s first two groups (5 and 12). We refer to\nthese as Dunbar levels 1 and 2, respectively. For example, Spotify, the Swedish music\nstreaming company, relies on a team size of around seven (what they call a [squad).\nThey also rely on an aggregate of several teams that they call a tribe and reference\nDunbar’s work directly when describing how they came to this arrangement.\nThere are a number of other factors in establishing your teams including responsibili‐\nties, deliverables, and skillsets that need to be present within a team. We’ll cover\ndetails on how to go about selecting and tuning these elements later in the book.\nFostering Innovation\nA third important element in managing company culture is fostering innovation\nwithin your organization. Many companies say they want to make innovative think‐\ning common within the organization. And the ability to take advantage of creative\nand innovative ideas is sometimes cited as a reason to adopt a microservice approach\nto developing software. So it makes sense to spend a bit of time exploring what inno‐\nvation looks like and how it can affect your organization.\n56 \n| \nChapter 4: Establishing a Foundation",
      "content_length": 2720,
      "extraction_method": "Direct"
    },
    {
      "page_number": 73,
      "chapter": null,
      "content": "A simple definition of innovate from Merriam-Webster’s dictionary is “to do some‐\nthing in a new way; to have new ideas about how something can be done.” It’s worth\nnoting that being innovative is most often focused on changing something that is\nalready established. This is different than creating something new. Innovation is usu‐\nally thought of as an opportunity to improve what a team or company already has or\nis currently doing.\nA common challenge is that the innovation process can be very disruptive to an orga‐\nnization. Sometimes “changing the way we do things” can be seen as a needless or\neven threatening exercise—especially if the change will disrupt some part of the orga‐\nnization (e.g., result in eliminating tasks, reducing workload, or even replacing whole\nteams). For this reason, the act of innovating can be difficult. Another problem with\ninnovation is that the actual process often looks chaotic from the outside. Innovating\ncan mean coming up with ideas that might not work, that take time to get operating\nproperly, or even start out as more costly and time consuming than the current prac‐\ntice. Yet, many organizations really want to encourage innovative work within their\nteams.\nCompanies we talked to enable innovation by adopting a few key principles. First,\nthey provide a level of autonomy to their teams. They allow teams to determine the\nbest way to handle details within the team. Netflix calls this the principle of “context,\nnot control.” Team leaders are taught to provide context for the team’s work and guid‐\nance on meeting goals, but to not control what the team does. Netflix’s Steve Urban\nexplains it like this:\nI have neither the place, the time, nor the desire, to micromanage or make technical\ndecisions for [my team].\n—Steve Urban, Netflix engineer\nSecond, companies that foster innovation build in a tolerance for some level of chaos.\nThey operate with the understanding that it’s OK if some things look a bit disorgan‐\nized or messy. Of course, there are limits to this. Harvard Business Review’s “Manag‐\ning Innovation: Controlled Chaos” points out that “Effective managers of innovation\n… administer primarily by setting goals, selecting key people, and establishing a few\ncritical limits and decision points for intervention.” Fostering innvotation means set‐\nting boundaries that prevent teams from taking actions that threaten the health and\nwelfare of the company and allowing teams to act on their own within these safe\nboundaries.\nManaging communication channels, aligning teams, and establishing a safe place to\ninnovate are all essential to enabling a successful culture that can take advantage of a\nmicroservice-style approach to designing, implementing, and maintaining software.\nCulture \n| \n57",
      "content_length": 2758,
      "extraction_method": "Direct"
    },
    {
      "page_number": 74,
      "chapter": null,
      "content": "Summary\nIn this chapter we’ve reviewed the common set of platform capabilities called Cock‐\ncroft’s “microservices concerns” and cited examples of how a number of organiza‐\ntions provide these platform capabilities to their teams. We also focused on the teams\nthemselves. The way your teams communicate, their size, and the level of innovation\nyou support within those teams have a significant effect on the quality of their output.\nSo, with these ideals in mind, what does it take to actually implement microservice\nsolutions? In the next two chapters we’ll show you working examples of the platform\ncapabilities we discussed here as well as offer guidance on component design and\nimplementation that follows the recommended principles from this chapter.\n58 \n| \nChapter 4: Establishing a Foundation",
      "content_length": 799,
      "extraction_method": "Direct"
    },
    {
      "page_number": 75,
      "chapter": null,
      "content": "PART III\nMicroservices in Practice\nThe Microservices Way at Hootsuite\nVancouver-based Hootsuite is a pioneer in social media for business. The company\nwas formed by members of Invoke Media who built a platform to manage their own\nsocial network interactions and then realized that other companies had the same\nneed. As the company grew, so did their monolithic, PHP-based platform. In order to\nmeet the demands of their market through a 100+ team of developers, they are evolv‐\ning their application to a collection of product-oriented microservices.\nHootsuite took a design-based approach to their microservice migration from the\noutset. They recognized that defining the right logic boundaries can be a harder prob‐\nlem than introducing new technology. They use what they call “distributed domain-\ndriven design” as a means of breaking services out of their monolith. API definitions\nand associated contracts provide a means of describing service scope and function,\nand API consumers are involved in the creation of both. The Hootsuite team found\nthat API design guidelines helped to create a common language for this process. Over\ntime, Hootsuite has classified their microservices into three categories: data services\nthat encapsulate key business entities and ensure scalability, functional services that\ncombine data services with business logic to execute core business logic, and facade\nservices that decouple consumer contracts from core functional logic. Hootsuite’s\ndesign approach continues to evolve as their microservice implementation matures.\nHootsuite’s organization includes product-aligned teams made up of five to seven\npeople. They also have a cross-functional platform team that is responsible for frame‐\nworks and tooling, and has visibility across the organization. To address common",
      "content_length": 1808,
      "extraction_method": "Direct"
    },
    {
      "page_number": 76,
      "chapter": null,
      "content": "interest areas like APIs and JavaScript, they have a collection of “guilds” that anyone\ncan join. In the spirit of empowerment and delivery speed, Hootsuite does not have\nany governance checkpoints that intrude on a team’s development process. Instead,\nthey have a set of community-defined principles and tools that guide microservice\ndevelopment. Recently, they formed a technology architecture group made up of\nsenior technical leaders to address technological issues that have a broad effect on the\norganization, but this group was formed organically—not as the result of an executive\nedict. Beier Cai, Director of Software Development, likens Hootsuite’s governance\napproach to “eventual consistency.” This empowered, iterative style is a match for the\nmicroservices way.\nFittingly given the company’s origin, Hootsuite has created a goal-oriented toolset for\nmicroservices. To address deployment, they use Docker and Mesos. For service dis‐\ncovery, they use Consul and NGINX. These four open source components are used\ntogether in a solution called “Skyline” that enables secure, dynamic, performant rout‐\ning in their growing fabric of microservices. They have also found Scala, Akka, and\nthe Play framework useful in building their individual services, and leverage both\nHTTP and Kafka for interservice communication. The tooling extends to the design\nprocess as well. To make sure developers know what services and components are\navailable for use in service development, the Hootsuite team created a tool to dynam‐\nically generate system visualizations that link to code repositories and operational\ndocumentation. As needs arise, more tools are discovered or created.\nHootsuite’s evolution to a microservice architecture continues. They have over a\ndozen microservices in production with many more on the way. As a result of\nembracing an approach to microservices adoption that cuts across their architecture,\norganization, culture, processes, and tools, they have been able to improve their deliv‐\nery speed, flexibility, autonomy, and developer morale.",
      "content_length": 2064,
      "extraction_method": "Direct"
    },
    {
      "page_number": 77,
      "chapter": null,
      "content": "CHAPTER 5\nService Design\nAs discussed in Chapter 3, one of the key elements—the one most everyone thinks of\nwhen we talk about microservice architecture—is the design of the actual microser‐\nvice components themselves. It is these autonomous services that make up the fabric\nof our microservice system and do the actual work of implementing your solution\nstrategy. Implementing systems that contain a large number of small service compo‐\nnents is a challenge so we’ll devote an entire chapter to a set of tools and processes\nthat can help you and your team take on the task.\nIn our experience working with various organizations and interviewing others, some\nof the more challenging questions that teams adopting microservice architecture face\nare how to properly size microservices (“how micro is micro?”) and how to properly\ndeal with data persistence in order to avoid sharing of data across services. These two\nconcerns are actually closely related. A mistake in optimal sizing often begets the\nextraneous data-sharing problem, but the latter is especially problematic, operation‐\nally, since it can create tight cross-service coupling and impede independent deploya‐\nbility, a core value of the architectural style. Other topics that come up frequently\nwhen we talk with people who are designing and implementing microservices are\nthings like support for asynchronous messaging, transaction modeling, and dealing\nwith dependencies in a microservice environment. Getting a handle on these ele‐\nments will help you curb the amount of additional (nonessential) complexity that\ncreeps into your overall system. And doing that can help you in your constant strug‐\ngle to balance the two key factors in any IT system: speed and safety.\nIn this chapter, we will cover microservice boundaries, looking at just how “micro” a\nservice should be and why. We will explore microservice interfaces (APIs), discussing\nthe importance of evolvable, message-oriented APIs for microservices and how they\ncan reduce intercomponent coupling. We will investigate effective data storage\napproaches for microservices, exploring the power of shifting from data-centric and\n61",
      "content_length": 2153,
      "extraction_method": "Direct"
    },
    {
      "page_number": 78,
      "chapter": null,
      "content": "1 http://api.co/1WtSZGE\nstate-capturing models toward capability-driven and event-sourcing-oriented ones.\nWe’ll also show how the command query responsibility segregation (CQRS) pattern\ncan improve the granularity of data services, while maintaining sufficient speed and\nsafety.\nThis chapter will also cover key topics such as supporting transactions across micro‐\nservice boundaries, asynchronous messaging, and dealing with dependencies with\neyes on the prize of independent deployability.\nBy the time we get through this material you should have a good understanding of\nthe challenges as well as the available patterns and practices you can use when it\ncomes to designing and building microservice components.\nLet’s get started with the big one: “What is the optimal size of a microservice?”\nMicroservice Boundaries\nSo just how micro should a microservice be?\nIn reality, there is no simple answer for this question. The things that first come to\nmind, such as lines of code in a microservice or the size of a team working on one are\ncompelling, since they offer the chance to focus on a quantifiable value (e.g., “The\nanswer is 42!”).1 However, the problem with these measures is that they ignore the\nbusiness context of what we are implementing. They don’t address the organizational\ncontext of who is implementing the service and, more importantly, how the service is\nbeing used within your system.\nInstead of trying to find some quantity to measure, we find most companies focus on\na quality of each microservice—the use case or context in which the component will\nbe used. Many microservice adopters have turned to Eric Evans’ “domain-driven\ndesign” (DDD) approach for a well-established set of processes and practices that\nfacilitate effective, business-context–friendly modularization of large complex sys‐\ntems.\nMicroservice Boundaries and Domain-Driven Design\nEssentially, what we see people doing when they introduce the microservices way into\ntheir companies is that they begin to decompose existing components into smaller\nparts in order to increase their ability to improve the quality of the service faster\nwithout sacrificing reliability.\nThere are many ways to decompose a large system into smaller subsystems. In one\ncase we may be tempted to decompose a system based on implementation technology.\n62 \n| \nChapter 5: Service Design",
      "content_length": 2350,
      "extraction_method": "Direct"
    },
    {
      "page_number": 79,
      "chapter": null,
      "content": "For instance, we can say that all computationally heavy services need to be written in\nC or Rust or Go (choose your own poison) and therefore they are a separate subsys‐\ntem, while I/O-heavy features could certainly benefit from the nonblocking I/O of a\ntechnology such as Node.js and therefore they are a subsystem of their own. Alterna‐\ntively, we can divide a large system based on team geography: one subsystem may be\nwritten in the US, while others may be developed and maintained by software teams\nin Africa, Asia, Australia, Europe, or South America. Intuitively, giving a self-\ncontained subsystem for development to a team that is located in one place is well-\noptimized. Another reason you may decide to divide a system based on geography is\nthat specific legal, commercial, and cultural requirements of operating in a particular\nmarket may be better understood by a local team. Can a software development team\nfrom New York accurately capture all the necessary details of an accounting software\nthat will be used in Cairo?\nIn his seminal book Domain-Driven Design, Eric Evans outlines a fresh approach to\ndetermining boundaries of subsystems in the context of a larger system. In the pro‐\ncess, he offers a model-centric view of software system design. As we’ve pointed out\nin this book, models are a great way to view a system. They provide an abstract way to\nlook at something—a way that highlights the things we are interested in. Models are a\npoint of view.\nIt’s Only a Model\nTo understand the DDD approach, it is important to remember\nthat any software system is a model of a reality—it is not the reality\nitself. For instance, when we log in to online banking and are look‐\ning at our checking account, we are not looking at the actual check‐\ning account. We’re just looking at a representation—a model—that\ngives us information about the checking account such as balance\nand past transactions. It’s likely that the screen our bank teller sees\nwhen looking at our account has different information because it’s\nanother model of our account.\nIn his book, Evans notes that most large systems don’t actually have a single model.\nThe overall model of a large system is actually comprised of many smaller models\nthat are intermingled with each other. These smaller models are organic representa‐\ntions of relevant business contexts—they make sense in their context and when used\nwithin the context they are intuitive for a person who is the subject matter expert of\nthe context.\nMicroservice Boundaries \n| \n63",
      "content_length": 2521,
      "extraction_method": "Direct"
    },
    {
      "page_number": 80,
      "chapter": null,
      "content": "Bounded Context\nIn DDD, Evans points out that teams need to be very careful when combining con‐\ntextual models to form a larger software system. He puts it this way:\nMultiple models are in play on any large project. Yet when code based on distinct mod‐\nels is combined, software becomes buggy, unreliable, and difficult to understand. Com‐\nmunication among team members becomes confused. It is often unclear in what\ncontext a model should not be applied.\n—Eric Evans, author of Domain-Driven Design: Tackling Complexity in the Heart of\nSoftware\nIt is worth noting that Evans’ DDD was introduced more than a decade before the\nword “microservice” had come into vogue. Yet, the preceding quotation is an impor‐\ntant observation about the nature of modeling—if you try to rely on a single model\n(e.g., a canonical model) things become difficult to understand. The microservices\nway attempts to break large components (models) into smaller ones in order to\nreduce the confusion and bring more clarity to each element of the system. As such,\nmicroservice architecture is an architectural style that is highly compatible with the\nDDD way of modeling. To aid in this process of creating smaller, more coherent com‐\nponents, Evans introduced the bounded contexts concept. Each component in the\nsystem lives within its own bounded context, which means the model for each com‐\nponent and these context models are only used within their bounded scope and are\nnot shared across the bounded contexts.\nIt is generally acknowledged that properly identifying bounded contexts in a system,\nusing DDD techniques, and breaking up a large system along the seams of those\nbounded contexts is an effective way of designing microservice boundaries. In his\nbook Building Microservices, Sam Newman states:\nIf our service boundaries align to the bounded contexts in our domain, and our micro‐\nservices represent those bounded contexts, we are off to an excellent start in ensuring\nthat our microservices are loosely coupled and strongly cohesive.\nNewman makes an important point here: bounded contexts represent autonomous\nbusiness domains (i.e., distinct business capabilities), and therefore are the appropri‐\nate starting point for identifying the dividing lines for microservices. If we use the\nDDD and bounded contexts approaches, the chances of two microservices needing to\nshare a model and the corresponding data space, or ending up having tight coupling,\nare much lower. Avoiding data sharing improves our ability to treat each microservice\nas an independently deployable unit. And independent deployability is how we can\nincrease our speed while still maintaining safety within the overall system.\nUsing DDD and bounded contexts is an excellent process for designing components.\nHowever, there is more to the story. We could actually use DDD and still end up cre‐\nating fairly large components. But large is not what we’re going for in a microservice\n64 \n| \nChapter 5: Service Design",
      "content_length": 2966,
      "extraction_method": "Direct"
    },
    {
      "page_number": 81,
      "chapter": null,
      "content": "architecture. Instead, we’re aiming at small—micro, even. And that leads to an impor‐\ntant aspect of designing microservice components—smaller is better.\nSmaller Is Better\nThe notion of work-unit granularity is a crucial one in many contexts of modern soft‐\nware development. Whether defined explicitly or implicitly, we can clearly see the\ntrend showing up in such foundational methodologies as Agile Development, Lean\nStartup, and Continuous Delivery, among others. These methodologies have revolu‐\ntionized project management, product development, and DevOps, respectively.\nIt is interesting to note that each one of them has the principle of size reduction at its\ncore: reducing the size or scope of the problem, reducing the time it takes to complete\na task, reducing the time it takes to get feedback, and reducing the size of the deploy‐\nment unit. These all fall into a notion we call “batch-size reduction.”\nFor example, here’s an excerpt from the Agile Manifesto:\nDeliver working software frequently, from a couple of weeks to a couple of months,\nwith a preference to the shorter timescale.\n—The Agile Manifesto, Kent Beck et al.\nBasically, moving to Agile from Waterfall can be viewed as a reduction of the “batch\nsize” of a development cycle—if the cycle was taking many months in Waterfall, now\nwe strive to complete a similar batch of tasks: define, architect, design, develop, and\ndeploy, in much shorter cycles (weeks versus months). Granted, the Agile Manifesto\nlists other important principles as well, but they only reinforce and complement the\ncore principle of “shorter cycles” (i.e., reduced batch size).\nIn the case of Lean Startup, Eric Ries directly points to the crucial importance of\nsmall batch size, right in the definition of the methodology:\nThe Lean Startup takes its name from the lean manufacturing revolution that Taiichi\nOhno and Shigeo Shingo are credited with developing at Toyota. Lean thinking is radi‐\ncally altering the way supply chains and production systems are run. Among its tenets\nare drawing on the knowledge and creativity of individual workers, the shrinking of\nbatch sizes, just-in-time production and inventory control, and an acceleration of cycle\ntimes. It taught the world the difference between value-creating activities and waste\nand showed how to build quality into products from the inside out.\n—Eric Ries, author of The Lean Startup\nSimilarly, when discussing the principal benefits of Continuous Delivery, Martin\nFowler is unambiguous about the role of small batch sizes, calling it the precondition\nfor a core benefit of the methodology.\nOnce you adopt the notion of limited batch size from Agile, Lean, and Continuous\nDelivery at the code, project, and deployment level, it makes sense to think about\nMicroservice Boundaries \n| \n65",
      "content_length": 2795,
      "extraction_method": "Direct"
    },
    {
      "page_number": 82,
      "chapter": null,
      "content": "applying it at the architecture level as well. And many of the companies we inter‐\nviewed have done this. After all, architecture is the direct counterpart to the other\nthree disciplines. So, in the simplest terms, this “limited batch size” is the “micro” in\nmicroservice.\nJust as in Agile, etc., there’s no simple, universal measure for deter‐\nmining just “how small” a microservice should be (e.g., a quantity).\nWhat people tell us is that they use the word “small” as a quality\nlike “reliable” and “coherent,” etc.\nUbiquitous Language\nJust by stating a simple preference of “smaller is better,” we immediately run into a\nproblem if bounded contexts are our only tool for sizing microservices, because\nbounded contexts cannot actually be arbitrarily small. Here’s what one of the promi‐\nnent authorities in the space of DDD, Vaughn Vernon, had to say about the optimal\nsize of a bounded context:\nBounded context should be as big as it needs to be in order to fully express its complete\nubiquitous language.\n—Vaughn Vernon, author of Implementing Domain–Driven Design\nIn DDD, we need a shared understanding and way of expressing the domain\nspecifics. This shared understanding should provide business and tech teams with a\ncommon language that they can use to collaborate on the definition and implementa‐\ntion of a model. Just as DDD tells us to use one model within a component (the\nbounded context), the language used within that bounded context should be coherent\nand pervasive—what we in DDD call ubiquitous language.\nFrom a purely technical perspective, the smaller the microservice the easier it can be\ndeveloped quicker (Agile), iterated on quicker (Lean), and deployed more frequently\n(Continuous Delivery). But on the modeling side, it is important to avoid creating\nservices that are “too small.” According to Vernon, we cannot arbitrarily reduce the\nsize of a bounded context because its optimal size is determined by the business con‐\ntext (model). Our technical need for the size of a service can sometimes be different\n(smaller) from what DDD modeling can facilitate. This is probably why Sam New‐\nman, very carefully, called bounded context analysis an “excellent start,” but not the\nsole prescription for how to size microservices. And we completely agree. Bounded\ncontexts are a great start, but we need more tools in our toolbelt if we are to size\nmicroservices efficiently. We will discuss some of those tools later in this chapter, in\nparticular when we look into data storage for microservices.\n66 \n| \nChapter 5: Service Design",
      "content_length": 2550,
      "extraction_method": "Direct"
    },
    {
      "page_number": 83,
      "chapter": null,
      "content": "API Design for Microservices\nWhen considering microservice component boundaries, the source code itself is only\npart of our concern. Microservice components only become valuable when they can\ncommunicate with other components in the system. They each have an interface or\nAPI. Just as we need to achieve a high level of separation, independence, and modu‐\nlarity of our code we need to make sure that our APIs, the component interfaces, are\nalso loosely coupled. Otherwise, we won’t be able to deploy two microservices inde‐\npendently, which is one of our primary goals in order to balance speed and safety.\nWe see two practices in crafting APIs for microservices worth mentioning here:\n• Message-oriented\n• Hypermedia-driven\nMesssage-Oriented\nJust as we work to write component code that can be safely refactored over time, we\nneed to apply the same efforts to the shared interfaces between components. The\nmost effective way to do this is to adopt a message-oriented implementation for\nmicroservice APIs. The notion of messaging as a way to share information between\ncomponents dates back to the initial ideas about how object-oriented programming\nwould work. Alan Kay reminded everyone of the power of messages on an email list\nin 1998:\nI’m sorry that I long ago coined the term “objects” for this topic because it gets many\npeople to focus on the lesser idea. The big idea is “messaging.”\n—Alan Kay\nAll of the companies we talked with about microservice component design men‐\ntioned the notion of messaging as a key design practice. For example, Netflix relies on\nmessage formats like Avro, Protobuf, and Thrift over TCP/IP for communicating\ninternally and JSON over HTTP for communicating to external consumers (e.g.,\nmobile phones, browsers, etc.). By adopting a message-oriented approach, developers\ncan expose general entry points into a component (e.g., an IP address and port num‐\nber) and receive task-specific messages at the same time. This allows for changes in\nmessage content as a way of refactoring components safely over time. The key lesson\nlearned here is that for far too long, developers have viewed APIs and web services as\ntools to transmit serialized “objects” over the wire. However, a more efficient\napproach is to look at a complex system as a collection of services exchanging mes‐\nsages over a wire.\nAPI Design for Microservices \n| \n67",
      "content_length": 2365,
      "extraction_method": "Direct"
    },
    {
      "page_number": 84,
      "chapter": null,
      "content": "Hypermedia-Driven\nSome companies we spoke to are taking the notion of message-oriented to the next\nlevel. They are relying on hypermedia-driven implementations. In these instances, the\nmessages passed between components contain more than just data. The messages also\ncontain descriptions of possible actions (e.g., links and forms). Now, not just the data\nis loosely coupled—so are the actions. For example, Amazon’s API Gateway and App‐\nStream APIs both support responses in the Hypertext Application Language (HAL)\nformat.\nHypermedia-style APIs embrace evolvability and loose coupling as the core values of\nthe design style. You may also know this style as APIs with Hypermedia As The\nEngine Of Application State (HATEOAS APIs). Regardless of the name used, if we are\nto design proper APIs in microservice architecture, it helps to get familiar with the\nhypermedia style.\nHypermedia style is essentially how HTML works for the browser. HTTP messages\nare sent to an IP address (your server or client location on the Internet) and a port\nnumber (usually “80” or “443”). The messages contain the data and actions encoded\nin HTML format. For example, a message that contains information on an outstand‐\ning shipment due to arrive at your office might look like this:\n<html>\n  <head>\n    <title>Shipment #123</title>\n  </head>\n  <body>\n    <h1>Shipment #123</h1>\n    <div id=\"data\">\n      <span>ID: 123</span><br />\n      <span>Description: Widget Covers</span><br />\n      <span>Quantity: 1 Gross</span><br />\n      <span>Estimated Arrival: 2017-01-09</span><br />\n    </div>\n    <div id=\"actions\">\n      <a href=\"...\">Refresh</a>\n      <a href=\"...\">Exit</a>\n      <form method=\"get\" action=\"...\">\n        <input name=\"id\" value=\"\" />\n        <input type=\"submit\" value=\"Search\" />\n      </form>\n    </div>\n</html>\nJames Gregory of ThoughtWorks, a company experienced in helping customers\nadopt and implement microservice-style systems, puts it this way:\n68 \n| \nChapter 5: Service Design",
      "content_length": 1986,
      "extraction_method": "Direct"
    },
    {
      "page_number": 85,
      "chapter": null,
      "content": "When we work on projects with more and more services involved the big revelation\nwas the people who build HTTP and use Hypermedia know what they’re talking about\n—and we should listen to them.\n—James Gregory, Lead Consultant at ThoughtWorks\nThe hypermedia API style is as transformative to the API space as object-oriented\ndesign was for code design. A long time ago, we used to just write endless lines of\ncode (maybe lightly organizing them in functions), but then object-oriented design\ncame by with a revolutionary idea: “what if we grouped the state and the methods\nthat operate on that state in an autonomous unit called an object, thus encapsulating\ndata and behavior?” In essence, hypermedia style has very similar approach but for\nAPI design. This is an API style in which API messages contain both data and con‐\ntrols (e.g., metadata, links, forms), thus dynamically guiding API clients by respond‐\ning with not just static data but also control metadata describing API affordances (i.e.,\n“what can I do with this API?”).\nTo learn more about hypermedia APIs and how to design them,\ncheck out the book RESTful Web APIs by Mike Amundsen, Leo‐\nnard Richardson, and Sam Ruby. By the way, don’t let the book title\nfool you—even though it says “RESTful,” it is about hypermedia\nAPIs and among other things explains why the book says REST\nwhile it talks about hypermedia APIs.\nExposing affordances makes sense for services that communicate over the Web. If we\nlook at the Web as both the human-centric Web (websites consumed by humans) and\nmachine Web (APIs), we can see stark differences in how far behind the machine\nWeb is. When you load a web page on the human-centric Web, it doesn’t just give you\ncontent (text, photos, videos, etc.)—most web pages also contain links to related con‐\ntent or search menus: something you can interact with. Basically, web pages tell you,\nin the response itself, what else you can do. Conventional web APIs don’t do this.\nMost contemporary RESTful (CRUD) APIs respond with just data and then you have\nto go and read some documentation to find out what else can be done. Imagine if\nwebsites were like that: you would go to a specific URL, read content, then you’d have\nto look in some documentation (a book? a PDF?) to find other interesting URLs,\nmany of which may be outdated, to navigate to the next thing. Most people would\nagree that it would be quite a ridiculous experience. The human Web wouldn’t be\nvery functional if the responses didn’t contain behavioral affordances. But that’s\nexactly the case for most modern RESTful APIs. And, as a matter of fact, the data-\nonly approach is quite as brittle and dysfunctional for the machine Web as the picture\nwe painted for the human-centric Web, except we have gotten used to the unfortunate\nstate of affairs.\nAPI Design for Microservices \n| \n69",
      "content_length": 2837,
      "extraction_method": "Direct"
    },
    {
      "page_number": 86,
      "chapter": null,
      "content": "Hypermedia APIs are more like the human Web: evolvable, adaptable, versioning-\nfree—when was the last time you cared about what “version” of a website you are\nlooking at? As such, hypermedia-style APIs are less brittle, more discoverable, and fit\nright at home in a highly distributed, collaborative architectural style such as micro‐\nservices.\nData and Microservices\nAs software engineers, we have been trained to think in terms of data, first and fore‐\nmost. To give the simplest example, it has pretty much been ingrained in our “muscle\nmemory,” or whatever the mental equivalent of one is, to start system design by first\ndesigning the pertinent data models. When asked to build an application, the very\nfirst task most software engineers will complete is identifying entities and designing\ndatabase tables for data storage. This is an efficient way of designing centralized sys‐\ntems and whole generations of programmers have been trained to think this way. But\ndata-centric design is not a good way to implement distributed systems—especially\nsystems that rely on independently deployable microservices. The biggest reason for\nthis is the absence of strong, centralized, uniform control over the entire system in\nthe case of distributed systems, which makes a formerly efficient process inefficient.\nThe first step in breaking the data-centric habit is to rethink our system designs. We\nneed to stop designing systems as a collection of data services and instead use busi‐\nness capabilities as the design element, or as Sam Newman notes in his book:\nYou should be thinking not in terms of data that is shared, but about the capabilities\nthose contexts provide [...]. I have seen too often that thinking about data leads to ane‐\nmic, CRUD-based (create, read, update, delete) services. So ask first “What does this\ncontext do?” and then “So what data does it need to do that?”\n—Sam Newman, author of Building Microservices\nIt turns out that capabilities-centric design is more suitable for microservices than a\nmore traditional, data-centric design.\nShipping, Inc.\nTo demonstrate some of the practical aspects of microservice architecture, through‐\nout Chapters 5 and 6 we will be using an imaginary startup. Let’s assume that we are\ndesigning a microservice architecture for a fledgling shipment company, aptly named\nShipping, Inc. As a parcel-delivery company, they need to accept packages, route\nthem through various sorting warehouses (hops on the route), and eventually deliver\nto the destination. Because it is 2016 and the company is very tech-savvy, Shipping,\nInc. is building native mobile applications for a variety of platforms to let customers\ntrack their packages all the way from pickup to final delivery. These mobile applica‐\ntions will get the data and functionality they need from a set of microservices.\n70 \n| \nChapter 5: Service Design",
      "content_length": 2860,
      "extraction_method": "Direct"
    },
    {
      "page_number": 87,
      "chapter": null,
      "content": "Let’s imagine that Shipping, Inc.’s accounting and sales subsystems (microservices)\nneed access to daily currency exchange rates to perform their operations. A data-\ncentric design would create a table or set of tables in a database that contain exchange\nrates. Then we would let various subsystems query our database to retrieve the data.\nThis solution has significant issues—two microservices depend on the design of the\nshared table and data in it, leading to tight coupling and impeding independent\ndeployability.\nIf instead, we had viewed “currency exchange rates” as a capability and had built an\nindependent microservice (currency rates) serving the sales and accounting micro‐\nservices, we would have had three independent services, all loosely coupled and inde‐\npendently deployable. Furthermore, since, by their nature, APIs in services hide\nimplementation details, we can completely change the data persistence supporting\nthe currency rates service (e.g., from MySQL to Cassandra, if scalability became an\nissue) without any of the service’s consumers noticing the change or needing to\nadjust. Last but not least, since services (APIs) are able to put forward alternative\ninterfaces to its various consumers, we can easily alter the interface that the currency\nrates microservice provides to the sales microservice, without affecting the account‐\ning microservice, thus fulfilling the promise of independent evolution, a necessity for\nindependent deployability. Mission accomplished!\nThinking in terms of capabilities rather than data is a very powerful technique for\nAPI design, in general. It usually results in a more use-case-oriented interface\n(instead of an SQL-like data-object interface). A capabilities-centric API design is\nusually a good approach, but in the case of microservices it is not just a smart design\ntechnique, it’s a powerful way of avoiding tight coupling. We just saw evidence of this.\nMuch like bounded context analysis, capabilities-oriented design is a crucial techni‐\nque but not sufficient to ensure independent deployability for all use cases. Not every\nexample is as simple as our currency rates one. We cannot always encapsulate shared\ndata inside a microservice and call it a day. For example, a common use case that can‐\nnot be solved with encapsulated capabilities is that of reporting. Any business applica‐\ntion requires a certain level of reporting. And reporting often spans across multiple\nmodels, bounded contexts, and capabilities. Should reporting-oriented microservices\nbe allowed to share tables with other microservices? The obvious answer is no,\nbecause that would immediately create severe tight coupling of services all around the\nsystem, and at the very least undermine (if not completely kill) independent deploya‐\nbility.\nLet’s see what techniques we can use to avoid data-sharing in complex use cases. The\nfirst one we will look at is event sourcing, a powerful data-modeling methodology that\ncan help us avoid data-sharing in microservices, even in very complicated cases. The\nsecond, related methodology is CQRS—command query responsibility segregation.\nData and Microservices \n| \n71",
      "content_length": 3150,
      "extraction_method": "Direct"
    },
    {
      "page_number": 88,
      "chapter": null,
      "content": "Event Sourcing\nWe’ve mentioned that there are some deeply ingrained software engineering habits\nthat greatly affect the way we typically approach systems engineering. One of the\nmost widespread of those habits is structural data modeling. It has become very natu‐\nral for us to describe models as collections of interacting logical entities and then to\nmap those logical entities to physical tables where the data is stored. More recently,\nwe have started using NoSQL and object stores that take us slightly away from the\nrelational world, but in essence the approach is still the same: we design structural\nentities that model objects around us and then we “save” the object’s state in a data‐\nbase store of some kind. Whether storage happens in table rows and columns, serial‐\nized as JSON strings, or as object graphs, we are still performing CRUD-based\nmodeling. But this is not the only way to model the world. Instead of storing struc‐\ntures that model the state of our world, we can store events that lead to the current\nstate of our world. This modeling approach is called event sourcing.\nEvent sourcing is all about storing facts and any time you have “state” (structural mod‐\nels)—they are first-level derivative off of your facts. And they are transient.\n—Greg Young, Code on the Beach, 2014\nIn this context, by “facts” Young means the representative value of an event occur‐\nrence. An example could be “a package was transported from the last sorting facility,\nout for final delivery.” Later in this chapter, we will see more examples of what facts\ncan be.\nIt is fair to note that for the majority of software developers used to structural data\nmodeling, event sourcing will initially sound alien and, maybe, even somewhat weird.\nBut it really isn’t. For one thing, event sourcing is not some bleeding-edge, untested\ntheory dreamed up to solve problems in microservices. Event sourcing has been used\nin the financial industry with great success, independent of any microservice archi‐\ntecture association.\nIn addition, the roots and inspiration for event sourcing go way beyond microservi‐\nces, the Internet itself, or even computers—all the way back to financial accounting\nand the paper-and-pen ledgers that contain a list of transactions, and never just the\nend value (“state”) of a balance. Think of your bank account: there’s a balance amount\nfor your checking and savings accounts, but those are not first-class values that banks\nstore in their databases. The account balance is always a derivative value; it’s a func‐\ntion. More specifically, the balance is the sum of all transactions from the day you\nopened your account.\n72 \n| \nChapter 5: Service Design",
      "content_length": 2675,
      "extraction_method": "Direct"
    },
    {
      "page_number": 89,
      "chapter": null,
      "content": "If you decide to dispute your current balance and call up your bank, they are not\ngoing to retort by saying, “But sir/ma’am, that’s the value in our database, it has to be\ntrue!” Instead, they will print out all relevant transactions for you (or point you to\nonline banking where you can do it yourself) and let you verify that the result of the\ntransactions should indeed be equal to the balance value displayed. If you do find any\nerrors with any of the transactions, the bank will issue a “compensating transaction”\nto fix the error. This is another crucial property of event sourcing: much like in life,\nwe can never “go back” in time and “change” the past, we can only do something in\nthe present to compensate for the mistakes of the past. In event sourcing, data is\nimmutable—we always issue a new command/event to compensate rather than\nupdate a state of an entity, as we would do in a CRUD style.\nWhen event sourcing is introduced to developers, the immediate concern is usually\nperformance. If any state value is a function of events, we may assume that every\naccess to the value would require recalculation of the current state from the source\nevents. Obviously that would be extremely slow and generally unacceptable. Fortu‐\nnately, in event sourcing, we can avoid such expensive operations by using a so-called\nrolling snapshot—a projection of the entity state at a given point in time. Depending\non the event source implementation, it is common to snapshot intermediary values at\nvarious time points. For instance, you may precalculate your bank account balance on\nthe last day of every month, so that if you need the balance on January 15, 2016 you\nwill already have it on December 31, 2015 and will just need to calculate the projec‐\ntion for two weeks, instead of the entire life of the bank account. The specifics of how\nyou implement rolling snapshots and projections may depend on the context of your\napplication. Later in this chapter we will see that with a related pattern called CQRS,\nwe can do much more than just cache states in rolling snapshots.\nDespite its accounting roots, event sourcing is not only relevant to just financial use\ncases. For the rest of this chapter we will use a business scenario as far from banking\nand accounting as we could imagine: shipment and delivery of goods.\nRemember the imaginary package-shipment startup Shipping, Inc. that we intro‐\nduced in this chapter? As a parcel-delivery company, they need to accept packages,\nroute them through various sorting warehouses (hops on the route), and eventually\ndeliver to their destinations.\nA representative data model for this system executed in structural style is shown in\nFigure 5-1.\nData and Microservices \n| \n73",
      "content_length": 2718,
      "extraction_method": "Direct"
    },
    {
      "page_number": 90,
      "chapter": null,
      "content": "Figure 5-1. Data model for Shipping, Inc. using “current state” approach\nThe corresponding events-based model is shown in Figure 5-2.\nFigure 5-2. Data model for Shipping, Inc. using event sourcing\n74 \n| \nChapter 5: Service Design",
      "content_length": 229,
      "extraction_method": "Direct"
    },
    {
      "page_number": 91,
      "chapter": null,
      "content": "As you can see, the structural model strives to only save the current state of the sys‐\ntem, while the event sourcing approach saves individual “facts.” State, in event sourc‐\ning, is a function of all the pertinent facts that occurred. Not only does this give us full\nauditability (as demonstrated in the case when we called our bank to dispute the bal‐\nance), we can also build state projections toward any time in the past, not just the\n“now.” Would you like to know where all the packages were on Wednesday? No prob‐\nlem with event sourcing! Answering this question would be more difficult with the\nstructural model, since it would require special coding.\nIf you enjoy noticing patterns in seemingly unrelated things the way we do, we urge\nyou to take another look at the two diagrams. You may notice how every entity in the\nstructural model is a “snowflake” (i.e., it has a unique “shape,” in terms of properties\nand relationships, and was attentively crafted to represent differing real-life con‐\ncepts). In contrast, events in an event store all look the same from the outside. This is\na very similar view to another technology closely related to microservices: containers.\nIndeed, for the container host (e.g., a Docker host), all containers look alike—the host\ndoesn’t “care” what is inside a container, it knows how to manage the lifecycle of a\ncontainer independent of the contents of the container. In contrast, custom-installed\nenterprise applications have all kinds of peculiar “shapes” and environmental depen‐\ndencies that the host must ensure exist (e.g., shared libraries the application expects).\nThe “indifference to shape and contents” approach seems to be a trend in modern\ntechnologies, as we can see the same pattern in SQL versus NoSQL storage. It is very\nreminiscent, in its tendency to show up under multiple contexts, of the “batch-size\nreduction” trend we noticed earlier while looking at different modern methodologies\nacross multiple disciplines (e.g., project management, product development, opera‐\ntions, and architecture). We love this—when the same pattern emerges in multiple\nplaces, we can use our understanding of the pattern to identify or predict “next big\nthing.”\nBut let’s get back to microservices. We dipped our toes in a data-modeling technology\ncalled event sourcing and noted some of its benefits compared to conventional, struc‐\ntural modeling, but how exactly does it help us solve the data isolation and encapsula‐\ntion challenges of microservice architecture? As it turns out, we need one more\ndesign pattern, CQRS, to complement event sourcing and we will be well on our way\ntoward being able to design effective data storage for microservices with data persis‐\ntence models that can avoid data sharing at even very small microservice sizes.\nSystem Model for Shipping, Inc.\nAs we noted earlier, a good start for a microservice system design is to identify boun‐\nded contexts in the system. Figure 5-3 shows a context map for key bounded contexts\nin our problem space. We will use this context map in discussing the solution\nthroughout the chapter.\nData and Microservices \n| \n75",
      "content_length": 3130,
      "extraction_method": "Direct"
    },
    {
      "page_number": 92,
      "chapter": null,
      "content": "Figure 5-3. High-level context map for Shipping, Inc.’s microservice architecture\nWhat are the capabilities of the three contexts and some of the data flows between the\ncontexts, depicted by the arrows and numbers on the graph? They are as follows:\n1. Customer Management creates, edits, enables/disables customer accounts, and\ncan provide a representation of a customer to any interested context.\n2. Shipment Management is responsible for the entire lifecycle of a package from\ndrop-off to final delivery. It emits events as the package moves through sorting\nand forwarding facilities, along the delivery route.\n3. Shipment Tracking is a reporting application that allows end users to track their\nshipments on their mobile device.\nIf we were to implement a data model of this application using a traditional, struc‐\ntural, CRUD-oriented model we would immediately run into data sharing and tight-\ncoupling problems. Indeed, notice that the Shipment Management and Shipment\nTracking contexts will have to query the same tables, at the very least the ones con‐\ntaining the transitions along the route. However, with event sourcing, the Shipment\nManagement bounded context (and its corresponding microservice) can instead\nrecord events/commands and issue event notifications for other contexts and those\nother contexts will build their own data indexes (projections), never needing direct\naccess to any data owned and managed by the Shipment Management microservice.\nThe formal approach to this process is described in a pattern called CQRS.\nCQRS\nCommand query responsibility segregation is a design pattern that states that we can\n(and sometimes should) separate data-update versus data-querying capabilities into\nseparate models. It tracks its ancestry back to a principle called command–query sep‐\naration (CQS), which was introduced by Bertrand Meyer in his book Object-Oriented\n76 \n| \nChapter 5: Service Design",
      "content_length": 1913,
      "extraction_method": "Direct"
    },
    {
      "page_number": 93,
      "chapter": null,
      "content": "Software Construction (Prentice-Hall, 1997). Meyer argued that data-altering opera‐\ntions should be in different methods, separated from methods performing read-only\noperations. CQRS takes this concept a large step further, instructing us to use entirely\ndifferent models for updates versus queries. This seemingly simple statement often\nturns out to be powerful enough to save the day, especially in the complicated case of\nthe reports-centric microservices we mentioned earlier in this chapter.\nSince reports usually need to aggregate and contrast data generated in different parts\nof a large system, they often need to span multiple subsystems and bounded contexts\nand almost always require access to data from multiple contexts. But it is only so if we\nassume we have a single model for any entity, where we both query and update the\nentity. If we instead use CQRS, the need to access data across multiple contexts (and\nrelated problems) can be eliminated. With CQRS, the Shipment Management micro‐\nservice can “own” and encapsulate any updates related to package delivery, just noti‐\nfying other contexts about events occurring. By subscribing to notifications of these\nevents, a reporting service such as Shipment Tracking can build completely inde‐\npendent, query-optimized model(s) that don’t need to be shared with any other\nservice.\nFigure 5-4 shows a conceptual diagram that depicts CQRS for our Shipping, Inc.\napplication.\nAs you can see, thanks to CQRS, we were able to completely separate the data models\nof the Shipment Management and Tracking microservices. In fact, Shipping Manage‐\nment doesn’t even need to know about the existence of the Tracking microservice,\nand the only thing the Tracking microservice relies on is a stream of events to build\nits query index. During runtime the Tracking microservice only queries its own\nindex. Furthermore, the Tracking microservice can include event and command data\nfrom other microservices using the same flow, keeping its independence and loose\ncoupling.\nThe big win with using event sourcing and CQRS is that they allow us to design very\ngranular, loosely coupled components. With bounded contexts our boundaries have\nto align with business capabilities and subdomain boundaries. With event sourcing,\nwe can literally create microservices so tiny that they just manage one type of event or\nrun a single report. Targeted use of event sourcing and CQRS can take us to the next\nlevel of autonomous granularity in microservice architecture. As such, they play a\ncrucial role in the architectural style.\nData and Microservices \n| \n77",
      "content_length": 2592,
      "extraction_method": "Direct"
    },
    {
      "page_number": 94,
      "chapter": null,
      "content": "Figure 5-4. Data flow in command-query responsibility segregation (CQRS)-based\nmodel for Shipping, Inc.\nBe careful not to abuse/overuse event sourcing and CQRS. You\nshould only use event sourcing and CQRS when necessary, since\nthey will complicate your implementation. Event sourcing and\nCQRS are not an “architecture” for your entire system, rather they\nare a powerful toolset to be used sparingly. There are still many use\ncases in which the conventional, CRUD-based model is much sim‐\npler and should be preferred.\nDistributed Transactions and Sagas\nThe shared data model is not the only use case that can introduce tight coupling\nbetween microservices. Another important threat is workflows. A lot of real-life pro‐\ncesses cannot be represented with a single, atomic operation, since they are a\nsequence of steps. When we are dealing with such workflows, the result only makes\nsense if all of the steps can be executed. In other words, if any step in the sequence\nfails, the resulting state of the relevant system becomes invalid. You probably recog‐\nnize this problem from RDBMS systems where we call such processes “transactions.”\nHowever, database transactions are local, contained within the confines of a single\n78 \n| \nChapter 5: Service Design",
      "content_length": 1253,
      "extraction_method": "Direct"
    },
    {
      "page_number": 95,
      "chapter": null,
      "content": "database where their implementations predominantly rely on the use of a shared state\n(i.e., we put locks on the rows and tables that participate in a transaction, guarantee‐\ning data consistency). Once the transaction is fully executed we can remove the locks,\nor if any step of the transaction steps fails, we can roll back the steps already attemp‐\nted.\nFor distributed workflows and share-nothing environments (and microservice archi‐\ntecture is both of those), we cannot use traditional transaction implementations with\ndata locks and ACID compliance, since such transactions require shared data and\nlocal execution. Instead, an effective approach many teams use is known as “Sagas”.\nSagas were designed for long-lived, distributed transactions by Hector Garcia-Molina\nand Kenneth Salem, and introduced in 1987 (yes, way before microservices or even\nthe Web) during their work at Princeton University.\nSagas are very powerful because they allow running transaction-like, reversible work‐\nflows in distributed, loosely coupled environments without making any assumptions\non the reliability of each component of the complex system or the overall system\nitself. The compromise here is that Sagas cannot always be rolled back to the exact\ninitial state of the system before the transaction attempt. But we can make a best\neffort to bring the system to a state that is consistent with the initial state through\ncompensation.\nIn Sagas, every step in the workflow executes its portion of the work, registers a call‐\nback to a “compensating transaction” in a message called a “routing slip,” and passes\nthe updated message down the activity chain. If any step downstream fails, that step\nlooks at the routing slip and invokes the most recent step’s compensating transaction,\npassing back the routing slip. The previous step does the same thing, calling its prede‐\ncessor compensating transaction and so on until all already executed transactions are\ncompensated.\nConsider this example: let’s say a customer mailed a prepaid cashier’s check for $100\nvia Shipping, Inc.’s insured delivery. When the courier showed up at the destination,\nthey found out that the address was wrong and the resident wouldn’t accept the pack‐\nage. Thus, Shipping, Inc. wasn’t able to complete the transaction. Since the package\nwas insured, it is Shipping, Inc.’s responsibility to “roll back” the transaction and\nreturn the money to the sender. With ACID-compliant transactions, Shipping, Inc. is\nsupposed to bring the exact $100 check back to the original sender, restoring the sys‐\ntem state to its exact initial value. Unfortunately, on the way back the package was\nlost. Since Shipping, Inc. could no longer “roll back” the transaction, they decided to\nreimburse the insured value of $100 by depositing that amount into the customer’s\naccount. Since this was an active, long-time Shipping, Inc. customer and a rational\nhuman being, they didn’t care which $100 was returned to them. The system didn’t\nreturn to its exact initial state, but the compensating transaction brought the environ‐\nment back to a consistent state. This is basically how Sagas work.\nDistributed Transactions and Sagas \n| \n79",
      "content_length": 3175,
      "extraction_method": "Direct"
    },
    {
      "page_number": 96,
      "chapter": null,
      "content": "Due to its highly fault-tolerant, distributed nature, Sagas are very well-suited to\nreplace traditional transactions when transactions across microservice boundaries are\nrequired in a microservice architecture. If you want to learn more about Sagas and\nsee working code implementing a very expressive example related to travel booking,\ncheck out the Saga example by Clemens Vasters.\nAsynchronous Message-Passing and Microservices\nAsynchronous message-passing plays a significant role in keeping things loosely cou‐\npled in a microservice architecture. You probably noticed that in one of the examples\nearlier in this chapter, we used a message broker to deliver event notifications from\nour Shipment Management microservice to the Shipment Tracking microservice in\nan asynchronous manner. That said, letting microservices directly interact with mes‐\nsage brokers (such as RabbitMQ, etc.) is rarely a good idea. If two microservices are\ndirectly communicating via a message-queue channel, they are sharing a data space\n(the channel) and we have already talked, at length, about the evils of two microservi‐\nces sharing a data space. Instead, what we can do is encapsulate message-passing\nbehind an independent microservice that can provide message-passing capability, in a\nloosely coupled way, to all interested microservices.\nThe message-passing workflow we are most interested in, in the context of microser‐\nvice architecture, is a simple publish/subscribe workflow. How do we express it as an\nHTTP API/microservice in a standard way? We recommend basing such a workflow\non an existing standard, such as PubSubHubbub. Now to be fair, PubSubHubbub\nwasn’t created for APIs or hypermedia APIs, it was created for RSS and Atom feeds in\nthe blogging context. That said, we can adapt it relatively well to serve a hypermedia\nAPI-enabled workflow. To do so, we need to implement a flow similar to the one\nshown in Figure 5-5.\nFigure 5-5. Asynchronous message-passing implemented with a PubSubHubbub-\ninspired flow\n80 \n| \nChapter 5: Service Design",
      "content_length": 2041,
      "extraction_method": "Direct"
    },
    {
      "page_number": 97,
      "chapter": null,
      "content": "We also need to standardize some hypermedia affordances:\nrel=\"hub\"\nRefers to a hub that enables registration for notification of updates to the context.\nrel=\"pingback\"\nGives the address of the pingback resource for the link context.\nrel=\"sub\"\nWhen included in a resource representation of an event, the \"sub\" (subscription)\nlink relation may identify a target resource that represents the ability to subscribe\nto the pub/sub event-type resource in the link context.\nrel=\"unsub\"\nWhen included in a resource representation of an event, the \"unsub\" (subscrip‐\ntion cancellation) link relation may identify a target resource that represents the\nability to unsubscribe from the pub/sub event-type resource in the link context.\nrel=\"event\"\nResource representation of a subscribable events.\nrel=\"events\"\nLink to a collection resource representing a list of subscribable events.\nDealing with Dependencies\nAnother important topic related to independent deployability is embedding of\ndependencies. Let’s imagine that Shipping, Inc.’s currency rates microservice is being\nhammered by user queries and requests from other microservices. It would cost us\nmuch less if we hosted that microservice in a public cloud rather than on expensive\nservers of our corporate data center. But it doesn’t seem possible to move the micro‐\nservice to another host, if it stores data in the same SQL or NoSQL database system as\nall other microservices.\nPlease note that data tables are not shared, just the installation of the database-\nmanagement system. It seems like the logical conclusion is that we cannot have any\nmicroservice share even the installation of a data storage system. Some may argue\nthat a microservice needs to “embed” every single dependency it may require, so that\nthe microservice can be deployed wherever and whenever, without any coordination\nwith the rest of the system.\nA strict requirement of full dependency embedding can be a significant problem,\nsince for decades we have designed our architectures with centralized data storage, as\nshown in Figure 5-6.\nDealing with Dependencies \n| \n81",
      "content_length": 2088,
      "extraction_method": "Direct"
    },
    {
      "page_number": 98,
      "chapter": null,
      "content": "Figure 5-6. Components using a centralized pool of dependencies\nCentralized data storage is operationally convenient: it allows dedicated, specialized\nteams (DBAs, sysadmins) to maintain and fine-tune these complex systems, obscur‐\ning the complexity from the developers.\nIn contrast, microservices favor embedding of all their dependencies, in order to ach‐\nieve independent deployability. In such a scenario, every microservice manages and\nembeds its database, key-value store, search index, queue, etc. Then moving this\nmicroservice anywhere becomes trivial. This deployment would look like Figure 5-7.\n82 \n| \nChapter 5: Service Design",
      "content_length": 638,
      "extraction_method": "Direct"
    },
    {
      "page_number": 99,
      "chapter": null,
      "content": "Figure 5-7. Components using fully embedded, isolated dependencies\nThe postulate of wholesale embedding of (data storage) dependencies looks beautiful\non the surface, but in practice it is extremely wasteful for all but the simplest use\ncases. It is obvious that you will have a very hard time embedding entire Cassandra,\nOracle, or ElasticSearch clusters in each and every microservice you develop. Espe‐\ncially if you are far down the microservices journey and possibly have hundreds of\nmicroservices. This is just not doable. Neither is it necessary.\nDealing with Dependencies \n| \n83",
      "content_length": 586,
      "extraction_method": "Direct"
    },
    {
      "page_number": 100,
      "chapter": null,
      "content": "In reality, a microservice doesn’t have to carry along every single dependency (such as\na data storage system) in order to be mobile and freely move across the data centers.\nLet us explain.\nIn his previous job, one of us (Irakli) traveled a lot for work. He’d acquired important\ntips for doing it efficiently—tips that he was completely indifferent to during his pre‐\nvious life as a casual traveler. As any frequent traveler will tell you, the most impor‐\ntant rule for mobility is to keep your luggage light. You don’t have to pack literally\neverything you may possibly need. For example, nobody packs shower-heads and\ntowels on a business trip: you know you will find those at the hotel. If you know that\nthe destination hotel has a convenience shop and your employer pays for incidentals,\nyou don’t even have to pack most toiletries. Irakli learned what he could count on\nbeing available “onsite” and what he needed to always bring with him. And, to pack\nlight, he learned to limit his “dependencies” on a lot of things that were not needed as\npart of his packing routine.\nLikewise, the trick to microservice mobility is not packing everything but instead\nensuring that the deployment destination provides heavy assets, such as database\nclusters, in a usable and auto-discoverable form at every destination where a micro‐\nservice may be deployed. Microservices should be written so that they can quickly\ndiscover those assets upon deployment and start using them.\nLet’s be clear: data sharing between microservices is still the ulti‐\nmate no-no. Sharing data creates tight coupling between microser‐\nvices, which kills their mobility. However, sharing a database\ncluster installation is absolutely OK, given that each microservice\nonly accesses isolated, namespaced portions of it.\nPragmatic Mobility\nFigure 5-8 shows what a proper, sophisticated microservices deployment should look\nlike in practice.\n84 \n| \nChapter 5: Service Design",
      "content_length": 1938,
      "extraction_method": "Direct"
    },
    {
      "page_number": 101,
      "chapter": null,
      "content": "Figure 5-8. Pragmatic approach: Components using a centralized pool of dependencies,\nwithout sharing data spaces\nIf we decide to move Microservice 1 to another data center, it will expect that the new\ndata center also has a functioning Cassandra cluster with a compatible version (in our\nearlier metaphor, the hotel provides towels we can use), but it will find a way to move\nits slice of data and won’t depend on the existence or state of any other microservice\nat the destination (Figure 5-9).\nDealing with Dependencies \n| \n85",
      "content_length": 528,
      "extraction_method": "Direct"
    },
    {
      "page_number": 102,
      "chapter": null,
      "content": "Figure 5-9. Pragmatic approach: Microservice 1’s move to different data center made\npossible without data sharing\nMicroservices do not have to “travel” heavy and pack everything they may possibly\nrequire. In complicated cases it is OK to have some reasonable expectations about the\ndestination environment, especially when it comes to complex data-storage capabili‐\nties.\nThe most important question we need to ask, when deciding on embedding depen‐\ndencies versus “expecting” traits in an environment, is will our decision increase or\ndecrease mobility? Our goal is to maximize deployment mobility of a microservice,\nwhich may mean different things in different contexts.\nSummary\nIn this chapter we described a framework for effectively designing individual micro‐\nservices and reviewed core modeling tools that a microservice architect needs to have\nin their toolbelt. We set out by demystifying the answer to one of the most commonly\nasked questions in microservices: how do we properly size services and identify\nboundaries? We started by clarifying the role of domain-driven design in the context\nof microservice architecture, the importance of bounded contexts, and gave an exam‐\nple of a context map for a fictional package delivery company Shipping, Inc.\n86 \n| \nChapter 5: Service Design",
      "content_length": 1295,
      "extraction_method": "Direct"
    },
    {
      "page_number": 103,
      "chapter": null,
      "content": "We explained the overarching role of the “batch-size reduction” technique for sys‐\ntems engineering, when achieving both speed and safety at scale is the desired out‐\ncome. We demonstrated that at certain levels of granularity architects may require\nadditional patterns, on top of the ones in domain-driven design, such as event sourc‐\ning, CQRS, and Sagas. We showed how these patterns can substantially alter our per‐\nspective on model design and how that can lead to more loosely coupled, splittable\nservices.\nLast, but not least, microservices are APIs, so going beyond code, implementation,\nand deployment considerations, we dedicated a significant portion of the chapter to\nexplaining unique interface design needs for APIs that constitute a microservice.\nSummary \n| \n87",
      "content_length": 776,
      "extraction_method": "Direct"
    },
    {
      "page_number": 104,
      "chapter": null,
      "content": "",
      "content_length": 0,
      "extraction_method": "OCR"
    },
    {
      "page_number": 105,
      "chapter": null,
      "content": "CHAPTER 6\nSystem Design and Operations\nHaving introduced a system-level view of the microservice architecture and architec‐\ntural perspective of the value proposition, as well as design considerations, it’s time to\ndiscuss aspects of runtime, operational management of a microservice architecture.\nThe benefits of adopting a microservice architecture don’t necessarily come free—\nthey can shift complexity into operations. Generally speaking, teams adopting a\nmicroservice architecture are expected to have a certain level of infrastructure auto‐\nmation and operational maturity to be successful. Let’s see what this means in practi‐\ncal terms.\nIn this chapter we will review key concepts of microservice operations such as inde‐\npendent deployability, the role of containers in cost-efficient deployments, and specif‐\nically, what role Docker can play in microservices, service discovery, security, routing,\ntransformation, and orchestration. Taken together, discussions of these topics, in the\ncontext, will give you a solid foundation for understanding, designing, and executing\non microservice architecture’s operational needs.\nIndependent Deployability\nOne of the core principles of the microservice architectural style is the principle of\nindependent deployability—i.e., each microservice must be deployable completely\nindependent of any other microservice. Some of the most important benefits of the\narchitectural style rely on faithful adherence to this principle.\nIndependent deployability allows us to perform selective or on-demand scaling; if a\npart of the system (e.g., a single microservice) experiences high load we can re-deploy\nor move that microservice to an environment with more resources, without having to\nscale up hardware capacity for the entire, typically large, enterprise system. For many\n89",
      "content_length": 1818,
      "extraction_method": "Direct"
    },
    {
      "page_number": 106,
      "chapter": null,
      "content": "organizations, the operational ability of selective scaling can save large amounts of\nmoney and provide essential flexibility.\nRemember the imaginary package-shipment startup Shipping, Inc. we introduced in\nChapter 5? As a parcel-delivery company, they need to accept packages, route them\nthrough various sorting warehouses (hops on the route), and eventually deliver them\nto their destinations.\nLet’s consider an example of selective scaling for Shipping, Inc. This company stores\nand operates sensitive customer information including demographic and financial\ndata for its customers. In particular, Shipping, Inc. collects credit card information\nand, as such, falls under the auditing requirements of strict government regulation.\nFor security reasons, Shipping, Inc. deploys sensitive parts of the implementation at\nan on-premise data center, but its CTO would still like to utilize “cloud computing,”\nfor cost and scalability reasons, when possible.\nScaling hardware resources on-premise can be extremely costly—we have to buy\nexpensive hardware in anticipation of the usage rather than in response to actual\nusage. At the same time, the part of the application that gets hammered under load\nand needs scaling may not contain any sensitive client or financial data. It can be\nsomething as trivial as an API returning a list of US states or an API capable of con‐\nverting various currency rates. The chief architect of Shipping, Inc. is confident that\ntheir security team will easily allow deployment of such safe microservices to a pub‐\nlic/private cloud, where scaling of resources is significantly cheaper. The question is—\ncould they deploy part of an application to a separate data center, a cloud-based one,\nin this case? The way most, typically monolithic, enterprise systems are architected,\ndeploying selective parts of the application independently is either very hard or prac‐\ntically impossible. Microservices, in contrast, emphasize the requirement of inde‐\npendent deployability to the level of core principle, thus giving us much needed\noperational flexibility.\nOn top of operational cost saving and flexibility, another significant benefit of the\nindependent deployability is an organizational one. Generally speaking, two different\nteams would be responsible for the development of separate microservices (e.g., Cus‐\ntomer Management and Shipment Management). If the first team, which is responsi‐\nble for the Customer Management microservice, needs to make a change and re-\nrelease, but Customer Management cannot be released independent of the Shipment\nManagement microservice, we now need to coordinate Customer Management’s\nrelease with the team that owns Shipment Management. Such coordination can be\ncostly and complicated, since the latter team may have completely different priorities\nfrom the team responsible for Customer Management. More often than not the\nnecessity of such coordination will delay a release. Now imagine that instead of just a\nhandful we potentially have hundreds of microservices maintained by dozens of\nteams. Release coordination overhead can be devastating for such organizations,\n90 \n| \nChapter 6: System Design and Operations",
      "content_length": 3181,
      "extraction_method": "Direct"
    },
    {
      "page_number": 107,
      "chapter": null,
      "content": "leading to products that ship with significant delays or sometimes get obsolete by the\ntime they can be shipped. Eliminating costly cross-team coordination challenges is\nindeed a significant motivation for microservice adopters.\nMore Servers, More Servers! My Kingdom for a Server!\nTo ensure independent deployability, we need to develop, package, and release every\nmicroservice using an autonomous, isolated unit of environment. But what does\n“autonomous, isolated unit of environment” mean in this context? What are some\nexamples of such units of environment?\nLet’s assume we are developing a Java/JEE application. At first glance, something like\na WAR or EAR file may seem like an appropriate unit of encapsulation and isolation.\nAfter all, that’s what these packaging formats were designed for—to distribute a col‐\nlection of executable code and related resources that together form an independent\napplication, within the context of an application server.\nIn reality, lightweight packaging solutions, such as JAR, WAR, and EAR archives in\nJava, Gem files (for Ruby), NPM modules (for Node), or PIP packages (for Python)\ndon’t provide sufficient modularity and the level of isolation required for microservi‐\nces. WAR files and Gem files still share system resources like disk, memory, shared\nlibraries, the operating system, etc. Case in point: a WAR or EAR file will typically\nexpect a specific version of Java SDK and application server (JBoss, WebSphere, Web‐\nlogic, etc.) to be present in the environment. They may also expect specific versions of\nOS libraries in the environment. As any experienced sysadmin or DevOps engineer\nknows, one application’s environmental expectations can be drastically different from\nanother’s, leading to version and dependency conflicts if we need to install both appli‐\ncations on the same server. One of the core motivations of adopting a microservice\narchitecture is to avoid the need for complex coordination and conflict resolution,\nthus packaging solutions that are incapable of avoiding such interdependencies are\nnot suitable for microservices. We need a higher level of component isolation to guar‐\nantee independent deployability.\nWhat if we deployed a microservice per physical server or per virtual machine? Well,\nthat would certainly meet the high bar of isolation demanded by microservices, but\nwhat would be the financial cost of such a solution?\nFor companies that have been using microservice architecture for a number of years,\nit is not uncommon to develop and maintain hundreds of microservices. Let’s assume\nyou are a mature microservices company with about 500 microservices. To deploy\nthese microservices in a reliable, redundant manner you will need at least three\nservers/VMs per each microservice, resulting in 1,500 servers just for the production\nsystem. Typically, most companies run more than one environment (QA, stage, inte‐\ngration, etc.), which quickly multiplies the number of required servers.\nMore Servers, More Servers! My Kingdom for a Server! \n| \n91",
      "content_length": 3029,
      "extraction_method": "Direct"
    },
    {
      "page_number": 108,
      "chapter": null,
      "content": "Here comes the bad news: thousands of servers cost a lot. Even if we use VMs and not\nphysical servers, even in the “cheapest” cloud-hosting environment the budget for a\nsetup utilizing thousands of servers would be significantly high, probably higher than\nwhat most companies can afford or would like to spend. And then there’s that impor‐\ntant question of development environments. Most developers like to have a working,\ncomplete, if scaled down, model of the production environment on their worksta‐\ntions. How many VMs can we realistically launch on a single laptop or desktop com‐\nputer? Maybe five or ten, at most? Definitely not hundreds or thousands.\nSo, what does this quick, on-a-napkin-style calculation of microservices hosting costs\nmean? Is a microservice architecture simply unrealistic and unattainable, from an\noperational perspective? It probably was, for most companies, some number of years\nago. And that’s why you see larger companies, such as Amazon and Netflix, being the\npioneers of the architectural style—they were the few who could justify the costs.\nThings, however, have changed significantly in recent years.\nMicroservice Architecture is a Product of Its Time\nWe often get asked—what is the fundamental difference between\nmicroservice architecture and service-oriented architecture, espe‐\ncially given that so many underlying principles seem similar? We\nbelieve that the two architectural styles are creations of their\nrespective eras, roughly a decade apart. In those 10 years we, as an\nindustry, have gotten significantly more skilled in effective ways of\nautomating infrastructure operations. Microservice architecture is\nleveraging the most advanced achievements in DevOps and contin‐\nuous delivery, making the benefits of the architectural style avail‐\nable and cost-effective to much wider audiences than just a handful\nof large early adopters like Amazon or Netflix.\nThe reason microservice architecture is financially and operationally feasible has a lot\nto do with containers.\nThe deployment unit universally used for releasing and shipping microservices is a\ncontainer. If you have never used containers before, you can think of a container as of\nan extremely lightweight “virtual machine.” The technology is very different from\nthat of conventional VMs. It is based on a Linux kernel extension (LXC) that allows\nrunning many isolated Linux environments (containers) on a single Linux host shar‐\ning the operating system kernel, which means we can run hundreds of containers on\na single server or VM and still achieve the environment isolation and autonomy that\nis on par with running independent servers, and is therefore entirely acceptable for\nour microservices needs.\nContainers will not be limited to just Linux in the future. Microsoft is actively work‐\ning on supporting similar technology on the Windows platform.\n92 \n| \nChapter 6: System Design and Operations",
      "content_length": 2908,
      "extraction_method": "Direct"
    },
    {
      "page_number": 109,
      "chapter": null,
      "content": "Containers provide a modern isolation solution with practically zero overhead. While\nwe cannot run more than a handful of conventional VMs on a single host, it is com‐\npletely possible to run hundreds of containers on a single host. Currently the most\nwidely deployed container toolset is Docker, so in practice Docker and containers\nhave become somewhat synonymous. In reality, there are other up-and-coming con‐\ntainer solutions, which may gain more prominence in the future.\nDocker and Microservices\nIn this section we discuss Docker as it is the container toolset most widely deployed\nin production today. However, as we already mentioned, alternative container solu‐\ntions exist in varying stages of production readiness. Therefore, most things in this\nsection should be understood as relevant to containers in general, not just Docker\nspecifically.\nAt the beginning of 2016 (the time of writing of this book), most microservices\ndeployments are practically unthinkable without utilizing Docker containers. We\nhave discussed some of the practical reasons for this. That said, we shouldn’t think of\nDocker or containers as tools designed just for the microservice architecture.\nContainers in general, and Docker specifically, certainly exist outside microservice\narchitecture. As a matter of fact, if we look at the current systems operations land‐\nscape we can see that the number of individuals and companies using containers\nmany times exceeds those implementing microservice architecture. Docker in and of\nitself is significantly more common than the microservice architecture.\nContainers were not created for microservices. They emerged as a powerful response\nto a practical need: technology teams needed a capable toolset for universal and pre‐\ndictable deployment of complex applications. Indeed, by packaging our application as\na Docker container, which assumes prebundling all the required dependencies at the\ncorrect version numbers, we can enable others to reliably deploy it to any cloud or\non-premise hosting facility, without worrying about target environment and compati‐\nbility. The only remaining deployment requirement is that the servers should be\nDocker-enabled—a pretty low bar, in most cases. In comparison, if we just gave\nsomebody our application as an executable, without prebundled environmental\ndependencies we would be setting them up for a load of dependency pain. Alterna‐\ntively if we wanted to package the same software as a VM image, we would have to\ncreate multiple VM images for several major platforms, since there is no single, domi‐\nnant VM standard currently adopted by major players.\nBut compatibility is not the only win; there’s another benefit that is equally, if not\nmore, important when we consider containers versus VM images. Linux containers\nuse a layered filesystem architecture known as union mounting. This allows a great\nextensibility and reusability not found in conventional VM architectures. With con‐\nDocker and Microservices \n| \n93",
      "content_length": 2992,
      "extraction_method": "Direct"
    },
    {
      "page_number": 110,
      "chapter": null,
      "content": "tainers, it is trivial to extend your image from the “base image.” If the base image\nupdates, your container will inherit the changes at the next rebuild. Such a layered,\ninheritable build process promotes a collaborative development, multiplying the\nefforts of many teams. Centralized registries, discovery services, and community-\noriented platforms such as Docker Hub and GitHub further facilitate quick adoption\nand education in the space.\nAs a matter of fact, we could easily turn the tables and claim that it is Docker that will\nbe driving the adoption of microservices instead of vice versa. One of the reasons for\nthis claim is that Docker puts significant emphasis on the “Unix philosophy” of ship‐\nping containers, i.e., “do one thing, and do it well.” Indeed, this core principle is\nprominently outlined in the Docker documentation itself:\nRun only one process per container. In almost all cases, you should only run a single\nprocess in a single container. Decoupling applications into multiple containers makes it\nmuch easier to scale horizontally and reuse containers.\n—Docker documentation\nIt is clear that with such principles at its core Docker philosophy is much closer to the\nmicroservice architecture than a conventional, large monolithic architecture. When\nyou are shooting for “doing one thing” it makes little sense to containerize your\nentire, huge, enterprise application as a single Docker container. Most certainly you\nwould want to first modularize the application into loosely coupled components that\ncommunicate via standard network protocols, which, in essence, is what the micro‐\nservice architecture delivers. As such, if you start with a goal of containerizing your\nlarge and complex application you will likely need a certain level of microservice\ndesign in your complex application.\nThe way we like to look at it, Docker containers and microservice architecture are\ntwo ends of the road that lead to the same ultimate goal of continuous delivery and\noperational efficiency. You may start at either end, as long as the desired goals are\nachieved.\nIf you are new to Docker and would like a quick sneak peek at Docker for microservi‐\nces, you can find one in a blog post Irakli recently published.\nThe Role of Service Discovery\nIf you are using Docker containers to package and deploy your microservices, you\ncan use a simple Docker Compose configuration to orchestrate multiple microservi‐\nces (and their containers) into a coherent application. As long as you are on a single\nhost (server) this configuration will allow multiple microservices to “discover” and\ncommunicate with each other. This approach is commonly used in local development\nand for quick prototyping.\n94 \n| \nChapter 6: System Design and Operations",
      "content_length": 2749,
      "extraction_method": "Direct"
    },
    {
      "page_number": 111,
      "chapter": null,
      "content": "But in production environments, things can get significantly more complicated. Due\nto reliability and redundancy needs, it is very unlikely that you will be using just one\nDocker host in production. Instead, you will probably deploy at least three or more\nDocker hosts, with a number of containers on each one of them.\nFurthermore, if your services get significantly different levels of load, you may decide\nto not deploy all services on all hosts but end up deploying high-load services on a\nselect number of hosts (let’s say ten of them), while low-load services may only be\ndeployed on three servers, and not necessarily the same ones. Additionally, there may\nbe security- and business-related reasons that may cause you to deploy some services\non certain hosts and other services on different ones.\nIn general, how you distribute your services across your available hosts will depend\non your business and technical needs and very likely may change over time. Hosts are\njust servers, they are not guaranteed to last forever.\nFigure 6-1 shows what the nonuniform distribution of your services may look like at\nsome point in time if you have four hosts with four containers.\nFigure 6-1. Microservice deployment topology with nonuniform service distribution\nThe Role of Service Discovery \n| \n95",
      "content_length": 1294,
      "extraction_method": "Direct"
    },
    {
      "page_number": 112,
      "chapter": null,
      "content": "Each instance of the microservice container in Figure 6-1 is depicted with a different\nnumber, shape, and color. In this example, we have Microservice 1 deployed on all\nfour hosts, but Microservice 2 is only on hosts 1–3. Keep in mind that the deploy‐\nment topology may change at any time, based on load, business rules, which host is\navailable, and whether an instance of your microservice suddenly crashes or not.\nNote that since typically many services are deployed on the same host, we cannot\naddress a microservice by just an IP address. There are usually too many microservi‐\nces, and the instances of those can go up and down at any time. If we allocated an IP\nper microservice, the IP address allocation + assignment would become too compli‐\ncated. Instead, we allocate an IP per host (server) and the microservice is fully\naddressed with a combination of:\n1. IP address (of the host)\n2. Port number(s) the service is available at on the host\nWe already noted that the IPs a microservice is available at are ever-changing, but\nwhat about the port? You might assume that we can assign fixed ports to individual\nmicroservices, in essence saying, “our account management microservice always\nlaunches on port 5555.” But this would not be a good idea. Generally speaking, many\ndifferent teams will need to independently launch microservices on, likely, a shared\npool of hosts. If we assumed that a specific microservice always launches on a specific\nport of a host, we would require a high level of cross-team coordination to ensure\nthat multiple teams don’t accidentally claim the same port. But one of the main moti‐\nvations of using a microservice architecture is eliminating the need for costly cross-\nteam coordination. Such coordination is untenable, in general. It is also unnecessary\nsince there are better ways to achieve the same goal.\nThis is where service discovery enters the microservices scene. We need some system\nthat will keep an eye on all services at all times and keep track of which service is\ndeployed on which IP/port combination at any given time, so that the clients of\nmicroservices can be seamlessly routed accordingly.\nAs mentioned in previous chapters, there are several established solutions in the open\nsource space for service discovery. On one side of the spectrum we have tools such as\nEtcd from CoreOs and Consul by HashiCorp. They are “low-level” tools providing a\nhigh degree of control and visibility to an architect. On the other side of the spectrum\nare tools that provide “container-scheduling” capabilities, alongside the service dis‐\ncovery. Kubernetes from Google is probably the most well-known in this category,\nDocker Swarm being another, more recent player. With container-scheduling solu‐\ntions, we get a high degree of automation and abstraction. In this scenario, instead of\ndeciding which container is launched on which servers, we just tell the system how\nmuch of the host pool’s resources should be devoted to a particular service and\nKubernetes or Swarm takes care of balancing/rebalancing containers on the hosts,\n96 \n| \nChapter 6: System Design and Operations",
      "content_length": 3120,
      "extraction_method": "Direct"
    },
    {
      "page_number": 113,
      "chapter": null,
      "content": "based on these criteria. Another important technology utilizing containers is Meso‐\nsphere. Mesosphere is even more abstracted than Kubernetes or Swarm, currently\nmarketed as “a data center operating system” that allows a higher degree of automa‐\ntion, without having to worry about the many nodes deployed, and operating the\nentire server cluster almost as if it were a single superserver.\nThere are no “better” tools when considering service discovery. As an architect, we\nneed to decide how much automation “magic” we want from our tools versus how\nmuch control we need to retain for ourselves. Even within the same enterprise appli‐\ncation, it is very likely that you may find Kubernetes a great fit for a certain batch of\nmicroservices, whereas architects may decide that another class of microservices can\nbe better deployed if directly managed using something like Consul.\nThe Need for an API Gateway\nA common pattern observed in virtually all microservice implementations is teams\nsecuring API endpoints, provided by microservices, with an API gateway. Modern\nAPI gateways provide an additional, critical feature required by microservices: trans‐\nformation and orchestration. Last but not least, in most mature implementations,\nAPI gateways cooperate with service discovery tools to route requests from the clients\nof microservices. In this section of the chapter, we will look into each one of the API\ngateway features and clarify their role in the overall architecture of the operations\nlayer for microservices.\nSecurity\nMicroservice architecture is an architecture with a significantly high degree of free‐\ndom. Or in other words, there are a lot more moving parts than in a monolithic\napplication. As we mentioned earlier, in mature microservices organizations where\nthe architecture is implemented for complex enterprise applications, it is common to\nhave hundreds of microservices deployed. Things can go horribly wrong security-\nwise when there are many moving parts. We certainly need some law and order to\nkeep everything in control and safe. Which is why, in virtually all microservice imple‐\nmentations, we see API endpoints provided by various microservices secured using a\ncapable API gateway.\nAPIs provided by microservices may call each other, may be called by “frontend,” i.e.,\npublic-facing APIs, or they may be directly called by API clients such as mobile appli‐\ncations, web applications, and partner systems. Depending on the microservice itself,\nthe business needs of the organization, and the industry, market, or application con‐\ntext—all scenarios are fair game. To make sure we never compromise the security of\nthe overall system, the widely recommended approach is to secure invocation of\n“public-facing” API endpoints of the microservices-enabled system using a capable\nAPI gateway.\nThe Need for an API Gateway \n| \n97",
      "content_length": 2853,
      "extraction_method": "Direct"
    },
    {
      "page_number": 114,
      "chapter": null,
      "content": "Based on our experience building microservices systems and helping a wide variety of\norganizations do the same, we recommend a more radical approach than just secur‐\ning “public API endpoints.”\nIn reality the distinction between “public” and “private” APIs often ends up being\narbitrary. How certain are we that the API we think is “only internal” will never be\nrequired by any outside system? As soon as we try to use an API over the public Web,\nfrom our own web application or from a mobile application, as far as security is con‐\ncerned, that endpoint is “public” and needs to be secured. We have mentioned Ama‐\nzon multiple times in this book. Let’s remember what the big picture was for Amazon,\nwith Amazon Web Services: they in essence exposed the lowest level of the technical\nstack possible—hardware resources such as disk, CPU, networking etc., used by their\necommerce website—for anybody in the world to use and they made billions out of it.\nSo, why would we ever assume that we have some APIs that will forever be “internal\nonly”?\nSometimes, certain microservices are deemed “internal” and excluded from the secu‐\nrity provided by an API Gateway, as we assume that they can never be reached by\nexternal clients. This is dangerous since the assumption may, over time, become inva‐\nlid. It’s better to always secure any API/microservice access with an API gateway. In\nmost cases the negligible overhead of introducing an API gateway in between service\ncalls is well worth the benefits.\nTransformation and Orchestration\nWe have already mentioned that microservices are typically designed to provide a sin‐\ngle capability. They are the Web’s version of embracing the Unix philosophy of “do\none thing, and do it well.” However, as any Unix developer will tell you, the single-\nresponsibility approach only works because Unix facilitates advanced orchestration of\nits highly specialized utilities, through universal piping of inputs and outputs. Using\npipes, you can easily combine and chain Unix utilities to solve nontrivial problems\ninvolving sophisticated process workflows. A critical need for a similar solution exists\nin the space of APIs and microservices as well. Basically, to make microservices use‐\nful, we need an orchestration framework like Unix piping, but one geared to web\nAPIs.\nMicroservices, due to their narrow specialization and typically small size, are very\nuseful deployment units for the teams producing them. That said, they may or may\nnot be as convenient for consumption, depending on the client. The Web is a dis‐\ntributed system. Due to its distributed nature, on the Web, so-called “chatty” inter‐\nfaces are shunned. Those are interfaces where you need to make many calls to get the\ndata required for a single task. This distaste for chatty interfaces is especially pro‐\nnounced among mobile developers, since they often have to deal with unreliable,\nintermittent, and slow connections. There are a few things a mobile developer loathes\n98 \n| \nChapter 6: System Design and Operations",
      "content_length": 3020,
      "extraction_method": "Direct"
    },
    {
      "page_number": 115,
      "chapter": null,
      "content": "more than an API interface that forces them to make multiple calls to retrieve some‐\nthing they consider a single piece of information.\nLet’s imagine that after successful completion of the APIs required for the mobile\napplication, the technical team behind Shipping, Inc.’s microservice architecture deci‐\nded to embark on a new journey of developing an “intelligent” inventory manage‐\nment system. The purpose of the new system is to analyze properly anonymized data\nabout millions of shipments passing through Shipping, Inc., combine this insight\nwith all of the metadata that is available on the goods being shipped, determine\nbehavioral patterns of the consumers, and utilizing human + machine algorithms\ndesign a “recommendation engine” capable of suggesting optimal inventory levels to\nShipping, Inc.’s “platinum” customers. If everything works, those suggestions will be\nable to help customers achieve unparalleled efficiency in managing product stock,\naddressing one of the main concerns of any online retailer.\nIf the team is building this system using a microservice architecture, they could end\nup creating two microservices for the main functionality:\n1. Recommendations microservice, which takes user information in, and responds\nwith the list containing the recommendations—i.e., suggested stock levels for\nvarious products that this customer typically ships.\n2. Product Metadata microservice, which takes in an ID of a product type and\nretrieves all kinds of useful metadata about it.\nSuch separation of concerns, into specialized microservices, makes complete sense\nfrom the perspective of the API publisher, or as we may call them, the server-side\nteam. However, for the team that is actually implementing the end-user interface,\ncalling the preceding microservices is nothing but a headache. More likely than not,\nthe mobile team is working on a user screen where they are trying to display several\nupcoming suggestions. Let’s say the page size is 20, so 20 suggestions at a time. With\nthe current, verbatim design of the microservices, the user-interface team will have to\nmake 21 HTTP calls: one to retrieve the recommendations list and then one for each\nrecommendation to retrieve the details, such as product name, dimensions, size,\nprice, etc.\nAt this point, the user-interface team is not happy. They wanted a single list; but\ninstead are forced to make multiple calls (the infamous “N+1 queries” problem,\nresurfaced in APIs). Additionally, the calls to the Product Metadata microservice\nreturn too much information (large payload problem), which is an issue for, say,\nmobile devices on slow connections. And the end result is that the rendering of the\nall-important mobile screen is slow and sluggish, leading to poor user experience.\nScenarios like the one just described are all too common. As a matter of fact, they\nexisted even before the dawn of the microservice architecture. For instance, the REST\nThe Need for an API Gateway \n| \n99",
      "content_length": 2965,
      "extraction_method": "Direct"
    },
    {
      "page_number": 116,
      "chapter": null,
      "content": "API style has been criticized a lot for “chatty interface.” We do not have to build our\nmicroservice APIs in the RESTful style, but a similar problem still exists, since we\ndecided that our microservices need to do “one thing,” which can lead to chattiness.\nFortunately, since the “chattiness” problem in the APIs is not new, mature API gate‐\nways are perfectly equipped to deal with the problem. A capable API gateway will\nallow you to declaratively, through configuration, create API interfaces that can\norchestrate backend microservices and “hide” their granularity behind a much more\ndeveloper-friendly interface and eliminate chattiness. In our example scenario, we\ncan quickly aggregate the N+1 calls into a single API call and optimize the response\npayload. This gives mobile developers exactly what they need: a list of recommenda‐\ntions via a single query, with exactly the metadata they required. The calls to back-\nend microservices will be made by the API gateway. Good API gateways can also\nparallelize the twenty calls to the Product Metadata microservice, making the aggre‐\ngate call very fast and efficient.\nRouting\nWe already mentioned that in order to properly discover microservices we need to\nuse a service discovery system. Service discovery systems such as Consul and etcd\nwill monitor your microservice instances and track metadata about what IPs and\nports each one of your microservices is available at, at any given time. However,\ndirectly providing tuples of the IP/port combinations to route an API client is not an\nadequate solution. A proper solution needs to abstract implementation details from\nthe client. An API client still expects to retrieve an API at a specific URI, regardless of\nwhether there’s a microservice architecture behind it and independent of how many\nservers, Docker containers, or anything else is serving the request.\nSome of the service discovery solutions (e.g., Consul, and etcd using SkyDNS) pro‐\nvide a DNS-based interface to discovery. This can be very useful for debugging, but\nstill falls short of production needs because normal DNS queries only look up\ndomain/IP mapping, whereas for microservices we need domain mapping with an IP\n+port combination. In both Consul and SkyDNS, you can actually use DNS to look\nup both IP and port number, via an RFC 2782 SRV query, but realistically no API\nclient expects or will appreciate having to make SRV requests before calling your API.\nThis is not the norm. Instead, what we should do is let an API gateway hide the com‐\nplexities of routing to a microservice from the client apps. An API gateway can inter‐\nface with either HTTP or DNS interfaces of a service discovery system and route an\nAPI client to the correct service when an external URI associated with the microser‐\nvice is requested. You can also use a load balancer or smart-reverse proxy to achieve\nthe same goal, but since we already use API gateways to secure routes to microservi‐\nces, it makes a lot of sense for the routing requirement to also be implemented on the\ngateway.\n100 \n| \nChapter 6: System Design and Operations",
      "content_length": 3093,
      "extraction_method": "Direct"
    },
    {
      "page_number": 117,
      "chapter": null,
      "content": "Monitoring and Alerting\nAs we have already mentioned, while microservice architecture delivers significant\nbenefits, it is also a system with a lot more moving parts than the alternative—mono‐\nlith. As such, when implementing a microservice architecture, it becomes very\nimportant to have extensive system-wide monitoring and to avoid cascading failures.\nThe same tools that we mentioned for service discovery can also provide powerful\nmonitoring and failover capabilities. Let’s take Consul as an example. Not only does\nConsul know how many active containers exist for a specific service, marking a ser‐\nvice broken if that number is zero, but Consul also allows us to deploy customized\nhealth-check monitors for any service. This can be very useful. Indeed, just because a\ncontainer instance for a microservice is up and running doesn’t always mean the\nmicroservice itself is healthy. We may want to additionally check that the microser‐\nvice is responding on a specific port or a specific URL, possibly even checking that\nthe health ping returns predetermined response data.\nIn addition to the “pull” workflow in which Consul agents query a service, we can\nalso configure “push”-oriented health checks, where the microservice itself is respon‐\nsible for periodically checking in, i.e., push predetermined payload to Consul. If Con‐\nsul doesn’t receive such a “check-in,” the instance of the service will be marked\n“broken.” This alternative workflow is very valuable for scheduled services that must\nrun on predetermined schedules. It is often hard to verify that scheduled jobs do run\nas expected, but the “push”-based health-check workflow can give us exactly what we\nneed.\nOnce we set up health checks we can install an open source plug-in called Consul\nAlerts, which can send service failure and recovery notifications to incident manage‐\nment services such as PagerDuty or OpsGenie. These are powerful services that allow\nyou to set up sophisticated incident-notification phone trees and/or notify your tech\nteam via email, SMS, and push notifications through their mobile apps. Since it is\n2016 and everybody seems to be using Slack or HipChat, Consul Alerts also has sup‐\nport for notifying these chat/communication systems, so that you can be alerted\nabout a service interruption even as you are sending your coworkers that day’s funny\nanimated .gif, or are, say, discussing product priorities for the upcoming cycle. I per‐\nsonally use Slack for both, so no judging.\nSummary\nIn this chapter we clarified the relationship between containers (such as Docker) and\nmicroservices. While simply containerizing your application doesn’t lead you to a\nmicroservice architecture, most microservices implementations do use containers as\nthey bring unparalleled cost savings and portability for autonomous deployment.\nFurther, we noted that containers were not created for microservices—they have their\nMonitoring and Alerting \n| \n101",
      "content_length": 2934,
      "extraction_method": "Direct"
    },
    {
      "page_number": 118,
      "chapter": null,
      "content": "own purpose and are actually much more widely adopted than microservice architec‐\nture. We also predicted that container adoption may, in effect, lead to increased popu‐\nlarity of microservices, since it is the architecture that best fits the container-based\ndeployment philosophy.\nWe also reviewed what is possibly the most important topic of microservices opera‐\ntions—service discovery—explaining the various options currently available in open\nsource, the similarities and differences between them, and what choices systems\narchitects make when picking a particular solution.\nWe discussed the role of the API gateway and the core capabilities it provides for the\narchitectural style: security, routing, and transformation/orchestration. We also\nlooked at an example of an intelligent recommendation engine to explain the key role\nof transformation/orchestration in the architectural style.\nAt the end of the chapter we discussed the role of monitoring for microservice archi‐\ntecture, alternative workflow approaches of push-based health-checks versus pull-\nbased ones, and provided some example tools that can help teams set up\nsophisticated monitoring and alerting workflows.\n102 \n| \nChapter 6: System Design and Operations",
      "content_length": 1229,
      "extraction_method": "Direct"
    },
    {
      "page_number": 119,
      "chapter": null,
      "content": "CHAPTER 7\nAdopting Microservices in Practice\nThroughout this book we’ve talked about companies that have enjoyed success with\nthe microservices style. In fact, a lot of the organizations that we’ve used to highlight\nthe microservice architecture are the same ones that pop up in most of the online lit‐\nerature: Amazon, Netflix, and SoundCloud, among others. But chances are that your\nbusiness doesn’t look or act like one of these online companies. That’s not a bad thing.\nDoing things in the microservices way can apply to almost any organization. We\nbelieve that every organization that does business on the Internet has an opportunity\nto improve with a focus on balancing safety and speed at scale. From this focus, you\ncan identify the principles and practices from our showcase microservices organiza‐\ntions that will work for you.\nWe also know that most readers are already working in a company with active IT\nservices up and running in production. That means you’re likely dealing with an\nexisting legacy of culture, organizational structure, process, tools, services, and archi‐\ntecture. You’re not going to be designing an optimized microservice-centric system\nfrom scratch. To adopt the microservices way of building applications, you’ll need a\nset of principles and practices that fit your unique set of constraints and coax the sys‐\ntem toward an optimal balance of safety and speed.\nIn this chapter we will highlight some of the most common adoption challenges that\nyou will face when implementing a microservice-style architecture within an existing\norganization. These are arranged in a kind of question-and-answer format to help\nyou zero in on the ones that interest you right now. While it isn’t an exhaustive list,\nwe hope it will help you tackle some of the biggest problems that mid- to large-sized\ncompanies have when wrestling with a microservices implementation. Hopefully,\nyou’ll be able to refer back to these topics several times as you work through your\nown microservice progress.\n103",
      "content_length": 2012,
      "extraction_method": "Direct"
    },
    {
      "page_number": 120,
      "chapter": null,
      "content": "Solution Architecture Guidance\nSolution architecture is distinct from individual service design elements because it\nrepresents a macro view of our solution. Here are some issues you may encounter\nwhen working at this macro-level view of the system.\nHow many bug fixes/features should be included in a single release?\nSince releases are expected to happen frequently, each release will likely be small. You\nprobably can’t box up 50 changes to a single service component in a week. We hear\nmost organizations have a practice of limiting the number of changes. Netflix, for\nexample, tells teams to make only one significant change per release. For example, if\nyour team needs to refactor some of the internal code and start using a new data store\nmodule, that would be two releases.\nThe biggest reason for limiting the number of changes in a release is to reduce uncer‐\ntainty. If you release a component that contains multiple changes, the uncertainty is\nincreased by the number of interactions that occur between those changes. The math‐\nematical discipline of graph theory provides a simple formula to calculate those inter‐\nactions: n(n–1)/2. Based on this, if you release a component that contains 5 changes\nand it causes problems in production, you know that there are 10 possible ways in\nwhich these 5 changes could interact to cause a problem. But if you release a compo‐\nnent with 15 changes there is a potential for over 100 different ways in which those\nchanges can interact to cause problems—and that’s just internal problems.\nLimit the number of changes in each release to increase the safety of each release.\nWhen do I know our microservice transformation is done?\nTechnically, creating and maintaining a vital information system is never “done.” And\nthat is also true for one built in the microservices way. In our experience some archi‐\ntects and developers spend a lot of time trying to identify the ideal solution or imple‐\nmentation model for their system design. It rarely works. In fact, one of the\nadvantages of microservices is that change over time is not as costly or dangerous as\nit might be in tightly coupled large-scope release models.\nTrying to perfect “the system” is an impossible task since it will always be a moving\ntarget. Often arriving at some “final state” marks the start of accumulating “technical\ndebt”—that status where the system is outdated and difficult to change. It helps to\nremember that everything you build today will likely be obsolete within a few years\nanyway.\n104 \n| \nChapter 7: Adopting Microservices in Practice",
      "content_length": 2565,
      "extraction_method": "Direct"
    },
    {
      "page_number": 121,
      "chapter": null,
      "content": "Since doing things in the microservices way means lots of small releases over time,\nyou’ll always be changing/improving something. This means you get lots of “done”\nmoments along the way and, in keeping with the theme of microservices, are able to\neffect change over time “at scale.”\nOrganizational Guidance\nFrom a microservice system perspective, organizational design includes the structure,\ndirection of authority, granularity, and composition of teams. A good microservice\nsystem designer understands the implications of changing these organizational prop‐\nerties and knows that good service design is a byproduct of good organizational\ndesign.\nHow do I know if my organization is ready for microservices?\nYou can start by assessing your organization’s structure and associated culture. In a\n1967 paper titled “How Committees Invent”, computer scientist Mel Conway argued\nthat the design of a software system will mimic the communication structure of the\norganization that produced it. “Conway’s law,” as it came to be known, has had a\nrecent revival in microservices circles. There is good reason for this. As discussed ear‐\nlier, the majority of microservice architecture pioneers began their quest for faster\nsoftware delivery by optimizing organizational design before addressing the software\narchitecture. Given this progression, these organizations landed on microservice\narchitecture as a style that aligned with their small, business-aligned teams, thus\nrevealing the wisdom of Conway’s decades-old assertion.\nHowever, many organizations now evaluating microservice architecture are not fol‐\nlowing the same path. In those cases, it is crucial to look at the organizational struc‐\nture. How are responsibilities divided between teams? Are they aligned to business\ndomains, or technology skillsets? At what level of the organization are development\nand operations divided? How big are the teams? What skills do they have? How\ndynamic is the communication and interaction between the teams who need to be\ninvolved in the delivery lifecycle? In addition to these organizational variables, you\nshould evaluate the culture. How is power distributed between the teams? Is it cen‐\ntralized at a high level, or decentralized among the delivery teams? Answering these\nquestions will help you understand what impacts these organizational factors will\nhave on your adoption efforts and resulting successes.\nOrganizational Guidance \n| \n105",
      "content_length": 2439,
      "extraction_method": "Direct"
    },
    {
      "page_number": 122,
      "chapter": null,
      "content": "Assessing Your Organization\n• How are responsibilities divided?\n• Are responsibilities aligned to business or technology?\n• Do you practice DevOps, or Dev and Ops?\n• How big are the teams? What kinds of skills do they have?\n• What are the dependencies for cross-team communication?\n• What does the power distribution look like between teams?\nThe ideal organization for microservices has small, empowered teams responsible for\nservices that align with specific business domains. These teams feature all of the roles\nnecessary to deliver these services, such as product owners, architects, developers,\nquality engineers, and operational engineers. The teams also need the right skills,\nsuch as API design and development, and knowledge of distributed applications.\nOrganizations that mismatch any of these characteristics will pay a toll when attempt‐\ning to apply microservice architecture. Teams that are not empowered will experience\ndelays waiting for decisions to be made above their heads. Lack of business alignment\nwill lead to cross-team dependencies, causing further delays and architectural devia‐\ntion. Teams that are too large create incomprehensible code bases that impede and\ndelay future changes. The higher up the divide between development and operations,\nthe less motivated the operations group will be to automate and optimize and the less\ndiligent developers will be in the operability of their software. Lastly, if the team\ndoesn’t have the right skills to build API-fronted services using distributed concepts,\ncosts could go up to cover training and/or contract hiring, or the solution could be\ndragged away from the microservices approach as existing resources retreat to their\ntechnological comfort zones.\nCulture Guidance\nYour organization’s culture is important because it shapes all of the atomic decisions\nthat people within the system will make. This large scope of influence is what makes\nit such a powerful tool in your system design endeavor.\nHow do I introduce change?\n...the challenge is to find small changes that can unfold in a way that creates large\neffects...\n—Gareth Morgan, author of Images of Organization\n106 \n| \nChapter 7: Adopting Microservices in Practice",
      "content_length": 2201,
      "extraction_method": "Direct"
    },
    {
      "page_number": 123,
      "chapter": null,
      "content": "If you aren’t working in a greenfield environment, chances are you’ll have inherited an\nexisting organizational design as well. Making changes to a working organization is\nnontrivial and carries a much greater risk than toying with a solution architecture.\nAfter all, if we make a mistake when refactoring our software we can always undo our\nchanges, but when we make a mistake when redesigning the reporting structure in an\norganization the damage is not so easily undone.\nYou’re unlikely to hear anyone refer to organizational design using the term refactor‐\ning. You’re far more likely to hear the term organizational transformation, and if it’s an\narea of interest to you, there is a wealth of material that can help you along the path to\nchange. But within the context of this book, the term refactoring makes a lot of sense.\nWhat we are primarily interested in is a method for making changes to the organiza‐\ntion in a way that is safe. Refactoring can help us with that.\nIn order to apply a refactoring strategy to the organizational design, you’ll need to:\n1. Devise a way to test changes\n2. Identify problem areas in your organizational design\n3. Identify safe transformations (changes that don’t change existing behavior)\nRefactoring the organization won’t help you do something you don’t already know\nhow to do. Your goal should be to do the same things, but improve the design of your\norganization so you can do them better.\nWhen you refactor an application you can measure and observe the performance of\nthe application; you can audit the source code, and you can comb through logs and\ndetermine where most of the problems occur. But when dealing with the processes\nand people that make up an organization things are a bit less black and white. To suc‐\ncessfully identify where the refactoring opportunities are within the organization,\nyou’ll need to find some way to model the existing system in order to analyze and\nmeasure its performance.\nSoundCloud’s Phil Calçado has written about using a lean management technique\ncalled value stream mapping as an initial step toward microservices. Value stream\nmaps are a great tool to use for this activity, but use whichever method you are com‐\nfortable with to get a better understanding of how work is being done. Flowcharts,\nbusiness process models, and activity diagrams can all do the job in the right hands.\nNo matter how you do it, the goal in this step is to identify how software changes are\nintroduced to the system, who implements those changes, and the type of coordina‐\ntion that is required for those changes to take place. For the microservice system we\nare especially interested in identifying opportunities to improve the efficiency of\nchange. Gaining a total understanding of how your organization works may be too\nlarge of an initial investment to undertake, so in practice you may need to focus only\nCulture Guidance \n| \n107",
      "content_length": 2902,
      "extraction_method": "Direct"
    },
    {
      "page_number": 124,
      "chapter": null,
      "content": "on the changes that occur the most often for the components that are the most vola‐\ntile.\nIn particular, you should be looking for the bottlenecks that cause change to be\nexpensive. Which processes result in a queue or backlog? Are there particular central‐\nized functions such as audits, code reviews, and gating procedures that cause teams to\nhave to wait? Are there any parts of your process flow that make it difficult for multi‐\nple changes to be introduced at the same time due to resource availability or a need\nfor serialized process execution? Finding these bottlenecks will help you identify\ngood candidates for process and organizational refactoring as they should yield a\nlarge benefit to the changeability and speed of release for the system.\nCan I do microservices in a project-centric culture?\nA hallmark of a microservices organization is that the teams that implement a feature,\napplication, or service continue to support, improve, and work on the code for its\nlifetime. This product-centric perspective instills a sense of ownership of the compo‐\nnent and reinforces the idea that deployed components will constantly be updated\nand replaced. This notion of ownership is important enough that Martin Fowler has\nmade “products not projects” one of the primary characteristics for a microservice\napplication.\nTypical project-centric cultures operate differently. Teams are formed to address a\nparticular problem (e.g., create a new component, add a feature, etc.) and disbanded\nwhen that problem is solved. Often a good deal of knowledge about both the problem\nand the solution gets lost when the team disbands. And, if there is a need to re-\naddress the same problem, or make additional changes to the same component, it\nmay be difficult to re-create the team or recover the lost knowledge. These challenges\nusually mean changes happen less often and are more likely to result in bugs or par‐\ntial solutions.\nIn truth, it is quite difficult to adopt the microservice style if you need to operate in\nthis type of culture. If changeability and speed of release are important properties for\nyour system, the long-term goal should be to transition to a style of building that\nencourages team-based ownership of components.\nCan I do microservices with outsourced workers?\nA particular challenge for large companies trying to incorporate the ideal microservi‐\nces system is the trend toward outsourcing technology services. The act of hiring an\noutside company to perform development and operations activities using workers\nwho are external to the organization seems at odds with the culture and organiza‐\ntional principles we’ve described in this book. But with the right outsourcing struc‐\nture, a microservice system may lend itself well to being developed by an external\norganization.\n108 \n| \nChapter 7: Adopting Microservices in Practice",
      "content_length": 2853,
      "extraction_method": "Direct"
    },
    {
      "page_number": 125,
      "chapter": null,
      "content": "By embracing a decentralized way of working and standardizing on the output and\nprocesses of service teams (containers and APIs), the outsourced development team\ncan be given enough autonomy to build a service that meets the capability require‐\nments of the owning organization. But this is only possible if the outsourced team\nconforms to the principles that exemplify the microservices way: the teams should be\nthe right size, built to last for the perpetuity of the life of the service, and composed of\nworkers who are skilled, experienced, and capable enough to make good design and\nimplementation decisions autonomously.\nIn addition to team composition, the microservice designer should acknowledge that\na cross-pollination of cultures occurs whenever outsourcing is conducted. The impli‐\ncation is that a desired organizational culture cannot simply be adopted by the out‐\nsourced team, nor can the buying organization avoid having their culture changed by\nthe intermingling of work. This means that culture becomes an important element in\ndeciding which companies or people should be chosen to support the outsourcing\nmodel.\nUltimately, the selection process for a microservices outsourcing model cannot be\noptimized purely for low-cost work. You will need to carefully select a partner who is\namenable to the cultural traits you are looking for and possesses aspects of culture\nyou’d like to incorporate into your own system. The deal must also be structured to\nincentivize the team dynamic that works best for building applications the microser‐\nvices way—teams should be dedicated to services, workers should be capable of\nworking autonomously, and speed of high-quality delivery should be the primary\nmetric for success.\nTools and Process Guidance\nThe system behavior is also a result of the processes and tools that workers in the sys‐\ntem use to do their job. In microservices systems, this usually includes tooling and\nprocesses related to software development, code deployment, maintenance, and prod‐\nuct management.\nWhat kinds of tools and technology are required for microservices?\nChapter 4 introduced the importance of the microservices platform and Chapters 5-6\nidentified some particularly important tools that you can use to “power up” your plat‐\nform and maximize both speed and safety of change. But these aren’t the only tools\nyou’ll need if you want to improve your chances of succeeding with microservices.\nThe ideal technological environment for microservices features cloud infrastructure,\nwhich facilitates rapid provisioning and automated deployment. The use of contain‐\ners is particularly useful to enable portability and heterogeneity. Middleware for data\nstorage, integration, security, and operations should be web API-friendly in order to\nTools and Process Guidance \n| \n109",
      "content_length": 2810,
      "extraction_method": "Direct"
    },
    {
      "page_number": 126,
      "chapter": null,
      "content": "facilitate automation and discovery, and should also be amenable to dynamic, decen‐\ntralized distribution. The ideal programming languages for microservices are API\nfriendly as well, and should be functional while also matching the skillsets of your\norganization. It is particularly useful to provide tools for developers that simplify\ntheir tasks yet incorporate constraints that encourage good operational behavior of\ntheir resulting code.\nStraying from these technological traits can lead to adoption issues. Lack of cloud\ninfrastructure will lead to deployment delays and inflexible scaling. Lack of contain‐\ners—or reliance on older virtualization or app servers—could increase the cost of\nresource utilization and lead to quality issues resulting from inconsistencies across\nenvironments. Middleware that assumes strict centralized control will break the\ndecentralized organizational model and challenge the provisioning of ephemeral\nenvironments. If used in a decentralized model, this specialized middleware could\nalso lead to skill challenges in the organization if every team is required to cultivate\nexpertise. Centralized or segregated data breaks the organizational model as well. It\nalso slows down delivery and impedes evolvability. Lack of developer tooling consis‐\ntency could lead to duplicate work and lack of visibility or resiliency in the overall\nsystem. Finally, a large dependency on legacy applications could limit the ability to\nmake changes.\nWhat kinds of practices and processes will I need to support\nmicroservices?\nWhile we talked about the principles that underpin good microservices practices in\nChapter 4, we haven’t told you which specific practices or methodologies you should\nuse. Our advice is to focus on the principles first, but it’s worth taking a look at how\nthe companies that are known for doing microservices well build their software.\nThe ideal software development lifecycle for microservices is based on a product\nmentality using Agile principles, which includes continuous integration and continu‐\nous delivery and features a high degree of automation in testing, deployment, and\noperations. Attempting to apply microservice architecture in a differing environment\ncan subtract from its potential value. A Waterfall approach can lead to tight coupling\nof services, making it difficult to manage the different change rates of those services\nand inhibiting their evolution. Project-focused delivery assumes static requirements\nand heavyweight change control, both impediments to fast software delivery. Being\nunable to deploy frequently will lead to a “big bang” release mentality and bring with\nit undue ceremony. If change frequency is increased in an environment that has a leg‐\nacy of change intolerance, many of those overweight processes can stick around,\nslowing down delivery, and introducing procedural fatigue as a new risk. Lack of\nautomation in the deployment lifecycle will have a negative compound effect on\nspeed to market, and lack of automation in operations will make it harder to deal\nwith the operational complexity of a distributed environment.\n110 \n| \nChapter 7: Adopting Microservices in Practice",
      "content_length": 3166,
      "extraction_method": "Direct"
    },
    {
      "page_number": 127,
      "chapter": null,
      "content": "How do I govern a microservice system?\nAside from regulatory issues (e.g., certification, audits, etc.) there are typically three\nways in which you can address security and governance requirements in a microser‐\nvice system: centralized, contextual, and decentralized.\nCentralized controls\nAt the component level, there really isn’t anything special about securing a micro‐\nservice system. If you know how to secure an operating system, secure an API, or\nsecure an application you can apply all of the same mechanisms to a microservice\nsystem. But when security mechanisms are introduced in the manner that most\nexperts are used to implementing them, you can inadvertently upset the system\noptimization goals that you’ve worked hard to design into the architecture.\nThis is because security, controls, and governance policies are often implemented\nin a centralized fashion. For example, if we have a need to authenticate, authorize,\nand audit messages before they are processed, the most common architecture\npattern is to implement some form of central security enforcement component\nwithin the architecture. Implementing a single, scalable component that can\nmanage a complex and expensive function like access control makes a lot of\nsense. Assigning a separate team to manage and implement such a service also\nmakes a lot of sense. Unfortunately, services like access control are likely to be\nused by every service in the infrastructure, which results in a common compo‐\nnent that all of other services will grow dependent on. In other words, a bottle‐\nneck can develop.\nA centralized security component risks putting our system into a state of mechan‐\nical organization or centralized control. In the early days of a microservice archi‐\ntecture it will be easy to set up the correct access and routing rules for a handful\nof services, but as more services are introduced and as those services change, the\ndemand to modify the access control component is likely to outgrow the access\ncontrol team’s capacity to roll out changes in time.\nFor organizations that wish to prioritize control and security it may be reasonable\nto trade the speed of change for improved system safety and security. However, if\nyou want to optimize for speed of implementation you’ll need to take a different\ndecentralized approach.\nDecentralized controls\nThe implication here is that the individual microservice teams will need to man‐\nage an infrastructure that includes security mechanisms that are bounded to the\nservice itself. The organization may standardize on the particular components\nand libraries that are to be used in every microservice, but it will be the teams\nthemselves that are responsible for implementing security components and con‐\nTools and Process Guidance \n| \n111",
      "content_length": 2766,
      "extraction_method": "Direct"
    },
    {
      "page_number": 128,
      "chapter": null,
      "content": "figuring them accordingly. It naturally follows that someone on the team must\nalso take on the role of becoming the security expert for the service.\nContextual controls\nA third approach that an organization can take is to define subsystems within the\nmicroservice architecture. Each subsystem may contain multiple services and\ntheir services within the subsystem are able to share common resources such as\naccess control. Again, the organization may mandate the nature and requirement\nfor these security components to be in place, but it is up to a subsystem service\nteam to own and manage the configuration for the security component.\nSecurity will always be an important design consideration for your microservice\nsystem. Even the absence of security is an implicit trade-off. While decisions\nabout how and what to secure will be dependent on the risk profile of your orga‐\nnization and nature of the application you are building, the decision about who\nwill manage the security implementation and where it will be implemented will\nhave a big impact on your ability to optimize for the system behavior that you\nwant.\nDesigning services that may be used by all other services in the system in itself is\nnot a problem. A commonly used service that is resilient, reliable, and available\nwill not impede the efforts of the rest of the service teams in the system. How‐\never, a commonly used service becomes a problem if the cost of implementing,\nconfiguring, and changing it becomes so high that it reduces the ability for ser‐\nvice teams to make changes to the system.\nServices Guidance\nIn a microservice system, the services form the atomic building blocks from which\nthe entire organism is built. The following are some additional questions and issues\nwe’ve identified when implementing well-designed microservices and APIs.\nShould all microservices be coded in the same programming\nlanguage?\nThe short answer is “no.” The internal language of the component is not as important\nas the external interface—the API—of that component. As long as two components\ncan use the same network protocols to exchange messages in an agreed-upon format\nusing shared terms, the programming language used to accomplish all this is not\nimportant.\nAt the same time, many companies we talked to constrained the number of languages\nsupported in the organization in order to simplify support and training. While a\npolyglot environment has advantages, too many languages results in added nonessen‐\ntial complexity system developers and maintainers need to deal with.\n112 \n| \nChapter 7: Adopting Microservices in Practice",
      "content_length": 2598,
      "extraction_method": "Direct"
    },
    {
      "page_number": 129,
      "chapter": null,
      "content": "What do I do about orphaned components?\nOver the life of a microservice implementation teams will come and go, and some‐\ntimes a team might disband and this can result in an “orphaned” microservice. It’s not\na good idea to just let a service run along without someone to care for it. As Martin\nFowler points out in “Products not Projects”, “ownership” is an important organiza‐\ntional aspect of microservices.\nWhen a team is about to disband, that team needs to designate a new “owner” of the\nmicroservice component. This might be one of the existing team members (“OK, I’ll\ntake responsibility for it”). It might be some other team that is willing to take care of\nit. Or it might be someone who has taken on the special role of caring for “orphaned”\nservices. But someone needs to be designated as the “owner.”\nIt’s not safe to allow orphaned services to run in your infrastructure.\nSummary\nIt is unlikely that the microservice system you design will be exactly like the ones that\nAmazon, Netflix, SoundCloud, or any of the other companies you may have heard do\nmicroservices correctly. Since there isn’t a formal definition for microservices, it’s easy\nenough for you to call whatever you do a microservice architecture. What you call\nyour system is relatively unimportant. But if your goal is to improve the changeability\nand adaptability of your system, following some of the principles we’ve outlined\nthroughout this book will help get you there.\nIn this chapter we’ve outlined some methods for dealing with some of the challenges\nthat many implementers face when introducing the microservice style to their organi‐\nzations. But it is important that you decide if the benefits of a microservice system\noutweigh the cost of changes that will be required to get there. It’s unlikely that every\norganization needs to build applications in the microservices way. This doesn’t mean\nthat you can’t take advantage of innovative tools—you can use Docker containers\nwithout rearchitecting your application and you can introduce modular services\nwithout redesigning your team structure. But to really take advantage of this adaptive\nway of building applications, you’ll need to eventually address all of the system\ncomponents.\nSummary \n| \n113",
      "content_length": 2237,
      "extraction_method": "Direct"
    },
    {
      "page_number": 130,
      "chapter": null,
      "content": "",
      "content_length": 0,
      "extraction_method": "OCR"
    },
    {
      "page_number": 131,
      "chapter": null,
      "content": "CHAPTER 8\nEpilogue\nThe best software architecture “knows” what changes often and makes that easy.\n—Paul Clements, author of Software Architecture in Practice\nWhile this book bears the title microservice architecture, you have likely noticed that\nthe central theme has been change. Specifically, we’ve focused on designing systems\nthat make change easier.\nWhen we work in a business environment where the goals and processes change fre‐\nquently, our software architecture needs to reflect that. When it doesn’t, the gap\nbetween business practice and system functionality widens and we call that “technical\ndebt.” On the other hand, when you engineer your system to support change safely—\nto allow replacing small interoperable parts without having to rebuild the entire sys‐\ntem—then you’re making change easier and avoiding that widening gap between\npractice and code.\nMicroservices are the small interoperable parts and microservice architecture is the\nengineering practice that can make change easier. The process of working along the\npath from your current architectural state and the desired future state where you can\nharmonize the speed of change with the need for system safety is what we call the\nmicroservices way.\nAnother key point to keep in mind is that there is no “all done” moment, that instant\nwhen you’ll have everything in place, just the way you like it all running along\nwithout the need for modification. This need for constant change is not a “bug” in the\nway your software is engineered or implemented—it’s a feature of a vital, viable infor‐\nmation system. While there may be times when things tend to calm down or seem to\nrun fairly quietly, they’re not likely to last very long.\nAs someone responsible for making sure IT practices keep in alignment with business\ngoals and objectives, you’ll find lots of opportunity for “wins,” but they might look a\n115",
      "content_length": 1880,
      "extraction_method": "Direct"
    },
    {
      "page_number": 132,
      "chapter": null,
      "content": "bit different than you’d expect. For example, a “win” is when you release refactored\nupdates to core services without anyone even noticing. Or you complete a multiyear\nmigration from one data-storage system to another. Or you learn that other teams in\nthe company are now releasing customer-facing applications at a speed not previ‐\nously thought possible. If you’re lucky, someone will remember that all this was possi‐\nble because of the work you’ve been doing all along.\nAs you’ve seen from our examples, you don’t need to transform your organization,\nculture, and processes all in one “big bang.” There are lots of small moves you can\nimplement as you learn from each attempt and gain experience in the microservices\nway. And, you’ll need all that experience as you face new challenges to adapt what\nyou’ve built today to meet the unique goals and requirements of the future. Hopefully,\nthe descriptions, models, and guidance we’ve collected here can give you a set of tools\nyou can use to improve your organization’s software system starting today and well\ninto the future.\nAs we mentioned at the outset, we don’t think it’s important to agree upon a universal\ndefinition for the term “microservice.” We don’t even expect the current popularity of\nthe term to last long. However, the principles that make microservices special—things\nlike immutability and modularity, speed and safety, resilience, and agility—are well-\nknown and lasting values. Technology advancements are already occurring as we\nwrite this book. The world around us is changing. Concepts such as serverless archi‐\ntectures, automated transport, virtual reality, and adaptive intelligent programs are all\ngenerating interest. We can’t predict the future, and any of these technological or\nsocial changes could have a profound impact on the industry we share. That may\nmean that the range and types of tools available in the future may change in profound\nways. These potential changes can alter the implementation details and processes you\nuse to meet your goals but the underlying principles will stay the same.\nAnd, even with all the possibilities of rapid change ahead, we think the microservices\nway of developing software—the harmonic balance of speed and safety at scale—will\nbe valuable to you far into the future. So, when technology, society, and businesses\nchange around you, you can use the way to identify the best of the new principles and\npatterns that will inevitably emerge from these important changes. That means you\nhave the opportunity to embrace change and more easily adapt to new ways of\ndesigning, building, and managing the information systems of the future.\nNothing endures but change.\n—Heraclitus\n116 \n| \nChapter 8: Epilogue",
      "content_length": 2723,
      "extraction_method": "Direct"
    },
    {
      "page_number": 133,
      "chapter": null,
      "content": "APPENDIX A\nMicroservice Architecture Reading List\nThere are a number of great resources out there for learning about microservice\narchitecture, many of which helped to shape this book. This appendix collects and\nclassifies the authors’ favorites.\nMicroservices 101\nThese materials are the best place to start learning about microservices and microser‐\nvice architecture:\n• Lewis, James, and Martin Fowler. “Microservices: A Definition of This New\nArchitectural Term”, March 25, 2014.\n• Miller, Matt. “Innovate or Die: The Rise of Microservices”. The Wall Street Jour‐\nnal, October 5, 2015.\n• Newman, Sam. Building Microservices. O’Reilly Media, 2015.\nBest Practices\nThese resources provide guidance on what to do—and what not to do—when it\ncomes to implementing a microservice architecture:\n• Alagarasan, Vijay. “Seven Microservices Anti-patterns”, August 24, 2015.\n• Cockcroft, Adrian. “State of the Art in Microservices”, December 4, 2014.\n• Fowler, Martin. “Microservice Prerequisites”, August 28, 2014.\n• Fowler, Martin. “Microservice Tradeoffs”, July 1, 2015.\n• Humble, Jez. “Four Principles of Low-Risk Software Release”, February 16, 2012.\n117",
      "content_length": 1150,
      "extraction_method": "Direct"
    },
    {
      "page_number": 134,
      "chapter": null,
      "content": "• Humble, Jez, Chris Read, and Dan North. “The Deployment Production Line”. In\nProceedings of the conference on AGILE 2006, 113–118. IEEE Computer Society.\n• Kniberg, Henrik, and Anders Ivarsson. “Scaling Agile at Spotify”, October 2012.\n• Vasters, Clemens. “Sagas”, September 1, 2012.\n• Wootton, Benjamin. “Microservices are Not a Free Lunch”, April 8, 2014.\nExample Implementations\nThe following articles include overviews and insight from real-life microservice\nimplementations:\n• Amazon Web Services\n• Autoscout24\n• CA Technologies (Rally)\n• Disney\n• Gilt\n— http://www.infoq.com/presentations/microservices-dependencies\n— http://www.infoq.com/news/2015/04/scaling-microservices-gilt\n• ITV\n• Jet.com\n• Netflix\n— http://techblog.netflix.com/2015/01/netflixs-viewing-data-how-we-know-\nwhere.html\n— https://yow.eventer.com/yow-2013-1080/cloud-native-architecture-at-netflix-\nby-adrian-cockcroft-1364\n• Nike\n• SoundCloud\n— https://www.thoughtworks.com/insights/blog/bff-soundcloud\n— http://www.infoq.com/articles/microservices-evolution-soundcloud\n— http://philcalcado.com/2015/09/08/how_we_ended_up_with_microservices.html\n• Spotify\n• Trinity Mirror Group\n118 \n| \nAppendix A: Microservice Architecture Reading List",
      "content_length": 1214,
      "extraction_method": "Direct"
    },
    {
      "page_number": 135,
      "chapter": null,
      "content": "Foundations\nThe last set of resources includes the historical foundations for microservice\narchitecture:\n• Arthur, W. Brian. The Nature of Technology. Simon & Schuster, 2009.\n• Brooks, Fred. “No Silver Bullet”. Reproduced from The Mythical Man-Month,\nAnniversary edition, Addison-Wesley, 1995.\n• Conway, Mel. “Conway’s Law”, accessed May 25, 2016.\n• Evans, Eric. Domain-Driven Design: Tackling Complexity in the Heart of Software.\nPrentice-Hall, 2003.\n• Fielding, Roy. “Architectural Styles and the Design of Network-based Software\nArchitectures”. PhD diss., University of California, Irvine, 2000.\n• Feldman, Stuart. “A Conversation with Alan Kay”. Queue 2(2004): 20–30.\n• Mintzberg, Henry. Structure in Fives: Designing Effective Organizations. Pearson,\n1992.\n• Morgan, Gareth. Images of Organization. SAGE Publishing, 2007.\n• Parnas, David. “On the Criteria to Be Used in Decomposing Systems Into Mod‐\nules”. Communications of the ACM 15(1972): 1053–1058.\n• Poppendieck, Mary. “The New New Software Development Game”, Craft Con‐\nference video, April 2015.\n• Ries, Eric. The Lean Startup. Crown Business, 2011.\nMicroservice Architecture Reading List \n| \n119",
      "content_length": 1159,
      "extraction_method": "Direct"
    },
    {
      "page_number": 136,
      "chapter": null,
      "content": "",
      "content_length": 0,
      "extraction_method": "OCR"
    },
    {
      "page_number": 137,
      "chapter": null,
      "content": "Index\nA\nadaptability, change and, 29\nAgile Manifesto, 65\nAir Force, US, 23\nalerting, 101\nAllspaw, John\non monitoring, 44\nAmazon\nand size of teams at, 56\nautomated testing of code, 51\nAmazon machine images (AMIs), 52\nAmazon Web Services, 13, 98\nantifragility, 45\nAPI design\nand output standardization, 32\nhypermedia-driven implementation, 68-70\nmessage-oriented implementation, 67\nstandardization trade-offs, 33\nAPI gateway, 97-100\nrouting, 100\nsecurity, 97\ntransformation and orchestration, 98-100\narchitectural policy services, 51\nArthur, W. Brian\non modularity, 17\nasynchronous message-passing, 80\nautomated testing, 44\nautonomy of microservices teams, 8\naverages, drawbacks as basis for design, 23\nB\nbatch-size reduction, 65\nBezos, Jeff\non size of teams at Amazon, 56\nblue-green deployment, 44\nboundaries\nand batch-size reduction, 65\nand bounded contexts, 64\nand domain-driven design, 62\nin service design, 62-66\nubiquitous language, 66\nbounded contexts, 64\nand business context, 66\noptimal size of, 66\nBrooks, Fred\nand Conway’s Law, 55\non team size and communication overhead,\n56\nbusiness context, bounded context and, 66\nC\nCai, Beier\non efficiency benefits of microservice, 14\non governance at Hootsuite, 60\nCalçado, Phil\nand value stream mapping, 107\nefficiency benefits of microservice, 15\non microservices, 3\ncapabilities, data vs., 70\ncapabilities-oriented design, 71\nchange\ncentrality to microservice architecture, 115\nembracing, 29\nintroducing, 107-108\nsafety of, 9\nspeed of, 9\nVision Zero and, 1\nchaos, tolerance for, 57\n121",
      "content_length": 1536,
      "extraction_method": "Direct"
    },
    {
      "page_number": 138,
      "chapter": null,
      "content": "chatty interfaces, 98, 99\nCockcroft, Adrian\nNetflix principles, 45\non microservices, 6\ncohesion, 18\ncommand query responsibility segregation\n(CQRS), 76-78\ncommand-query separation (CQS), 76\ncommunication, culture and, 55\ncomplex systems\nemergence and, 26\nGall’s Law and, 17\ncomponents, orphaned, 113\nConstantine, Larry\non cohesive architecture, 18\nConsul, 101\nConsul Alerts, 101\ncontainers, 51, 92\n(see also Docker)\ncontrols\nas illusion, 30\ndecentralization and, 8\npractical guidance for, 111\nConway, Mel\non organizations and their communication\nstructures, 55, 105\nConway’s law, 55, 105\ncost reduction, as goal of microservices, 43\nculture\nand communication, 55\nand outsourced workers, 108\nand team alignment, 55\nas foundational element, 54-57\ndefined, 29\nin systems approach, 29\ninnovation-fostering, 56\nintroducing change to, 107-108\npractical guidance for, 106-109\nproject-centric, 108\nVision Zero and, 1\nD\nDaniels, Gilbert, 23\ndata sharing, 84\ndata, service design and, 70-78\nand event sourcing, 72-75\nand Shipping, Inc., 70\nCQRS, 76-78\nsystem model for Shipping, Inc., 75\ndata-centric design, 70\ndecentralization, 8\nDecider (configuration tool), 53\ndecomposition, 62\ndependencies\nand pragmatic mobility, 85-86\nin service design, 81-86\ndesign process, 33-38\ndesigner’s position in the organization, 38\ndevelopment principles, 35-35\nflaw of averages and, 23\nimplement/observe/adjust, 36\noptimization goals, 34\nsketching the system design, 35\ndevelopment principles, 35-35\nDevOps\nlogging and monitoring, 44\nresilience through automated testing, 44\nDisney\nefficiency benefits of microservice, 14\ndistributed transactions, 78\nDNS interfaces, 100\nDocker\nand operational management, 93-97\ncontainers, 51\nDocker Swarm, 96\ndomain-driven design (DDD), 62\n(see also boundaries)\nand bounded contexts, 64\nand software system as model of a reality, 63\nboundaries and, 62\noptimal size of founded context, 66\nDunbar, Robin\non social groups, 55\nE\nEdwards, Damon\non culture, 54\nemergent behavior, 26\nEvans, Eric\nDDD approach, 62\nmodel-centric view of software system\ndesign, 63\non combining contextual models, 64\nevent sourcing, 72-75\nF\nFacebook, 53\nFowler, Martin\n122 \n| \nIndex",
      "content_length": 2166,
      "extraction_method": "Direct"
    },
    {
      "page_number": 139,
      "chapter": null,
      "content": "on products over projects, 108\nG\nGall’s Law, 17\nGarrard, Clay\non efficiency benefits of microservice, 14\nGatekeeper (configuration tool), 53\nGilt, 14\ngoal orientation, 4\ngoal-oriented, layered approach, 17-21\nand cohesion, 18\nand maturity model, 19\nand modularity, 17\nand systematization, 18\ndefinition, 17-21\ngoals\ncost reduction, 43\nfor microservices way, 42\nprinciples vs., 45\nrelease speed improvement, 43\nresilience improvement, 43\nruntime visibility, 44\ntrade-offs in, 44\ngovernance, 111\ngreenfield environments, 35\nGregory, James\non HTTP and Hypermedia, 68\nH\nhardware services, 50\nharmony, of speed and safety, 10\nHaufe-Lexware, 21\nHeraclitus\non change, 116\nHock, Dee\non leaders, 30\nholistic systems, 30\nHootsuite\nefficiency benefits of microservice, 14\nmicroservices way at, 59\nHumble, Jez, 44\nhypermedia-style APIs, 68-70\nHystrix, 54\nI\nimmutability, 45\nindependent deployability, 89-93\ninnovation, fostering, 56\nInvoke Media, 59\nJ\njaggedness, principle of, 24\nK\nKay, Alan\non messages, 67\non systematization, 18\nkey performance indicator (KPI), 36\nKirkorian, Raffi, 53\nKubernetes, 96\nL\nlanguage, ubiquitous, 66\nLean Startup, 65\nLewis, James, 4\nLinux kernel extension (LXC), 92\nlocal capabilities, 52-54\ngeneral tooling, 53\nrequest routing, 53\nruntime configuration, 53\nservice discovery, 53\nsystem observability, 54\nloose coupling, 68\nM\nmaturity model, 19\nMcIlroy, Douglas\non Unix architecture principles, 46\nmechanical organization, 111\nMesosphere, 97\nmessage-oriented API design, 67\nmessage-passing, 80\nmethodologies, practical guidance for, 110-112\nMeyer, Bertrand\nand CQS, 76\nmicroservice (defined), 6\nmicroservice architecture\nminimum viable, 6\nservice-oriented architecture vs., 92\nmicroservice concerns\nlocal capabilities, 52-54\nshared capabilities, 50-52\nmicroservice system design model, 27\nmicroservices way\nadopting, 5-8\nand decentralization, 8\nIndex \n| \n123",
      "content_length": 1877,
      "extraction_method": "Direct"
    },
    {
      "page_number": 140,
      "chapter": null,
      "content": "and safety of change, 9\nand speed of change, 9\nand team autonomy, 8\nbalancing speed and safety, 10\nbasics of, 3-11\nbuilding at scale, 10\ncharacteristics of, 7\ndefinitions, 6\nflexibility of application scenarios, 7\ngoals for, 42\norigins, 4\nprincipal concepts of, 4\nreal value of, 9-11\nMintzberg, Henry\non coordination mechanisms and stand‐\nards, 31\nMitchell, Melanie\non emergence and complexity, 26\nmobility, pragmatic, 85-86\nmodularity, 17\nmonitoring, 44, 101\nmonoliths, 17, 37\nMorgan, Gareth\non changes, 107\nN\nNetflix\nand AMIs, 52\nHystrix, 54\nmessage formats at, 67\noperating principles at, 45\npolicy enforcement, 51\nteam leadership at, 57\nNewman, Sam\nmicroservices definition, 6\non bounded contexts, 64\non data vs. context, 70\nO\nobservability tooling, 54\noperating principles, 45-49\nat Netflix, 45\nin Unix system, 46\nsuggested principles, 47\noperational management, 89-102\nand service discovery, 94-97\nAPI gateway, 97-100\nDocker and, 93-97\nindependent deployability, 89-91\nmonitoring/alerting, 101\nserver minimization, 91-93\noptimization goals, 34\norchestration, API gateway, 98-100\norganizational design\nand systems approach, 28\npractical guidance for, 105\norganizations\nassessment guidelines, 106\nculture (see culture)\nsystem designers position in, 38\norphaned components, 113\noutputs, standardization of, 32\noutsourcing, 108\nP\npeople, standardization of, 32\nplatforms, 49-54\nlocal capabilities, 52-54\nshared capabilities, 50-52\npolicy services, 51\npractices, practical guidance for, 110-112\npragmatic mobility, 85-86\nprinciple of jaggedness, 24\nprinciples\ndevelopment, 35-35\ngoals vs., 45\noperating (see operating principles)\nprocesses\nchoosing, 28\ndesign (see design process)\npractical guidance for, 110-112\nsecurity/governance requirements, 111\nstandardization of, 31\nprogramming languages, 112\nproject-centric culture, 108\nR\nrefactoring, 107\nReihnard, Holger\non goal-oriented approach, 21\nreleases, limiting number of changes in, 104\nreplaceability, 5\nrequest routing, 53\nresilience, 43\nRESTful APIs, 69, 99\nRies, Eric\non Lean Startup, 65\nroad systems, 1\n124 \n| \nIndex",
      "content_length": 2076,
      "extraction_method": "Direct"
    },
    {
      "page_number": 141,
      "chapter": null,
      "content": "Rose, Todd\non averages, 24\nrouting, API gateway, 100\nruntime visibility, 44\nS\nsafety\nand business value, 16\nand systematization, 19\nbalancing with speed, 1, 10\nof change, 9\nSagas, 78\nscale/scaling\nand independent deployability, 89-91\nbuilding at, 10\nmicroservices and, 4\nselective, 90\nsecurity\nAPI gateway, 97\ncentralized controls, 111\ncontextual controls, 112\ndecentralized controls, 111\npractical guidance for, 111\nselective scaling, 90\nseparation of concerns (SoCs), 46\nservice design, 61-87\nAPI design, 67-70\nasynchronous message-passing, 80\nboundaries, 62-66\ndata considerations, 70-78\ndealing with dependencies, 81-86\ndistributed transactions, 78\nSagas, 78\nservice discovery\nin operational management, 94-97\ntools for, 53\nservice-oriented architecture (SOA), microser‐\nvice architecture vs., 92\nservices\nand orphaned components, 113\nas atomic building block, 27\npractical guidance for, 112\nprogramming languages for, 112\nshared capabilities, 50-52\narchitectural policy services, 51\ncode management, testing, and deployment,\n51\ndata stores, 51\nhardware services, 50\nsecurity and identity, 51\nservice orchestration, 51\nShipping, Inc. (imaginary startup)\nand dependencies in service design, 81-86\nCQRS for, 77\ndata in service design, 70\nevent sourcing at, 73-75\nintelligent inventory management system,\n99\nSagas at, 79\nselective scaling at, 90\nsystem model for, 75\nsketching, 35\nskills, standardization of, 32\nSmircich, Linda\non culture, 54\nsolution architecture\nas macro-level view of system, 28\npractical guidance for, 104\nSoundCloud, 15\nspeed\nand business value, 15\nand systematization, 19\nas goal, 43\nbalancing with safety, 1, 10\nof change, 9\nSpotify, 56\nstandardization\nin systems approach, 30-33\nof outputs, 32\nof people, 32\nof process, 31\ntrade-offs in, 33\nStickdorn, Marc\non design process, 33\nsubsystems, decomposition of large systems\ninto, 62\nSweden, 1\nsystem designers, 38\nsystematization of microservice architecture, 18\nsystems approach to microservices, 25-33\nand culture, 29\nand holistic system, 30\nand organizational design, 28\nand solution architecture, 28\nembracing change, 29\nprocess and tools, 28\nservice as building block, 27\nstandardization and coordination, 30-33\nIndex \n| \n125",
      "content_length": 2204,
      "extraction_method": "Direct"
    },
    {
      "page_number": 142,
      "chapter": null,
      "content": "systems design, 25-39\nand operations (see operational manage‐\nment)\nand systems approach to microservices,\n25-33\nfoundation for, 41-58\ngoals, 42\nmicroservice system design model, 27\nmicroservices design process, 33-38\nT\nteams\nalignment, 55\nautonomy of, 8\norganizational design, 28\nsize of, 55\ntechnical debt, 37, 104\ntesting, automated, 44\ntight coupling\ndata sharing and, 84\nwaterfall approach and, 110\ntime, as essential element in microservice sys‐\ntem, 29\ntools\nbuilding, 48\nchoosing, 28\npractical guidance for, 109\ntraffic systems, 1\ntransformation\nAPI gateway, 98-100\nas unending process, 104\nTrenaman, Adrian\non microservice architecture at Gilt, 14\nTwitter\nDecider configuration tool, 53\nZipkin, 54\nU\nubiquitous language, 66\nUnix, 46\nUrban, Steve\non team leadership at Netflix, 57\nUS Air Force, 23\nV\nvalue proposition, 13-21\narchitecture benefits, 13-15\nbusiness value, 15-16\ngoal-oriented, layered approach, 17-19\nvalue stream mapping, 107\nVernon, Vaughn\non bounded context, 66\nvirtual machines (VMs), 50\nvisibility, runtime, 44\nVision Zero, 1\nVogels, Werner\non Amazon Web Services architecture, 13\non running what you build, 52\nY\nYoung, Greg\non event sourcing, 72\nYourdon, Edward\non cohesive architecture, 18\nZ\nZipkin, 54\n126 \n| \nIndex",
      "content_length": 1245,
      "extraction_method": "Direct"
    },
    {
      "page_number": 143,
      "chapter": null,
      "content": "About the Authors\nIrakli Nadareishvili is CTO and cofounder of a New York health tech startup Refer‐\nWell. At any given time he can be found designing and implementing APIs, discus‐\nsing distributed systems architecture, and expressing opinions about product\nmanagement. Prior to ReferWell, Irakli held leadership roles at the API Academy of\nCA Technologies and NPR. Irakli is highly involved in the startup community and\nhas spent over a decade in Washington, DC building innovative products for media\ncompanies and government and international organizations, while also being an\nactive open source contributor and advocate.\nRonnie Mitra is the Director of Design at CA’s API Academy, and is focused on help‐\ning people design better distributed systems. He travels around the world, helping\norganizations adopt a design-centric approach to interface design and a system-\ncentric approach to application architecture.\nMatt McLarty is Vice President of the API Academy at CA Technologies. The API\nAcademy helps companies thrive in the digital economy by providing expert guid‐\nance on strategy, architecture, and design for APIs.\nIn his role of Director of Architecture for the API Academy, Mike Amundsen heads\nup the API Architecture and Design Practice in North America. He is responsible for\nworking with companies to provide insight on how best to capitalize on the myriad\nopportunities APIs present to both consumers and the enterprise.\nAmundsen has authored numerous books and papers on programming over the last\n15 years.\nColophon\nThe animal on the cover of Microservice Architecture is a cowry snail, an ocean-\ndwelling mollusk of the Cypraeidae family, found worldwide in tropical waters. There\nare many species of different sizes and shell patterns, but all possess a very rounded\nshell with a smooth glossy exterior. The texture of these shells is similar to porcelain,\nwhich itself was named after the Italian term for these snails: porcellana. Cowrie shells\nhave historically been used as currency in several world cultures, and are still popular\nin jewelry and decoration.\nThe shell of a cowry snail is also distinctive for its narrow toothed opening. It’s very\ndifficult for predators to get into, though some species (such as certain octopi and\ncarnivorous snails of the cone family) attack by injecting venom directly into the\ncowry’s flesh.\nCowry snails themselves primarily feed on algae, but also eat sea sponges. They are\nmost active at night. During the day, the snails hide inside coral reefs or beneath",
      "content_length": 2526,
      "extraction_method": "Direct"
    },
    {
      "page_number": 144,
      "chapter": null,
      "content": "rocks. The part of the snail visible outside the shell is the mantle, a muscular fringed\nappendage that not only provides locomotion but excretes calcium carbonate, the\nsubstance that gradually builds up and maintains the shell around the animal.\nMany of the animals on O’Reilly covers are endangered; all of them are important to\nthe world. To learn more about how you can help, go to animals.oreilly.com.\nThe cover image is from Beauties of Land and Sea. The cover fonts are URW Type‐\nwriter and Guardian Sans. The text font is Adobe Minion Pro; the heading font is\nAdobe Myriad Condensed; and the code font is Dalton Maag’s Ubuntu Mono.",
      "content_length": 639,
      "extraction_method": "Direct"
    }
  ],
  "enrichment": {
    "version": "1.0.0",
    "generated_by": "generate_chapter_metadata.py",
    "contains": [
      "keywords",
      "concepts",
      "summary"
    ]
  }
}